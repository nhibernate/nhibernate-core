<chapter id="collections">
    <title>Collection Mapping</title>

    <sect1 id="collections-persistent">
        <title>Persistent Collections</title>

        <para>
            NHibernate requires that persistent collection-valued fields be declared
            as a generic interface type, for example:
        </para>
        
        <programlisting><![CDATA[public class Product
{
    public virtual ISet<Part> Parts { get; set; } = new HashSet<Part>();

    public virtual string SerialNumber { get; set; }
}]]></programlisting>
        
        <para>
            The actual interface might be
            <literal>System.Collections.Generic.ICollection&lt;T&gt;</literal>,
            <literal>System.Collections.Generic.IList&lt;T&gt;</literal>,
            <literal>System.Collections.Generic.IDictionary&lt;K, V&gt;</literal>,
            <literal>System.Collections.Generic.ISet&lt;T&gt;</literal>
            or ... anything you like! (Where "anything you like" means you will
            have to write an implementation of <literal>NHibernate.UserType.IUserCollectionType</literal>.)
        </para>
        
        <para>
            Notice how we initialized the instance variable with an instance of
            <literal>HashSet&lt;T&gt;</literal>. This is the best way to initialize collection
            valued properties of newly instantiated (non-persistent) instances. When
            you make the instance persistent - by calling <literal>Save()</literal>,
            for example - NHibernate will actually replace the <literal>HashSet&lt;T&gt;</literal>
            with an instance of NHibernate's own implementation of <literal>ISet&lt;T&gt;</literal>.
            Watch out for errors like this:
        </para>

        <programlisting><![CDATA[Cat cat = new DomesticCat();
Cat kitten = new DomesticCat();
...
ISet<Cat> kittens = new HashSet<Cat>();
kittens.Add(kitten);
cat.Kittens = kittens;
session.Save(cat);
kittens = cat.Kittens; //Okay, kittens collection is an ISet
HashSet<Cat> hs = (HashSet<Cat>) cat.Kittens; //Error!]]></programlisting>

        <para>
            Collection instances have the usual behavior of value types. They are automatically
            persisted when referenced by a persistent object and automatically deleted when
            unreferenced. If a collection is passed from one persistent object to another,
            its elements might be moved from one table to another. Two entities may not share
            a reference to the same collection instance. Due to the underlying relational model,
            collection-valued properties do not support null value semantics; NHibernate does
            not distinguish between a null collection reference and an empty collection.
        </para>

        <para>
            You shouldn't have to worry much about any of this. Just use NHibernate's collections
            the same way you use ordinary .NET collections, but make sure you understand the
            semantics of bidirectional associations (discussed later) before using them.
        </para>

        <para>
            Collection instances are distinguished in the database by a foreign key to
            the owning entity. The collection key is mapped by
            the <link linkend="collections-foreignkeys"><literal>&lt;key&gt;</literal> element</link>.
        </para>

        <para>
            Collections may contain almost any other NHibernate type, including all basic types,
            custom types, entity types and components. See <xref linkend="collections-elements"/>.
        </para>

        <para>
            All collection types except <literal>ISet</literal> and bag have an <emphasis>index</emphasis>
            column - a column that maps to an array or <literal>IList</literal> index or
            <literal>IDictionary</literal> key. See <xref linkend="collections-indexed"/> for more
            information.
        </para>

        <para>
            There are quite a range of mappings that can be generated for collections,
            covering many common relational models. We suggest you experiment with the
            schema generation tool to get a feeling for how various mapping declarations
            translate to database tables.
        </para>

    </sect1>

    <sect1 id="collections-mapping">
        <title>Mapping a Collection</title>

        <para>
            The NHibernate mapping element used for mapping a collection depends upon the type of interface.
            By example, a <literal>&lt;set&gt;</literal> element is used for mapping properties of type
            <literal>ISet</literal>.
        </para>

        <programlisting><![CDATA[<class name="Product">
    <id name="SerialNumber" column="productSerialNumber"/>
    <set name="Parts">
        <key column="productSerialNumber" not-null="true"/>
        <one-to-many class="Part"/>
    </set>
</class>]]></programlisting>

        <para>
            Apart from
            <literal>&lt;set&gt;</literal>, there is also
            <literal>&lt;list&gt;</literal>,
            <literal>&lt;map&gt;</literal>,
            <literal>&lt;bag&gt;</literal>,
            <literal>&lt;array&gt;</literal> and
            <literal>&lt;primitive-array&gt;</literal> mapping elements.
            The <literal>&lt;map&gt;</literal> element is representative:
        </para>

        <programlistingco>
            <areaspec>
                <area id="mappingcollection1" coords="2 65"/>
                <area id="mappingcollection2" coords="3 65"/>
                <area id="mappingcollection3" coords="4 65"/>
                <area id="mappingcollection4" coords="5 65"/>
                <area id="mappingcollection5" coords="6 65"/>
                <area id="mappingcollection6" coords="7 65"/>
                <area id="mappingcollection7" coords="8 65"/>
                <area id="mappingcollection8" coords="9 65"/>
                <area id="mappingcollection9" coords="10 65"/>
                <area id="mappingcollection10" coords="11 65"/>
                <area id="mappingcollection11" coords="12 65"/>
                <area id="mappingcollection12" coords="13 65"/>
                <area id="mappingcollection13" coords="14 65"/>
                <area id="mappingcollection14" coords="15 65"/>
                <area id="mappingcollection15" coords="16 65"/>
                <area id="mappingcollection16" coords="17 65"/>
                <area id="mappingcollection17" coords="18 65"/>
                <area id="mappingcollection18" coords="19 65"/>
                <area id="mappingcollection19" coords="20 65"/>
                <area id="mappingcollection20" coords="21 65"/>
                <area id="mappingcollection21" coords="22 65"/>
            </areaspec>
            <programlisting><![CDATA[<map
    name="propertyName"
    table="tableName"
    schema="schemaName"
    catalog="catalogName"
    lazy="true|false|extra"
    inverse="true|false"
    cascade="all|none|save-update|delete|all-delete-orphan"
    sort="unsorted|natural|comparatorClass"
    order-by="columnName asc|desc"
    where="arbitrary sql where condition"
    fetch="select|join|subselect"
    batch-size="N"
    access="field|property|className"
    optimistic-lock="true|false"
    mutable="true|false"
    subselect="SQL expression"
    check="arbitrary sql check condition"
    persister="persisterClass"
    collection-type="collectionClass"
    outer-join="auto|true|false"
    generic="true|false">

    <key ... />
    <map-key ... />
    <element ... />
</map>]]></programlisting>
            <calloutlist>
                <callout arearefs="mappingcollection1">
                    <para>
                        <literal>name</literal>: the collection property name.
                    </para>
                </callout>
                <callout arearefs="mappingcollection2">
                    <para>
                        <literal>table</literal> (optional - defaults to property name): the
                        name of the collection table. It is not used for one-to-many associations.
                    </para>
                </callout>
                <callout arearefs="mappingcollection3">
                    <para>
                        <literal>schema</literal> (optional): overrides the schema name specified by
                            the root <literal>&lt;hibernate-mapping&gt;</literal> element.
                    </para>
                </callout>
                <callout arearefs="mappingcollection4">
                    <para>
                        <literal>catalog</literal> (optional): overrides the catalog name specified by
                        the root <literal>&lt;hibernate-mapping&gt;</literal> element.
                    </para>
                </callout>
                <callout arearefs="mappingcollection5">
                    <para>
                        <literal>lazy</literal> (optional - defaults to <literal>true</literal>):
                        may be used to disable lazy fetching and specify that the association
                        is always eagerly fetched. Using <literal>extra</literal> fetches only the
                        elements that are needed - see <xref linkend="performance-fetching"/> for more information.
                    </para>
                </callout>
                <callout arearefs="mappingcollection6">
                    <para>
                        <literal>inverse</literal> (optional - defaults to <literal>false</literal>):
                        marks this collection as the "inverse" end of a bidirectional association.
                    </para>
                </callout>
                <callout arearefs="mappingcollection7">
                    <para>
                        <literal>cascade</literal> (optional - defaults to <literal>none</literal>):
                        enables operations to cascade to child entities.
                    </para>
                </callout>
                <callout arearefs="mappingcollection8">
                    <para>
                        <literal>sort</literal> (optional): specifies a sorted collection with a
                        <literal>natural</literal> sort order, or a given comparator class. See
                        <xref linkend="collections-sorted"/>.
                    </para>
                </callout>
                <callout arearefs="mappingcollection9">
                    <para>
                        <literal>order-by</literal> (optional): specifies a table column (or columns)
                        that defines the iteration order of the <literal>IDictionary</literal>, <literal>ISet</literal>
                        or bag, together with an optional <literal>asc</literal> or <literal>desc</literal>.
                    </para>
                </callout>
                <callout arearefs="mappingcollection10">
                    <para>
                        <literal>where</literal> (optional): specifies an arbitrary SQL <literal>WHERE</literal>
                        condition to be used when retrieving or removing the collection. It is useful if the
                        collection should contain only a subset of the available data.
                    </para>
                </callout>
                <callout arearefs="mappingcollection11">
                    <para>
                        <literal>fetch</literal> (optional, defaults to <literal>select</literal>): chooses between
                        outer-join fetching, fetching by sequential select, and fetching by sequential subselect -
                        see <xref linkend="performance-fetching-subselect" />. <literal>join</literal> takes
                        precedence over the <literal>lazy</literal> attribute and causes the association to be
                        eagerly fetched.
                    </para>
                </callout>
                <callout arearefs="mappingcollection12">
                    <para>
                        <literal>batch-size</literal> (optional, defaults to <literal>1</literal>): specifies a
                        "batch size" for lazily fetching instances of this collection. See
                        <xref linkend="performance-fetching-batch"/>.
                    </para>
                </callout>
                <callout arearefs="mappingcollection13">
                    <para>
                        <literal>access</literal> (optional - defaults to <literal>property</literal>): the
                        strategy NHibernate should use for accessing the property value.
                    </para>
                </callout>
                <callout arearefs="mappingcollection14">
                    <para>
                        <literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>):
                        specifies that changes to the state of the collection results in increment of the
                        owning entity's version. For one to many associations, you may want to disable this
                        setting.
                    </para>
                </callout>
                <callout arearefs="mappingcollection15">
                    <para>
                        <literal>mutable</literal> (optional - defaults to <literal>true</literal>): a value of
                        <literal>false</literal> specifies that the elements of the collection never change.
                        This allows for minor performance optimization in some cases.
                    </para>
                </callout>
                <callout arearefs="mappingcollection16">
                    <para>
                        <literal>subselect</literal> (optional): maps an immutable and read-only collection to a
                        database sub-select. This is useful if you want to have a view instead of a base table.
                        It is not used for one-to-many associations.
                    </para>
                </callout>
                <callout arearefs="mappingcollection17">
                    <para>
                        <literal>check</literal> (optional): an SQL expression used to generate a multi-row check
                        constraint for automatic schema generation. It is not used for one-to-many associations.
                    </para>
                </callout>
                <callout arearefs="mappingcollection18">
                    <para>
                        <literal>persister</literal> (optional>): specifies a custom
                        <literal>ICollectionPersister</literal>.
                    </para>
                </callout>
                <callout arearefs="mappingcollection19">
                    <para>
                        <literal>collection-type</literal> (optional): the fully qualified type name of a class
                        implementing <literal>IUserCollectionType</literal>.
                    </para>
                </callout>
                <callout arearefs="mappingcollection20">
                    <para>
                        <literal>outer-join</literal> (optional): This attribute is obsoleted in favor of
                        <literal>fetch</literal>. <literal>auto</literal> is equivalent to not specifying
                        <literal>fetch</literal>, <literal>true</literal> is equivalent to
                        <literal>join</literal> and <literal>false</literal> is equivalent to
                        <literal>select</literal>. It has no value matching the <literal>subselect</literal>
                        <literal>fetch</literal> value.
                    </para>
                </callout>
                <callout arearefs="mappingcollection21">
                    <para>
                        <literal>generic</literal> (optional, defaults according to the reflected property type):
                        if <literal>false</literal>, NHibernate will type the collection elements as
                        <literal>object</literal>. Otherwise NHibernate will use reflection to determine the
                        element type to use.
                    </para>
                </callout>
            </calloutlist>
        </programlistingco>

        <para>
            The mapping of an <literal>IList</literal> or array requires a separate table column holding the array
            or list index (the <literal>i</literal> in <literal>foo[i]</literal>). If your relational model doesn't
            have an index column, use an unordered <literal>ISet</literal> instead. This seems to put people off
            who assume that <literal>IList</literal> should just be a more
            convenient way of accessing an unordered collection. NHibernate collections strictly obey the actual
            semantics attached to the <literal>ISet</literal>, <literal>IList</literal> and <literal>IDictionary</literal>
            interfaces. <literal>IList</literal> elements don't just spontaneously rearrange themselves!
        </para>

        <para>
            On the other hand, people who planned to use the <literal>IList</literal> to emulate
            <emphasis>bag</emphasis> semantics have a legitimate grievance here.
            A bag is an unordered, unindexed collection which may contain the same element multiple times.
            The .NET collections framework lacks an <literal>IBag</literal> interface, hence you have to emulate
            it with an <literal>IList</literal>. NHibernate lets you map properties of type <literal>IList</literal>
            or <literal>ICollection</literal> with the <literal>&lt;bag&gt;</literal> element. Note that bag
            semantics are not really part of the <literal>ICollection</literal> contract and they actually
            conflict with the semantics of the <literal>IList</literal> contract (however, you can sort
            the bag arbitrarily, discussed later in this chapter).
        </para>

        <para>
            Note: large NHibernate bags mapped with <literal>inverse="false"</literal> are inefficient and
            should be avoided. NHibernate can't create, delete or update rows individually, because there is
            no key that may be used to identify an individual row.
        </para>

        <sect2 id="collections-foreignkeys">
            <title>Collection foreign keys</title>

            <para>
                Collection instances are distinguished in the database by the foreign key of the entity that owns the
                collection. This foreign key is referred to as the <emphasis>collection key column</emphasis>, or
                columns, of the collection table. The collection key column is mapped by the
                <literal>&lt;key&gt;</literal> element.
            </para>

            <para>
                There can be a nullability constraint on the foreign key column. For most collections, this is implied.
                For unidirectional one-to-many associations, the foreign key column is nullable by default, so you may
                need to specify <literal>not-null="true"</literal>.
            </para>

            <programlisting><![CDATA[<key column="productSerialNumber" not-null="true"/>]]></programlisting>

            <para>
                The foreign key constraint can use <literal>ON DELETE CASCADE</literal>.
            </para>

            <programlisting><![CDATA[<key column="productSerialNumber" on-delete="cascade"/>]]></programlisting>

            <para>
                See <xref linkend="mapping-declaration-key" /> for a full definition of the
                <literal>&lt;key&gt;</literal> element.
            </para>

        </sect2>

        <sect2 id="collections-elements">
            <title>Collection elements</title>

            <para>
                Collections can contain almost any other NHibernate type, including: basic types, custom types, components
                and references to other entities. This is an important distinction. An object in a collection might be
                handled with "value" semantics (its life cycle fully depends on the collection owner), or it might be a
                reference to another entity with its own life cycle. In the latter case, only the "link" between the two
                objects is considered to be a state held by the collection.
            </para>

            <para>
                The contained type is referred to as the collection element type. Collection elements are mapped by
                <literal>&lt;element&gt;</literal> or <literal>&lt;composite-element&gt;</literal>, or in the case of entity
                references, with <literal>&lt;one-to-many&gt;</literal> or <literal>&lt;many-to-many&gt;</literal>. The
                first two map elements with value semantics, the next two are used to map entity associations. A last one
                exist for exotic entity associations, <literal>&lt;many-to-any&gt;</literal>, similar to
                <link linkend="mapping-types-anymapping">the <literal>&lt;any&gt;</literal> mapping element</link>.
            </para>

        </sect2>

        <sect2 id="collections-indexed">
            <title>Indexed collections</title>

            <para>
                All collection mappings, except those with set and bag semantics, need an <emphasis>index column</emphasis>
                in the collection table. An index column is a column that maps to an array index, or <literal>IList</literal>
                index, or <literal>IDictionary</literal> key. The index of an <literal>IDictionary</literal> may be of any
                basic type, mapped with <literal>&lt;map-key&gt;</literal>. It can be an entity reference mapped with
                <literal>&lt;map-key-many-to-many&gt;</literal> (or in exotic cases <literal>&lt;index-many-to-any&gt;</literal>,
                similar to <link linkend="mapping-types-anymapping">the <literal>&lt;any&gt;</literal> mapping element</link>),
                or it can be a composite type mapped with <literal>&lt;composite-map-key&gt;</literal>. The index of an array or
                list is always of type <literal>Int32</literal> and is mapped using the &lt;list-index&gt; element. The mapped
                column contains sequential integers that are numbered from zero by default.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="listindex1" coords="2 55"/>
                    <area id="listindex2" coords="3 55"/>
                </areaspec>
                <programlisting><![CDATA[<list-index
    column="columnName"
    base="0|1|..."
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="listindex1">
                        <para>
                            <literal>column</literal> (required): the name of the column holding the collection index values.
                        </para>
                    </callout>
                    <callout arearefs="listindex2">
                        <para>
                            <literal>base</literal> (optional - defaults to <literal>0</literal>): the value of the index column
                            that corresponds to the first element of the list or array.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <programlistingco>
                <areaspec>
                    <area id="mapkey1" coords="2 55"/>
                    <area id="mapkey2" coords="3 55"/>
                    <area id="mapkey3" coords="4 55"/>
                    <area id="mapkey4" coords="5 55"/>
                </areaspec>
                <programlisting><![CDATA[<map-key
    column="columnName"
    formula="any SQL expression"
    type="typeName"
    length="N"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="mapkey1">
                        <para>
                            <literal>column</literal> (required unless <literal>formula</literal> is used): the name of the column
                            holding the map key values.
                        </para>
                    </callout>
                    <callout arearefs="mapkey2">
                        <para>
                            <literal>formula</literal> (optional): a SQL formula used to evaluate the key of the map.
                        </para>
                    </callout>
                    <callout arearefs="mapkey3">
                        <para>
                            <literal>type</literal> (required): the type of the map keys.
                        </para>
                    </callout>
                    <callout arearefs="mapkey4">
                        <para>
                            <literal>length</literal> (optional): If the type takes a length and does not
                            already specify it, its length.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <programlistingco>
                <areaspec>
                    <area id="mapkeymanytomany1" coords="2 55"/>
                    <area id="mapkeymanytomany2" coords="3 55"/>
                    <area id="mapkeymanytomany3" coords="4 55"/>
                    <area id="mapkeymanytomany4" coords="5 55"/>
                    <area id="mapkeymanytomany5" coords="6 55"/>
                </areaspec>
                <programlisting><![CDATA[<map-key-many-to-many
    column="columnName"
    formula="any SQL expression"
    class="className"
    entity-name="entityName"
    foreign-key="foreignKeyName"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="mapkeymanytomany1">
                        <para>
                            <literal>column</literal> (required unless <literal>formula</literal> is used): the name of the column
                            holding the map key values.
                        </para>
                    </callout>
                    <callout arearefs="mapkeymanytomany2">
                        <para>
                            <literal>formula</literal> (optional): a SQL formula used to evaluate the key of the map.
                        </para>
                    </callout>
                    <callout arearefs="mapkeymanytomany3">
                        <para>
                            <literal>class</literal> (required): the entity class used as the map key.
                        </para>
                    </callout>
                    <callout arearefs="mapkeymanytomany4">
                        <para>
                            <literal>entity-name</literal> (optional): the entity name of the associated class.
                        </para>
                    </callout>
                    <callout arearefs="mapkeymanytomany5">
                        <para>
                            <literal>foreign-key</literal> (optional): specifies the name of the foreign key
                            constraint for DDL generation.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <programlistingco>
                <areaspec>
                    <area id="compositemapkey1" coords="2 55"/>
                    <area id="compositemapkey2" coords="4 55"/>
                    <area id="compositemapkey3" coords="5 55"/>
                </areaspec>
                <programlisting><![CDATA[<composite-map-key
    class="className">

    <key-property .../>
    <key-many-to-one .../>
    ...
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="compositemapkey1">
                        <para>
                            <literal>class</literal> (required): the component class used as the map key. Make sure
                            you override <literal>GetHashCode()</literal> and <literal>Equals()</literal>
                            correctly on the component class.
                        </para>
                    </callout>
                    <callout arearefs="compositemapkey2">
                        <para>
                            <literal>&lt;key-property&gt;</literal>: maps a component property.
                        </para>
                    </callout>
                    <callout arearefs="compositemapkey3">
                        <para>
                            <literal>&lt;key-many-to-one&gt;</literal>: maps a component many-to-one association.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                If your table does not have an index column, and you still wish to use <literal>IList</literal> as the
                property type, you can map the property as a NHibernate <literal>&lt;bag&gt;</literal>. A bag does not
                retain its order when it is retrieved from the database, but it can be optionally sorted or ordered.
                Also consider using an <literal>ISet</literal> as the property type.
            </para>

            <para>
                 The <literal>&lt;index&gt;</literal>, <literal>&lt;index-many-to-many&gt;</literal> and
                <literal>&lt;composite-index&gt;</literal> elements are obsoleted predecessors to
                <literal>&lt;map-key&gt;</literal>/<literal>&lt;list-index&gt;</literal>,
                <literal>&lt;map-key-many-to-many&gt;</literal> and <literal>&lt;composite-map-key&gt;</literal> respectively.
            </para>

        </sect2>

        <sect2 id="collections-ofvalues">
            <title>Collections of Values and Many-To-Many Associations</title>

            <para>
                Any collection of values or many-to-many associations requires a dedicated
                <emphasis>collection table</emphasis> with a <link linkend="collections-foreignkeys">foreign
                key column or columns</link>, <emphasis>collection element column</emphasis> or columns, and
                possibly an <link linkend="collections-indexed">index column or columns</link>.
            </para>

            <para>
                For a collection of values, use the <literal>&lt;element&gt;</literal> tag.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="element1" coords="2 55"/>
                    <area id="element2" coords="3 55"/>
                    <area id="element3" coords="4 55"/>
                    <area id="element4" coords="5 55"/>
                    <area id="element5" coords="6 55"/>
                    <area id="element6" coords="7 55"/>
                    <area id="element7" coords="8 55"/>
                    <area id="element8" coords="9 55"/>
                </areaspec>
                <programlisting><![CDATA[<element
    column="columnName"
    formula="any SQL expression"
    type="typeName"
    length="L"
    precision="P"
    scale="S"
    not-null="true|false"
    unique="true|false"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="element1">
                        <para>
                            <literal>column</literal> (required unless <literal>formula</literal> is used): the
                            name of the column holding the collection element values.
                        </para>
                    </callout>
                    <callout arearefs="element2">
                        <para>
                            <literal>formula</literal> (optional): an SQL formula used to evaluate the element.
                        </para>
                    </callout>
                    <callout arearefs="element3">
                        <para>
                            <literal>type</literal> (required): the type of the collection element.
                        </para>
                    </callout>
                   <callout arearefs="element4">
                        <para>
                            <literal>length</literal> (optional): if the type takes a length and does not
                            already specify it, its length.
                        </para>
                    </callout>
                   <callout arearefs="element5">
                        <para>
                            <literal>precision</literal> (optional): if the type takes a precision and does not
                            already specify it, its precision.
                        </para>
                    </callout>
                   <callout arearefs="element6">
                        <para>
                            <literal>scale</literal> (optional): if the type takes a scale and does not
                            already specify it, its scale.
                        </para>
                    </callout>
                   <callout arearefs="element7">
                        <para>
                            <literal>not-null</literal> (optional - defaults to <literal>false</literal>):
                            sets the column nullability for DDL generation.
                        </para>
                    </callout>
                   <callout arearefs="element8">
                        <para>
                            <literal>unique</literal> (optional - defaults to <literal>false</literal>):
                            sets the column uniqueness for DDL generation.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                A <emphasis>many-to-many association</emphasis> is specified using the
                <literal>&lt;many-to-many&gt;</literal> element.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="manytomany1" coords="2 60"/>
                    <area id="manytomany2" coords="3 60"/>
                    <area id="manytomany3" coords="4 60"/>
                    <area id="manytomany4" coords="5 60"/>
                    <area id="manytomany5" coords="6 60"/>
                    <area id="manytomany6" coords="7 60"/>
                    <area id="manytomany7" coords="8 60"/>
                    <area id="manytomany8" coords="9 60"/>
                    <area id="manytomany9" coords="10 60"/>
                    <area id="manytomany10" coords="11 60"/>
                    <area id="manytomany11" coords="12 60"/>
                    <area id="manytomany12" coords="13 60"/>
                    <area id="manytomany13" coords="14 60"/>
                </areaspec>
                <programlisting><![CDATA[<many-to-many
    column="columnName"
    formula="any SQL expression"
    class="className"
    fetch="join|select"
    lazy="false|proxy"
    not-found="ignore|exception"
    entity-name="entityName"
    property-ref="propertyNameFromAssociatedClass"
    order-by="columnName asc|desc"
    where="arbitrary sql where condition"
    unique="true|false"
    foreign-key="foreignKeyName"
    outer-join="auto|true|false"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="manytomany1">
                        <para>
                            <literal>column</literal> (required unless <literal>formula</literal> is used): the
                            name of the element foreign key column.
                        </para>
                    </callout>
                    <callout arearefs="manytomany2">
                        <para>
                            <literal>formula</literal> (optional): an SQL formula used to evaluate the element
                            foreign key value.
                        </para>
                    </callout>
                    <callout arearefs="manytomany3">
                        <para>
                            <literal>class</literal> (required): the name of the associated class.
                        </para>
                    </callout>
                    <callout arearefs="manytomany4">
                        <para>
                            <literal>fetch</literal> (optional, defaults to <literal>join</literal>):
                            enables outer-join or sequential select fetching for this association. This is a
                            special case; for full eager fetching (in a single SELECT) of an entity and its
                            many-to-many relationships to other entities, you would enable join fetching not
                            only of the collection itself, but also with this attribute on the
                            <literal>&lt;many-to-many&gt;</literal> nested element.
                        </para>
                    </callout>
                    <callout arearefs="manytomany5">
                        <para>
                            <literal>lazy</literal> (optional, defaults to <literal>proxy</literal>):
                            may be used to disable lazy fetching and specify that the associated entities
                            are always eagerly fetched. This is a special case; disabling laziness of the
                            collection itself only would only eagerly load the list of ids of the associated
                            entities. For fully loading the associated entities instead, while keeping
                            <literal>fetch</literal> value as <literal>select</literal>, you would also
                            disable laziness with this attribute on the <literal>&lt;many-to-many&gt;</literal>
                            nested element.
                        </para>
                    </callout>
                    <callout arearefs="manytomany6">
                        <para>
                            <literal>not-found</literal> (optional - defaults to <literal>exception</literal>):
                            specifies how foreign keys that reference missing rows will be handled.
                            <literal>ignore</literal> will treat a missing row as a null association.
                        </para>
                    </callout>
                    <callout arearefs="manytomany7">
                        <para>
                            <literal>entity-name</literal> (optional): the entity name of the associated class.
                        </para>
                    </callout>
                    <callout arearefs="manytomany8">
                        <para>
                            <literal>property-ref</literal> (optional): the name of a property of the associated
                            class that is joined to this foreign key. If not specified, the primary key of the
                            associated class is used.
                        </para>
                    </callout>
                    <callout arearefs="manytomany9">
                        <para>
                            <literal>order-by</literal> (optional): specifies a table column (or columns) that
                            defines the iteration order of the collection. This is a special case; the
                            <literal>order-by</literal> on the collection could order only by the foreign key.
                            The <literal>order-by</literal> on the <literal>&lt;many-to-many&gt;</literal>
                            nested element allows to order by the associated entity columns.
                        </para>
                    </callout>
                    <callout arearefs="manytomany10">
                        <para>
                            <literal>where</literal> (optional): specifies an arbitrary SQL <literal>WHERE</literal>
                        condition to be used when retrieving or removing the collection. This is a special case; the
                            <literal>where</literal> on the collection could filter only by the foreign key.
                            The <literal>where</literal> on the <literal>&lt;many-to-many&gt;</literal>
                            nested element allows to filter by the associated entity columns.
                        </para>
                    </callout>
                    <callout arearefs="manytomany11">
                        <para>
                            <literal>unique</literal> (optional): enables the DDL generation of a unique constraint
                            for the foreign-key column. This makes the association multiplicity effectively
                            one-to-many.
                        </para>
                    </callout>
                    <callout arearefs="manytomany12">
                        <para>
                            <literal>foreign-key</literal> (optional): specifies the name of the foreign key
                            constraint for DDL generation.
                        </para>
                    </callout>
                    <callout arearefs="manytomany13">
                        <para>
                            <literal>outer-join</literal> (optional): This attribute is obsoleted in favor of
                            <literal>fetch</literal>. <literal>auto</literal> is equivalent to not specifying
                            <literal>fetch</literal>, <literal>true</literal> is equivalent to
                            <literal>join</literal> and <literal>false</literal> is equivalent to
                            <literal>select</literal>.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                Here are some examples.
            </para>

            <para>
                A set of strings:
            </para>

            <programlisting><![CDATA[<set name="Names" table="NAMES">
    <key column="GROUPID"/>
    <element column="NAME" type="String"/>
</set>]]></programlisting>

            <para>
                A bag containing integers with an iteration order determined by the
                <literal>order-by</literal> attribute:
            </para>

            <programlisting><![CDATA[<bag name="Sizes" table="SIZES" order-by="SIZE ASC">
    <key column="OWNER"/>
    <element column="SIZE" type="Int32"/>
</bag>]]></programlisting>

            <para>
                An array of entities, in this case, a many-to-many association (note that
                the entities are lifecycle objects, <literal>cascade="all"</literal>, see
                <xref linkend="manipulatingdata-graphs"/>):
            </para>

            <programlisting><![CDATA[<array name="Addresses" table="PersonAddress" cascade="all">
    <key column="personId"/>
    <list-index column="sortOrder"/>
    <many-to-many column="addressId" class="Address"/>
</array>]]></programlisting>

            <para>
                A map from string indices to dates:
            </para>

            <programlisting><![CDATA[<map name="Holidays" table="holidays" schema="dbo" order-by="hol_name asc">
    <key column="id"/>
    <map-key column="hol_name" type="string"/>
    <element column="hol_date" type="Date"/>
</map>]]></programlisting>

            <para>
                A list of components (discussed in <xref linkend="components"/>):
            </para>

            <programlisting><![CDATA[<list name="CarComponents" table="car_components">
    <key column="car_id"/>
    <list-index column="sortOrder"/>
    <composite-element class="Eg.Car.CarComponent">
        <property name="Price"/>
        <property name="Type"/>
        <property name="SerialNumber" column="serial_no"/>
    </composite-element>
</list>]]></programlisting>

        </sect2>

        <sect2 id="collections-onetomany">
            <title>One-To-Many Associations</title>

            <para>
                A <emphasis>one-to-many association</emphasis> links the tables of two classes via a
                foreign key with no intervening collection table. This mapping loses certain semantics
                of normal .NET collections:
            </para>

            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        No null values may be contained in a dictionary, set or list (unless
                        using <literal>not-found</literal> value <literal>ignore</literal>).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        An instance of the contained entity class cannot belong to more than
                        one instance of the collection.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        An instance of the contained entity class cannot appear at more than
                        one value of the collection index.
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                An association from <literal>Product</literal> to <literal>Part</literal> requires the
                existence of a foreign key column and possibly an index column into the Part table. A
                <literal>&lt;one-to-many&gt;</literal> tag indicates that this is a one-to-many
                association.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="onetomany1" coords="2 60"/>
                    <area id="onetomany2" coords="3 60"/>
                    <area id="onetomany3" coords="4 60"/>
                </areaspec>
                <programlisting><![CDATA[<one-to-many
    class="className"
    not-found="ignore|exception"
    entity-name="entityName"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="onetomany1">
                        <para>
                            <literal>class</literal> (required): the name of the associated class.
                        </para>
                    </callout>
                    <callout arearefs="onetomany2">
                        <para>
                            <literal>not-found</literal> (optional - defaults to <literal>exception</literal>):
                            specifies how foreign keys that reference missing rows will be handled.
                            <literal>ignore</literal> will treat a missing row as a null association.
                        </para>
                    </callout>
                    <callout arearefs="onetomany3">
                        <para>
                            <literal>entity-name</literal> (optional): the entity name of the associated class.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                The <literal>&lt;one-to-many&gt;</literal> element does not need to declare any columns. Nor is
                it necessary to specify the table name anywhere. 
            </para>

            <para>
                <emphasis>Very Important Note:</emphasis> If the foreign key column of an
                <literal>&lt;one-to-many&gt;</literal> association is declared <literal>NOT NULL</literal>, you
                must declare the <literal>&lt;key&gt;</literal> mapping <literal>not-null="true"</literal> or
                <emphasis>use a bidirectional association</emphasis> with the collection mapping marked
                <literal>inverse="true"</literal>. See <xref linkend="collections-bidirectional" /> for more
                information.
            </para>

            <para>
                Example:
            </para>

            <programlisting><![CDATA[<set name="Parts">
    <key column="product_id"/>
    <one-to-many class="Eg.Part, Eg"/>
</set>]]></programlisting>

        </sect2>

    </sect1>

    <sect1 id="collections-advancedmappings">
        <title>Advanced collection mappings</title>

        <sect2 id="collections-sorted" revision="1">
            <title>Sorted Collections</title>

            <para>
                NHibernate supports collections implemented by <literal>System.Collections.Generic.SortedList&lt;T&gt;</literal> and
                <literal>System.Collections.Generic.SortedSet&lt;T&gt;</literal>. You must specify a comparer in the mapping file:
            </para>

            <programlisting><![CDATA[<set name="Aliases" table="person_aliases" sort="natural">
    <key column="person"/>
    <element column="name" type="String"/>
</set>

<map name="Holidays" sort="My.Custom.HolidayComparer, MyAssembly">
    <key column="year_id"/>
    <map-key column="hol_name" type="String"/>
    <element column="hol_date" type="Date"/>
</map>]]></programlisting>

            <para>
                Allowed values of the <literal>sort</literal> attribute are <literal>unsorted</literal>,
                <literal>natural</literal> and the name of a class implementing
                <literal>System.Collections.Generic.IComparer&lt;T&gt;</literal>.
            </para>

            <para>
                If you want the database itself to order the collection elements use the
                <literal>order-by</literal> attribute of <literal>set</literal>, <literal>bag</literal>
                or <literal>map</literal> mappings. This performs the ordering in the SQL query, not in
                memory.
            </para>

            <para>
                Setting the <literal>order-by</literal> attribute tells NHibernate to use
                <literal>Iesi.Collections.Generic.LinkedHashSet</literal> class
                internally for sets, maintaining the order of the elements. It is not supported on maps,
                unless specifying also a custom <literal>collection-type</literal> implementing
                <literal>IUserCollectionType</literal>.
            </para>

            <programlisting><![CDATA[<set name="Aliases" table="person_aliases" order-by="name asc">
    <key column="person"/>
    <element column="name" type="String"/>
</set>

<map name="Holidays" order-by="hol_date, hol_name" collection-type="...">
    <key column="year_id"/>
    <map-key column="hol_name" type="String"/>
    <element column="hol_date type="Date"/>
</map>]]></programlisting>

            <para>
                Note that the value of the <literal>order-by</literal> attribute is an SQL ordering, not
                a HQL ordering!
            </para>

            <para>
                Associations can even be sorted by some arbitrary criteria at runtime using a
                <literal>CreateFilter()</literal>.
            </para>

            <programlisting><![CDATA[sortedUsers = s
    .CreateFilter(group.Users, "order by this.Name")
    .List<User>();]]></programlisting>

        </sect2>

        <sect2 id="collections-bidirectional">
            <title>Bidirectional Associations</title>

            <para>
                A <emphasis>bidirectional association</emphasis> allows navigation from both
                "ends" of the association. Two kinds of bidirectional association are
                supported:

                <variablelist>
                    <varlistentry>
                        <term>one-to-many</term>
                        <listitem>
                            <para>
                                set or bag valued at one end, single-valued at the other
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>many-to-many</term>
                        <listitem>
                            <para>
                                set or bag valued at both ends
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>

            </para>

            <para>
                You can specify a bidirectional many-to-many association simply by mapping two
                many-to-many associations to the same database table and declaring one end as
                <emphasis>inverse</emphasis>. You cannot select an indexed collection.
            </para>

            <para>
                Here is an example of a bidirectional many-to-many association that illustrates how each
                category can have many items and each item can be in many categories: 
            </para>

            <programlisting><![CDATA[<class name="Category">
    <id name="Id" column="CATEGORY_ID"/>
    ...
    <bag name="Items" table="CATEGORY_ITEM">
        <key column="CATEGORY_ID"/>
        <many-to-many class="Item" column="ITEM_ID"/>
    </bag>
</class>

<class name="Item">
    <id name="Id" column="ITEM_ID"/>
    ...

    <!-- inverse end -->
    <bag name="Categories" table="CATEGORY_ITEM" inverse="true">
        <key column="ITEM_ID"/>
        <many-to-many class="Category" column="CATEGORY_ID"/>
    </bag>
</class>]]></programlisting>

            <para>
                Changes made only to the inverse end of the association are <emphasis>not</emphasis>
                persisted. This means that NHibernate has two representations in memory for every
                bidirectional association, one link from A to B and another link from B to A. This
                is easier to understand if you think about the .NET object model and how we create
                a many-to-many relationship in C#:
            </para>

            <programlisting><![CDATA[category.Items.Add(item);      // The category now "knows" about the relationship
item.Categories.Add(category); // The item now "knows" about the relationship

session.Update(item);          // No effect, nothing will be saved!
session.Update(category);      // The relationship will be saved]]></programlisting>

            <para>
                The non-inverse side is used to save the in-memory representation to the database.
                We would get an unnecessary INSERT/UPDATE and probably even a foreign key violation
                if both would trigger changes! The same is of course also true for bidirectional
                one-to-many associations.
            </para>

            <para>
                You can map a bidirectional one-to-many association by mapping a one-to-many association
                to the same table column(s) as a many-to-one association and declaring the many-valued
                end <literal>inverse="true"</literal>.
            </para>

            <programlisting><![CDATA[<class name="Parent">
    <id name="Id" column="id"/>
    ...
    <set name="Children" inverse="true">
        <key column="parent_id"/>
        <one-to-many class="Child"/>
    </set>
</class>

<class name="Child">
    <id name="Id" column="id"/>
    ...
    <many-to-one name="Parent" class="Parent" column="parent_id"/>
</class>]]></programlisting>

            <para>
                Mapping one end of an association with <literal>inverse="true"</literal> doesn't
                affect the operation of cascades as these are orthogonal concepts.
            </para>

        </sect2>

        <sect2 id="collections-indexedbidirectional">
            <title>Bidirectional associations with indexed collections</title>

            <para>
                A bidirectional association where one end is represented as a <literal>&lt;list&gt;</literal>
                or <literal>&lt;map&gt;</literal>, requires special consideration. If there is a property of
                the child class that maps to the index column you can use <literal>inverse="true"</literal>
                on the collection mapping:
            </para>

            <programlisting><![CDATA[<class name="Parent">
    <id name="Id" column="parent_id"/>
    ...
    <map name="Children" inverse="true">
        <key column="parent_id"/>
        <map-key column="name"
            type="string"/>
        <one-to-many class="Child"/>
    </map>
</class>

<class name="Child">
    <id name="Id" column="child_id"/>
    ...
    <property name="Name" column="name"
        not-null="true"/>
    <many-to-one name="Parent"
        class="Parent"
        column="parent_id"
        not-null="true"/>
</class>]]></programlisting>

            <para>
                If there is no such property on the child class, the association cannot be considered truly
                bidirectional. That is, there is information available at one end of the association that is not
                available at the other end. In this case, you cannot map the collection
                <literal>inverse="true"</literal>. Instead, you could use the following mapping:
            </para>

            <programlisting><![CDATA[<class name="Parent">
    <id name="Id" column="parent_id"/>
    ...
    <map name="Children">
        <key column="parent_id"
            not-null="true"/>
        <map-key column="name"
            type="string"/>
        <one-to-many class="Child"/>
    </map>
</class>

<class name="Child">
    <id name="Id" column="child_id"/>
    ...
    <many-to-one name="Parent"
        class="Parent"
        column="parent_id"
        insert="false"
        update="false"
        not-null="true"/>
</class>]]></programlisting>

            <para>
                Note that in this mapping, the collection-valued end of the association is responsible for
                updates to the foreign key.
            </para>

        </sect2>

        <sect2 id="collections-ternary">
            <title>Ternary Associations</title>

            <para>
                There are three possible approaches to mapping a ternary association. One approach is to use
                an <literal>IDictionary</literal> with an association as its index:
            </para>

            <programlisting><![CDATA[<map name="Contracts">
    <key column="employer_id"/>
    <map-key-many-to-many column="employee_id" class="Employee"/>
    <one-to-many class="Contract"/>
</map>]]></programlisting>

                <programlisting><![CDATA[<map name="Connections">
    <key column="incoming_node_id"/>
    <map-key-many-to-many column="outgoing_node_id" class="Node"/>
    <many-to-many column="connection_id" class="Connection"/>
</map>]]></programlisting>

            <para>
                A second approach is to remodel the association as an entity class. This is the most common
                approach.
            </para>

            <para>
                A final alternative is to use composite elements, see <xref linkend="components-incollections"/>.
            </para>

        </sect2>

        <sect2 id="collections-idbag" revision="1">
            <title>Using an <literal>&lt;idbag&gt;</literal></title>

            <para>
                If you've fully embraced our view that composite keys are a bad thing and that
                entities should have synthetic identifiers (surrogate keys), then you might
                find it a bit odd that the many to many associations and collections of values
                that we've shown so far all map to tables with composite keys! Now, this point
                is quite arguable; a pure association table doesn't seem to benefit much from
                a surrogate key (though a collection of composite values <emphasis>might</emphasis>).
                Nevertheless, NHibernate provides a feature that allows you to map many-to-many
                associations and collections of values to a table with a surrogate key.
            </para>

            <para>
                The <literal>&lt;idbag&gt;</literal> element lets you map a <literal>List</literal>
                (or <literal>Collection</literal>) with bag semantics.
            </para>

            <programlisting><![CDATA[<idbag name="Lovers" table="LOVERS">
    <collection-id column="ID" type="Int64">
        <generator class="hilo"/>
    </collection-id>
    <key column="PERSON1"/>
    <many-to-many column="PERSON2" class="Person" fetch="join"/>
</idbag>]]></programlisting>

            <para>
                An <literal>&lt;idbag&gt;</literal> has a synthetic id generator,
                just like an entity class. A different surrogate key is assigned to each collection
                row. NHibernate does not, however, provide any mechanism to discover the surrogate key value
                of a particular row.
            </para>

            <para>
                The update performance of an <literal>&lt;idbag&gt;</literal> supersedes a regular
                <literal>&lt;bag&gt;</literal>. NHibernate can locate individual rows efficiently and update
                or delete them individually, similar to a <literal>&lt;list&gt;</literal>,
                <literal>&lt;map&gt;</literal> or <literal>&lt;set&gt;</literal>.
            </para>

            <para>
                As of version 2.0, the <literal>native</literal> identifier generation
                strategy is supported for <literal>&lt;idbag&gt;</literal> collection identifiers.
            </para>

        </sect2>

        <sect2 id="collections-heterogeneous">
            <title>Heterogeneous Associations</title>

            <para>
                The <literal>&lt;many-to-any&gt;</literal> and <literal>&lt;index-many-to-any&gt;</literal>
                elements provide for true heterogeneous associations. These mapping elements work in the
                same way than the <link linkend="mapping-types-anymapping"><literal>&lt;any&gt;</literal>
                element</link> - and should also be used rarely, if ever.
            </para>

        </sect2>

    </sect1>

    <sect1 id="collections-lazy">
        <title>Lazy Initialization</title>

        <para>
            Collections (other than arrays) may be lazily initialized, meaning they load
            their state from the database only when the application needs to access it.
            Initialization happens transparently to the user so the application would not
            normally need to worry about this (in fact, transparent lazy initialization is
            the main reason why NHibernate needs its own collection implementations).
            However, if the application tries something like this:
        </para>

        <programlisting><![CDATA[IDictionary<string, int> permissions;
using (s = sessions.OpenSession())
using (ITransaction tx = sessions.BeginTransaction())
{
    var u = s.Load<User>(userId);
    permissions = u.Permissions;
    tx.Commit();
}

int accessLevel = permissions["accounts"];  // Error!]]></programlisting>

        <para>
            It could be in for a nasty surprise. Since the permissions collection was not
            initialized when the <literal>ISession</literal> was committed,
            the collection will never be able to load its state. The fix is to move the
            line that reads from the collection to just before the commit. (There are
            other more advanced ways to solve this problem, however.)
        </para>

        <para>
            Alternatively, use a non-lazy collection. However, it is intended that
            lazy initialization be used for almost all collections, especially for
            collections of entities (for reasons of efficiency).
        </para>

        <para>
            Exceptions that occur while lazily initializing a collection are wrapped in a
            <literal>LazyInitializationException</literal>.
        </para>

        <para>
            Disable lazy initialization of collection by using the optional <literal>lazy</literal>
            attribute:
        </para>

        <programlisting><![CDATA[<set name="Names" table="NAMES" lazy="false">
    <key column="group_id"/>
    <element column="NAME" type="String"/>
</set>]]></programlisting>

        <para>
            In some application architectures, particularly where the code that accesses data
            using NHibernate, and the code that uses it are in different application layers, it
            can be a problem to ensure that the <literal>ISession</literal> is open when a
            collection is initialized. There are two basic ways to deal with this issue:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    In a web-based application, an event handler can be used to close the
                    <literal>ISession</literal> only at the very end of a user request, once
                    the rendering of the view is complete. Of course, this places heavy
                    demands upon the correctness of the exception handling of your application
                    infrastructure. It is vitally important that the <literal>ISession</literal>
                    is closed and the transaction ended before returning to the user, even
                    when an exception occurs during rendering of the view. The event handler
                    has to be able to access the <literal>ISession</literal> for this approach.
                    We recommend that the current <literal>ISession</literal> is stored in the
                    <literal>HttpContext.Items</literal> collection (see chapter 1,
                    <xref linkend="quickstart-playingwithcats"/>, for an example implementation).
                </para>
            </listitem>
            <listitem>
                <para>
                    In an application with a separate business tier, the business logic must
                    "prepare" all collections that will be needed by the web tier before
                    returning. This means that the business tier should load all the data and
                    return all the data already initialized to the presentation/web tier that
                    is required for a particular use case. Usually, the application calls
                    <literal>NHibernateUtil.Initialize()</literal> for each collection that will
                    be needed in the web tier (this call must occur before the session is closed)
                    or retrieves the collection eagerly using a NHibernate query with a
                    <literal>FETCH</literal> clause.
                </para>
            </listitem>
            <listitem>
                <para>
                    You may also attach a previously loaded object to a new <literal>ISession</literal>
                    with <literal>Update()</literal> or <literal>Lock()</literal> before
                    accessing uninitialized collections (or other proxies). NHibernate can not
                    do this automatically, as it would introduce ad hoc transaction semantics!
                </para>
            </listitem>
        </itemizedlist>

        <para>
            You can use the <literal>CreateFilter()</literal> method of the NHibernate ISession API to
            get the size of a collection without initializing it:
        </para>

        <programlisting><![CDATA[var count = s
    .CreateFilter(collection, "select count(*)")
    .UniqueResult<long>();]]></programlisting>

        <para>
            <literal>CreateFilter()</literal> is also used to
            efficiently retrieve subsets of a collection without needing to initialize the whole
            collection.
        </para>

    </sect1>

    <sect1 id="collections-example">
        <title>Collection examples</title>

        <para>
            This section covers collection examples.
        </para>

        <para>
            The following class has a collection of <literal>Child</literal> instances: 
        </para>

        <programlisting><![CDATA[using System;
using System.Collections.Generic;

namespace Eg

    public class Parent
    {
        public virtual long Id { get; set; }

        public virtual ISet<Child> Children { get; set; }

        ...
    }
}]]></programlisting>

        <para>
            If each child has at most one parent, the most natural mapping is a one-to-many
            association:
        </para>

        <programlisting><![CDATA[<hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="Eg" namespace="Eg">

    <class name="Parent">
        <id name="Id">
            <generator class="sequence"/>
        </id>
        <set name="Children">
            <key column="parent_id"/>
            <one-to-many class="Child"/>
        </set>
    </class>

    <class name="Child">
        <id name="Id">
            <generator class="sequence"/>
        </id>
        <property name="Name"/>
    </class>

</hibernate-mapping>]]></programlisting>

        <para>
            This maps to the following table definitions:
        </para>

        <programlisting><![CDATA[create table parent (Id bigint not null primary key)
create table child (Id bigint not null primary key, Name varchar(255), parent_id bigint)
alter table child add constraint childfk0 (parent_id) references parent]]></programlisting>

        <para>
            The <literal>Child</literal> class has no property referencing its parent.
        </para>

        <para>
            If the parent is <emphasis>required</emphasis>, use a bidirectional one-to-many
            association:
        </para>

        <programlisting><![CDATA[<hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="Eg" namespace="Eg">

    <class name="Parent">
        <id name="Id">
            <generator class="sequence"/>
        </id>
        <set name="Children" inverse="true">
            <key column="parent_id"/>
            <one-to-many class="Child"/>
        </set>
    </class>

    <class name="Child">
        <id name="Id">
            <generator class="sequence"/>
        </id>
        <property name="Name"/>
        <many-to-one name="Parent" class="Parent" column="parent_id" not-null="true"/>
    </class>

</hibernate-mapping>]]></programlisting>

        <para>
            Notice the <literal>NOT NULL</literal> constraint:
        </para>

        <programlisting><![CDATA[create table parent ( Id bigint not null primary key )
create table child ( Id bigint not null
                     primary key,
                     Name varchar(255),
                     parent_id bigint not null )
alter table child add constraint childfk0 (parent_id) references parent]]></programlisting>

        <para>
            Here, the <literal>Child</literal> class has a <literal>Parent</literal> property.
        </para>

        <para>
            Alternatively, if this association must be unidirectional you can declare the
            <literal>NOT NULL</literal> constraint on the <literal>&lt;key&gt;</literal>
            mapping:
        </para>

        <programlisting><![CDATA[<hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="Eg" namespace="Eg">

    <class name="Parent">
        <id name="Id">
            <generator class="sequence"/>
        </id>
        <set name="Children">
            <key column="parent_id" not-null="true"/>
            <one-to-many class="Child"/>
        </set>
    </class>

    <class name="Child">
        <id name="Id">
            <generator class="sequence"/>
        </id>
        <property name="Name"/>
    </class>

</hibernate-mapping>]]></programlisting>

        <para>
            On the other hand, if a child might have multiple parents, a many-to-many
            association is appropriate:
        </para>

        <programlisting><![CDATA[<hibernate-mapping xmlns="urn:nhibernate-mapping-2.2"
    assembly="Eg" namespace="Eg">

    <class name="Parent">
        <id name="Id">
            <generator class="sequence"/>
        </id>
        <set name="Children" table="childset">
            <key column="parent_id"/>
            <many-to-many class="Child" column="child_id"/>
        </set>
    </class>

    <class name="eg.Child">
        <id name="Id">
            <generator class="sequence"/>
        </id>
        <property name="Name"/>
    </class>

</hibernate-mapping>]]></programlisting>

        <para>
            Table definitions:
        </para>

        <programlisting><![CDATA[create table parent ( Id bigint not null primary key )
create table child ( Id bigint not null primary key, name varchar(255) )
create table childset ( parent_id bigint not null,
                        child_id bigint not null,
                        primary key ( parent_id, child_id ) )
alter table childset add constraint childsetfk0 (parent_id) references parent
alter table childset add constraint childsetfk1 (child_id) references child]]></programlisting>

        <para>
            For more examples and a complete explanation of a parent/child relationship mapping,
            see <xref linkend="associations" /> and <xref linkend="example-parentchild" />.
        </para>

    </sect1>

</chapter>
