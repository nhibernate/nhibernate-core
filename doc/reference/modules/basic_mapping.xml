<chapter id="mapping">
    <title>Basic O/R Mapping</title>

    <sect1 id="mapping-declaration">
        <title>Mapping declaration</title>

        <para>
            Object/relational mappings are defined in an XML document. The mapping document
            is designed to be readable and hand-editable. The mapping language is object-centric,
            meaning that mappings are constructed around persistent class declarations, not
            table declarations.
        </para>
        
        <para>
            Note that, even though many NHibernate users choose to define XML mappings by hand,
            a number of tools exist to generate the mapping document, including
            NHibernate.Mapping.Attributes library and various template-based code
            generators (CodeSmith, MyGeneration). You may also use
            <literal>NHibernate.Mapping.ByCode</literal> available since NHibernate 3.2, or
            <ulink url="https://github.com/jagregory/fluent-nhibernate">Fluent NHibernate</ulink>.
        </para>

        <para>
            Let's kick off with an example mapping:
        </para>

        <programlisting><![CDATA[<?xml version="1.0"?>
<hibernate-mapping xmlns="urn:nhibernate-mapping-2.2" assembly="Eg"
    namespace="Eg">

    <class name="Cat" table="CATS" discriminator-value="C">
        <id name="Id" column="uid" type="Int64">
            <generator class="hilo"/>
        </id>
        <discriminator column="subclass" type="Char"/>
        <property name="BirthDate" type="Date"/>
        <property name="Color" not-null="true"/>
        <property name="Sex" not-null="true" update="false"/>
        <property name="Weight"/>
        <many-to-one name="Mate" column="mate_id"/>
        <set name="Kittens">
            <key column="mother_id"/>
            <one-to-many class="Cat"/>
        </set>
        <subclass name="DomesticCat" discriminator-value="D">
            <property name="Name" type="String"/>
        </subclass>
    </class>

    <class name="Dog">
        <!-- mapping for Dog could go here -->
    </class>

</hibernate-mapping>]]></programlisting>

        <para>
             We will now discuss the content of the mapping document. We will mainly describe the
             document elements and attributes that are used by NHibernate at runtime. The mapping
             document also contains some extra optional attributes and elements that affect the
             database schemas exported by the schema export tool, for example, the
             <literal>column</literal> sub-element of a property.
        </para>

        <sect2 id="mapping-declaration-xmlns">
            <title>XML Namespace</title>

            <para>
                All XML mappings should declare the XML namespace shown. The actual schema definition
                may be found in the <literal>src\nhibernate-mapping.xsd</literal> file in the
                NHibernate distribution.
            </para>

            <para><emphasis>
                Tip: to enable IntelliSense for mapping and configuration files, copy the appropriate
                <literal>.xsd</literal> files as part of any project in your solution,
                (<literal>Build Action</literal> can be "None") or as "Solution Files" or in your
              <literal>"Lib"</literal> folder and then add it to the <literal>Schemas</literal> property of the xml file.
              You can copy it in <literal>&lt;VS installation directory&gt;\Xml\Schemas</literal>, take care because you will have to deal
              with different version of the xsd for different versions of NHibernate.
            </emphasis>
            </para>

        </sect2>

        <sect2 id="mapping-declaration-mapping">
            <title>hibernate-mapping</title>

            <para>
                This element has several optional attributes. The <literal>schema</literal> and <literal>catalog</literal> attributes
                specify that tables referred to by this mapping belong to the named schema and/or catalog. If they are specified,
                table names will be qualified by the given schema and/or catalog name. If they are missing, table names will be
                unqualified. The <literal>default-cascade</literal> attribute specifies what cascade style
                should be assumed for properties and collections which do not specify a
                <literal>cascade</literal> attribute. The <literal>auto-import</literal> attribute lets us
                use unqualified class names in the query language, by default. The <literal>assembly</literal>
                and <literal>namespace</literal> attributes specify the assembly where persistent classes
                are located and the namespace they are declared in.
            </para>
 
            <programlistingco>
                <areaspec>
                    <area id="hm1" coords="2 55"/>
                    <area id="hm2" coords="3 55"/>
                    <area id="hm3" coords="4 55"/>
                    <area id="hm4" coords="5 55"/>
                    <area id="hm5" coords="6 55"/>
                    <area id="hm6" coords="7 55"/>
                    <area id="hm7" coords="8 55"/>
                    <area id="hm8" coords="9 55"/>
                </areaspec>
                <programlisting><![CDATA[<hibernate-mapping
    schema="schemaName"
    catalog="catalogName"
    default-cascade="none|save-update..."
    auto-import="true|false"
    assembly="Eg"
    namespace="Eg"
    default-access="field|property|field.camelcase..."
    default-lazy="true|false"
 />]]></programlisting>
                <calloutlist>
                    <callout arearefs="hm1">
                        <para>
                            <literal>schema</literal> (optional): The name of a database schema.
                        </para>
                    </callout>
                    <callout arearefs="hm2">
                        <para>
                            <literal>catalog</literal> (optional): The name of a database catalog.
                        </para>
                    </callout>
                    <callout arearefs="hm3">
                        <para>
                            <literal>default-cascade</literal> (optional - defaults to <literal>none</literal>):
                            A default cascade style.
                        </para>
                    </callout>
                    <callout arearefs="hm4">
                        <para>
                            <literal>auto-import</literal> (optional - defaults to <literal>true</literal>):
                            Specifies whether we can use unqualified class names of classes in this mapping
                            in the query language.
                        </para>
                    </callout>
                    <callout arearefs="hm5 hm6">
                        <para>
                            <literal>assembly</literal> and <literal>namespace</literal> (optional): Specify
                            assembly and namespace to use for unqualified class names in the mapping document.
                        </para>
                    </callout>
                    <callout arearefs="hm7">
                        <para>
                            <literal>default-access</literal> (optional - defaults to property):
                            The strategy NHibernate should use for accessing a property value. It can be a custom
                            implementation of <literal>IPropertyAccessor</literal>.
                        </para>
                    </callout>
                    <callout arearefs="hm8">
                        <para>
                            <literal>default-lazy</literal> (optional - defaults to <literal>true</literal>):
                            The default value for unspecified <literal>lazy</literal> attributes of class and collection mappings.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                If you are not using <literal>assembly</literal> and <literal>namespace</literal>
                attributes, you have to specify fully-qualified class names, including the name
                of the assembly that classes are declared in.
            </para>

            <para>
                If you have two persistent classes with the same (unqualified) name, you should set
                <literal>auto-import="false"</literal>. NHibernate will throw an exception if you attempt
                to assign two classes to the same "imported" name.
            </para>

            <para>
                The <literal>hibernate-mapping</literal> element allows you to nest several persistent <literal>&lt;class&gt;</literal>
                mappings, as shown above. It is, however, good practice to map only a single persistent class, or a single class
                hierarchy, in one mapping file and name it after the persistent super-class. For example, <literal>Cat.hbm.xml</literal>,
                <literal>Dog.hbm.xml</literal>, or if using inheritance, <literal>Animal.hbm.xml</literal>.
            </para>
        </sect2>

        <sect2 id="mapping-declaration-class">
            <title>class</title>

            <para>
                You may declare a persistent class using the <literal>class</literal> element:
            </para>

            <programlistingco>
                <areaspec>
                    <area id="class1" coords="2 55"/>
                    <area id="class2" coords="3 55" />
                    <area id="class3" coords="4 55"/>
                    <area id="class4" coords="5 55" />
                    <area id="class5" coords="6 55"/>
                    <area id="class6" coords="7 55" />
                    <area id="class7" coords="8 55"/>
                    <area id="class8" coords="9 55" />
                    <area id="class9" coords="10 55" />
                    <area id="class10" coords="11 55"/>
                    <area id="class11" coords="12 55"/>
                    <area id="class12" coords="13 55"/>
                    <area id="class13" coords="14 55"/>
                    <area id="class14" coords="15 55"/>
                    <area id="class15" coords="16 55"/>
                    <area id="class16" coords="17 55"/>
                    <area id="class17" coords="18 55"/>
                    <area id="class18" coords="19 55"/>
                    <area id="class19" coords="20 55"/>
                    <area id="class20" coords="21 55"/>
                    <area id="class21" coords="22 80"/>
                    <area id="class22" coords="23 55"/>
                    <area id="class23" coords="24 55"/>
                </areaspec>
                <programlisting><![CDATA[<class
    name="className"
    table="tableName"
    discriminator-value="discriminatorValue"
    mutable="true|false"
    schema="owner"
    catalog="catalog"
    proxy="proxyInterface"
    dynamic-update="true|false"
    dynamic-insert="true|false"
    select-before-update="true|false"
    polymorphism="implicit|explicit"
    where="arbitrary sql where condition"
    persister="persisterClass"
    batch-size="N"
    optimistic-lock="none|version|dirty|all"
    lazy="true|false"
    abstract="true|false"
    entity-name="entityName"
    check="arbitrary sql check condition"
    subselect="SQL expression"
    schema-action="none|drop|update|export|validate|all|commaSeparatedValues"
    rowid="unused"
    node="unused"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="class1">
                        <para>
                            <literal>name</literal>: The fully qualified .NET class name of the persistent class
                            (or interface), including its assembly name.
                        </para>
                    </callout>
                    <callout arearefs="class2">
                        <para>
                            <literal>table</literal>(optional - defaults to the unqualified class name): The name of its database table.
                        </para>
                    </callout>
                    <callout arearefs="class3">
                        <para>
                            <literal>discriminator-value</literal> (optional, defaults to the class name): A value
                            that distinguishes individual subclasses, used for polymorphic behaviour. Acceptable
                            values include <literal>null</literal> and <literal>not null</literal>.
                        </para>
                    </callout>
                    <callout arearefs="class4">
                        <para>
                            <literal>mutable</literal> (optional - defaults to <literal>true</literal>): Specifies
                            that instances of the class are (not) mutable.
                        </para>
                    </callout>
                    <callout arearefs="class5">
                        <para>
                            <literal>schema</literal> (optional): Overrides the schema name specified by
                            the root <literal>&lt;hibernate-mapping&gt;</literal> element.
                        </para>
                    </callout>
                    <callout arearefs="class6">
                        <para>
                            <literal>catalog</literal> (optional): Overrides the catalog name specified by
                            the root <literal>&lt;hibernate-mapping&gt;</literal> element.
                        </para>
                    </callout>
                    <callout arearefs="class7">
                        <para>
                            <literal>proxy</literal> (optional): Specifies an interface to use for lazy
                            initializing proxies. You may specify the name of the class itself.
                        </para>
                    </callout>
                    <callout arearefs="class8">
                        <para>
                            <literal>dynamic-update</literal> (optional - defaults to <literal>false</literal>):
                            Specifies that <literal>UPDATE</literal> SQL should be generated at runtime and
                            can contain only those columns whose values have changed.
                        </para>
                    </callout>
                    <callout arearefs="class9">
                        <para>
                            <literal>dynamic-insert</literal> (optional - defaults to <literal>false</literal>):
                            Specifies that <literal>INSERT</literal> SQL should be generated at runtime and
                            contain only the columns whose values are not null.
                        </para>
                    </callout>
                    <callout arearefs="class10">
                        <para>
                            <literal>select-before-update</literal> (optional - defaults to <literal>false</literal>):
                            Specifies that NHibernate should <emphasis>never</emphasis> perform an SQL <literal>UPDATE</literal>
                            unless it is certain that an object is actually modified. In certain cases (actually, only
                            when a transient object has been associated with a new session using <literal>update()</literal>),
                            this means that NHibernate will perform an extra SQL <literal>SELECT</literal> to determine
                            if an <literal>UPDATE</literal> is actually required.
                        </para>
                    </callout>
                    <callout arearefs="class11">
                        <para>
                            <literal>polymorphism</literal> (optional - defaults to <literal>implicit</literal>):
                            Determines whether implicit or explicit query polymorphism is used.
                        </para>
                    </callout>
                    <callout arearefs="class12">
                        <para>
                            <literal>where</literal> (optional) specify an arbitrary SQL <literal>WHERE</literal>
                            condition to be used when retrieving objects of this class.
                        </para>
                    </callout>
                    <callout arearefs="class13">
                        <para>
                            <literal>persister</literal> (optional): Specifies a custom <literal>IClassPersister</literal>.
                        </para>
                    </callout>
                    <callout arearefs="class14">
                        <para>
                            <literal>batch-size</literal> (optional - defaults to <literal>1</literal>): Specifies a "batch size"
                            for fetching instances of this class by identifier. See <xref linkend="performance-fetching-batch"/>.
                        </para>
                    </callout>
                   <callout arearefs="class15">
                        <para>
                            <literal>optimistic-lock</literal> (optional - defaults to <literal>version</literal>):
                            Determines the optimistic locking strategy.
                        </para>
                    </callout>
                    <callout arearefs="class16">
                        <para>
                            <literal>lazy</literal> (optional - defaults to <literal>true</literal>): Lazy fetching can be
                            disabled by setting <literal>lazy="false"</literal>.
                        </para>
                    </callout>
                    <callout arearefs="class17">
                        <para>
                            <literal>abstract</literal> (optional - defaults to <literal>false</literal>): Used to mark abstract
                            super-classes in <literal>&lt;union-subclass&gt;</literal> hierarchies.
                        </para>
                    </callout>
                    <callout arearefs="class18">
                        <para>
                            <literal>entity-name</literal> (optional - defaults to the class name): NHibernate allows a class to
                            be mapped multiple times, potentially to different tables. See <xref linkend="mapping-entityname" />.
                            It also allows entity mappings that are represented by dictionaries at the .Net level. In these cases,
                            you should provide an explicit arbitrary name for the entity. See
                            <xref linkend="persistent-classes-dynamicmodels"/> for more information.
                        </para>
                    </callout>
                    <callout arearefs="class19">
                        <para>
                            <literal>check</literal> (optional): An SQL expression used to generate a multi-row check constraint
                            for automatic schema generation.
                        </para>
                    </callout>
                    <callout arearefs="class20">
                        <para>
                            <literal>subselect</literal> (optional): Maps an immutable and read-only entity to a database sub-select.
                            This is useful if you want to have a view instead of a base table. See
                            <xref linkend="mapping-declaration-subselect"/> for more information.
                        </para>
                    </callout>
                    <callout arearefs="class21">
                        <para>
                            <literal>schema-action</literal> (optional): Specifies which schema actions should be generated for the
                            class table by the schema export tool. Valid values are <literal>none</literal>, <literal>drop</literal>,
                            <literal>update</literal>, <literal>export</literal>, <literal>validate</literal>,
                            <literal>all</literal> and any combination of them separated by commas (<literal>,</literal>).
                            Not specifying it is treated as <literal>all</literal>. See <xref linkend="toolsetguide-s1" />.
                        </para>
                    </callout>
                    <callout arearefs="class22 class23">
                        <para>
                            <literal>rowid</literal> and <literal>node</literal> (optional): These attributes have no
                            usage in NHibernate. The <literal>node</literal> attribute is present on many more mapping elements, and
                            has no usage on them too. It will be omitted from the documentation of these other elements.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                It is perfectly acceptable for the named persistent class to be an interface. You would then
                declare implementing classes of that interface using the <literal>&lt;subclass&gt;</literal>
                element. You may persist any inner class. You should specify the
                class name using the standard form ie. <literal>Eg.Foo+Bar, Eg</literal>.
                Due to an HQL parser limitation inner classes can not be used in queries in NHibernate, unless
                assigning to them an <literal>entity-name</literal> without the <literal>+</literal> character.
            </para>

            <para>
                Changes to immutable classes, <literal>mutable="false"</literal>, will not be
                persisted. This allows NHibernate to make some minor performance optimizations.
            </para>

            <para>
                The optional <literal>proxy</literal> attribute enables customization of the generated proxy
                for lazy initialization of persistent instances of the class: by default, the proxy derives
                from the class. Specifying an interface causes the proxy to implement it and to use
                <literal>System.Object</literal> as its base class. This enables proxifying a sealed class
                or a class having non virtual members. The specified interface should declare all the public
                members of the persistent class. On <literal>ISession.Load</literal> and on
                <literal>many-to-one</literal> associations, NHibernate will initially return proxies. The
                actual persistent object will be loaded when a method or property of the proxy is invoked.
                See <xref linkend="performance-fetching-initialization"/>.
            </para>

            <para><emphasis>Implicit</emphasis> polymorphism means that instances of the class will be returned
                by a query that names any superclass or implemented interface or the class and that instances
                of any subclass of the class will be returned by a query that names the class itself.
                <emphasis>Explicit</emphasis> polymorphism means that class instances will be returned only
                be queries that explicitly name that class and that queries that name the class will return
                only instances of subclasses mapped inside this <literal>&lt;class&gt;</literal> declaration
                as a <literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-subclass&gt;</literal>. For
                most purposes the default, <literal>polymorphism="implicit"</literal>, is appropriate.
                Explicit polymorphism is useful when two different classes are mapped to the same table
                (this allows a "lightweight" class that contains a subset of the table columns).
            </para>

            <para>
                The <literal>persister</literal> attribute lets you customize the persistence strategy used for
                the class. You may, for example, specify your own subclass of
                <literal>NHibernate.Persister.EntityPersister</literal> or you might even provide a
                completely new implementation of the interface
                <literal>NHibernate.Persister.IClassPersister</literal> that implements persistence via,
                for example, stored procedure calls, serialization to flat files or LDAP. See
                <literal>NHibernate.DomainModel.CustomPersister</literal> for a simple example (of "persistence"
                to a <literal>Hashtable</literal>).
            </para>

            <para>
                Note that the <literal>dynamic-update</literal> and <literal>dynamic-insert</literal>
                settings are not inherited by subclasses and so may also be specified on the
                <literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-subclass&gt;</literal> elements.
                These settings may increase performance in some cases, but might actually decrease
                performance in others. Use judiciously.
            </para>

            <para>
                Use of <literal>select-before-update</literal> will usually decrease performance. It is very
                useful to prevent a database update trigger being called unnecessarily if you reattach a graph
                of detached instances to an <literal>ISession</literal>.
            </para>

            <para>
                If you enable <literal>dynamic-update</literal>, you will have a choice of optimistic
                locking strategies:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <literal>version</literal> check the version/timestamp columns
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>all</literal> check all columns
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>dirty</literal> check the changed columns
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>none</literal> do not use optimistic locking
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                We <emphasis>very</emphasis> strongly recommend that you use version/timestamp
                columns for optimistic locking with NHibernate. This is the optimal strategy with
                respect to performance and is the only strategy that correctly handles modifications
                made outside of the session (ie. when <literal>ISession.Update()</literal> is used).
            </para>

            <para>
                Beginning with NHibernate 1.2.0, version numbers start with 1, not 0 as in previous
                versions. This was done to allow using 0 as <literal>unsaved-value</literal> for the
                version property.
            </para>
        </sect2>

        <sect2 id="mapping-declaration-subselect">
            <title>subselect</title>

            <para>
                An alternative to mapping a class to table or view columns is to map a <emphasis>query</emphasis>.
                For that, we use the <literal>&lt;subselect&gt;</literal> element, which is mutually
                exclusive with <literal>&lt;subclass&gt;</literal>, <literal>&lt;joined-subclass&gt;</literal>
                and <literal>&lt;union-subclass&gt;</literal>. The subselect may also be specified as a
                <literal>&lt;class&gt;</literal> attribute.
                The content of the <literal>subselect</literal> element is a SQL query:
            </para>

            <programlisting>&lt;subselect&gt;
    &lt;![CDATA[
    SELECT cat.ID, cat.NAME, cat.SEX, cat.MATE FROM cat
    ]]&gt;
&lt;/subselect&gt;</programlisting>

            <para>
                Usually, when mapping a query using <literal>subselect</literal> you will want to mark
                the class as not mutable (<literal>mutable="false"</literal>), unless you specify custom
                SQL for performing the UPDATE, DELETE and INSERT operations.
            </para>

            <para>
                Also, it makes sense to force synchronization of the tables affected by the query, using
                one or more <literal>&lt;synchronize&gt;</literal> entries:
            </para>

            <programlisting>&lt;subselect&gt;
    &lt;![CDATA[
    SELECT cat.ID, cat.NAME, cat.SEX, cat.MATE FROM cat
    ]]&gt;
&lt;/subselect&gt;
&lt;synchronize table="cat"/&gt;</programlisting>

            <para>
                This ensures that auto-flush happens correctly and that queries against the derived entity
                do not return stale data.
            </para>

            <para>
                You then still have to declare the class id and properties.
            </para>

        </sect2>

        <sect2 id="mapping-declaration-id">
            <title>id</title>

            <para>
                Mapped classes <emphasis>must</emphasis> declare the primary key column of the database
                table. Most classes will also have a property holding the unique identifier
                of an instance. The <literal>&lt;id&gt;</literal> element defines the mapping from that
                property to the primary key column.
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="id1" coords="2 55" />
                    <area id="id2" coords="3 55" />
                    <area id="id3" coords="4 55" />
                    <area id="id4" coords="5 55" />
                    <area id="id5" coords="6 55" />
                    <area id="id6" coords="7 55" />
                    <area id="id7" coords="8 55" />
                </areaspec>
                <programlisting><![CDATA[<id
    name="propertyName"
    type="typeName"
    length="typeLength"
    column="columnName"
    unsaved-value="any|none|null|undefined|idValue"
    access="field|property|nosetter|className"
    generator="generatorClass">

    <generator class="generatorClass"/>
</id>]]></programlisting>
                <calloutlist>
                    <callout arearefs="id1">
                        <para>
                            <literal>name</literal> (optional): The name of the identifier property.
                        </para>
                    </callout>
                    <callout arearefs="id2">
                        <para>
                            <literal>type</literal> (optional): A name that indicates the NHibernate type.
                        </para>
                    </callout>
                    <callout arearefs="id3">
                        <para>
                            <literal>length</literal> (optional): If the type takes a length and does not
                            already specify it, its length.
                        </para>
                    </callout>
                    <callout arearefs="id4">
                        <para>
                            <literal>column</literal> (optional - defaults to the property name): The
                            name of the primary key column.
                        </para>
                    </callout>
                    <callout arearefs="id5">
                        <para>
                            <literal>unsaved-value</literal> (optional - defaults to a "sensible" value):
                            An identifier property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from transient instances that were saved or loaded
                            in a previous session.
                        </para>
                    </callout>
                   <callout arearefs="id6">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): The
                            strategy NHibernate should use for accessing the property value.
                        </para>
                    </callout>
                   <callout arearefs="id7">
                        <para>
                            <literal>generator</literal>: The name of a generator class to use for generating
                            unique identifiers for instances of the persistent class. See the
                            <link linkend="mapping-declaration-id-generator">generator element</link>. Specifying
                            either the attribute or the element is required. The attribute takes precedence over
                            the element.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                If the <literal>name</literal> attribute is missing, it is assumed that the class has no
                identifier property.
            </para>

            <para>
                The <literal>unsaved-value</literal> attribute is almost never needed in NHibernate.
            </para>

            <para>
                There is an alternative <literal>&lt;composite-id&gt;</literal> declaration to allow access to
                legacy data with composite keys. We strongly discourage its use for anything else.
            </para>

            <sect3 id="mapping-declaration-id-generator">
                <title>generator</title>

                <para>
                    The required <literal>generator</literal> names a .NET class used to generate unique identifiers
                    for instances of the persistent class.
                </para>
                <para>
                  The generator can be declared using the <literal>&lt;generator&gt;</literal> child element. If
                  any parameters are required to configure or initialize the generator instance, they are passed
                  using <literal>&lt;param&gt;</literal> elements.
                </para>

                <programlisting><![CDATA[<id name="Id" type="Int64" column="uid">
    <generator class="NHibernate.Id.TableHiLoGenerator">
        <param name="table">uid_table</param>
        <param name="column">next_hi_value_column</param>
    </generator>
</id>]]></programlisting>

                <para>
                    If no parameters are required, the generator can be declared using a <literal>generator</literal>
                    attribute directly on the <literal>&lt;id&gt;</literal> element, as follows:
                </para>

                <programlisting><![CDATA[<id name="Id" type="Int64" column="uid" generator="native" />]]></programlisting>

                <para>
                    All generators implement the interface <literal>NHibernate.Id.IIdentifierGenerator</literal>.
                    This is a very simple interface; some applications may choose to provide their own specialized
                    implementations. However, NHibernate provides a range of built-in implementations. There are shortcut
                    names for the built-in generators:

                    <variablelist>
                        <varlistentry>
                        <term><literal>increment</literal></term>
                        <listitem>
                            <para>
                                generates identifiers of any integral type that are unique only when
                                no other process is inserting data into the same table.
                                <emphasis>Do not use in a cluster.</emphasis>
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>counter</literal>, <literal>vm</literal></term>
                        <listitem>
                            <para>
                                generates identifiers of 64bits integral type constructed from the system
                                time and a counter value.
                                <emphasis>Do not use in a cluster.  May generate colliding identifiers in
                                a bit less than one year.</emphasis>
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>identity</literal></term>
                        <listitem>
                            <para>
                                supports identity columns in DB2, MySQL, MS SQL Server, Sybase and some other systems.
                                The identifier returned by the database is converted to the property type using
                                <literal>Convert.ChangeType</literal>. Any integral property type is thus supported.
                                See <xref linkend="mapping-declaration-id-sequences" />.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>sequence</literal></term>
                        <listitem>
                            <para>
                                uses a sequence in DB2, PostgreSQL, Oracle and some other systems, or a generator
                                in Firebird. The identifier returned by the database is converted to the property
                                type using <literal>Convert.ChangeType</literal>. Any integral property type is
                                thus supported.
                                See <xref linkend="mapping-declaration-id-sequences" />.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>hilo</literal></term>
                        <listitem>
                            <para id="mapping-declaration-id-hilodescription" revision="1">
                                uses a hi/lo algorithm to efficiently generate identifiers of any integral type,
                                given a table and column (by default <literal>hibernate_unique_key</literal> and
                                <literal>next_hi</literal> respectively) as a source of hi values. The hi/lo algorithm
                                generates identifiers that are unique only for a particular database. <emphasis>Do not
                                use this generator with an user-supplied connection.</emphasis> See
                                <xref linkend="mapping-declaration-id-hilo" />.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>seqhilo</literal></term>
                        <listitem>
                            <para>
                                uses a hi/lo algorithm to efficiently generate identifiers of any integral type,
                                given a named database sequence. See <xref linkend="mapping-declaration-id-hilo" />.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>uuid.hex</literal></term>
                        <listitem>
                            <para>
                                uses <literal>System.Guid</literal> and its <literal>ToString(string format)</literal> method
                                to generate identifiers of type string.  The length of the string returned depends on the 
                                configured <literal>format</literal>. See <xref linkend="mapping-declaration-id-uuid-hex" />.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>uuid.string</literal></term>
                        <listitem>
                            <para>
                                uses a new <literal>System.Guid</literal> to create a <literal>byte[]</literal> that is
                                converted to a string. See <xref linkend="mapping-declaration-id-uuid-string" />.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>guid</literal></term>
                        <listitem>
                            <para>
                                uses a new <literal>System.Guid</literal> as the identifier. It is <emphasis>not equivalent</emphasis>
                                to the Hibernate <literal>guid</literal> generator. See <xref linkend="mapping-declaration-id-guid" />.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>guid.comb</literal></term>
                        <listitem>
                            <para>
                                uses the algorithm to generate a new <literal>System.Guid</literal>
                                described by Jimmy Nilsson in
                                <ulink url="https://www.informit.com/articles/article.aspx?p=25862">this
                                article</ulink>. See also <xref linkend="mapping-declaration-id-guid" />.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>guid.native</literal></term>
                        <listitem>
                            <para>
                                uses the database server side Guid function.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>native</literal></term>
                        <listitem>
                            <para>
                                picks <literal>identity</literal>, <literal>sequence</literal> or
                                <literal>hilo</literal> depending upon the capabilities of the
                                underlying database.
                                See <xref linkend="mapping-declaration-id-sequences" />.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>assigned</literal></term>
                        <listitem>
                            <para>
                                lets the application to assign an identifier to the object before
                                <literal>Save()</literal> is called.
                                See <xref linkend="mapping-declaration-id-assigned" />.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>select</literal></term>
                        <listitem>
                            <para>
                                retrieves a primary key, assigned by a database trigger, by selecting the row by some
                                unique key and retrieving the primary key value.
                                See <xref linkend="mapping-declaration-id-select" />.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>foreign</literal></term>
                        <listitem>
                            <para>
                                uses the identifier of another associated object. It is usually used in conjunction
                                with a <literal>&lt;one-to-one&gt;</literal> primary key association.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>sequence-identity</literal></term>
                        <listitem>
                            <para>
                                a generator which combines sequence generation with immediate retrieval
                                by attaching an output parameter to the SQL command.
                                In this respect it works much like ANSI-SQL identity generation.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>trigger-identity</literal></term>
                        <listitem>
                            <para>
                                a generator which uses an output parameter to return the identifier generated by the insert
                                on database server side.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>enhanced-sequence</literal></term>
                        <listitem>
                            <para>
                                uses a sequence with database supporting them, otherwise uses a table for emulating the sequence.
                                See <xref linkend="mapping-declaration-id-enhanced" />. Supports
                                <xref linkend="mapping-declaration-id-enhanced-optimizers" />.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>enhanced-table</literal></term>
                        <listitem>
                            <para>
                                uses a table like the <literal>hilo</literal> generator, but can handle multiple increment values
                                per table. See <xref linkend="mapping-declaration-id-enhanced" />. Supports
                                <xref linkend="mapping-declaration-id-enhanced-optimizers" />.
                            </para>
                        </listitem>
                        </varlistentry>
                    </variablelist>

                </para>
            </sect3>
            
            <sect3 id="mapping-declaration-id-hilo">
                <title>Hi/Lo Algorithm</title>
                <para>
                    The <literal>hilo</literal> and <literal>seqhilo</literal> generators provide two alternate
                    implementations of the hi/lo algorithm, a favorite approach to identifier generation. The
                    first implementation requires a "special" database table to hold the next available "hi" value.
                    The second uses an Oracle-style sequence (where supported).
                </para>

                <para>
                    Unfortunately, you can't use <literal>hilo</literal> when supplying your own
                    <literal>DbConnection</literal> to NHibernate. NHibernate must be able to
                    fetch the "hi" value in a new transaction.
                </para>

                <programlisting><![CDATA[<id name="Id" type="Int64" column="cat_id">
    <generator class="hilo">
        <param name="table">tableName</param>
        <param name="column">columnName</param>
        <param name="schema">schemaName</param>
        <param name="catalog">catalogName</param>
        <param name="max_lo">100</param>
        <param name="where">arbitraryWhereClause</param>
    </generator>
</id>]]></programlisting>

                <para>
                    <literal>table</literal> defaults to <literal>hibernate_unique_key</literal>,
                    <literal>column</literal> defaults to <literal>next_hi</literal>,
                    and <literal>max_lo</literal> defaults to <literal>32767</literal>.
                    <literal>schema</literal>, <literal>catalog</literal> and <literal>where</literal>
                    are optional and have no default value.
                </para>

                <para>
                    You can use the optional <literal>where</literal> parameter to specify the row to use in a table. This is
                    useful if you want to use a single table for your identifiers, with different rows for each table. Do not
                    include the <literal>where</literal> keyword in its value.
                    This is not handled by NHibernate schema generation tooling.
                </para>

                <programlisting><![CDATA[<id name="Id" type="Int64" column="cat_id">
    <generator class="seqhilo">
        <param name="sequence">hi_value</param>hibernate_sequence
        <param name="schema">schemaName</param>
        <param name="catalog">catalogName</param>
        <param name="max_lo">100</param>
        <param name="parameters">arbitrarySqlFragment</param>
    </generator>
</id>]]></programlisting>

                <para>
                    <literal>sequence</literal> defaults to <literal>hibernate_sequence</literal>,
                    and <literal>max_lo</literal> defaults to <literal>9</literal>.
                    <literal>schema</literal>, <literal>catalog</literal> and <literal>parameters</literal>
                    are optional and have no default value.
                </para>

                <para>
                    You can use the optional <literal>parameters</literal> parameter to specify some SQL to be
                    appended to the create sequence DDL.
                </para>
            </sect3>
            
            <sect3 id="mapping-declaration-id-uuid-hex">
                <title>UUID Hex Algorithm</title>

                <programlisting><![CDATA[<id name="Id" type="String" column="cat_id">
    <generator class="uuid.hex">
        <param name="format">format_value</param>
        <param name="separator">separator_value</param>
    </generator>
</id>]]></programlisting>

                <para>
                    The UUID is generated by calling <literal>Guid.NewGuid().ToString(format)</literal>.
                    The valid values for <literal>format</literal> are described in the MSDN documentation.
                    The default <literal>separator</literal> is <literal>-</literal> and should rarely be
                    modified.  The <literal>format</literal> determines if the configured
                    <literal>separator</literal> can replace the default separator used by
                    the <literal>format</literal>.
                </para>
            </sect3>
            
            <sect3 id="mapping-declaration-id-uuid-string">
                <title>UUID String Algorithm</title>
                <para>
                    The UUID is generated by calling <literal>Guid.NewGuid().ToByteArray()</literal> and
                    then converting the <literal>byte[]</literal> into a <literal>char[]</literal>.  The
                    <literal>char[]</literal> is returned as a <literal>String</literal> consisting of
                    16 characters.
                </para>
            </sect3>

            <sect3 id="mapping-declaration-id-guid">
                <title>GUID Algorithms</title>
                <para>
                    The <literal>guid</literal> identifier is generated by calling <literal>Guid.NewGuid()</literal>.
                    To address some of the performance concerns with using Guids as primary keys, foreign keys, and
                    as part of indexes with MS SQL the <literal>guid.comb</literal> can be used.  The benefit of using
                    the <literal>guid.comb</literal> with other databases that support GUIDs has not been measured.
                </para>
            </sect3>

            <sect3 id="mapping-declaration-id-sequences">
            <title>Identity columns and Sequences</title>
                <para>
                    For databases which support identity columns (DB2, MySQL, Sybase, MS SQL), you
                    may use <literal>identity</literal> key generation. For databases that support
                    sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you may use
                    <literal>sequence</literal> style key generation. Both these strategies require
                    two SQL queries to insert a new object.
                </para>

                <programlisting><![CDATA[<id name="Id" type="Int64" column="uid">
    <generator class="sequence">
        <param name="sequence">uid_sequence</param>
    </generator>
</id>]]></programlisting>

                <programlisting><![CDATA[<id name="Id" type="Int64" column="uid">
    <generator class="identity"/>
</id>]]></programlisting>

                <para>
                    For cross-platform development, the <literal>native</literal> strategy will
                    choose from the <literal>identity</literal>, <literal>sequence</literal> and
                    <literal>hilo</literal> strategies, dependent upon the capabilities of the
                    underlying database.
                </para>
            </sect3>

            <sect3 id="mapping-declaration-id-assigned">
                <title>Assigned Identifiers</title>
                <para>
                    If you want the application to assign identifiers (as opposed to having
                    NHibernate generate them), you may use the <literal>assigned</literal> generator.
                    This special generator will use the identifier value already assigned to the
                    object's identifier property. Be very careful when using this feature to assign
                    keys with business meaning (almost always a terrible design decision).
                </para>
                <para>
                    Due to its inherent nature, entities that use this generator may, when saved via
                    the ISession's SaveOrUpdate() method, cause NHibernate to query the database for
                    checking if the entity exist or not.
                </para>
                <para>
                    To avoid this, either:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            ensure that the identifier <literal>unsaved-value</literal> is not defined or is set
                            to <literal>undefined</literal>, and define an <literal>unsaved-value</literal> on
                            a <literal>&lt;version&gt;</literal> or <literal>&lt;timestamp&gt;</literal> property
                            mapping for the class. (Depending on the version type, its default
                            <literal>unsaved-value</literal> will generally already be suitable.)
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            specify to NHibernate if the object should be saved or updated by calling either the
                            <literal>Save()</literal> or <literal>Update()</literal> method of the ISession.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            set <literal>unsaved-value="none"</literal> and explicitly <literal>Save()</literal>
                            newly instantiated objects.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            set <literal>unsaved-value="any"</literal> and explicitly <literal>Update()</literal>
                            previously persistent objects.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            implement <literal>IInterceptor.IsTransient()</literal> for providing your own strategy
                            for distinguishing newly instantiated objects. See
                            <xref linkend="objectstate-interceptors"/>.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    For assigned identifiers, <literal>unsaved-value</literal> default value is
                    <literal>undefined</literal>.
                </para>
            </sect3>

            <sect3 id="mapping-declaration-id-select">
                <title>Primary keys assigned by triggers</title>
                <para>
                    NHibernate does not generate DDL with triggers. It is for legacy schemas only.
                </para>

                <programlisting><![CDATA[<id name="id" type="long" column="person_id">
    <generator class="select">
        <param name="key">socialSecurityNumber</param>
    </generator>
</id>]]></programlisting>

                <para>
                    In the above example, there is a unique valued property named
                    <literal>socialSecurityNumber</literal>. It is defined by the class, as a property.
                    And a surrogate key named person_id has its value generated by a trigger. Its value
                    will be retrieved by querying the entity table filtered by the <literal>key</literal>
                    property.
                </para>

                <para>
                    If the class maps a <link linkend="mapping-declaration-naturalid">natural id</link>,
                    <literal>key</literal> can be omitted. The natural id will be used when
                    <literal>key</literal> is omitted.
                </para>
            </sect3>

            <sect3 id="mapping-declaration-id-enhanced">
                <title>Enhanced identifier generators</title>

                <para>Starting with NHibernate release 3.3.0, there are two new generators which
                represent a re-thinking of two different aspects of identifier
                generation. The first aspect is database portability; the second is
                optimization. Optimization means that you do not have to query the
                database for every request for a new identifier value. These two new
                generators are intended to take the place of some of the named
                generators described above.</para>

                <para>The first of these new generators is
                <literal>NHibernate.Id.Enhanced.SequenceStyleGenerator</literal>
                (short name <literal>enhanced-sequence</literal>)
                which is intended, firstly, as a replacement for the
                <literal>sequence</literal> generator and, secondly, as a better
                portability generator than <literal>native</literal>. This is because
                <literal>native</literal> generally chooses between
                <literal>identity</literal> and <literal>sequence</literal> which have
                largely different semantics that can cause subtle issues in
                applications eyeing portability.
                <literal>NHibernate.Id.Enhanced.SequenceStyleGenerator</literal>,
                however, achieves portability in a different manner. It chooses
                between a table or a sequence in the database to store its
                incrementing values, depending on the capabilities of the dialect
                being used. The difference between this and <literal>native</literal>
                is that table-based and sequence-based storage have the same exact
                semantic. In fact, sequences are exactly what NHibernate tries to
                emulate with its table-based generators. This generator has a number
                of configuration parameters: <itemizedlist spacing="compact">
                    <listitem>
                      <para><literal>sequence_name</literal> (optional - defaults to
                      <literal>hibernate_sequence</literal>): the name of the sequence
                      or table to be used. <literal>schema</literal> and
                      <literal>catalog</literal> parameters can be additionally used
                      to qualify the sequence name.</para>
                    </listitem>

                    <listitem>
                      <para><literal>initial_value</literal> (optional - defaults to
                      <literal>1</literal>): the initial value to be retrieved from
                      the sequence/table. In sequence creation terms, this is
                      analogous to the clause typically named "STARTS WITH".</para>
                    </listitem>

                    <listitem>
                      <para><literal>increment_size</literal> (optional - defaults to
                      <literal>1</literal>): the value by which subsequent calls to
                      the sequence/table should differ. In sequence creation terms,
                      this is analogous to the clause typically named "INCREMENT
                      BY".</para>
                    </listitem>

                    <listitem>
                      <para><literal>force_table_use</literal> (optional - defaults to
                      <literal>false</literal>): should we force the use of a table as
                      the backing structure even though the dialect might support
                      sequence?</para>
                    </listitem>

                    <listitem>
                      <para><literal>value_column</literal> (optional - defaults to
                      <literal>next_val</literal>): only relevant for table
                      structures, it is the name of the column on the table which is
                      used to hold the value.</para>
                    </listitem>

                    <listitem>
                      <para><literal>optimizer</literal> (optional - defaults to
                      <literal>none</literal> if <literal>increment_size</literal> is <literal>1</literal>):
                       See <xref linkend="mapping-declaration-id-enhanced-optimizers" /></para>
                    </listitem>
                  </itemizedlist></para>

                <para>The second of these new generators is
                <literal>NHibernate.Id.Enhanced.TableGenerator</literal> (short name <literal>enhanced-table</literal>), which is
                intended, firstly, as a replacement for the <literal>table</literal>
                generator, even though it actually functions much more like
                <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal> (not available in NHibernate), and
                secondly, as a re-implementation of
                <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal> (not available in NHibernate) that
                utilizes the notion of pluggable optimizers. Essentially this
                generator defines a table capable of holding a number of different
                increment values simultaneously by using multiple distinctly keyed
                rows. This generator has a number of configuration parameters:
                <itemizedlist spacing="compact">
                    <listitem>
                      <para><literal>table_name</literal> (optional - defaults to
                      <literal>hibernate_sequences</literal>): the name of the table
                      to be used. <literal>schema</literal> and
                      <literal>catalog</literal> parameters can be additionally used
                      to qualify the sequence name.</para>
                    </listitem>

                    <listitem>
                      <para><literal>value_column_name</literal> (optional - defaults
                      to <literal>next_val</literal>): the name of the column on the
                      table that is used to hold the value.</para>
                    </listitem>

                    <listitem>
                      <para><literal>segment_column_name</literal> (optional -
                      defaults to <literal>sequence_name</literal>): the name of the
                      column on the table that is used to hold the "segment key". This
                      is the value which identifies which increment value to
                      use.</para>
                    </listitem>

                    <listitem>
                      <para><literal>segment_value</literal> (optional - defaults to
                      <literal>default</literal> unless
                      <literal>prefer_entity_table_as_segment_value</literal> is
                      <literal>true</literal>): The "segment key" value for the
                      segment from which we want to pull increment values for this
                      generator.</para>
                    </listitem>

                    <listitem>
                      <para><literal>segment_value_length</literal> (optional -
                      defaults to <literal>255</literal>): Used for schema generation;
                      the column size to create this segment key column.</para>
                    </listitem>

                    <listitem>
                      <para><literal>prefer_entity_table_as_segment_value</literal>
                      (optional - defaults to <literal>false</literal>): If
                      <literal>segment_value</literal> is not specified, whether it
                      should defaults to the entity table name or to
                      <literal>default</literal>.</para>
                    </listitem>

                    <listitem>
                      <para><literal>initial_value</literal> (optional - defaults to
                      <literal>1</literal>): The initial value to be retrieved from
                      the table.</para>
                    </listitem>

                    <listitem>
                      <para><literal>increment_size</literal> (optional - defaults to
                      <literal>1</literal>): The value by which subsequent calls to
                      the table should differ.</para>
                    </listitem>

                    <listitem>
                      <para><literal>optimizer</literal> (optional - defaults to
                      <literal>none</literal> if <literal>increment_size</literal> is <literal>1</literal>): See <xref
                      linkend="mapping-declaration-id-enhanced-optimizers" />.</para>
                    </listitem>
                  </itemizedlist></para>

                <sect4 id="mapping-declaration-id-enhanced-optimizers">
                  <title>Identifier generator optimization</title>

                  <para>For identifier generators that store values in the database,
                  it is inefficient for them to hit the database on each and every
                  call to generate a new identifier value. Instead, you can group a
                  bunch of them in memory and only hit the database when you have
                  exhausted your in-memory value group. This is the role of the
                  pluggable optimizers. Currently only the two enhanced generators
                  (<xref linkend="mapping-declaration-id-enhanced" /> support this
                  operation.</para>

                  <itemizedlist spacing="compact">
                    <listitem>
                      <para><literal>none</literal> (generally this is the default if
                      no optimizer was specified): this will not perform any
                      optimizations and hit the database for each and every
                      request.</para>
                    </listitem>

                    <listitem>
                      <para><literal>hilo</literal>: applies a hi/lo algorithm around
                      the database retrieved values. The values from the database for
                      this optimizer are expected to be sequential. The values
                      retrieved from the database structure for this optimizer
                      indicates the "group number". The
                      <literal>increment_size</literal> is multiplied by that value in
                      memory to define a group "hi value".</para>
                    </listitem>

                    <listitem>
                      <para><literal>pooled</literal>: as with the case of
                      <literal>hilo</literal>, this optimizer attempts to minimize the
                      number of hits to the database. Here, however, we simply store
                      the starting value for the "next group" into the database
                      structure rather than a sequential value in combination with an
                      in-memory grouping algorithm. Here,
                      <literal>increment_size</literal> refers to the values coming
                      from the database.</para>
                    </listitem>

                    <listitem>
                      <para><literal>pooled-lo</literal>: similar to
                      <literal>pooled</literal>, except that it's the starting value of
                      the "current group" that is stored into the database structure.
                      Here,
                      <literal>increment_size</literal> refers to the values coming
                      from the database.</para>
                    </listitem>
                  </itemizedlist>
                </sect4>
            </sect3>

        </sect2>

        <sect2 id="mapping-declaration-compositeid">
            <title>composite-id</title>

            <programlisting><![CDATA[<composite-id
    name="propertyName"
    class="className"
    unsaved-value="any|none"
    access="field|property|nosetter|className"
    mapped="true|false">

    <key-property name="propertyName" type="typeName" column="columnName"/>
    <key-many-to-one name="propertyName class="className" column="columnName"/>
    ...
</composite-id>]]></programlisting>

            <para>
                For a table with a composite key, you may map multiple properties of the class
                as identifier properties. The <literal>&lt;composite-id&gt;</literal> element
                accepts <literal>&lt;key-property&gt;</literal> property mappings and
                <literal>&lt;key-many-to-one&gt;</literal> mappings as child elements.
            </para>

            <programlisting><![CDATA[<composite-id>
    <key-property name="MedicareNumber"/>
    <key-property name="Dependent"/>
</composite-id>]]></programlisting>

            <para>
                Your persistent class <emphasis>must</emphasis> override <literal>Equals()</literal>
                and <literal>GetHashCode()</literal> to implement composite identifier equality. It must
                also be marked with the <literal>Serializable</literal> attribute.
            </para>

            <para>
                Unfortunately, this approach to composite identifiers means that a persistent object
                is its own identifier. There is no convenient "handle" other than the object itself.
                You must instantiate an instance of the persistent class itself and populate its
                identifier properties before you can <literal>Load()</literal> the persistent state
                associated with a composite key. We call this approach an embedded composite identifier,
                and discourage it for serious applications.
            </para>

            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>unsaved-value</literal> (optional - default to <literal>undefined</literal>):
                        controls how transient instances are considered. <literal>any</literal> assumes
                        any transient instance is newly instantiated. In other words, the instance will be
                        saved (inserted in the database). <literal>none</literal> assumes any transient instance
                        is already persisted. In other words, the instance will be updated.
                        <literal>undefined</literal> does not assume anything: NHibernate may query the database
                        for determining if the entity is already persisted or not.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>mapped</literal> (optional - defaults to <literal>false</literal>):
                        This attribute has no usage in NHibernate.
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                A much more convenient approach is to implement the composite identifier as a separate class,
                as in <xref linkend="components-compositeid"/>. The attributes described below apply only
                to this alternative approach:
            </para>

            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>name</literal> (optional, required for this approach): A property of
                        component type that holds the composite identifier (see <xref linkend="components-compositeid"/>).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>access</literal> (optional - defaults to <literal>property</literal>):
                        The strategy NHibernate should use for accessing the property value.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>class</literal> (optional - defaults to the property type determined by
                        reflection): The component class used as a composite identifier.
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                The second approach, an identifier component, is recommended for almost all applications.
            </para>

        </sect2>

        <sect2 id="mapping-declaration-discriminator" revision="1">
            <title>discriminator</title>

            <para>
                The <literal>&lt;discriminator&gt;</literal> element is required for polymorphic persistence
                using the table-per-class-hierarchy mapping strategy and declares a discriminator column of the
                table. The discriminator column contains marker values that tell the persistence layer what
                subclass to instantiate for a particular row. A restricted set of types may be used:
                <literal>String</literal>, <literal>Char</literal>, <literal>Int32</literal>,
                <literal>Byte</literal>, <literal>Short</literal>, <literal>Boolean</literal>,
                <literal>YesNo</literal>, <literal>TrueFalse</literal>.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="discriminator1" coords="2 55"/>
                    <area id="discriminator2" coords="3 55" />
                    <area id="discriminator3" coords="4 55" />
                    <area id="discriminator4" coords="5 55" />
                    <area id="discriminator5" coords="6 55" />
                    <area id="discriminator6" coords="7 55" />
                    <area id="discriminator7" coords="8 55" />
                </areaspec>
                <programlisting><![CDATA[<discriminator
    column="discriminatorColumn"
    type="discriminatorType"
    length="typeLength"
    not-null="true|false"
    force="true|false"
    insert="true|false"
    formula="arbitrary SQL expression"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="discriminator1">
                        <para>
                            <literal>column</literal> (optional - defaults to <literal>class</literal>): the
                            name of the discriminator column.
                        </para>
                    </callout>
                    <callout arearefs="discriminator2">
                        <para>
                            <literal>type</literal> (optional - defaults to <literal>String</literal>): a
                            name that indicates the NHibernate type
                        </para>
                    </callout>
                    <callout arearefs="discriminator3">
                        <para>
                            <literal>length</literal> (optional): if the type takes a length and does not
                            already specify it, its length.
                        </para>
                    </callout>
                    <callout arearefs="discriminator4">
                        <para>
                            <literal>not-null</literal> (optional - defaults to <literal>true</literal>):
                            sets the column nullability for DDL generation.
                        </para>
                    </callout>
                    <callout arearefs="discriminator5">
                        <para>
                            <literal>force</literal> (optional - defaults to <literal>false</literal>):
                            "force" NHibernate to specify allowed discriminator values even when retrieving 
                            all instances of the root class.
                        </para>
                    </callout>
                    <callout arearefs="discriminator6">
                        <para>
                            <literal>insert</literal> (optional - defaults to <literal>true</literal>):
                            set this to <literal>false</literal> if your discriminator column is also part
                            of a mapped composite identifier.
                        </para>
                    </callout>
                    <callout arearefs="discriminator7">
                        <para>
                            <literal>formula</literal> (optional): an arbitrary SQL expression that is
                            executed when a type has to be evaluated. Allows content-based discrimination.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                Actual values of the discriminator column are specified by the
                <literal>discriminator-value</literal> attribute of the <literal>&lt;class&gt;</literal> and
                <literal>&lt;subclass&gt;</literal> elements.
            </para>
            
            <para>
                The <literal>force</literal> attribute is only useful if the table contains rows with
                "extra" discriminator values that are not mapped to a persistent class. This will not
                usually be the case.
            </para>

            <para>
                Using the <literal>formula</literal> attribute, you can declare an arbitrary SQL expression
                that will be used to evaluate the type of a row:
            </para>

            <programlisting><![CDATA[<discriminator
    formula="case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end"
    type="Int32"/>]]></programlisting>
        </sect2>

        <sect2 id="mapping-declaration-version">
            <title>version (optional)</title>
            
            <para>
                The <literal>&lt;version&gt;</literal> element is optional and indicates that
                the table contains versioned data. This is particularly useful if you plan to
                use <emphasis>long transactions</emphasis> (see <xref linkend="transactions-optimistic" />).
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="version1" coords="2 55"/>
                    <area id="version2" coords="3 55"/>
                    <area id="version3" coords="4 55"/>
                    <area id="version4" coords="5 55"/>
                    <area id="version5" coords="6 55"/>
                    <area id="version6" coords="7 55"/>
                    <area id="version7" coords="8 55"/>
                </areaspec>
                <programlisting><![CDATA[<version
    column="versionColumn"
    name="propertyName"
    type="typeName"
    access="field|property|nosetter|className"
    unsaved-value="null|negative|undefined|value"
    generated="never|always"
    insert="false|true"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="version1">
                        <para>
                            <literal>column</literal> (optional - defaults to the property name): The name
                            of the column holding the version number.
                        </para>
                    </callout>
                    <callout arearefs="version2">
                        <para>
                            <literal>name</literal>: The name of a property  of the persistent class.
                        </para>
                    </callout>
                    <callout arearefs="version3">
                        <para>
                            <literal>type</literal> (optional - defaults to <literal>Int32</literal>):
                            The type of the version number.
                        </para>
                    </callout>
                   <callout arearefs="version4">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): The
                            strategy NHibernate should use for accessing the property value.
                        </para>
                    </callout>
                   <callout arearefs="version5">
                        <para>
                            <literal>unsaved-value</literal> (optional - defaults to a "sensible" value):
                            A version property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from transient instances that were saved or loaded
                            in a previous session. <literal>undefined</literal> specifies that nothing
                            should be assumed from the version property. The identifier check on its own
                            <literal>unsaved-value</literal> will take precedence, unless its own value is
                            <literal>undefined</literal>.
                        </para>
                    </callout>
                    <callout arearefs="version6">
                        <para>
                            <literal>generated</literal> (optional - defaults to <literal>never</literal>):
                            Specifies that this version property value is actually generated by the database.
                            See the discussion of <link linkend="mapping-generated">generated properties</link>.
                        </para>
                    </callout>
                    <callout arearefs="version7">
                        <para>
                            <literal>insert</literal> (optional - defaults to <literal>false</literal>):
                            This attribute has no usage in NHibernate.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                Version may be of type <literal>Int64</literal>, <literal>Int32</literal>,
                <literal>Int16</literal>, <literal>Ticks</literal>, <literal>Timestamp</literal>,
                <literal>TimeSpan</literal>, <literal>datetimeoffset</literal>, ... (or their nullable
                counterparts in .NET 2.0 and higher). Any type implementing <literal>IVersionType</literal> is
                usable as a version.
            </para>

        </sect2>
        
        <sect2 id="mapping-declaration-timestamp" revision="1">
            <title>timestamp (optional)</title>

            <para>
                The optional <literal>&lt;timestamp&gt;</literal> element indicates that the table contains 
                timestamped data. This is intended as an alternative to versioning. Timestamps are by nature
                a less safe implementation of optimistic locking. However, sometimes the application might
                use the timestamps in other ways.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="timestamp1" coords="2 55"/>
                    <area id="timestamp2" coords="3 55" />
                    <area id="timestamp3" coords="4 55" />
                    <area id="timestamp4" coords="5 55" />
                    <area id="timestamp5" coords="6 55" />
                    <area id="timestamp6" coords="7 55" />
                </areaspec>
                <programlisting><![CDATA[<timestamp
    column="timestampColumn"
    name="propertyName"
    access="field|property|nosetter|className"
    unsaved-value="null|undefined"
    generated="never|always"
    source="vm|db"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="timestamp1">
                        <para>
                            <literal>column</literal> (optional - defaults to the property name): The name
                            of a column holding the timestamp.
                        </para>
                    </callout>
                    <callout arearefs="timestamp2">
                        <para>
                            <literal>name</literal>: The name of a property of .NET type
                            <literal>DateTime</literal> of the persistent class.
                        </para>
                    </callout>
                   <callout arearefs="timestamp3">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): The
                            strategy NHibernate should use for accessing the property value.
                        </para>
                    </callout>
                   <callout arearefs="timestamp4">
                        <para>
                            <literal>unsaved-value</literal> (optional - defaults to <literal>null</literal>):
                            A timestamp property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from transient instances that were saved or loaded
                            in a previous session. <literal>undefined</literal> specifies that nothing
                            should be assumed from the timestamp value. The identifier check on its own
                            <literal>unsaved-value</literal> will take precedence, unless its own value is
                            <literal>undefined</literal>.
                        </para>
                    </callout>
                    <callout arearefs="timestamp5">
                        <para>
                            <literal>generated</literal> (optional - defaults to <literal>never</literal>):
                            Specifies that this timestamp property value is actually generated by the database
                            on insert and updates.
                            See the discussion of <link linkend="mapping-generated">generated properties</link>.
                            It should not to be confused with <literal>source</literal> value
                            <literal>db</literal>, which mandates NHibernate to retrieve the timestamp from the
                            database in a dedicated query, in order to get the new value to set in the next insert
                            or update.
                        </para>
                    </callout>
                   <callout arearefs="timestamp6">
                        <para>
                            <literal>source</literal> (optional - defaults to <literal>vm</literal>): Where should
                            NHibernate retrieve the timestamp value from? From the database, or from the current
                            runtime? Database-based timestamps incur an overhead because NHibernate must hit the
                            database in order to determine the "next value". It is safer to use in clustered
                            environments. Not all dialects are known to support the retrieval of the database's
                            current timestamp. Others may also be unsafe for usage in locking due to lack of
                            precision.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            
            <para>
                Note that <literal>&lt;timestamp&gt;</literal> is equivalent to
                <literal>&lt;version type="datetime"&gt;</literal>, and <literal>&lt;timestamp source="db"&gt;</literal>
                is equivalent to <literal>&lt;version type="dbtimestamp"&gt;</literal>.
            </para>
        </sect2>

        <sect2 id="mapping-declaration-property">
            <title>property</title>

            <para>
                The <literal>&lt;property&gt;</literal> element declares a persistent property
                of the class.
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="property1" coords="2 55"/>
                    <area id="property2" coords="3 55"/>
                    <area id="property3" coords="4 55"/>
                    <areaset id="property4-5" coords="">
                        <area id="property4" coords='5 55'/>
                        <area id="property5" coords='6 55'/>
                    </areaset>
                    <area id="property6" coords="7 55"/>
                    <area id="property7" coords="8 55"/>
                    <area id="property8" coords="9 55"/>
                    <area id="property9" coords="10 55" />
                    <area id="property10" coords="11 55" />
                    <area id="property11" coords="12 55" />
                    <area id="property12" coords="13 55" />
                    <area id="property13" coords="14 55" />
                    <area id="property14" coords="15 55" />
                    <area id="property15" coords="16 55" />
                    <area id="property16" coords="17 55" />
                    <area id="property17" coords="18 55" />
                </areaspec>
                <programlisting><![CDATA[<property
    name="propertyName"
    column="columnName"
    type="typeName"
    update="true|false"
    insert="true|false"
    formula="arbitrary SQL expression"
    access="field|property|className"
    optimistic-lock="true|false"
    generated="never|insert|always"
    lazy="true|false"
    not-null="true|false"
    unique="true|false"
    unique-key="uniqueKeyName"
    index="indexName"
    length="L"
    precision="P"
    scale="S"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="property1">
                        <para>
                            <literal>name</literal>: the name of the property of your class.
                        </para>
                    </callout>
                    <callout arearefs="property2">
                        <para>
                            <literal>column</literal> (optional - defaults to the property name): the name
                            of the mapped database table column.
                        </para>
                    </callout>
                    <callout arearefs="property3">
                        <para>
                            <literal>type</literal> (optional): a name that indicates the NHibernate type.
                        </para>
                    </callout>
                    <callout arearefs="property4-5">
                        <para>
                            <literal>update, insert</literal> (optional - defaults to <literal>true</literal>):
                            specifies that the mapped columns should be included in SQL <literal>UPDATE</literal>
                            and/or <literal>INSERT</literal> statements. Setting both to <literal>false</literal>
                            allows a pure "derived" property whose value is initialized from some other
                            property that maps to the same column(s) or by a trigger or other application.
                        </para>
                    </callout>
                    <callout arearefs="property6">
                        <para>
                            <literal>formula</literal> (optional): an SQL expression that defines the value for a
                            <emphasis>computed</emphasis> property. Computed properties do not have a column
                            mapping of their own.
                        </para>
                    </callout>
                   <callout arearefs="property7">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): the
                            strategy NHibernate should use for accessing the property value.
                        </para>
                    </callout>
                    <callout arearefs="property8">
                        <para>
                            <literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>):
                            specifies that updates to this property do or do not require acquisition of the
                            optimistic lock. In other words, determines if a version increment should occur when
                            this property is dirty.
                        </para>
                    </callout>
                    <callout arearefs="property9">
                        <para>
                            <literal>generated</literal> (optional - defaults to <literal>never</literal>):
                            specifies that this property value is actually generated by the database.
                            See the discussion of <link linkend="mapping-generated">generated properties</link>.
                        </para>
                    </callout>
                    <callout arearefs="property10">
                        <para>
                            <literal>lazy</literal> (optional - defaults to <literal>false</literal>):
                            specifies that this property is lazy. A lazy property is not loaded when
                            the object is initially loaded, unless the fetch mode has been overridden
                            in a specific query. Values for lazy properties are loaded when any lazy
                            property of the object is accessed. Having lazy properties causes instances
                            of the entity to be loaded as proxies. Theses proxies ignore the class
                            <literal>proxy</literal> setting and always derives from the persistent class,
                            requiring its members to be overridable.
                        </para>
                    </callout>
                   <callout arearefs="property11">
                        <para>
                            <literal>not-null</literal> (optional - defaults to <literal>false</literal>):
                            sets the column nullability for DDL generation.
                        </para>
                    </callout>
                   <callout arearefs="property12">
                        <para>
                            <literal>unique</literal> (optional - defaults to <literal>false</literal>):
                            sets the column uniqueness for DDL generation. Use <literal>unique-key</literal>
                            instead if the value is unique only in combination with other properties.
                        </para>
                    </callout>
                   <callout arearefs="property13">
                        <para>
                            <literal>unique-key</literal> (optional):
                            a logical name for an unique index for DDL generation. The column will be included in
                            the index, along with other columns sharing the same <literal>unique-key</literal>
                            logical name. The actual index name depends on the dialect.
                        </para>
                    </callout>
                   <callout arearefs="property14">
                        <para>
                            <literal>index</literal> (optional):
                            a logical name for an index for DDL generation. The column will be included in
                            the index, along with other columns sharing the same <literal>index</literal> logical
                            name. The actual index name depends on the dialect.
                        </para>
                    </callout>
                   <callout arearefs="property15">
                        <para>
                            <literal>length</literal> (optional): if the type takes a length and does not
                            already specify it, its length.
                        </para>
                    </callout>
                   <callout arearefs="property16">
                        <para>
                            <literal>precision</literal> (optional): if the type takes a precision and does not
                            already specify it, its precision.
                        </para>
                    </callout>
                   <callout arearefs="property17">
                        <para>
                            <literal>scale</literal> (optional): if the type takes a scale and does not
                            already specify it, its scale.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                <emphasis>typeName</emphasis> could be:
            </para>

            <orderedlist spacing="compact">
                <listitem>
                    <para>
                        The name of a NHibernate basic type (eg. <literal>Int32, String, Char,
                        DateTime, Timestamp, Single, Byte[], Object, ...</literal>).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The name of a .NET type with a default basic type (eg. <literal>System.Int16, System.Single,
                        System.Char, System.String, System.DateTime, System.Byte[], ...</literal>).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The name of an enumeration type (eg. <literal>Eg.Color, Eg</literal>).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The name of a serializable .NET type.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The class name of a custom type (eg. <literal>Illflow.Type.MyCustomType</literal>).
                    </para>
                </listitem>
            </orderedlist>

            <para>
                Note that you have to specify full <emphasis>assembly-qualified</emphasis> names for all
                except basic NHibernate types (unless you set <literal>assembly</literal>
                and/or <literal>namespace</literal> attributes of the
                <literal>&lt;hibernate-mapping&gt;</literal> element).
            </para>

            <para>
                NHibernate supports .NET 2.0 <literal>Nullable</literal> types. These types are
                mostly treated the same as plain non-<literal>Nullable</literal> types internally.
                For example, a property of type <literal>Nullable&lt;Int32&gt;</literal> can be mapped
                using <literal>type="Int32"</literal> or <literal>type="System.Int32"</literal>.
            </para>

            <para>
                If you do not specify a type, NHibernate will use reflection upon the named
                property to take a guess at the correct NHibernate type. NHibernate will try to
                interpret the name of the return class of the property getter using rules 2, 3,
                4 in that order. However, this is not always enough.
                In certain cases you will still need the <literal>type</literal>
                attribute. (For example, to distinguish between <literal>NHibernateUtil.DateTime</literal> and
                <literal>NHibernateUtil.UtcDateTime</literal>, or to specify a custom type.)
            </para>

            <para>
                See also <xref linkend="mapping-types" />.
            </para>

            <para>
                The <literal>access</literal> attribute lets you control how NHibernate will access
                the value of the property at runtime.  The value of the <literal>access</literal> attribute should
                be text formatted as <literal>access-strategy.naming-strategy</literal>.  The
                <literal>.naming-strategy</literal> is not always required.
                <table>
                    <title>Access Strategies</title>
                    <tgroup cols="2">
                        <thead>
                            <row>
                                <entry>Access Strategy Name</entry>
                                <entry>Description</entry>	
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><literal>property</literal></entry>
                                <entry>
                                    <para>
                                        The default implementation.  NHibernate uses the get/set accessors of
                                        the property.  No naming strategy should be used with this access strategy
                                        because the value of the <literal>name</literal> attribute is the name
                                        of the property.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>field</literal></entry>
                                <entry>
                                    <para>
                                        NHibernate will access the field directly.  NHibernate uses the value
                                        of the <literal>name</literal> attribute as the name of the field.
                                        This can be used when a property's getter and setter contain extra actions
                                        that you don't want to occur when NHibernate is populating or reading
                                        the object. If you want the name of the property and not the field to
                                        be what the consumers of your API use with HQL, then a naming strategy
                                        is needed.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>backfield</literal></entry>
                                <entry>
                                    <para>
                                        NHibernate will access the field of an auto-property directly.
                                        This can be used when a property's setter is not accessible.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>nosetter</literal></entry>
                                <entry>
                                    <para>
                                        NHibernate will access the field directly when setting the value and will use the
                                        Property when getting the value.  This can be used when a property only exposes
                                        a get accessor because the consumers of your API can't change the value directly.
                                        A naming strategy is required because NHibernate uses the value of the
                                        <literal>name</literal> attribute as the property name and needs to
                                        be told what the name of the field is.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>readonly</literal></entry>
                                <entry>
                                    <para>
                                        Access the mapped property through a Property <literal>get</literal> to get the value
                                        and do nothing to set the value. This is useful to allow calculated properties in the
                                        domain that will never be recovered from the DB but can be used for querying.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>noop</literal> / <literal>none</literal></entry>
                                <entry>
                                    <para>
                                        Used to declare properties not represented at the poco level.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>className</literal></entry>
                                <entry>
                                    <para>
                                        If NHibernate's built in access strategies are not what is needed for your situation
                                        then you can build your own by implementing the interface 
                                        <literal>NHibernate.Property.IPropertyAccessor</literal>.  The value of the 
                                        <literal>access</literal> attribute should be an assembly-qualified name that can be
                                        loaded with <literal>Activator.CreateInstance(string assemblyQualifiedName)</literal>.
                                    </para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>
                <table>
                    <title>Naming Strategies</title>
                    <tgroup cols="2">
                        <thead>
                            <row>
                                <entry>Naming Strategy Name</entry>
                                <entry>Description</entry>	
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><literal>camelcase</literal></entry>
                                <entry>
                                    <para>
                                        The <literal>name</literal> attribute is converted to camel case to find the field.
                                        <literal>&lt;property name="FooBar" ... &gt;</literal> uses the field <literal>fooBar</literal>.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>camelcase-underscore</literal></entry>
                                <entry>
                                    <para>
                                        The <literal>name</literal> attribute is converted to camel case and prefixed with an
                                        underscore to find the field.
                                        <literal>&lt;property name="FooBar" ... &gt;</literal> uses the field <literal>_fooBar</literal>.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>camelcase-m-underscore</literal></entry>
                                <entry>
                                    <para>
                                        The <literal>name</literal> attribute is converted to camel case and prefixed with
                                        the character <literal>m</literal> and an underscore to find the field.
                                        <literal>&lt;property name="FooBar" ... &gt;</literal> uses the field <literal>m_fooBar</literal>.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>lowercase</literal></entry>
                                <entry>
                                    <para>
                                        The <literal>name</literal> attribute is converted to lower case to find the Field.
                                        <literal>&lt;property name="FooBar" ... &gt;</literal> uses the field <literal>foobar</literal>.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>lowercase-underscore</literal></entry>
                                <entry>
                                    <para>
                                        The <literal>name</literal> attribute is converted to lower case and prefixed with an
                                        underscore to find the Field.
                                        <literal>&lt;property name="FooBar" ... &gt;</literal> uses the field <literal>_foobar</literal>.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>pascalcase-underscore</literal></entry>
                                <entry>
                                    <para>
                                        The <literal>name</literal> attribute is prefixed with an underscore to find the field.
                                        <literal>&lt;property name="FooBar" ... &gt;</literal> uses the field <literal>_FooBar</literal>.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>pascalcase-m</literal></entry>
                                <entry>
                                    <para>
                                        The <literal>name</literal> attribute is prefixed with the character
                                        <literal>m</literal> to find the field.
                                        <literal>&lt;property name="FooBar" ... &gt;</literal> uses the field <literal>mFooBar</literal>.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>pascalcase-m-underscore</literal></entry>
                                <entry>
                                    <para>
                                        The <literal>name</literal> attribute is prefixed with the character
                                        <literal>m</literal> and an underscore to find the field.
                                        <literal>&lt;property name="FooBar" ... &gt;</literal> uses the field <literal>m_FooBar</literal>.
                                    </para>
                                </entry>
                            </row>	
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>
                A powerful feature is derived properties. These properties are by definition read-only. The property value is computed at
                load time. You declare the computation as an SQL expression. This then translates to a <literal>SELECT</literal> clause
                subquery in the SQL query that loads an instance:
            </para>

            <programlisting><![CDATA[<property name="totalPrice"
    formula="( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p
                WHERE li.productId = p.productId
                AND li.customerId = customerId
                AND li.orderNumber = orderNumber )"/>]]></programlisting>

            <para>
                You can reference the entity table by not declaring an alias on a particular column. This would be
                <literal>customerId</literal> in the given example. You can also use the nested <literal>&lt;formula&gt;</literal> mapping
                element if you do not want to use the attribute.
            </para>

            <para>
                The nested <literal>&lt;column&gt;</literal> mapping element can also be used instead of the <literal>column</literal>
                attribute.
            </para>

        </sect2>

        <sect2 id="mapping-declaration-manytoone" revision="1">
            <title>many-to-one</title>

            <para>
                An ordinary association to another persistent class is declared using a
                <literal>many-to-one</literal> element. The relational model is a
                many-to-one association. (It is really just an object reference.)
            </para>

            <programlistingco>
                <areaspec>
                    <area id="manytoone1" coords="2 60"/>
                    <area id="manytoone2" coords="3 60"/>
                    <area id="manytoone3" coords="4 60"/>
                    <area id="manytoone4" coords="5 60"/>
                    <area id="manytoone5" coords="6 60"/>
                    <area id="manytoone6" coords="7 60"/>
                    <areaset id="manytoone7-8" coords="">
                        <area id="manytoone7" coords='8 60'/>
                        <area id="manytoone8" coords='9 60'/>
                    </areaset>
                    <area id="manytoone9" coords="10 60"/>
                    <area id="manytoone10" coords="11 60"/>
                    <area id="manytoone11" coords="12 60"/>
                    <area id="manytoone12" coords="13 60"/>
                    <area id="manytoone13" coords="14 60"/>
                    <area id="manytoone14" coords="15 60"/>
                    <area id="manytoone15" coords="16 60"/>
                    <area id="manytoone16" coords="17 60"/>
                    <area id="manytoone17" coords="18 60"/>
                    <area id="manytoone18" coords="19 60"/>
                    <area id="manytoone19" coords="20 60"/>
                    <area id="manytoone20" coords="21 60"/>
                </areaspec>
                <programlisting><![CDATA[<many-to-one
    name="propertyName"
    column="columnName"
    class="className"
    cascade="all|none|save-update|delete|delete-orphan|all-delete-orphan"
    fetch="join|select"
    lazy="proxy|no-proxy|false"
    update="true|false"
    insert="true|false"
    property-ref="propertyNameFromAssociatedClass"
    access="field|property|nosetter|className"
    optimistic-lock="true|false"
    not-found="ignore|exception"
    entity-name="entityName"
    formula="arbitrary SQL expression"
    not-null="true|false"
    unique="true|false"
    unique-key="uniqueKeyName"
    index="indexName"
    foreign-key="foreignKeyName"
    outer-join="auto|true|false"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="manytoone1">
                        <para>
                            <literal>name</literal>: The name of the property.
                        </para>
                    </callout>
                    <callout arearefs="manytoone2">
                        <para>
                            <literal>column</literal> (optional): The name of the column. This can also be
                            specified by nested <literal>&lt;column&gt;</literal> element(s).
                        </para>
                    </callout>
                    <callout arearefs="manytoone3">
                        <para>
                            <literal>class</literal> (optional - defaults to the property type
                            determined by reflection): The name of the associated class.
                        </para>
                    </callout>
                    <callout arearefs="manytoone4">
                        <para>
                            <literal>cascade</literal> (optional): Specifies which operations should
                            be cascaded from the parent object to the associated object.
                        </para>
                    </callout>
                    <callout arearefs="manytoone5">
                        <para>
                            <literal>fetch</literal> (optional - defaults to <literal>select</literal>):
                            Chooses between outer-join fetching or sequential select fetching.
                            <literal>join</literal> takes precedence over the <literal>lazy</literal>
                            attribute and causes the association to be eagerly fetched.
                        </para>
                    </callout>
                    <callout arearefs="manytoone6">
                        <para>
                            <literal>lazy</literal> (optional - defaults to <literal>proxy</literal>):
                            By default, single point associations are proxied. <literal>lazy="no-proxy"</literal>
                            specifies that the property should be fetched lazily when the instance property is first
                            accessed. It works similarly to lazy properties, and causes the entity owning the
                            association to be proxied instead of the association. <literal>lazy="false"</literal>
                            specifies that the association will be eagerly fetched.
                        </para>
                    </callout>
                    <callout arearefs="manytoone7-8">
                        <para>
                            <literal>update, insert</literal> (optional - defaults to <literal>true</literal>):
                            Specifies that the mapped columns should be included in SQL <literal>UPDATE</literal>
                            and/or <literal>INSERT</literal> statements. Setting both to <literal>false</literal>
                            allows a pure "derived" association whose value is initialized from some other
                            property that maps to the same column(s) or by a trigger or other application.
                        </para>
                    </callout>
                    <callout arearefs="manytoone9">
                        <para>
                            <literal>property-ref</literal> (optional): The name of a property of the associated
                            class that is joined to this foreign key. If not specified, the primary key of
                            the associated class is used.
                        </para>
                    </callout>
                   <callout arearefs="manytoone10">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): The
                            strategy NHibernate should use for accessing the property value.
                        </para>
                    </callout>
                    <callout arearefs="manytoone11">
                        <para>
                            <literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>):
                            Specifies that updates to this property do or do not require acquisition of the
                            optimistic lock. In other words, determines if a version increment should occur when
                            this property is dirty.
                        </para>
                    </callout>
                    <callout arearefs="manytoone12">
                        <para>
                            <literal>not-found</literal> (optional - defaults to <literal>exception</literal>):
                            Specifies how foreign keys that reference missing rows will be handled.
                            <literal>ignore</literal> will treat a missing row as a null association.
                        </para>
                    </callout>
                    <callout arearefs="manytoone13">
                        <para>
                            <literal>entity-name</literal> (optional): The entity name of the associated class.
                        </para>
                    </callout>
                    <callout arearefs="manytoone14">
                        <para>
                            <literal>formula</literal> (optional): An SQL expression that defines the value for
                            a <emphasis>computed</emphasis> foreign key.
                        </para>
                    </callout>
                    <callout arearefs="manytoone15">
                        <para>
                            <literal>not-null</literal> (optional - defaults to <literal>false</literal>): Enables
                            the DDL generation of a nullability constraint for the foreign key column.
                        </para>
                    </callout>
                    <callout arearefs="manytoone16">
                        <para>
                            <literal>unique</literal> (optional - defaults to <literal>false</literal>): Enables
                            the DDL generation of an unique constraint for the foreign-key column.
                        </para>
                    </callout>
                   <callout arearefs="manytoone17">
                        <para>
                            <literal>unique-key</literal> (optional):
                            A logical name for an unique index for DDL generation. The column will be included in
                            the index, along with other columns sharing the same <literal>unique-key</literal>
                            logical name. The actual index name depends on the dialect.
                        </para>
                    </callout>
                   <callout arearefs="manytoone18">
                        <para>
                            <literal>index</literal> (optional):
                            A logical name for an index for DDL generation. The column will be included in
                            the index, along with other columns sharing the same <literal>index</literal> logical
                            name. The actual index name depends on the dialect.
                        </para>
                    </callout>
                    <callout arearefs="manytoone19">
                        <para>
                            <literal>foreign-key</literal> (optional): Specifies the name of the foreign key
                            constraint for DDL generation.
                        </para>
                    </callout>
                    <callout arearefs="manytoone20">
                        <para>
                            <literal>outer-join</literal> (optional): This attribute is obsoleted in favor of
                            <literal>fetch</literal>. <literal>auto</literal> is equivalent to not specifying
                            <literal>fetch</literal>, <literal>true</literal> is equivalent to
                            <literal>join</literal> and <literal>false</literal> is equivalent to
                            <literal>select</literal>. This obsolete attribute also appears on other elements,
                            with the same usage. It will be omitted from the documentation of these other
                            elements.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                 Setting a value of the <literal>cascade</literal> attribute to any meaningful value other than
                 <literal>none</literal> will propagate certain operations to the associated object. The
                 meaningful values are divided into three categories. First, basic operations, which include:
                 <literal>persist</literal>, <literal>merge</literal>, <literal>delete</literal>,
                 <literal>save-update</literal>, <literal>evict</literal>, <literal>replicate</literal>,
                 <literal>lock</literal> and <literal>refresh</literal>; second, special values:
                 <literal>delete-orphan</literal>; and third, all comma-separated combinations of operation names:
                 <literal>cascade="persist,merge,evict"</literal> or <literal>cascade="all,delete-orphan"</literal>.
                 See <xref linkend="manipulatingdata-graphs"/>.
            </para>

            <para>
                Here is an example of a typical many-to-one declaration:
            </para>

            <programlisting><![CDATA[<many-to-one name="product" class="Product" column="PRODUCT_ID"/>]]></programlisting>

            <para>
                The <literal>property-ref</literal> attribute should only be used for mapping legacy data where a
                foreign key refers to a unique key of the associated table other than the primary key. This is a
                complicated and confusing relational model. For example, if the Product class had a unique serial
                number that is not the primary key, mapped as below:
            </para>

            <programlisting><![CDATA[<property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/>]]></programlisting>

            <para>
                The unique attribute controls NHibernate's DDL generation with the SchemaExport tool. Then the
                mapping for OrderItem might use:
            </para>

            <programlisting><![CDATA[<many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/>]]></programlisting>

            <para>
                This is not encouraged, however.
            </para>

            <para>
                If the referenced unique key comprises multiple properties of the associated entity, you should map
                the referenced properties inside a named <literal>&lt;properties&gt;</literal> element.
            </para>

            <para>
                If the referenced unique key is the property of a component, you can specify a property path:
            </para>

            <programlisting><![CDATA[<many-to-one name="owner" property-ref="Identity.Ssn" column="OWNER_SSN"/>]]></programlisting>

        </sect2>

        <sect2 id="mapping-declaration-onetoone">
            <title>one-to-one</title>

            <para>
                A one-to-one association to another persistent class is declared using a
                <literal>one-to-one</literal> element.
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="onetoone1" coords="2 60"/>
                    <area id="onetoone2" coords="3 60"/>
                    <area id="onetoone3" coords="4 60"/>
                    <area id="onetoone4" coords="5 60"/>
                    <area id="onetoone5" coords="6 60"/>
                    <area id="onetoone6" coords="7 60"/>
                    <area id="onetoone7" coords="8 60"/>
                    <area id="onetoone8" coords="9 60"/>
                    <area id="onetoone9" coords="10 60"/>
                    <area id="onetoone10" coords="11 60"/>
                    <area id="onetoone11" coords="12 60"/>
                </areaspec>
                <programlisting><![CDATA[<one-to-one
    name="propertyName"
    class="className"
    cascade="all|none|save-update|delete|delete-orphan|all-delete-orphan"
    constrained="true|false"
    fetch="join|select"
    lazy="proxy|no-proxy|false"
    property-ref="propertyNameFromAssociatedClass"
    access="field|property|nosetter|className"
    formula="any SQL expression"
    entity-name="entityName"
    foreign-key="foreignKeyName"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="onetoone1">
                        <para>
                            <literal>name</literal>: The name of the property.
                        </para>
                    </callout>
                    <callout arearefs="onetoone2">
                        <para>
                            <literal>class</literal> (optional - defaults to the property type
                            determined by reflection): The name of the associated class.
                        </para>
                    </callout>
                    <callout arearefs="onetoone3">
                        <para>
                            <literal>cascade</literal> (optional): Specifies which operations should
                            be cascaded from the parent object to the associated object.
                        </para>
                    </callout>
                    <callout arearefs="onetoone4">
                        <para>
                            <literal>constrained</literal> (optional - default to <literal>false</literal>):
                            Specifies that a foreign key constraint on the primary key of the mapped table
                            references the table of the associated class. This option affects the order in
                            which <literal>Save()</literal> and <literal>Delete()</literal> are cascaded,
                            and determines whether the association can be proxied. It is also used by the
                            schema export tool.
                        </para>
                    </callout>
                    <callout arearefs="onetoone5">
                        <para>
                            <literal>fetch</literal> (optional - defaults to <literal>select</literal>):
                            Chooses between outer-join fetching or sequential select fetching.
                        </para>
                    </callout>
                    <callout arearefs="onetoone6">
                        <para>
                            <literal>lazy</literal> (optional - defaults to <literal>proxy</literal>):
                            By default, single point associations are proxied. <literal>lazy="no-proxy"</literal>
                            specifies that the property should be fetched lazily when the instance property is first
                            accessed. It works similarly to lazy properties, and causes the entity owning the
                            association to be proxied instead of the association. <literal>lazy="false"</literal>
                            specifies that the association will be eagerly fetched. <emphasis>Note that if
                            <literal>constrained="false"</literal>, proxying the association is impossible and
                            NHibernate will eagerly fetch the association.</emphasis>
                        </para>
                    </callout>
                    <callout arearefs="onetoone7">
                        <para>
                            <literal>property-ref</literal>: (optional): The name of a property of the associated class
                            that is joined to the primary key of this class (or to the <literal>formula</literal> of
                            this association). If not specified, the primary key of the associated class is used.
                        </para>
                    </callout>
                    <callout arearefs="onetoone8">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): The
                            strategy NHibernate should use for accessing the property value.
                        </para>
                    </callout>
                    <callout arearefs="onetoone9">
                        <para>
                            <literal>formula</literal> (optional): Almost all one-to-one associations map to the primary
                            key of the owning entity. If this is not the case, you can specify another column or expression
                            to join on using an SQL formula. This can also be specified by nested
                            <literal>&lt;formula&gt;</literal> element(s).
                        </para>
                    </callout>
                    <callout arearefs="onetoone10">
                        <para>
                            <literal>entity-name</literal> (optional): The entity name of the associated class.
                        </para>
                    </callout>
                    <callout arearefs="manytoone11">
                        <para>
                            <literal>foreign-key</literal> (optional): Specifies the name of the foreign key
                            constraint for DDL generation.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
        
            <para>
                There are two varieties of one-to-one association:
            </para>
            <itemizedlist>
            <listitem><para>
                primary key associations
            </para></listitem>
            <listitem><para>
                unique foreign key associations
            </para></listitem>
            </itemizedlist>
            
            <para>
                Primary key associations don't need an extra table column; if two rows are related by
                the association then the two table rows share the same primary key value. So if you want 
                two objects to be related by a primary key association, you must make sure that they
                are assigned the same identifier value!
            </para>
            
            <para>
                For a primary key association, add the following mappings to <literal>Employee</literal> and 
                <literal>Person</literal>, respectively.
            </para>

            <programlisting><![CDATA[<one-to-one name="Person" class="Person"/>]]></programlisting>
            <programlisting><![CDATA[<one-to-one name="Employee" class="Employee" constrained="true"/>]]></programlisting>

            <para>
                Now we must ensure that the primary keys of related rows in the PERSON and
                EMPLOYEE tables are equal. We use a special NHibernate identifier generation strategy
                called <literal>foreign</literal>:
            </para>

            <programlisting><![CDATA[<class name="Person" table="PERSON">
    <id name="Id" column="PERSON_ID">
        <generator class="foreign">
            <param name="property">Employee</param>
        </generator>
    </id>
    ...
    <one-to-one name="Employee"
        class="Employee"
        constrained="true"/>
</class>]]></programlisting>

            <para>
                A newly saved instance of <literal>Person</literal> is then assigned the same primary
                key value as the <literal>Employee</literal> instance referred with the <literal>Employee</literal>
                property of that <literal>Person</literal>.
            </para>

            <para>
                Alternatively, a foreign key with a unique constraint, from <literal>Employee</literal> to 
                <literal>Person</literal>, may be expressed as:
            </para>

            <programlisting><![CDATA[<many-to-one name="Person" class="Person" column="PERSON_ID" unique="true"/>]]></programlisting>

            <para>
                And this association may be made bidirectional by adding the following to the 
                <literal>Person</literal> mapping:
            </para>

           <programlisting><![CDATA[<one-to-one name="Employee" class="Employee" property-ref="Person"/>]]></programlisting>

        </sect2>

        <sect2 id="mapping-declaration-naturalid">
            <title>natural-id</title>

            <programlisting><![CDATA[<natural-id mutable="true|false"/>
    <property ... />
    <many-to-one ... />
    ...
</natural-id>]]></programlisting>

            <para>
                Even though we recommend the use of surrogate keys as primary keys, you should still try
                to identify natural keys for all entities. A natural key is a property or combination of
                properties that is unique and non-null. If it is also immutable, even better. Map the
                properties of the natural key inside the <literal>&lt;natural-id&gt;</literal> element.
                NHibernate will generate the necessary unique key and nullability constraints, and your
                mapping will be more self-documenting.
            </para>

            <para>
                The <literal>&lt;natural-id&gt;</literal> element can only appear before the other
                properties, including version.
            </para>

            <para>
                We strongly recommend that you implement <literal>Equals()</literal> and
                <literal>GetHashCode()</literal> to compare the natural key properties of the entity.
            </para>

            <para>
                This mapping is not intended for use with entities with natural primary keys.
            </para>

            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>mutable</literal> (optional, defaults to <literal>false</literal>):
                        By default, natural identifier properties as assumed to be immutable (constant).
                    </para>
                </listitem>
            </itemizedlist>

        </sect2>

        <sect2 id="mapping-declaration-component">
            <title>component, dynamic-component</title>

            <para>
                The <literal>&lt;component&gt;</literal> element maps properties of a
                child object to columns of the table of a parent class. Components may, in
                turn, declare their own properties, components or collections. See
                <xref linkend="components"/>.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="component1" coords="2 60"/>
                    <area id="component2" coords="3 60"/>
                    <area id="component3" coords="4 60"/>
                    <area id="component4" coords="5 60"/>
                    <area id="component5" coords="6 60"/>
                    <area id="component6" coords="7 60"/>
                    <area id="component7" coords="8 60"/>
                    <area id="component8" coords="9 60"/>
                </areaspec>
                <programlisting><![CDATA[<component
    name="propertyName"
    class="className"
    insert="true|false"
    update="true|false"
    access="field|property|nosetter|className"
    optimistic-lock="true|false"
    lazy="true|false"
    unique="true|false">

        <property ... />
        <many-to-one ... />
        ...
</component>]]></programlisting>
                <calloutlist>
                    <callout arearefs="component1">
                        <para>
                            <literal>name</literal>: The name of the property.
                        </para>
                    </callout>
                    <callout arearefs="component2">
                        <para>
                            <literal>class</literal> (optional - defaults to the property type
                            determined by reflection): The name of the component (child) class.
                        </para>
                    </callout>
                    <callout arearefs="component3">
                        <para>
                            <literal>insert</literal> (optional - defaults to <literal>true</literal>):
                            Do the mapped columns appear in SQL <literal>INSERT</literal>s?
                        </para>
                    </callout>
                    <callout arearefs="component4">
                        <para>
                            <literal>update</literal> (optional - defaults to <literal>true</literal>):
                            Do the mapped columns appear in SQL <literal>UPDATE</literal>s?
                        </para>
                    </callout>
                    <callout arearefs="component5">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): The
                            strategy NHibernate should use for accessing the property value.
                        </para>
                    </callout>
                    <callout arearefs="component6">
                        <para>
                            <literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>):
                            Specifies that updates to this component do or do not require acquisition of the
                            optimistic lock. In other words, determines if a version increment should occur when
                            this property is dirty.
                        </para>
                    </callout>
                    <callout arearefs="component7">
                        <para>
                            <literal>lazy</literal> (optional - defaults to <literal>false</literal>): Specifies
                            that this component should be fetched lazily when the instance property is first
                            accessed. For more informations, see <literal>lazy</literal> on
                            <link linkend="mapping-declaration-property"><literal>property</literal> element</link>.
                        </para>
                    </callout>
                    <callout arearefs="component8">
                        <para>
                            <literal>unique</literal> (optional - defaults to <literal>false</literal>): Specifies
                            that an unique constraint exists upon all mapped columns of the component.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                The child <literal>&lt;property&gt;</literal> tags map properties of the
                child class to table columns.
            </para>

            <para>
                The <literal>&lt;component&gt;</literal> element allows a <literal>&lt;parent&gt;</literal>
                sub-element that maps a property of the component class as a reference back to the
                containing entity.
            </para>

            <para>
                The <literal>&lt;dynamic-component&gt;</literal> element allows an <literal>IDictionary</literal>,
                <literal>IDictionary&lt;string, object&gt;</literal>, or a C# <literal>dynamic</literal> to be mapped
                as a component. When using dictionaries, the property names refer to keys of the dictionary. See
                <xref linkend="components-dynamic" />.
            </para>
            
        </sect2>

        <sect2 id="mapping-declaration-properties">
          <title>properties</title>

          <para>
            The <literal>&lt;properties&gt;</literal> element allows the
            definition of a named, logical grouping of the properties of a class.
            The most important use of the construct is that it allows a combination
            of properties to be the target of a <literal>property-ref</literal>. It
            is also a convenient way to define a multi-column unique constraint. For
            example:
          </para>

          <programlistingco>
            <areaspec>
              <area coords="2 60" id="properties1" />
              <area coords="3 60" id="properties2" />
              <area coords="4 60" id="properties3" />
              <area coords="5 60" id="properties4" />
              <area coords="6 60" id="properties5" />
            </areaspec>

            <programlisting><![CDATA[<properties
    name="logicalName"
    insert="true|false"
    update="true|false"
    optimistic-lock="true|false"
    unique="true|false">

    <property .../>
    <many-to-one .../>
    ...
</properties>]]></programlisting>

            <calloutlist>
              <callout arearefs="properties1">
                <para>
                  <literal>name</literal>: the logical name of the grouping.
                  It is <emphasis>not</emphasis> an actual property name.
                </para>
              </callout>

              <callout arearefs="properties2">
                <para>
                  <literal>insert</literal> (optional - defaults to <literal>true</literal>):
                  do the mapped columns appear in SQL <literal>INSERTs</literal>?
                </para>
              </callout>

              <callout arearefs="properties3">
                <para>
                  <literal>update</literal> (optional - defaults to <literal>true</literal>):
                  do the mapped columns appear in SQL <literal>UPDATEs</literal>?
                </para>
              </callout>

              <callout arearefs="properties4">
                <para>
                  <literal>optimistic-lock</literal> (optional - defaults to
                  <literal>true</literal>): specifies that updates to these
                  properties either do or do not require acquisition of the
                  optimistic lock. It determines if a version increment should occur
                  when these properties are dirty.
                </para>
              </callout>

              <callout arearefs="properties5">
                <para>
                  <literal>unique</literal> (optional - defaults to
                  <literal>false</literal>): specifies that a unique constraint
                  exists upon all mapped columns of the component.
                </para>
              </callout>
            </calloutlist>
          </programlistingco>

          <para>
            For example, if we have the following
            <literal><![CDATA[<properties>]]></literal> mapping:
          </para>

          <programlisting role="XML"><![CDATA[<class name="Person">
    <id name="personNumber" />
    <properties name="name" unique="true" update="false">
        <property name="firstName" />
        <property name="lastName" />
        <property name="initial" />
    </properties>
</class>]]></programlisting>

          <para>
            You might have some legacy data association that refers to this
            unique key of the <literal>Person</literal> table, instead of to the
            primary key:
          </para>

          <programlisting role="XML"><![CDATA[<many-to-one name="owner" class="Person" property-ref="name">
    <column name="firstName" />
    <column name="lastName" />
    <column name="initial" />
</many-to-one>]]></programlisting>

          <para>
            The use of this outside the context of mapping legacy data is not
            recommended.
          </para>
        </sect2>

        <sect2 id="mapping-declaration-subclass">
            <title>subclass</title>

            <para>
                Polymorphic persistence requires the declaration of each subclass of
                the root persistent class. For the (recommended) table-per-class-hierarchy
                mapping strategy, the <literal>&lt;subclass&gt;</literal> declaration is used.
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="subclass1" coords="2 55"/>
                    <area id="subclass2" coords="3 55"/>
                    <area id="subclass3" coords="4 55"/>
                    <area id="subclass4" coords="5 55"/>
                </areaspec>
                <programlisting><![CDATA[<subclass
    name="className"
    discriminator-value="discriminatorValue"
    extends="superclassName"
    ...>

    <property ... />
    <properties ... />
    ...
</subclass>]]></programlisting>
                <calloutlist>
                    <callout arearefs="subclass1">
                        <para>
                            <literal>name</literal>: The fully qualified .NET class name of the
                            subclass, including its assembly name.
                        </para>
                    </callout>
                    <callout arearefs="subclass2">
                        <para>
                            <literal>discriminator-value</literal> (optional - defaults to the class name): A
                            value that distinguishes individual subclasses.
                        </para>
                    </callout>
                    <callout arearefs="subclass3">
                        <para>
                            <literal>extends</literal> (optional if the <literal>&lt;subclass&gt;</literal>
                            element is nested into its superclass mapping declaration): Specifies the name of
                            a mapped class as the superclass for the subclass.
                        </para>
                    </callout>
                    <callout arearefs="subclass4">
                        <para>
                            Many attributes available on the <literal>&lt;class&gt;</literal> mapping element
                            are also available on <literal>&lt;subclass&gt;</literal> with the same usage:
                            <literal>proxy</literal>, <literal>dynamic-update</literal>,
                            <literal>dynamic-insert</literal>, <literal>select-before-update</literal>,
                            <literal>persister</literal>, <literal>batch-size</literal>, <literal>lazy</literal>,
                            <literal>entity-name</literal>, <literal>abstract</literal>. See
                            <xref linkend="mapping-declaration-class"/>.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                Each subclass should declare its own persistent properties and subclasses.
                <literal>&lt;version&gt;</literal> and <literal>&lt;id&gt;</literal> properties
                are assumed to be inherited from the root class. Each subclass in a hierarchy must
                define a unique <literal>discriminator-value</literal>. If none is specified, the
                fully qualified .NET class name is used.
            </para>

            <para>
                For information about inheritance mappings, see <xref linkend="inheritance"/>.
            </para>

        </sect2>

        <sect2 id="mapping-declaration-joinedsubclass" revision="1">
            <title>joined-subclass</title>

            <para>
                Each subclass can also be mapped to its own table. This is called the table-per-subclass
                mapping strategy. An inherited state is retrieved by joining with the table of the
                superclass. To do this you use the <literal>&lt;joined-subclass&gt;</literal> element.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="joinedsubclass1" coords="2 55"/>
                    <area id="joinedsubclass2" coords="3 55"/>
                    <area id="joinedsubclass3" coords="4 55"/>
                    <area id="joinedsubclass4" coords="5 55"/>
                </areaspec>
                <programlisting><![CDATA[<joined-subclass
    name="className"
    table="tableName"
    extends="superclassName"
    ...>

    <key ... />

    <property ... />
    <properties ... />
    ...
</joined-subclass>]]></programlisting>
                <calloutlist>
                    <callout arearefs="joinedsubclass1">
                        <para>
                            <literal>name</literal>: The fully qualified class name of the subclass.
                        </para>
                    </callout>
                    <callout arearefs="joinedsubclass2">
                        <para>
                            <literal>table</literal> (optional - defaults to the unqualified subclass name):
                            The name of the subclass table.
                        </para>
                    </callout>
                    <callout arearefs="joinedsubclass3">
                        <para>
                            <literal>extends</literal> (optional if the <literal>&lt;joined-subclass&gt;</literal>
                            element is nested into its superclass mapping declaration): Specifies the name of
                            a mapped class as the superclass for the subclass.
                        </para>
                    </callout>
                    <callout arearefs="joinedsubclass4">
                        <para>
                            Many attributes available on the <literal>&lt;class&gt;</literal> mapping element
                            are also available on <literal>&lt;joined-subclass&gt;</literal> with the same usage:
                            <literal>schema</literal>, <literal>catalog</literal>, <literal>proxy</literal>,
                            <literal>subselect</literal>, <literal>dynamic-update</literal>,
                            <literal>dynamic-insert</literal>, <literal>select-before-update</literal>,
                            <literal>persister</literal>, <literal>batch-size</literal>, <literal>lazy</literal>,
                            <literal>entity-name</literal>, <literal>abstract</literal>, <literal>check</literal>,
                            <literal>schema-action</literal>. See <xref linkend="mapping-declaration-class"/>.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                No discriminator column is required for this mapping strategy. Each subclass must,
                however, declare a table column holding the object identifier using the
                <literal>&lt;key&gt;</literal> element. The mapping at the start of the chapter
                would be re-written as:
            </para>

            <programlisting><![CDATA[<?xml version="1.0"?>
<hibernate-mapping xmlns="urn:nhibernate-mapping-2.2" assembly="Eg"
    namespace="Eg">

    <class name="Cat" table="CATS">
        <id name="Id" column="uid" type="Int64">
            <generator class="hilo"/>
        </id>
        <property name="BirthDate" type="Date"/>
        <property name="Color" not-null="true"/>
        <property name="Sex" not-null="true"/>
        <property name="Weight"/>
        <many-to-one name="Mate"/>
        <set name="Kittens">
            <key column="MOTHER"/>
            <one-to-many class="Cat"/>
        </set>
        <joined-subclass name="DomesticCat" table="DOMESTIC_CATS">
            <key column="CAT"/>
            <property name="Name" type="String"/>
        </joined-subclass>
    </class>

    <class name="Dog">
        <!-- mapping for Dog could go here -->
    </class>

</hibernate-mapping>]]></programlisting>

            <para>
                For information about inheritance mappings, see <xref linkend="inheritance"/>.
            </para>

        </sect2>

        <sect2 id="mapping-declaration-unionsubclass" revision="2">
           <title>union-subclass</title>

           <para>
               A third option is to map only the concrete classes of an inheritance hierarchy
               to tables, (the table-per-concrete-class strategy) where each table defines all
               persistent state of the class, including inherited state. In NHibernate, it is
               not absolutely necessary to explicitly map such inheritance hierarchies. You
               can simply map each class with a separate <literal>&lt;class&gt;</literal>
               declaration. However, if you wish use polymorphic associations (e.g. an association
               to the superclass of your hierarchy), you need to
               use the <literal>&lt;union-subclass&gt;</literal> mapping.
           </para>

            <programlistingco>
                <areaspec>
                    <area id="unionsubclass1" coords="2 55"/>
                    <area id="unionsubclass2" coords="3 55"/>
                    <area id="unionsubclass3" coords="4 55"/>
                    <area id="unionsubclass4" coords="5 55"/>
                </areaspec>
                <programlisting><![CDATA[<union-subclass
    name="className"
    table="tableName"
    extends="superclassName"
    ...>

    <property ... />
    <properties ... />
    ...
</union-subclass>]]></programlisting>
                <calloutlist>
                    <callout arearefs="unionsubclass1">
                        <para>
                            <literal>name</literal>: The fully qualified class name of the subclass.
                        </para>
                    </callout>
                    <callout arearefs="unionsubclass2">
                        <para>
                            <literal>table</literal> (optional - defaults to the unqualified subclass name):
                            The name of the subclass table.
                        </para>
                    </callout>
                    <callout arearefs="unionsubclass3">
                        <para>
                            <literal>extends</literal> (optional if the <literal>&lt;union-subclass&gt;</literal>
                            element is nested into its superclass mapping declaration): Specifies the name of
                            a mapped class as the superclass for the subclass.
                        </para>
                    </callout>
                    <callout arearefs="unionsubclass4">
                        <para>
                            Many attributes available on the <literal>&lt;class&gt;</literal> mapping element
                            are also available on <literal>&lt;union-subclass&gt;</literal> with the same usage:
                            <literal>schema</literal>, <literal>catalog</literal>, <literal>proxy</literal>,
                            <literal>subselect</literal>, <literal>dynamic-update</literal>,
                            <literal>dynamic-insert</literal>, <literal>select-before-update</literal>,
                            <literal>persister</literal>, <literal>batch-size</literal>, <literal>lazy</literal>,
                            <literal>entity-name</literal>, <literal>abstract</literal>, <literal>check</literal>.
                            See <xref linkend="mapping-declaration-class"/>.
                         </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                No discriminator column or key column is required for this mapping strategy.
            </para>

            <para>
                For information about inheritance mappings, see <xref linkend="inheritance"/>.
            </para>

        </sect2>

        <sect2 id="mapping-declaration-join" revision="1">
            <title>join</title>

            <para>
                Using the <literal>&lt;join&gt;</literal> element, it is possible to map
                properties of one class to several tables, when there's a 1-to-1 relationship between the tables.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="join1" coords="2 50"/>
                    <area id="join2" coords="3 50"/>
                    <area id="join3" coords="4 50"/>
                    <area id="join4" coords="5 50"/>
                    <area id="join5" coords="6 50"/>
                    <area id="join6" coords="7 50"/>
                    <area id="join7" coords="8 50"/>
                </areaspec>
                <programlisting><![CDATA[<join
    table="tableName"
    schema="owner"
    catalog="catalog"
    fetch="join|select"
    inverse="true|false"
    optional="true|false"
    subselect="SQL expression">

    <key ... />

    <property ... />
    ...
</join>]]></programlisting>

                <calloutlist>
                    <callout arearefs="join1">
                        <para>
                            <literal>table</literal>: The name of the joined table.
                        </para>
                    </callout>
                    <callout arearefs="join2">
                        <para>
                            <literal>schema</literal> (optional): Overrides the schema name specified by
                            the root <literal>&lt;hibernate-mapping&gt;</literal> element.
                        </para>
                    </callout>
                    <callout arearefs="join3">
                        <para>
                            <literal>catalog</literal> (optional): Overrides the catalog name specified by
                            the root <literal>&lt;hibernate-mapping&gt;</literal> element.
                        </para>
                    </callout>
                    <callout arearefs="join4">
                        <para>
                            <literal>fetch</literal> (optional - defaults to <literal>join</literal>):
                            If set to <literal>join</literal>, the default, NHibernate will use an inner join
                            to retrieve a <literal>&lt;join&gt;</literal> defined by a class or its superclasses
                            and an outer join for a <literal>&lt;join&gt;</literal> defined by a subclass.
                            If set to <literal>select</literal> then NHibernate will use a sequential select for
                            a <literal>&lt;join&gt;</literal> defined on a subclass, which will be issued only
                            if a row turns out to represent an instance of the subclass. Inner joins will still
                            be used to retrieve a <literal>&lt;join&gt;</literal> defined by the class and its
                            superclasses.
                        </para>
                    </callout>
                    <callout arearefs="join5">
                        <para>
                            <literal>inverse</literal> (optional - defaults to <literal>false</literal>):
                            If enabled, NHibernate will not try to insert or update the properties defined
                            by this join.
                        </para>
                    </callout>
                    <callout arearefs="join6">
                        <para>
                            <literal>optional</literal> (optional - defaults to <literal>false</literal>):
                            If enabled, NHibernate will insert a row only if the properties defined by this
                            join are non-null and will always use an outer join to retrieve the properties.
                        </para>
                    </callout>
                    <callout arearefs="join7">
                        <para>
                            <literal>subselect</literal> (optional): Maps an immutable and read-only join to
                            a database sub-select. This is useful if you want to have a view instead of a
                            table. See <xref linkend="mapping-declaration-subselect"/> for more information.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                For example, the address information for a person can be mapped to a separate
                table (while preserving value type semantics for all properties):
            </para>

            <programlisting><![CDATA[<class name="Person" table="PERSON">
    <id name="id" column="PERSON_ID">...</id>

    <join table="ADDRESS">
        <key column="ADDRESS_ID"/>
        <property name="address"/>
        <property name="zip"/>
        <property name="country"/>
    </join>
    ...]]></programlisting>

            <para>
                This feature is often only useful for legacy data models, we recommend fewer
                tables than classes and a fine-grained domain model. However, it is useful
                for switching between inheritance mapping strategies in a single hierarchy, as
                explained later.
            </para>

        </sect2>

        <sect2 id="mapping-declaration-key">
            <title>key</title>

            <para>
                The <literal>&lt;key&gt;</literal> element has featured a few times within this guide. It appears
                anywhere the parent mapping element defines a join to a new table that references the primary key
                of the original table. It also defines the foreign key in the joined table:
            </para>

            <programlistingco>
                <areaspec>
                    <area id="key1" coords="2 50"/>
                    <area id="key2" coords="3 50"/>
                    <area id="key3" coords="4 50"/>
                    <area id="key4" coords="5 50"/>
                    <area id="key5" coords="6 50"/>
                    <area id="key6" coords="7 50"/>
                    <area id="key7" coords="8 50"/>
                </areaspec>
                <programlisting><![CDATA[<key
        column="columnName"
        on-delete="noaction|cascade"
        property-ref="propertyName"
        not-null="true|false"
        update="true|false"
        unique="true|false"
        foreign-key="foreignKeyName"
/>]]></programlisting>

                <calloutlist>
                    <callout arearefs="key1">
                        <para>
                            <literal>column</literal>: the name of the foreign key column. This can also be specified
                            by nested <literal>&lt;column&gt;</literal> element(s).
                        </para>
                    </callout>
                    <callout arearefs="key2">
                        <para>
                            <literal>on-delete</literal> (optional - defaults to <literal>noaction</literal>): specifies
                            whether the foreign key constraint has database-level cascade delete enabled.
                        </para>
                    </callout>
                    <callout arearefs="key3">
                        <para>
                            <literal>property-ref</literal> (optional): specifies that the foreign key refers to columns
                            that are not the primary key of the original table. It is provided for legacy data.
                        </para>
                    </callout>
                    <callout arearefs="key4">
                        <para>
                            <literal>not-null</literal> (optional): specifies that the foreign key columns are not nullable.
                            This is implied whenever the foreign key is also part of the primary key.
                        </para>
                    </callout>
                    <callout arearefs="key5">
                        <para>
                            <literal>update</literal> (optional): specifies that the foreign key should never be updated.
                            This is implied whenever the foreign key is also part of the primary key.
                        </para>
                    </callout>
                    <callout arearefs="key6">
                        <para>
                            <literal>unique</literal> (optional): specifies that the foreign key should have a unique
                            constraint. This is implied whenever the foreign key is also the primary key.
                        </para>
                    </callout>
                    <callout arearefs="key7">
                        <para>
                            <literal>foreign-key</literal> (optional): specifies the name of the foreign key
                            constraint for DDL generation.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                For systems where delete performance is important, we recommend that all keys should be defined
                <literal>on-delete="cascade"</literal>. NHibernate uses a database-level
                <literal>ON CASCADE DELETE</literal> constraint, instead of many individual <literal>DELETE</literal>
                statements. Be aware that this feature bypasses NHibernate's usual optimistic locking strategy for
                versioned data.
            </para>

            <para>
                The <literal>not-null</literal> and <literal>update</literal> attributes are useful when mapping an
                unidirectional one-to-many association. If you map an unidirectional one-to-many association to a
                non-nullable foreign key, you <emphasis>must</emphasis> declare the key column using
                <literal>&lt;key not-null="true"&gt;</literal>.
            </para>

        </sect2>

        <sect2 id="mapping-column">
            <title>column and formula elements</title>

            <para>
                Mapping elements which accept a <literal>column</literal> attribute will alternatively accept a
                <literal>&lt;column&gt;</literal> subelement. Likewise, <literal>&lt;formula&gt;</literal> is an
                alternative to the <literal>formula</literal> attribute. For example:
            </para>

            <programlisting><![CDATA[<column
        name="columnName"
        length="N"
        precision="N"
        scale="N"
        not-null="true|false"
        unique="true|false"
        unique-key="multicolumnUniqueKeyName"
        index="indexName"
        sql-type="sqlTypeName"
        check="SQL expression"
        default="SQL expression"/>]]></programlisting>

            <programlisting><![CDATA[<formula>SQL expression</formula>]]></programlisting>

            <para>
                Most of the attributes on <literal>column</literal> provide a means of tailoring the DDL during
                automatic schema generation. See <xref linkend="toolsetguide-s1-2" />.
            </para>

            <para>
                The <literal>column</literal> and <literal>formula</literal> elements can even be combined within
                the same property or association mapping to express, for example, exotic join conditions.
            </para>

            <programlisting><![CDATA[<many-to-one name="HomeAddress" class="Address"
        insert="false" update="false">
    <column name="person_id" not-null="true" length="10"/>
    <formula>'MAILING'</formula>
</many-to-one>]]></programlisting>

        </sect2>

        <sect2 id="mapping-declaration-collections">
            <title>map, set, list, bag</title>

            <para>
                Collections are discussed in <xref linkend="collections" />.
            </para>
        </sect2>

        <sect2 id="mapping-declaration-import" revision="1">
            <title>import</title>

            <para>
                Suppose your application has two persistent classes with the same name, and you don't want to
                specify the fully qualified name in NHibernate queries. Classes may be "imported" 
                explicitly, rather than relying upon <literal>auto-import="true"</literal>. You may even import 
                classes and interfaces that are not explicitly mapped.
            </para>

            <programlisting><![CDATA[<import class="System.Object" rename="Universe"/>]]></programlisting>

            <programlistingco>
                <areaspec>
                    <area id="import1" coords="2 40"/>
                    <area id="import2" coords="3 40"/>
                </areaspec>
                <programlisting><![CDATA[<import
    class="className"
    rename="shortName"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="import1">
                        <para>
                            <literal>class</literal>: The fully qualified class name of any .NET class, including
                            its assembly name.
                        </para>
                    </callout>
                    <callout arearefs="import2">
                        <para>
                            <literal>rename</literal> (optional - defaults to the unqualified class name):
                            A name that may be used in the query language.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

        </sect2>

        <sect2 id="mapping-types-anymapping">
            <title>any</title>

            <para>
                There is one more type of property mapping. The <literal>&lt;any&gt;</literal> mapping element defines a
                polymorphic association to classes from multiple tables. This type of mapping requires more than one
                column. The first column contains the type of the associated entity. The remaining columns contain the
                identifier. It is impossible to specify a foreign key constraint for this kind of association. This is
                not the usual way of mapping polymorphic associations and you should use this only in special cases. For
                example, for audit logs, user session data, etc.
            </para>

            <programlisting><![CDATA[<any name="AnyEntity" id-type="long" meta-type="class">
    <column name="type"/>
    <column name="id"/>
</any>]]></programlisting>

            <para>
                The <literal>meta-type</literal> attribute allows the application to specify a custom type that maps
                database column values to persistent classes that have identifier properties of the type specified by
                <literal>id-type</literal>. If the meta-type is <literal>class</literal>, nothing else is required.
                The class full name will be persisted in the database as the type of the associated entity.
                On the other hand, if it is a basic type like <literal>string</literal> or
                <literal>char</literal>, you must specify the mapping from values to classes.
            </para>

            <programlisting><![CDATA[<any name="being" id-type="long" meta-type="string">
    <meta-value value="ANIMAL_TYPE" class="Animal"/>
    <meta-value value="HUMAN_TYPE" class="Human"/>
    <meta-value value="ALIEN_TYPE" class="Alien"/>
    <column name="type"/>
    <column name="id"/>
</any>]]></programlisting>

            <programlistingco>
                <areaspec>
                    <area id="any1" coords="2 55"/>
                    <area id="any2" coords="3 55"/>
                    <area id="any3" coords="4 55"/>
                    <area id="any4" coords="5 55"/>
                    <area id="any5" coords="6 55"/>
                    <area id="any6" coords="7 55"/>
                    <area id="any7" coords="8 55"/>
                    <area id="any8" coords="9 55"/>
                    <area id="any9" coords="10 55"/>
                    <area id="any10" coords="11 55"/>
                </areaspec>
                <programlisting><![CDATA[<any
    name="propertyName"
    id-type="idTypeName"
    meta-type="metaTypeName"
    cascade="cascadeStyle"
    access="field|property|className"
    optimistic-lock="true|false"
    lazy="true|false"
    update="true|false"
    insert="true|false"
    index="indexName">

    <meta-value ... />
    <meta-value ... />
    ...
    <column ... />
    <column ... />
    ...
</any>]]></programlisting>
                <calloutlist>
                    <callout arearefs="any1">
                        <para>
                            <literal>name</literal>: the property name.
                        </para>
                    </callout>
                    <callout arearefs="any2">
                        <para>
                            <literal>id-type</literal>: the identifier type.
                        </para>
                    </callout>
                    <callout arearefs="any3">
                        <para>
                            <literal>meta-type</literal> (optional - defaults to <literal>string</literal>): a type
                            that is allowed for a discriminator mapping, or <literal>class</literal>.
                        </para>
                    </callout>
                    <callout arearefs="any4">
                        <para>
                            <literal>cascade</literal> (optional - defaults to <literal>none</literal>): the cascade style.
                        </para>
                    </callout>
                    <callout arearefs="any5">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): the strategy
                            Hibernate uses for accessing the property value.
                        </para>
                    </callout>
                    <callout arearefs="any6">
                        <para>
                            <literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): specifies
                            that updates to this property either do or do not require acquisition of the optimistic lock.
                            It defines whether a version increment should occur if this property is dirty.
                        </para>
                    </callout>
                    <callout arearefs="any7">
                        <para>
                            <literal>lazy</literal> (optional - defaults to <literal>false</literal>): specifies that this
                            property should be fetched lazily when the it is first accessed. For more informations, see
                            <literal>lazy</literal> on
                            <link linkend="mapping-declaration-property"><literal>property</literal> element</link>.
                        </para>
                    </callout>
                    <callout arearefs="any8">
                        <para>
                            <literal>update</literal> (optional - defaults to <literal>true</literal>):
                            Do the mapped columns appear in SQL <literal>UPDATE</literal>s?
                        </para>
                    </callout>
                    <callout arearefs="any9">
                        <para>
                            <literal>insert</literal> (optional - defaults to <literal>true</literal>):
                            Do the mapped columns appear in SQL <literal>INSERT</literal>s?
                        </para>
                    </callout>
                    <callout arearefs="any10">
                        <para>
                            <literal>index</literal> (optional):
                            a logical name for an index for DDL generation. The column will be included in
                            the index, along with other columns sharing the same <literal>index</literal> logical
                            name. The actual index name depends on the dialect.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                Do not confuse <literal>&lt;meta-value&gt;</literal> elements with <literal>&lt;meta&gt;</literal>
                elements. <literal>&lt;meta&gt;</literal> elements have no functionnal impact on
                <literal>&lt;any&gt;</literal>, see <xref linkend="mapping-meta"/> for more information on them.
            </para>

        </sect2>
    </sect1>

    <sect1 id="mapping-types">
        <title>NHibernate Types</title>

        <sect2 id="mapping-types-entitiesvalues" revision="1">
            <title>Entities and values</title>

            <para>
                To understand the behaviour of various .NET language-level objects with respect
                to the persistence service, we need to classify them into two groups:
            </para>

            <para>
                An <emphasis>entity</emphasis> exists independently of any other objects holding
                references to the entity. Contrast this with the usual .NET model where an
                unreferenced object is garbage collected. Entities must be explicitly saved and
                deleted (except that saves and deletions may be <emphasis>cascaded</emphasis>
                from a parent entity to its children). This is different from the ODMG model of
                object persistence by reachability - and corresponds more closely to how
                application objects are usually used in large systems. Entities support
                circular and shared references. They may also be versioned.
            </para>

            <para>
                An entity's persistent state consists of references to other entities and
                instances of <emphasis>value</emphasis> types. Values are primitives,
                collections, components and certain immutable objects. Unlike entities, values
                (in particular collections and components) <emphasis>are</emphasis>
                persisted and deleted by reachability. Since value objects (and primitives) are
                persisted and deleted along with their containing entity they may not be
                independently versioned. Values have no independent identity, so they cannot be
                shared by two entities or collections.
            </para>

            <para>
                All NHibernate types except collections support null semantics if the .NET type
                is nullable (i.e. not derived from <literal>System.ValueType</literal>).
            </para>

            <para>
                Up until now, we've been using the term "persistent class" to refer to
                entities. We will continue to do that. Strictly speaking, however, not all
                user-defined classes with persistent state are entities. A
                <emphasis>component</emphasis> is a user defined class with value semantics.
            </para>

            <para>
                The challenge is to map the .Net type system, and the developers' definition of
                entities and value types, to the SQL/database type system. The bridge between both
                systems is provided by NHibernate. For entities, <literal>&lt;class&gt;</literal>,
                <literal>&lt;subclass&gt;</literal> and so on are used. For value types we use
                <literal>&lt;property&gt;</literal>, <literal>&lt;component&gt;</literal>, etc.,
                that usually have a type attribute. The value of this attribute is the name of a
                NHibernate mapping type. NHibernate provides a range of mappings for standard .Net
                value types out of the box. You can write your own mapping types and implement
                your own custom conversion strategies.
            </para>
        </sect2>

        <sect2 id="mapping-types-basictypes">
            <title>Basic value types</title>

            <para>
                The <emphasis>basic types</emphasis> may be roughly categorized into three groups - <literal>System.ValueType</literal>
                types, <literal>System.Object</literal> types, and <literal>System.Object</literal> types for large objects.  Just like
                Columns for System.ValueType types can handle <literal>null</literal> values only if the entity property is properly
                typed with a <literal>Nullable&lt;T&gt;</literal>. Otherwise <literal>null</literal> will be replaced by the default
                value for the type when reading, and then will be overwritten by it when persisting the entity, potentially leading to
                phantom updates.
            </para>
            <table>
                <title>System.ValueType Mapping Types</title>
                <tgroup cols="4">
                    <thead>
                        <row>
                            <entry>NHibernate Type</entry>
                            <entry>.NET Type</entry>
                            <entry>Database Type</entry>
                            <entry>Remarks</entry>
                        </row>
                    </thead>	
                    <tbody>
                        <row>
                            <entry><literal>AnsiChar</literal></entry>
                            <entry><literal>System.Char</literal></entry>
                            <entry><literal>DbType.AnsiStringFixedLength - 1 char</literal></entry>
                            <entry><literal>type="AnsiChar"</literal> must be specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Boolean</literal></entry>
                            <entry><literal>System.Boolean</literal></entry>
                            <entry><literal>DbType.Boolean</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Byte</literal></entry>
                            <entry><literal>System.Byte</literal></entry>
                            <entry><literal>DbType.Byte</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Char</literal></entry>
                            <entry><literal>System.Char</literal></entry>
                            <entry><literal>DbType.StringFixedLength - 1 char</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Currency</literal></entry>
                            <entry><literal>System.Decimal</literal></entry>
                            <entry><literal>DbType.Currency</literal></entry>
                            <entry><literal>type="Currency"</literal> must be specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Date</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry><literal>DbType.Date</literal></entry>
                            <entry><literal>type="Date"</literal> must be specified.</entry>
                        </row>
                        <row>
                            <entry><literal>DateTime</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry>
                                <literal>DbType.DateTime</literal> / <literal>DbType.DateTime2</literal><co id="basic_mapping.datetime-co" linkends="basic_mapping.datetime"/>
                            </entry>
                            <entry>
                                Default when no <literal>type</literal> attribute specified. Does no
                                longer ignore fractional seconds since NHibernate v5.0.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>DateTimeNoMs</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry>
                                <literal>DbType.DateTime</literal> / <literal>DbType.DateTime2</literal><coref linkend="basic_mapping.datetime-co" />
                            </entry>
                            <entry>
                                <literal>type="DateTimeNoMs"</literal> must be specified. Ignores fractional seconds.
                                Available since NHibernate v5.0.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>DateTime2</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry><literal>DbType.DateTime2</literal></entry>
                            <entry>
                                <literal>type="DateTime2"</literal> must be specified. Obsolete since
                                NHibernate v5.0, use <literal>DateTime</literal> instead.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>DateTimeOffset</literal></entry>
                            <entry><literal>System.DateTimeOffset</literal></entry>
                            <entry><literal>DbType.DateTimeOffset</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>DbTimestamp</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry>
                                <literal>DbType.DateTime</literal> / <literal>DbType.DateTime2</literal><coref linkend="basic_mapping.datetime-co" />
                            </entry>
                            <entry>
                                <literal>type="DbTimestamp"</literal> must be specified. When used as a
                                <literal>version</literal> field, uses the database's current time retrieved
                                in dedicated queries, rather than the client's current time. In case of lack of
                                database support, it falls back on the client's current time.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>Decimal</literal></entry>
                            <entry><literal>System.Decimal</literal></entry>
                            <entry><literal>DbType.Decimal</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Double</literal></entry>
                            <entry><literal>System.Double</literal></entry>
                            <entry><literal>DbType.Double</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Guid</literal></entry>
                            <entry><literal>System.Guid</literal></entry>
                            <entry><literal>DbType.Guid</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Int16</literal></entry>
                            <entry><literal>System.Int16</literal></entry>
                            <entry><literal>DbType.Int16</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Int32</literal></entry>
                            <entry><literal>System.Int32</literal></entry>
                            <entry><literal>DbType.Int32</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Int64</literal></entry>
                            <entry><literal>System.Int64</literal></entry>
                            <entry><literal>DbType.Int64</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>LocalDateTime</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry>
                                <literal>DbType.DateTime</literal> / <literal>DbType.DateTime2</literal><coref linkend="basic_mapping.datetime-co" />
                            </entry>
                            <entry>
                                <literal>type="LocalDateTime"</literal> must be specified. Ensures the
                                <literal>DateTimeKind</literal> is set to <literal>DateTimeKind.Local</literal>.
                                Throws if set with a date having another kind.
                                Does no longer ignore fractional seconds since NHibernate v5.0.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>LocalDateTimeNoMs</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry>
                                <literal>DbType.DateTime</literal> / <literal>DbType.DateTime2</literal><coref linkend="basic_mapping.datetime-co" />
                            </entry>
                            <entry>
                                <literal>type="LocalDateTimeNoMs"</literal> must be specified. Similar to
                                <literal>LocalDateTime</literal> but ignores fractional seconds.
                                Available since NHibernate v5.0.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>PersistentEnum</literal></entry>
                            <entry>A <literal>System.Enum</literal></entry>
                            <entry>The <literal>DbType</literal> for the underlying value.</entry>
                            <entry>Do not specify <literal>type="PersistentEnum"</literal> in the mapping.  Instead 
                            specify the Assembly Qualified Name of the Enum or let NHibernate use Reflection to "guess" the Type.
                            The UnderlyingType of the Enum is used to determine the correct <literal>DbType</literal>.</entry>
                        </row>
                        <row>
                            <entry><literal>SByte</literal></entry>
                            <entry><literal>System.SByte</literal></entry>
                            <entry><literal>DbType.SByte</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Single</literal></entry>
                            <entry><literal>System.Single</literal></entry>
                            <entry><literal>DbType.Single</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Ticks</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry><literal>DbType.Int64</literal></entry>
                            <entry>
                                <literal>type="Ticks"</literal> must be specified. This is the recommended way to "timestamp" a
                                column, along with <literal>UtcTicks</literal>.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>Time</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry><literal>DbType.Time</literal></entry>
                            <entry><literal>type="Time"</literal> must be specified.</entry>
                        </row>
                        <row>
                            <entry><literal>TimeAsTimeSpan</literal></entry>
                            <entry><literal>System.TimeSpan</literal></entry>
                            <entry><literal>DbType.Time</literal></entry>
                            <entry><literal>type="TimeAsTimeSpan"</literal> must be specified.</entry>
                        </row>
                        <row>
                            <entry><literal>TimeSpan</literal></entry>
                            <entry><literal>System.TimeSpan</literal></entry>
                            <entry><literal>DbType.Int64</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Timestamp</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry>
                                <literal>DbType.DateTime</literal> / <literal>DbType.DateTime2</literal><coref linkend="basic_mapping.datetime-co" />
                            </entry>
                            <entry>
                                Obsolete, its <literal>Timestamp</literal> alias will be remapped to
                                <literal>DateTime</literal> in a future version.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>TrueFalse</literal></entry>
                            <entry><literal>System.Boolean</literal></entry>
                            <entry><literal>DbType.AnsiStringFixedLength</literal> - 1 char either 'T' or 'F'</entry>
                            <entry><literal>type="TrueFalse"</literal> must be specified.</entry>
                        </row>
                        <row>
                            <entry><literal>UInt16</literal></entry>
                            <entry><literal>System.UInt16</literal></entry>
                            <entry><literal>DbType.UInt16</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>UInt32</literal></entry>
                            <entry><literal>System.UInt32</literal></entry>
                            <entry><literal>DbType.UInt32</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>UInt64</literal></entry>
                            <entry><literal>System.UInt64</literal></entry>
                            <entry><literal>DbType.UInt64</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>UtcDateTime</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry>
                                <literal>DbType.DateTime</literal> / <literal>DbType.DateTime2</literal><coref linkend="basic_mapping.datetime-co" />
                            </entry>
                            <entry>
                                Ensures the <literal>DateTimeKind</literal> is set to <literal>DateTimeKind.Utc</literal>.
                                Throws if set with a date having another kind.
                                Does no longer ignore fractional seconds since NHibernate v5.0.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>UtcDateTimeNoMs</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry>
                                <literal>DbType.DateTime</literal> / <literal>DbType.DateTime2</literal><coref linkend="basic_mapping.datetime-co" />
                            </entry>
                            <entry>
                                <literal>type="UtcDateTimeNoMs"</literal> must be specified. Similar to
                                <literal>UtcDateTime</literal> but ignores fractional seconds.
                                Available since NHibernate v5.0.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>UtcDbTimestamp</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry>
                                <literal>DbType.DateTime</literal> / <literal>DbType.DateTime2</literal><coref linkend="basic_mapping.datetime-co" />
                            </entry>
                            <entry>
                                <literal>type="UtcDbTimestamp"</literal> must be specified. When used as a
                                <literal>version</literal> field, uses the database's current UTC time retrieved
                                in dedicated queries, rather than the client's current time. In case of lack of
                                database support, it falls back on the client's current time.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>UtcTicks</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry><literal>DbType.Int64</literal></entry>
                            <entry>
                                <literal>type="UtcTicks"</literal> must be specified. This is the recommended way to "timestamp" a
                                column, along with <literal>Ticks</literal>.
                                Ensures the <literal>DateTimeKind</literal> is set to <literal>DateTimeKind.Utc</literal>.
                                Throws if set with a date having another kind.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>YesNo</literal></entry>
                            <entry><literal>System.Boolean</literal></entry>
                            <entry><literal>DbType.AnsiStringFixedLength</literal> - 1 char either 'Y' or 'N'</entry>
                            <entry><literal>type="YesNo"</literal> must be specified.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

            <calloutlist>
              <callout arearefs="basic_mapping.datetime-co" id="basic_mapping.datetime">
                <para>
                  Since NHibernate v5.0 and if the dialect supports it, <literal>DbType.DateTime2</literal>
                  is used instead of <literal>DbType.DateTime</literal>. This may be disabled by setting
                  <literal>sql_types.keep_datetime</literal> to <literal>true</literal>.
                </para>
              </callout>
            </calloutlist>

            <table>
                <title>System.Object Mapping Types</title>
                <tgroup cols="4">
                    <thead>
                        <row>
                            <entry>NHibernate Type</entry>
                            <entry>.NET Type</entry>
                            <entry>Database Type</entry>
                            <entry>Remarks</entry>	
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><literal>AnsiString</literal></entry>
                            <entry><literal>System.String</literal></entry>
                            <entry><literal>DbType.AnsiString</literal></entry>
                            <entry><literal>type="AnsiString"</literal> must be specified.</entry>
                        </row>
                        <row>
                            <entry><literal>CultureInfo</literal></entry>
                            <entry><literal>System.Globalization.CultureInfo</literal></entry>
                            <entry><literal>DbType.String</literal> - 5 chars for culture</entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Binary</literal></entry>
                            <entry><literal>System.Byte[]</literal></entry>
                            <entry><literal>DbType.Binary</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Type</literal></entry>
                            <entry><literal>System.Type</literal></entry>
                            <entry><literal>DbType.String</literal> holding Assembly Qualified Name.</entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>String</literal></entry>
                            <entry><literal>System.String</literal></entry>
                            <entry><literal>DbType.String</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Uri</literal></entry>
                            <entry><literal>System.Uri</literal></entry>
                            <entry><literal>DbType.String</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

            <para>
                String types use by default .Net default string equality, which is case sensitive and culture
                insensitive. When a string type is used as an identifier, if the underlying database string
                equality semantic differs, it may cause issues. For example, loading a children collection by
                a string parent key stored in a case insensitive column may cause matching children having
                their parent key differing by the case to be ignored by NHibernate by default.
            </para>

            <para>
                String types comparer can be set for matching the database or column behavior. To set the
                default comparer for all string types, affect by code a <literal>StringComparer</literal> to
                <literal>AbstractStringType.DefaultComparer</literal> static property. To set the comparer used
                only for a specific <literal>&lt;property&gt;</literal> or <literal>&lt;id&gt;</literal>,
                specify its type as a sub-element and supply <literal>IgnoreCase</literal> and/or
                <literal>ComparerCulture</literal> parameters.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="stringcomp1" coords="3 55"/>
                    <area id="stringcomp2" coords="4 55"/>
                </areaspec>
                <programlisting><![CDATA[<id name="Id" generator="assigned">
    <type name="string">
        <param name="ComparerCulture">en-US</param>
        <param name="IgnoreCase">true</param>
    </type>
</id>]]></programlisting>
                <calloutlist>
                    <callout arearefs="stringcomp1">
                        <para>
                            <literal>IgnoreCase</literal>: <literal>true</literal> for case insensitive comparisons.
                            Any other value will result in case sensitive comparisons.
                        </para>
                    </callout>
                    <callout arearefs="stringcomp2">
                        <para>
                            <literal>ComparerCulture</literal>: <literal>Current</literal> for using the application
                            current culture, <literal>Invariant</literal> for using the invariant culture,
                            <literal>Ordinal</literal> for using ordinal comparison, or any valid culture name for
                            using another culture. By default, ordinal comparisons are used.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                If you have many properties to map with these parameters, consider using <literal>&lt;typedef&gt;</literal>.
                See <xref linkend="mapping-types-custom"/> for more information.
            </para>

            <para>
                These settings should be used in order to match the database or column behavior. They are not taken into
                account by the hbm2ddl tool for generating the database schema. (In other words, it will not generate
                matching <literal>collate</literal> statements for SQL-Server.)
            </para>

            <table>
                <title>Large Object Mapping Types</title>
                <tgroup cols="4">
                    <thead>
                        <row>
                            <entry>NHibernate Type</entry>
                            <entry>.NET Type</entry>
                            <entry>Database Type</entry>
                            <entry>Remarks</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><literal>StringClob</literal></entry>
                            <entry><literal>System.String</literal></entry>
                            <entry><literal>DbType.String</literal></entry>
                            <entry><literal>type="StringClob"</literal> must be specified.  Entire field is read into memory.</entry>
                        </row>
                        <row>
                            <entry><literal>BinaryBlob</literal></entry>
                            <entry><literal>System.Byte[]</literal></entry>
                            <entry><literal>DbType.Binary</literal></entry>
                            <entry><literal>type="BinaryBlob"</literal> must be specified.  Entire field is read into memory.</entry>
                        </row>
                        <row>
                            <entry><literal>Serializable</literal></entry>
                            <entry>Any <literal>System.Object</literal> that is marked with SerializableAttribute.</entry>
                            <entry><literal>DbType.Binary</literal></entry>
                            <entry><literal>type="Serializable"</literal> should be specified.  This is the fallback type
                            if no NHibernate Type can be found for the Property.</entry>
                        </row>
                        <row>
                            <entry><literal>XDoc</literal></entry>
                            <entry><literal>System.Xml.Linq.XDocument</literal></entry>
                            <entry><literal>DbType.Xml</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.  Entire field is read into memory.</entry>
                        </row>
                        <row>
                            <entry><literal>XmlDoc</literal></entry>
                            <entry><literal>System.Xml.XmlDocument</literal></entry>
                            <entry><literal>DbType.Xml</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.  Entire field is read into memory.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

            <para>
                NHibernate supports some additional type names for compatibility with Java's Hibernate (useful for those coming over from
                Hibernate or using some of the tools to generate <literal>hbm.xml</literal> files).
                A <literal>type="integer"</literal> or <literal>type="int"</literal> will map to an <literal>Int32</literal>
                NHibernate type, <literal>type="short"</literal> to an <literal>Int16</literal> NHibernateType.
                To see all of the conversions you can view the source of static constructor of the class
                <literal>NHibernate.Type.TypeFactory</literal>.
            </para>

            <para>
                Default NHibernate types used when no <literal>type</literal> attribute is specified can be overridden by using
                the <literal>NHibernate.Type.TypeFactory.RegisterType</literal> static method before configuring and building
                session factories.
            </para>

        </sect2>

        <sect2 id="mapping-types-custom">
            <title>Custom value types</title>

            <para>
                It is relatively easy for developers to create their own value types. For example,
                you might want to persist properties of type <literal>Int64</literal>
                to <literal>VARCHAR</literal> columns. NHibernate does not provide a built-in type
                for this. But custom types are not limited to mapping a property (or collection element)
                to a single table column. So, for example, you might have a property
                <literal>Name { get; set; }</literal> of type
                <literal>String</literal> that is persisted to the columns
                <literal>FIRST_NAME</literal>, <literal>INITIAL</literal>, <literal>SURNAME</literal>.
            </para>
            
            <para>
                To implement a custom type, implement either <literal>NHibernate.UserTypes.IUserType</literal>
                or <literal>NHibernate.UserTypes.ICompositeUserType</literal> and declare properties using the
                fully qualified name of the type. Check out
                <literal>NHibernate.DomainModel.DoubleStringType</literal> to see the kind of things that
                are possible.
            </para>

            <programlisting><![CDATA[<property name="TwoStrings"
    type="NHibernate.DomainModel.DoubleStringType, NHibernate.DomainModel">
    <column name="first_string"/>
    <column name="second_string"/>
</property>]]></programlisting>

            <para>
                Notice the use of <literal>&lt;column&gt;</literal> tags to map a property to multiple
                columns.
            </para>

            <para>
                The <literal>IEnhancedUserType</literal>, <literal>IUserVersionType</literal>,
                and <literal>IUserCollectionType</literal> interfaces provide support for more specialized
                uses. The later is to be used with collections, see <xref linkend="collections-persistent" />.
            </para>

            <para>
                You may even supply parameters to an <literal>IUserType</literal> in the mapping file. To
                do this, your <literal>IUserType</literal> must implement the
                <literal>NHibernate.UserTypes.IParameterizedType</literal> interface. To supply parameters
                to your custom type, you can use the <literal>&lt;type&gt;</literal> element in your mapping
                files.
            </para>
            
            <programlisting><![CDATA[<property name="priority">
    <type name="MyCompany.UserTypes.DefaultValueIntegerType">
        <param name="default">0</param>
    </type>
</property>]]></programlisting>

            <para>
                The <literal>IUserType</literal> can now retrieve the value for the parameter named 
                <literal>default</literal> from the <literal>IDictionary</literal> object passed to it.
            </para>
            <para>
                If you use a certain <literal>UserType</literal> very often, it may be useful to define a
                shorter name for it. You can do this using the <literal>&lt;typedef&gt;</literal> element.
                Typedefs assign a name to a custom type, and may also contain a list of default
                parameter values if the type is parameterized.
            </para>

            <programlisting><![CDATA[<typedef class="MyCompany.UserTypes.DefaultValueIntegerType" name="default_zero">
    <param name="default">0</param>
</typedef>]]></programlisting>

            <programlisting><![CDATA[<property name="priority" type="default_zero"/>]]></programlisting>
            
            <para>
                It is also possible to override the parameters supplied in a typedef on a case-by-case basis
                by using type parameters on the property mapping.
            </para>

            <para>
                Even though NHibernate's rich range of built-in types and support for components means you
                will very rarely <emphasis>need</emphasis> to use a custom type, it is nevertheless
                considered good form to use custom types for (non-entity) classes that occur frequently
                in your application. For example, a <literal>MonetaryAmount</literal> class is a good
                candidate for an <literal>ICompositeUserType</literal>, even though it could easily be mapped
                as a component. One motivation for this is abstraction. With a custom type, your mapping
                documents would be future-proofed against possible changes in your way of representing
                monetary values.
            </para>

        </sect2>

    </sect1>

    <sect1 id="mapping-entityname">
        <title>Mapping a class more than once</title>
        <para>
            It is possible to provide more than one mapping for a particular persistent class. In this case,
            you must specify an <emphasis>entity name</emphasis> to disambiguate between instances of the two
            mapped entities. By default, the entity name is the same as the class name. NHibernate lets you
            specify the entity name when working with persistent objects, when writing queries, or when
            mapping associations to the named entity. 
        </para>

        <programlisting><![CDATA[<class name="Contract" table="Contracts"
        entity-name="CurrentContract">
    ...
    <set name="History" inverse="true"
            order-by="effectiveEndDate desc">
        <key column="currentContractId"/>
        <one-to-many entity-name="HistoricalContract"/>
    </set>
</class>

<class name="Contract" table="ContractHistory"
        entity-name="HistoricalContract">
    ...
    <many-to-one name="CurrentContract"
            column="currentContractId"
            entity-name="CurrentContract"/>
</class>]]></programlisting>

        <para>
            Associations are now specified using <literal>entity-name</literal> instead of
            <literal>class</literal>.
        </para>

    </sect1>

    <sect1 id="mapping-quotedidentifiers">
        <title>SQL quoted identifiers</title>
        <para>
            You may force NHibernate to quote an identifier in the generated SQL by enclosing the table or
            column name in back-ticks in the mapping document. NHibernate will use the correct quotation
            style for the SQL <literal>Dialect</literal> (usually double quotes, but brackets for SQL
            Server and back-ticks for MySQL).
        </para>

        <programlisting><![CDATA[<class name="LineItem" table="`Line Item`">
    <id name="Id" column="`Item Id`">
        <generator class="assigned"/>
    </id>
    <property name="ItemNumber" column="`Item #`"/>
    ...
</class>]]></programlisting>

        <para>
            Quoting column identifiers is required if a table contains two columns differing only by case.
            Ensure you use consistent casing when quoting identifiers.
        </para>

    </sect1>

   <sect1 id="mapping-modularfiles">
       <title>Modular mapping files</title>
       <para>
            It is possible to define <literal>subclass</literal> and <literal>joined-subclass</literal>
            mappings in separate mapping documents, directly beneath <literal>hibernate-mapping</literal>.
            This allows you to extend a class hierarchy just by adding a new mapping file. You must
            specify an <literal>extends</literal> attribute in the subclass mapping, naming a previously
            mapped superclass.
        </para>

        <programlisting><![CDATA[
<hibernate-mapping>
    <subclass name="Eg.Subclass.DomesticCat, Eg"
        extends="Eg.Cat, Eg" discriminator-value="D">

        <property name="name" type="string"/>
    </subclass>
</hibernate-mapping>]]></programlisting>

    </sect1>

    <sect1 id="mapping-generated">
        <title>Generated Properties</title>
        <para>
            Generated properties are properties which have their values generated by the
            database.  Typically, NHibernate applications needed to <literal>Refresh</literal>
            objects which contain any properties for which the database was generating values.
            Marking properties as generated, however, lets the application delegate this
            responsibility to NHibernate.  Essentially, whenever NHibernate issues an SQL INSERT
            or UPDATE for an entity which has defined generated properties, it immediately
            issues a select afterwards to retrieve the generated values.
        </para>
        <para>
            Properties marked as generated must additionally be non-insertable and non-updatable.
            Only <link linkend="mapping-declaration-version">versions</link>,
            <link linkend="mapping-declaration-timestamp">timestamps</link>, and
            <link linkend="mapping-declaration-property">simple properties</link> can be marked as
            generated.
        </para>
        <para>
            <literal>never</literal> (the default) - means that the given property value
            is not generated within the database.
        </para>
        <para>
            <literal>insert</literal> - states that the given property value is generated on
            insert, but is not regenerated on subsequent updates.  Things like created-date would
            fall into this category.  Note that even though
            <link linkend="mapping-declaration-version">version</link> and
            <link linkend="mapping-declaration-timestamp">timestamp</link> properties can
            be marked as generated, this option is not available for them.
        </para>
        <para>
            <literal>always</literal> - states that the property value is generated both
            on insert and on update.
        </para>
    </sect1>

    <sect1 id="mapping-database-object">
        <title>Auxiliary Database Objects</title>
        <para>
            Auxiliary database objects allow CREATE and DROP of arbitrary database objects. In
            conjunction with NHibernate's schema evolution tools, they have the ability to fully
            define a user schema within the NHibernate mapping files. Although designed specifically
            for creating and dropping things like triggers or stored procedures, any SQL command
            that can be run via a <literal>DbCommand.ExecuteNonQuery()</literal> method is valid
            (for example, ALTERs, INSERTS, etc.). There are essentially two modes for defining
            auxiliary database objects:
        </para>
        <para>
            The first mode is to explicitly list the CREATE and DROP commands in the mapping file:
        </para>
        <programlisting><![CDATA[<nhibernate-mapping>
    ...
    <database-object>
        <create>CREATE TRIGGER my_trigger ...</create>
        <drop>DROP TRIGGER my_trigger</drop>
    </database-object>
</nhibernate-mapping>]]></programlisting>
        <para>
            The second mode is to supply a custom class that constructs the
            CREATE and DROP commands.  This custom class must implement the
            <literal>NHibernate.Mapping.IAuxiliaryDatabaseObject</literal> interface.
        </para>
        <programlisting><![CDATA[<hibernate-mapping>
    ...
    <database-object>
        <definition class="MyTriggerDefinition, MyAssembly"/>
    </database-object>
</hibernate-mapping>]]></programlisting>
        <para>
            You may also specify parameters to be passed to the database object:
        </para>
        <programlisting><![CDATA[<hibernate-mapping>
    ...
    <database-object>
        <definition class="MyTriggerDefinition, MyAssembly">
            <param name="parameterName">parameterValue</param>
        </definition>
    </database-object>
</hibernate-mapping>]]></programlisting>
        <para>
            NHibernate will call <literal>IAuxiliaryDatabaseObject.SetParameterValues</literal>
            passing it a dictionary of parameter names and values.
        </para>
        <para>
            Additionally, these database objects can be optionally scoped such that they only
            apply when certain dialects are used.
        </para>
        <programlisting><![CDATA[<hibernate-mapping>
    ...
    <database-object>
        <definition class="MyTriggerDefinition"/>
        <dialect-scope name="NHibernate.Dialect.Oracle9iDialect"/>
        <dialect-scope name="NHibernate.Dialect.Oracle8iDialect"/>
    </database-object>
</hibernate-mapping>]]></programlisting>
    </sect1>

    <sect1 id="mapping-meta">
        <title>Meta data</title>

        <para>
            You may declare additional metadata in your mappings by using the <literal>meta</literal> element. This element
            can be added to the main mapping elements.
        </para>

        <programlistingco>
            <areaspec>
                <area id="meta1" coords="2 55"/>
                <area id="meta2" coords="3 55"/>
                <area id="meta3" coords="4 55"/>
            </areaspec>
            <programlisting><![CDATA[<meta
    attribute="metaName"
    inherit="true|false"
    >metaData</meta>]]></programlisting>
            <calloutlist>
                <callout arearefs="meta1">
                    <para>
                        <literal>attribute</literal>: The name of the metadata.
                    </para>
                </callout>
                <callout arearefs="meta2">
                    <para>
                        <literal>inherit</literal> (optional - defaults to <literal>true</literal>):
                        Whether the metadata is inherited by mapping sub-elements or not.
                    </para>
                </callout>
                <callout arearefs="meta3">
                    <para>
                        The text content of the meta element is its data.
                    </para>
                </callout>
            </calloutlist>
        </programlistingco>

        <para>
            The metadata can be retrieved at runtime from the <xref linkend="manipulatingdata-metadata"/>.
        </para>
    </sect1>

</chapter>
