<chapter id="mapping">
    <title>Basic O/R Mapping</title>

    <sect1 id="mapping-declaration">
        <title>Mapping declaration</title>

        <para>
            Object/relational mappings are defined in an XML document. The mapping document
            is designed to be readable and hand-editable. The mapping language is object-centric,
            meaning that mappings are constructed around persistent class declarations, not
            table declarations.
        </para>
        
        <para>
            Note that, even though many NHibernate users choose to define XML mappings by hand,
            a number of tools exist to generate the mapping document, including
            NHibernate.Mapping.Attributes library and various template-based code
            generators (CodeSmith, MyGeneration). You may also use
            <literal>NHibernate.Mapping.ByCode</literal> available since NHibernate 3.2, or
            <ulink url="https://github.com/jagregory/fluent-nhibernate">Fluent NHibernate</ulink>.
        </para>

        <para>
            Let's kick off with an example mapping:
        </para>

        <programlisting><![CDATA[<?xml version="1.0"?>
<hibernate-mapping xmlns="urn:nhibernate-mapping-2.2" assembly="Eg"
    namespace="Eg">

        <class name="Cat" table="CATS" discriminator-value="C">
                <id name="Id" column="uid" type="Int64">
                        <generator class="hilo"/>
                </id>
                <discriminator column="subclass" type="Char"/>
                <property name="BirthDate" type="Date"/>
                <property name="Color" not-null="true"/>
                <property name="Sex" not-null="true" update="false"/>
                <property name="Weight"/>
                <many-to-one name="Mate" column="mate_id"/>
                <set name="Kittens">
                        <key column="mother_id"/>
                        <one-to-many class="Cat"/>
                </set>
                <subclass name="DomesticCat" discriminator-value="D">
                        <property name="Name" type="String"/>
                </subclass>
        </class>

        <class name="Dog">
                <!-- mapping for Dog could go here -->
        </class>

</hibernate-mapping>]]></programlisting>

        <para>
             We will now discuss the content of the mapping document. We will only describe the
             document elements and attributes that are used by NHibernate at runtime. The mapping
             document also contains some extra optional attributes and elements that affect the
             database schemas exported by the schema export tool. (For example the <literal>
             not-null</literal> attribute.)
        </para>

        <sect2 id="mapping-declaration-xmlns">
            <title>XML Namespace</title>

            <para>
                All XML mappings should declare the XML namespace shown. The actual schema definition
                may be found in the <literal>src\nhibernate-mapping.xsd</literal> file in the
                NHibernate distribution.
            </para>

            <para><emphasis>
                Tip: to enable IntelliSense for mapping and configuration files, copy the appropriate
                <literal>.xsd</literal> files as part of any project in your solution,
                (<literal>Build Action</literal> can be "None") or as "Solution Files" or in your
              <literal>"Lib"</literal> folder and then add it to the <literal>Schemas</literal> property of the xml file.
              You can copy it in <literal>&lt;VS installation directory&gt;\Xml\Schemas</literal>, take care because you will have to deal
              with different version of the xsd for different versions of NHibernate.
            </emphasis>
            </para>

        </sect2>

        <sect2 id="mapping-declaration-mapping">
            <title>hibernate-mapping</title>

            <para>
                This element has several optional attributes. The <literal>schema</literal> attribute
                specifies that tables referred to by this mapping belong to the named schema. If specified, 
                table names will be qualified by the given schema name. If missing, table names will be 
                unqualified. The <literal>default-cascade</literal> attribute specifies what cascade style
                should be assumed for properties and collections which do not specify a
                <literal>cascade</literal> attribute. The <literal>auto-import</literal> attribute lets us
                use unqualified class names in the query language, by default. The <literal>assembly</literal>
                and <literal>namespace</literal> attributes specify the assembly where persistent classes
                are located and the namespace they are declared in.
            </para>
 
             <programlistingco>
                 <areaspec>
                     <area id="hm1" coords="2 55"/>
                     <area id="hm2" coords="3 55"/>
                     <area id="hm3" coords="4 55"/>
                     <area id="hm4" coords="5 55"/>
                     <area id="hm5" coords="6 55"/>
                   <area id="hm6" coords="7 55"/>
                   <area id="hm7" coords="8 55"/>
                 </areaspec>
                 <programlisting><![CDATA[<hibernate-mapping
         schema="schemaName"
         default-cascade="none|save-update"
         auto-import="true|false"
         assembly="Eg"
         namespace="Eg"
         default-access="field|property|field.camecase..."
         default-lazy="true|false"
 />]]></programlisting>
                 <calloutlist>
                     <callout arearefs="hm1">
                         <para>
                             <literal>schema</literal> (optional): The name of a database schema.
                         </para>
                     </callout>
                     <callout arearefs="hm2">
                         <para>
                             <literal>default-cascade</literal> (optional - defaults to <literal>none</literal>):
                             A default cascade style.
                         </para>
                     </callout>
                     <callout arearefs="hm3">
                         <para>
                             <literal>auto-import</literal> (optional - defaults to <literal>true</literal>):
                             Specifies whether we can use unqualified class names (of classes in this mapping)
                             in the query language.
                         </para>
                     </callout>
                     <callout arearefs="hm4 hm5">
                         <para>
                             <literal>assembly</literal> and <literal>namespace</literal>(optional): Specify
                             assembly and namespace to assume for unqualified class names in the mapping
                             document.
                         </para>
                     </callout>
                   <callout arearefs="hm6">
                     <para>
                       <literal>default-access</literal> (optional - defaults to property):
                       The strategy NHibernate should use for accessing a property value
                     </para>
                   </callout>
                   <callout arearefs="hm7">
                     <para>
                       <literal>default-lazy</literal> (optional - defaults to <literal>true</literal>):
                       Lazy fetching may be completely disabled by setting default-lazy="false".
                     </para>
                   </callout>
                 </calloutlist>
             </programlistingco>

             <para>
                 If you are not using <literal>assembly</literal> and <literal>namespace</literal>
                 attributes, you have to specify fully-qualified class names, including the name
                 of the assembly that classes are declared in.
             </para>

             <para>
                 If you have two persistent classes with the same (unqualified) name, you should set
                 <literal>auto-import="false"</literal>. NHibernate will throw an exception if you attempt
                 to assign two classes to the same "imported" name.
             </para>
        </sect2>

        <sect2 id="mapping-declaration-class">
            <title>class</title>

            <para>
                You may declare a persistent class using the <literal>class</literal> element:
            </para>

            <programlistingco>
                <areaspec>
                    <area id="class1" coords="2 55"/>
                    <area id="class2" coords="3 55" />
                    <area id="class3" coords="4 55"/>
                    <area id="class4" coords="5 55" />
                    <area id="class5" coords="6 55"/>
                    <area id="class6" coords="7 55" />
                    <area id="class7" coords="8 55"/>
                    <area id="class8" coords="9 55" />
                    <area id="class9" coords="10 55" />
                    <area id="class10" coords="11 55"/>
                    <area id="class11" coords="12 55"/>
                    <area id="class12" coords="13 55"/>
                    <area id="class13" coords="14 55"/>
                    <area id="class14" coords="15 55"/>
                    <area id="class15" coords="16 55"/>
                    <area id="class16" coords="17 55"/>
                </areaspec>
                <programlisting><![CDATA[<class
        name="ClassName"
        table="tableName"
        discriminator-value="discriminator_value"
        mutable="true|false"
        schema="owner"
        proxy="ProxyInterface"
        dynamic-update="true|false"
        dynamic-insert="true|false"
        select-before-update="true|false"
        polymorphism="implicit|explicit"
        where="arbitrary sql where condition"
        persister="PersisterClass"
        batch-size="N"
        optimistic-lock="none|version|dirty|all"
        lazy="true|false"
        abstract="true|false"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="class1">
                        <para>
                            <literal>name</literal>: The fully qualified .NET class name of the persistent class
                            (or interface), including its assembly name.
                        </para>
                    </callout>
                    <callout arearefs="class2">
                        <para>
                            <literal>table</literal>(optional - defaults to the unqualified class name): The name of its database table.
                        </para>
                    </callout>
                    <callout arearefs="class3">
                        <para>
                            <literal>discriminator-value</literal> (optional - defaults to the class name): A value
                            that distinguishes individual subclasses, used for polymorphic behaviour. Acceptable
                            values include <literal>null</literal> and <literal>not null</literal>.
                        </para>
                    </callout>
                    <callout arearefs="class4">
                        <para>
                            <literal>mutable</literal> (optional, defaults to <literal>true</literal>): Specifies
                            that instances of the class are (not) mutable.
                        </para>
                    </callout>
                    <callout arearefs="class5">
                        <para>
                            <literal>schema</literal> (optional): Override the schema name specified by
                            the root <literal>&lt;hibernate-mapping&gt;</literal> element.
                        </para>
                    </callout>
                    <callout arearefs="class6">
                        <para>
                            <literal>proxy</literal> (optional): Specifies an interface to use for lazy
                            initializing proxies. You may specify the name of the class itself.
                        </para>
                    </callout>
                    <callout arearefs="class7">
                        <para>
                            <literal>dynamic-update</literal> (optional, defaults to <literal>false</literal>):
                            Specifies that <literal>UPDATE</literal> SQL should be generated at runtime and 
                            contain only those columns whose values have changed.
                        </para>
                    </callout>
                    <callout arearefs="class8">
                        <para>
                            <literal>dynamic-insert</literal> (optional, defaults to <literal>false</literal>):
                            Specifies that <literal>INSERT</literal> SQL should be generated at runtime and 
                            contain only the columns whose values are not null.
                        </para>
                    </callout>
                    <callout arearefs="class9">
                        <para>
                            <literal>select-before-update</literal> (optional, defaults to <literal>false</literal>):
                            Specifies that NHibernate should <emphasis>never</emphasis> perform an SQL <literal>UPDATE</literal>
                            unless it is certain that an object is actually modified. In certain cases (actually, only
                            when a transient object has been associated with a new session using <literal>update()</literal>),
                            this means that NHibernate will perform an extra SQL <literal>SELECT</literal> to determine
                            if an <literal>UPDATE</literal> is actually required.
                        </para>
                    </callout>
                    <callout arearefs="class10">
                        <para>
                            <literal>polymorphism</literal> (optional, defaults to <literal>implicit</literal>):
                            Determines whether implicit or explicit query polymorphism is used.
                        </para>
                    </callout>
                    <callout arearefs="class11">
                        <para>
                            <literal>where</literal> (optional) specify an arbitrary SQL <literal>WHERE</literal>
                            condition to be used when retrieving objects of this class
                        </para>
                    </callout>
                    <callout arearefs="class12">
                        <para>
                            <literal>persister</literal> (optional): Specifies a custom <literal>IClassPersister</literal>.
                        </para>
                    </callout>
                    <callout arearefs="class13">
                        <para>
                            <literal>batch-size</literal> (optional, defaults to <literal>1</literal>) specify a "batch size"
                            for fetching instances of this class by identifier.
                        </para>
                    </callout>
                   <callout arearefs="class14">
                        <para>
                            <literal>optimistic-lock</literal> (optional, defaults to <literal>version</literal>):
                            Determines the optimistic locking strategy.
                        </para>
                    </callout>    
                    <callout arearefs="class15">
                        <para>
                            <literal>lazy</literal> (optional): Lazy fetching may be completely disabled by setting
                            <literal>lazy="false"</literal>.
                        </para>
                    </callout>
                    <callout arearefs="class16">
                        <para>
                            <literal>abstract</literal> (optional): Used to mark abstract superclasses in
                            <literal>&lt;union-subclass&gt;</literal> hierarchies.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                It is perfectly acceptable for the named persistent class to be an interface. You would then
                declare implementing classes of that interface using the <literal>&lt;subclass&gt;</literal>
                element. You may persist any inner class. You should specify the
                class name using the standard form ie. <literal>Eg.Foo+Bar, Eg</literal>.
                Due to an HQL parser limitation inner classes can not be used in queries in NHibernate 1.0.
            </para>

            <para>
                Changes to immutable classes, <literal>mutable="false"</literal>, will not be
                persisted. This allows NHibernate to make some minor performance optimizations.
            </para>

            <para>
                The optional <literal>proxy</literal> attribute enables lazy initialization of persistent
                instances of the class. NHibernate will initially return proxies which implement
                the named interface. The actual persistent object will be loaded when a method of the
                proxy is invoked. See "Proxies for Lazy Initialization" below.
            </para>

            <para><emphasis>Implicit</emphasis> polymorphism means that instances of the class will be returned
                by a query that names any superclass or implemented interface or the class and that instances
                of any subclass of the class will be returned by a query that names the class itself.
                <emphasis>Explicit</emphasis> polymorphism means that class instances will be returned only
                be queries that explicitly name that class and that queries that name the class will return
                only instances of subclasses mapped inside this <literal>&lt;class&gt;</literal> declaration
                as a <literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-subclass&gt;</literal>. For
                most purposes the default, <literal>polymorphism="implicit"</literal>, is appropriate.
                Explicit polymorphism is useful when two different classes are mapped to the same table
                (this allows a "lightweight" class that contains a subset of the table columns).
            </para>

            <para>
                The <literal>persister</literal> attribute lets you customize the persistence strategy used for
                the class. You may, for example, specify your own subclass of
                <literal>NHibernate.Persister.EntityPersister</literal> or you might even provide a
                completely new implementation of the interface
                <literal>NHibernate.Persister.IClassPersister</literal> that implements persistence via,
                for example, stored procedure calls, serialization to flat files or LDAP. See
                <literal>NHibernate.DomainModel.CustomPersister</literal> for a simple example (of "persistence"
                to a <literal>Hashtable</literal>).
            </para>

            <para>
                Note that the <literal>dynamic-update</literal> and <literal>dynamic-insert</literal>
                settings are not inherited by subclasses and so may also be specified on the
                <literal>&lt;subclass&gt;</literal> or <literal>&lt;joined-subclass&gt;</literal> elements.
                These settings may increase performance in some cases, but might actually decrease
                performance in others. Use judiciously.
            </para>

            <para>
                Use of <literal>select-before-update</literal> will usually decrease performance. It is very
                useful to prevent a database update trigger being called unnecessarily.
            </para>

            <para>
                If you enable <literal>dynamic-update</literal>, you will have a choice of optimistic
                locking strategies:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <literal>version</literal> check the version/timestamp columns
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>all</literal> check all columns
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>dirty</literal> check the changed columns
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>none</literal> do not use optimistic locking
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                We <emphasis>very</emphasis> strongly recommend that you use version/timestamp
                columns for optimistic locking with NHibernate. This is the optimal strategy with
                respect to performance and is the only strategy that correctly handles modifications
                made outside of the session (ie. when <literal>ISession.Update()</literal> is used).
                Keep in mind that a version or timestamp property should never be null, no matter
                what <literal>unsaved-value</literal> strategy, or an instance will be detected as
                transient.
            </para>

            <para>
                Beginning with NHibernate 1.2.0, version numbers start with 1, not 0 as in previous
                versions. This was done to allow using 0 as <literal>unsaved-value</literal> for the
                version property.
            </para>
        </sect2>

        <sect2 id="mapping-declaration-subselect">
            <title>subselect</title>

            <para>
                An alternative to mapping a class to table or view columns is to map a <emphasis>query</emphasis>.
                For that, we use the <literal>&lt;subselect&gt;</literal> element, which is mutually
                exclusive with <literal>&lt;subclass&gt;</literal>, <literal>&lt;joined-subclass&gt;</literal>
                and <literal>&lt;union-subclass&gt;</literal>.
                The content of the <literal>subselect</literal> element is a SQL query:
            </para>

            <programlisting>&lt;subselect&gt;
    &lt;![CDATA[
    SELECT cat.ID, cat.NAME, cat.SEX, cat.MATE FROM cat
    ]]&gt;
&lt;/subselect&gt;</programlisting>

            <para>
                Usually, when mapping a query using <literal>subselect</literal> you will want to mark
                the class as not mutable (<literal>mutable="false"</literal>), unless you specify custom
                SQL for performing the UPDATE, DELETE and INSERT operations.
            </para>

            <para>
                Also, it makes sense to force synchronization of the tables affected by the query, using
                one or more <literal>&lt;synchronize&gt;</literal> entries:
            </para>

            <programlisting>&lt;subselect&gt;
    &lt;![CDATA[
    SELECT cat.ID, cat.NAME, cat.SEX, cat.MATE FROM cat
    ]]&gt;
&lt;/subselect&gt;
&lt;syncronize table="cat"/&gt;</programlisting>

            <para>
                You then still have to declare the class id and properties.
            </para>

        </sect2>

        <sect2 id="mapping-declaration-id">
            <title>id</title>

            <para>
                Mapped classes <emphasis>must</emphasis> declare the primary key column of the database
                table. Most classes will also have a property holding the unique identifier
                of an instance. The <literal>&lt;id&gt;</literal> element defines the mapping from that
                property to the primary key column.
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="id1" coords="2 50" />
                    <area id="id2" coords="3 50" />
                    <area id="id3" coords="4 50" />
                    <area id="id4" coords="5 50" />
                    <area id="id5" coords="6 50" />
                </areaspec>
                <programlisting><![CDATA[<id
        name="PropertyName"
        type="typename"
        column="column_name"
        unsaved-value="any|none|null|id_value"
        access="field|property|nosetter|ClassName">

        <generator class="generatorClass"/>
</id>]]></programlisting>
                <calloutlist>
                    <callout arearefs="id1">
                        <para>
                            <literal>name</literal> (optional): The name of the identifier property.
                        </para>
                    </callout>
                    <callout arearefs="id2">
                        <para>
                            <literal>type</literal> (optional): A name that indicates the NHibernate type.
                        </para>
                    </callout>
                    <callout arearefs="id3">
                        <para>
                            <literal>column</literal> (optional - defaults to the property name): The
                            name of the primary key column.
                        </para>
                    </callout>
                    <callout arearefs="id4">
                        <para>
                            <literal>unsaved-value</literal> (optional - defaults to a "sensible" value): 
                            An identifier property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from transient instances that were saved or loaded
                            in a previous session.
                        </para>
                    </callout>
                   <callout arearefs="id5">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): The
                            strategy NHibernate should use for accessing the property value.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            
            <para>
                If the <literal>name</literal> attribute is missing, it is assumed that the class has no
                identifier property.
            </para>

            <para>
                The <literal>unsaved-value</literal> attribute is almost never needed in NHibernate 1.0.
            </para>

             <para>
                There is an alternative <literal>&lt;composite-id&gt;</literal> declaration to allow access to
                legacy data with composite keys. We strongly discourage its use for anything else.
            </para>

            <sect3 id="mapping-declaration-id-generator">
                <title>generator</title>

                <para>
                    The required <literal>generator</literal> names a .NET class used to generate unique identifiers
                    for instances of the persistent class.
                </para>
                <para>
                  The generator can be declared using the <literal>&lt;generator&gt;</literal> child element. If
                  any parameters are required to configure or initialize the generator instance, they are passed
                  using <literal>&lt;param&gt;</literal> elements.
                </para>

                <programlisting><![CDATA[<id name="Id" type="Int64" column="uid" unsaved-value="0">
        <generator class="NHibernate.Id.TableHiLoGenerator">
                <param name="table">uid_table</param>
                <param name="column">next_hi_value_column</param>
        </generator>
</id>]]></programlisting>

                <para>
                    If no parameters are required, the generator can be declared using a <literal>generator</literal>
                    attribute directly on the <literal>&lt;id&gt;</literal> element, as follows:
                </para>

                <programlisting><![CDATA[<id name="Id" type="Int64" column="uid" unsaved-value="0" generator="native" />]]></programlisting>

                <para>
                    All generators implement the interface <literal>NHibernate.Id.IIdentifierGenerator</literal>.
                    This is a very simple interface; some applications may choose to provide their own specialized
                    implementations. However, NHibernate provides a range of built-in implementations. There are shortcut
                    names for the built-in generators:

                    <variablelist>
                        <varlistentry>
                        <term><literal>increment</literal></term>
                        <listitem>
                            <para>
                                generates identifiers of any integral type that are unique only when
                                no other process is inserting data into the same table.
                                <emphasis>Do not use in a cluster.</emphasis>
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>identity</literal></term>
                        <listitem>
                            <para>
                                supports identity columns in DB2, MySQL, MS SQL Server and Sybase. The identifier
                                returned by the database is converted to the property type using <literal>
                                Convert.ChangeType</literal>. Any integral property type is thus supported.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>sequence</literal></term>
                        <listitem>
                            <para>
                                uses a sequence in DB2, PostgreSQL, Oracle or a generator
                                in Firebird. The identifier returned by the database is converted to the property
                                type using <literal>Convert.ChangeType</literal>. Any integral property type is
                                thus supported.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>hilo</literal></term>
                        <listitem>
                            <para id="mapping-declaration-id-hilodescription" revision="1">
                                uses a hi/lo algorithm to efficiently generate identifiers of any integral type,
                                given a table and column (by default <literal>hibernate_unique_key</literal> and
                                <literal>next_hi</literal> respectively) as a source of hi values. The hi/lo algorithm
                                generates identifiers that are unique only for a particular database. <emphasis>Do not
                                use this generator with a user-supplied connection.</emphasis>
                            </para>
                            <para>
                                You can use the "where" parameter to specify the row to use in a table. This is useful
                                if you want to use a single table for your identifiers, with different rows for each table.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>seqhilo</literal></term>
                        <listitem>
                            <para>
                                uses a hi/lo algorithm to efficiently generate identifiers of any integral type,
                                given a named database sequence.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>uuid.hex</literal></term>
                        <listitem>
                            <para>
                                uses <literal>System.Guid</literal> and its <literal>ToString(string format)</literal> method
                                to generate identifiers of type string.  The length of the string returned depends on the 
                                configured <literal>format</literal>.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>uuid.string</literal></term>
                        <listitem>
                            <para>
                                uses a new <literal>System.Guid</literal> to create a <literal>byte[]</literal> that is
                                converted to a string.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>guid</literal></term>
                        <listitem>
                            <para>
                                uses a new <literal>System.Guid</literal> as the identifier.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>guid.comb</literal></term>
                        <listitem>
                            <para>
                                uses the algorithm to generate a new <literal>System.Guid</literal>
                                described by Jimmy Nilsson in
                                <ulink url="https://www.informit.com/articles/article.aspx?p=25862">this
                                article</ulink>.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>native</literal></term>
                        <listitem>
                            <para>
                                picks <literal>identity</literal>, <literal>sequence</literal> or
                                <literal>hilo</literal> depending upon the capabilities of the
                                underlying database.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>assigned</literal></term>
                        <listitem>
                            <para>
                                lets the application to assign an identifier to the object before
                                <literal>Save()</literal> is called.
                            </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                        <term><literal>foreign</literal></term>
                        <listitem>
                            <para>
                                uses the identifier of another associated object. Usually used in conjunction
                                with a <literal>&lt;one-to-one&gt;</literal> primary key association.
                            </para>
                        </listitem>
                        </varlistentry>
                    </variablelist>

                </para>
            </sect3>
            
            <sect3 id="mapping-declaration-id-hilo">
                <title>Hi/Lo Algorithm</title>
                <para>
                    The <literal>hilo</literal> and <literal>seqhilo</literal> generators provide two alternate
                    implementations of the hi/lo algorithm, a favorite approach to identifier generation. The
                    first implementation requires a "special" database table to hold the next available "hi" value.
                    The second uses an Oracle-style sequence (where supported).
                </para>

                <programlisting><![CDATA[<id name="Id" type="Int64" column="cat_id">
        <generator class="hilo">
                <param name="table">hi_value</param>
                <param name="column">next_value</param>
                <param name="max_lo">100</param>
        </generator>
</id>]]></programlisting>

                <programlisting><![CDATA[<id name="Id" type="Int64" column="cat_id">
        <generator class="seqhilo">
                <param name="sequence">hi_value</param>
                <param name="max_lo">100</param>
        </generator>
</id>]]></programlisting>

                <para>
                    Unfortunately, you can't use <literal>hilo</literal> when supplying your own
                    <literal>DbConnection</literal> to NHibernate. NHibernate must be able to
                    fetch the "hi" value in a new transaction.
                </para>
            </sect3>
            
            <sect3 id="mapping-declaration-id-uuid-hex">
                <title>UUID Hex Algorithm</title>

                <programlisting><![CDATA[<id name="Id" type="String" column="cat_id">
        <generator class="uuid.hex">
            <param name="format">format_value</param>
            <param name="separator">separator_value</param>
        </generator>
</id>]]></programlisting>

                <para>
                    The UUID is generated by calling <literal>Guid.NewGuid().ToString(format)</literal>.
                    The valid values for <literal>format</literal> are described in the MSDN documentation.
                    The default <literal>separator</literal> is <literal>-</literal> and should rarely be
                    modified.  The <literal>format</literal> determines if the configured
                    <literal>separator</literal> can replace the default separator used by
                    the <literal>format</literal>.
                </para>
            </sect3>
            
            <sect3 id="mapping-declaration-id-uuid-string">
                <title>UUID String Algorithm</title>
                <para>
                    The UUID is generated by calling <literal>Guid.NewGuid().ToByteArray()</literal> and
                    then converting the <literal>byte[]</literal> into a <literal>char[]</literal>.  The
                    <literal>char[]</literal> is returned as a <literal>String</literal> consisting of
                    16 characters.
                </para>
            </sect3>

            <sect3 id="mapping-declaration-id-guid">
                <title>GUID Algorithms</title>
                <para>
                    The <literal>guid</literal> identifier is generated by calling <literal>Guid.NewGuid()</literal>.
                    To address some of the performance concerns with using Guids as primary keys, foreign keys, and
                    as part of indexes with MS SQL the <literal>guid.comb</literal> can be used.  The benefit of using
                    the <literal>guid.comb</literal> with other databases that support GUIDs has not been measured.
                </para>
            </sect3>

            <sect3 id="mapping-declaration-id-sequences">
            <title>Identity columns and Sequences</title>
                <para>
                    For databases which support identity columns (DB2, MySQL, Sybase, MS SQL), you
                    may use <literal>identity</literal> key generation. For databases that support
                    sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you may use
                    <literal>sequence</literal> style key generation. Both these strategies require
                    two SQL queries to insert a new object.
                </para>

                <programlisting><![CDATA[<id name="Id" type="Int64" column="uid">
        <generator class="sequence">
                <param name="sequence">uid_sequence</param>
        </generator>
</id>]]></programlisting>

                <programlisting><![CDATA[<id name="Id" type="Int64" column="uid" unsaved-value="0">
        <generator class="identity"/>
</id>]]></programlisting>
            
                <para>
                    For cross-platform development, the <literal>native</literal> strategy will
                    choose from the <literal>identity</literal>, <literal>sequence</literal> and
                    <literal>hilo</literal> strategies, dependent upon the capabilities of the
                    underlying database.
                </para>
            </sect3>
            
            <sect3 id="mapping-declaration-id-assigned">
                <title>Assigned Identifiers</title>
                <para>
                    If you want the application to assign identifiers (as opposed to having
                    NHibernate generate them), you may use the <literal>assigned</literal> generator.
                    This special generator will use the identifier value already assigned to the
                    object's identifier property. Be very careful when using this feature to assign
                    keys with business meaning (almost always a terrible design decision).
                </para>
                <para>
                    Due to its inherent nature, entities that use this generator cannot be saved
                    via the ISession's SaveOrUpdate() method. Instead you have to explicitly specify to
                    NHibernate if the object should be saved or updated by calling either the
                    <literal>Save()</literal> or <literal>Update()</literal> method of the ISession.
                </para>
            </sect3>

            <sect3 id="mapping-declaration-id-enhanced">
                <title>Enhanced identifier generators</title>

                <para>Starting with NHibernate release 3.3.0, there are 2 new generators which
                represent a re-thinking of 2 different aspects of identifier
                generation. The first aspect is database portability; the second is
                optimization. Optimization means that you do not have to query the
                database for every request for a new identifier value. These two new
                generators are intended to take the place of some of the named
                generators described above, starting in 3.3.x. However, they are
                included in the current releases and can be referenced by FQN.</para>

                <para>The first of these new generators is
                <literal>NHibernate.Id.Enhanced.SequenceStyleGenerator</literal>
                (short name <literal>enhanced-sequence</literal>)
                which is intended, firstly, as a replacement for the
                <literal>sequence</literal> generator and, secondly, as a better
                portability generator than <literal>native</literal>. This is because
                <literal>native</literal> generally chooses between
                <literal>identity</literal> and <literal>sequence</literal> which have
                largely different semantics that can cause subtle issues in
                applications eyeing portability.
                <literal>NHibernate.Id.Enhanced.SequenceStyleGenerator</literal>,
                however, achieves portability in a different manner. It chooses
                between a table or a sequence in the database to store its
                incrementing values, depending on the capabilities of the dialect
                being used. The difference between this and <literal>native</literal>
                is that table-based and sequence-based storage have the same exact
                semantic. In fact, sequences are exactly what NHibernate tries to
                emulate with its table-based generators. This generator has a number
                of configuration parameters: <itemizedlist spacing="compact">
                    <listitem>
                      <para><literal>sequence_name</literal> (optional, defaults to
                      <literal>hibernate_sequence</literal>): the name of the sequence
                      or table to be used.</para>
                    </listitem>

                    <listitem>
                      <para><literal>initial_value</literal> (optional, defaults to
                      <literal>1</literal>): the initial value to be retrieved from
                      the sequence/table. In sequence creation terms, this is
                      analogous to the clause typically named "STARTS WITH".</para>
                    </listitem>

                    <listitem>
                      <para><literal>increment_size</literal> (optional - defaults to
                      <literal>1</literal>): the value by which subsequent calls to
                      the sequence/table should differ. In sequence creation terms,
                      this is analogous to the clause typically named "INCREMENT
                      BY".</para>
                    </listitem>

                    <listitem>
                      <para><literal>force_table_use</literal> (optional - defaults to
                      <literal>false</literal>): should we force the use of a table as
                      the backing structure even though the dialect might support
                      sequence?</para>
                    </listitem>

                    <listitem>
                      <para><literal>value_column</literal> (optional - defaults to
                      <literal>next_val</literal>): only relevant for table
                      structures, it is the name of the column on the table which is
                      used to hold the value.</para>
                    </listitem>

                    <listitem>
                      <para><literal>prefer_sequence_per_entity</literal> (optional -
                      defaults to <literal>false</literal>): should we create
                      separate sequence for each entity that share current generator
                      based on its name?</para>
                    </listitem>

                    <listitem>
                      <para><literal>sequence_per_entity_suffix</literal> (optional -
                      defaults to <literal>_SEQ</literal>): suffix added to the name
                      of a dedicated sequence.</para>
                    </listitem>

                    <listitem>
                      <para><literal>optimizer</literal> (optional - defaults to
                      <literal>none</literal>): See <xref
                      linkend="mapping-declaration-id-enhanced-optimizers" /></para>
                    </listitem>
                  </itemizedlist></para>

                <para>The second of these new generators is
                <literal>NHibernate.Id.Enhanced.TableGenerator</literal> (short name <literal>enhanced-table</literal>), which is
                intended, firstly, as a replacement for the <literal>table</literal>
                generator, even though it actually functions much more like
                <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal> (not available in NHibernate), and
                secondly, as a re-implementation of
                <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal> (not available in NHibernate) that
                utilizes the notion of pluggable optimizers. Essentially this
                generator defines a table capable of holding a number of different
                increment values simultaneously by using multiple distinctly keyed
                rows. This generator has a number of configuration parameters:
                <itemizedlist spacing="compact">
                    <listitem>
                      <para><literal>table_name</literal> (optional - defaults to
                      <literal>hibernate_sequences</literal>): the name of the table
                      to be used.</para>
                    </listitem>

                    <listitem>
                      <para><literal>value_column_name</literal> (optional - defaults
                      to <literal>next_val</literal>): the name of the column on the
                      table that is used to hold the value.</para>
                    </listitem>

                    <listitem>
                      <para><literal>segment_column_name</literal> (optional -
                      defaults to <literal>sequence_name</literal>): the name of the
                      column on the table that is used to hold the "segment key". This
                      is the value which identifies which increment value to
                      use.</para>
                    </listitem>

                    <listitem>
                      <para><literal>segment_value</literal> (optional - defaults to
                      <literal>default</literal>): The "segment key" value for the
                      segment from which we want to pull increment values for this
                      generator.</para>
                    </listitem>

                    <listitem>
                      <para><literal>segment_value_length</literal> (optional -
                      defaults to <literal>255</literal>): Used for schema generation;
                      the column size to create this segment key column.</para>
                    </listitem>

                    <listitem>
                      <para><literal>initial_value</literal> (optional - defaults to
                      <literal>1</literal>): The initial value to be retrieved from
                      the table.</para>
                    </listitem>

                    <listitem>
                      <para><literal>increment_size</literal> (optional - defaults to
                      <literal>1</literal>): The value by which subsequent calls to
                      the table should differ.</para>
                    </listitem>

                    <listitem>
                      <para><literal>optimizer</literal> (optional - defaults to
                      <literal>??</literal>): See <xref
                      linkend="mapping-declaration-id-enhanced-optimizers" />.</para>
                    </listitem>
                  </itemizedlist></para>

                <sect4 id="mapping-declaration-id-enhanced-optimizers">
                  <title>Identifier generator optimization</title>

                  <para>For identifier generators that store values in the database,
                  it is inefficient for them to hit the database on each and every
                  call to generate a new identifier value. Instead, you can group a
                  bunch of them in memory and only hit the database when you have
                  exhausted your in-memory value group. This is the role of the
                  pluggable optimizers. Currently only the two enhanced generators
                  (<xref linkend="mapping-declaration-id-enhanced" /> support this
                  operation.</para>

                  <itemizedlist spacing="compact">
                    <listitem>
                      <para><literal>none</literal> (generally this is the default if
                      no optimizer was specified): this will not perform any
                      optimizations and hit the database for each and every
                      request.</para>
                    </listitem>

                    <listitem>
                      <para><literal>hilo</literal>: applies a hi/lo algorithm around
                      the database retrieved values. The values from the database for
                      this optimizer are expected to be sequential. The values
                      retrieved from the database structure for this optimizer
                      indicates the "group number". The
                      <literal>increment_size</literal> is multiplied by that value in
                      memory to define a group "hi value".</para>
                    </listitem>

                    <listitem>
                      <para><literal>pooled</literal>: as with the case of
                      <literal>hilo</literal>, this optimizer attempts to minimize the
                      number of hits to the database. Here, however, we simply store
                      the starting value for the "next group" into the database
                      structure rather than a sequential value in combination with an
                      in-memory grouping algorithm. Here,
                      <literal>increment_size</literal> refers to the values coming
                      from the database.</para>
                    </listitem>

                    <listitem>
                      <para><literal>pooled-lo</literal>: similar to
                      <literal>pooled</literal>, except that it's the starting value of
                      the "current group" that is stored into the database structure.
                      Here,
                      <literal>increment_size</literal> refers to the values coming
                      from the database.</para>
                    </listitem>
                  </itemizedlist>
                </sect4>
            </sect3>

        </sect2>

        <sect2 id="mapping-declaration-compositeid">
            <title>composite-id</title>

            <programlisting><![CDATA[<composite-id
        name="PropertyName"
        class="ClassName"
        unsaved-value="any|none"
        access="field|property|nosetter|ClassName">

        <key-property name="PropertyName" type="typename" column="column_name"/>
        <key-many-to-one name="PropertyName class="ClassName" column="column_name"/>
        ......
</composite-id>]]></programlisting>

            <para>
                For a table with a composite key, you may map multiple properties of the class
                as identifier properties. The <literal>&lt;composite-id&gt;</literal> element
                accepts <literal>&lt;key-property&gt;</literal> property mappings and
                <literal>&lt;key-many-to-one&gt;</literal> mappings as child elements.
            </para>

            <programlisting><![CDATA[<composite-id>
        <key-property name="MedicareNumber"/>
        <key-property name="Dependent"/>
</composite-id>]]></programlisting>

            <para>
                Your persistent class <emphasis>must</emphasis> override <literal>Equals()</literal>
                and <literal>GetHashCode()</literal> to implement composite identifier equality. It must
                also be marked with the <literal>Serializable</literal> attribute.
            </para>

            <para>
                Unfortunately, this approach to composite identifiers means that a persistent object
                is its own identifier. There is no convenient "handle" other than the object itself.
                You must instantiate an instance of the persistent class itself and populate its
                identifier properties before you can <literal>Load()</literal> the persistent state
                associated with a composite key. We will describe a much more
                convenient approach where the composite identifier is implemented as a separate class
                in <xref linkend="components-compositeid"/>. The attributes described below apply only
                to this alternative approach:
            </para>

            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>name</literal> (optional, required for this approach): A property of
                        component type that holds the composite identifier (see next section).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>access</literal> (optional - defaults to <literal>property</literal>):
                        The strategy NHibernate should use for accessing the property value.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>class</literal> (optional - defaults to the property type determined by 
                        reflection): The component class used as a composite identifier (see next section).
                    </para>
                </listitem>
            </itemizedlist>

        </sect2>

        <sect2 id="mapping-declaration-discriminator" revision="1">
            <title>discriminator</title>

            <para>
                The <literal>&lt;discriminator&gt;</literal> element is required for polymorphic persistence
                using the table-per-class-hierarchy mapping strategy and declares a discriminator column of the
                table. The discriminator column contains marker values that tell the persistence layer what
                subclass to instantiate for a particular row. A restricted set of types may be used:
                <literal>String</literal>, <literal>Char</literal>, <literal>Int32</literal>,
                <literal>Byte</literal>, <literal>Short</literal>, <literal>Boolean</literal>,
                <literal>YesNo</literal>, <literal>TrueFalse</literal>.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="discriminator1" coords="2 40"/>
                    <area id="discriminator2" coords="3 40" />
                    <area id="discriminator3" coords="4 40" />
                    <area id="discriminator4" coords="5 40" />
                    <area id="discriminator5" coords="6 40" />
                </areaspec>
                <programlisting><![CDATA[<discriminator
        column="discriminator_column"
        type="discriminator_type"
        force="true|false"
        insert="true|false"
        formula="arbitrary SQL expression"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="discriminator1">
                        <para>
                            <literal>column</literal> (optional - defaults to <literal>class</literal>) the
                            name of the discriminator column.
                        </para>
                    </callout>
                    <callout arearefs="discriminator2">
                        <para>
                            <literal>type</literal> (optional - defaults to <literal>String</literal>) a
                            name that indicates the NHibernate type
                        </para>
                    </callout>
                    <callout arearefs="discriminator3">
                        <para>
                            <literal>force</literal> (optional - defaults to <literal>false</literal>)
                            "force" NHibernate to specify allowed discriminator values even when retrieving 
                            all instances of the root class.
                        </para>
                    </callout>
                    <callout arearefs="discriminator4">
                        <para>
                            <literal>insert</literal> (optional - defaults to <literal>true</literal>)
                            set this to <literal>false</literal> if your discriminator column is also part
                            of a mapped composite identifier.
                        </para>
                    </callout>
                    <callout arearefs="discriminator5">
                        <para>
                            <literal>formula</literal> (optional) an arbitrary SQL expression that is
                            executed when a type has to be evaluated. Allows content-based discrimination.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                Actual values of the discriminator column are specified by the
                <literal>discriminator-value</literal> attribute of the <literal>&lt;class&gt;</literal> and
                <literal>&lt;subclass&gt;</literal> elements.
            </para>
            
            <para>
                The <literal>force</literal> attribute is (only) useful if the table contains rows with
                "extra" discriminator values that are not mapped to a persistent class. This will not
                usually be the case.
            </para>

            <para>
                Using the <literal>formula</literal> attribute you can declare an arbitrary SQL expression
                that will be used to evaluate the type of a row:
            </para>

            <programlisting><![CDATA[<discriminator
    formula="case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end"
    type="Int32"/>]]></programlisting>
        </sect2>

        <sect2 id="mapping-declaration-version">
            <title>version (optional)</title>
            
            <para>
                The <literal>&lt;version&gt;</literal> element is optional and indicates that
                the table contains versioned data. This is particularly useful if you plan to
                use <emphasis>long transactions</emphasis> (see below).
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="version1" coords="2 60"/>
                    <area id="version2" coords="3 60"/>
                    <area id="version3" coords="4 60"/>
                    <area id="version4" coords="5 60"/>
                    <area id="version5" coords="6 60"/>
                    <area id="version6" coords="7 60"/>
                </areaspec>
                <programlisting><![CDATA[<version
        column="version_column"
        name="PropertyName"
        type="typename"
        access="field|property|nosetter|ClassName"
        unsaved-value="null|negative|undefined|value"
        generated="never|always"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="version1">
                        <para>
                            <literal>column</literal> (optional - defaults to the property name): The name
                            of the column holding the version number.
                        </para>
                    </callout>
                    <callout arearefs="version2">
                        <para>
                            <literal>name</literal>: The name of a property  of the persistent class.
                        </para>
                    </callout>
                    <callout arearefs="version3">
                        <para>
                            <literal>type</literal> (optional - defaults to <literal>Int32</literal>):
                            The type of the version number.
                        </para>
                    </callout>
                   <callout arearefs="version4">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): The
                            strategy NHibernate should use for accessing the property value.
                        </para>
                    </callout>
                   <callout arearefs="version5">
                        <para>
                            <literal>unsaved-value</literal> (optional - defaults to a "sensible" value):
                            A version property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from transient instances that were saved or loaded
                            in a previous session. (<literal>undefined</literal> specifies that the identifier
                            property value should be used.)
                        </para>
                    </callout>
                    <callout arearefs="version6">
                        <para>
                            <literal>generated</literal> (optional - defaults to <literal>never</literal>):
                            Specifies that this version property value is actually generated by the database.
                            See the discussion of <xref linkend="mapping-generated">generated properties</xref>.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                Version may be of type <literal>Int64</literal>, <literal>Int32</literal>,
                <literal>Int16</literal>, <literal>Ticks</literal>, <literal>Timestamp</literal>,
                <literal>TimeSpan</literal>, <literal>datetimeoffset</literal>, ... (or their nullable
                counterparts in .NET 2.0). Any type implementing <literal>IVersionType</literal> is
                usable as a version.
            </para>

        </sect2>
        
        <sect2 id="mapping-declaration-timestamp" revision="1">
            <title>timestamp (optional)</title>

            <para>
                The optional <literal>&lt;timestamp&gt;</literal> element indicates that the table contains 
                timestamped data. This is intended as an alternative to versioning. Timestamps are by nature
                a less safe implementation of optimistic locking. However, sometimes the application might
                use the timestamps in other ways.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="timestamp1" coords="2 45"/>
                    <area id="timestamp2" coords="3 45" />
                    <area id="timestamp3" coords="4 45" />
                    <area id="timestamp4" coords="5 45" />
                    <area id="timestamp5" coords="6 45" />
                </areaspec>
                <programlisting><![CDATA[<timestamp
        column="timestamp_column"
        name="PropertyName"
        access="field|property|nosetter|ClassName"
        unsaved-value="null|undefined|value"
        generated="never|always"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="timestamp1">
                        <para>
                            <literal>column</literal> (optional - defaults to the property name): The name
                            of a column holding the timestamp.
                        </para>
                    </callout>
                    <callout arearefs="timestamp2">
                        <para>
                            <literal>name</literal>: The name of a property of .NET type
                            <literal>DateTime</literal> of the persistent class.
                        </para>
                    </callout>
                   <callout arearefs="timestamp3">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): The
                            strategy NHibernate should use for accessing the property value.
                        </para>
                    </callout>
                   <callout arearefs="timestamp4">
                        <para>
                            <literal>unsaved-value</literal> (optional - defaults to <literal>null</literal>):
                            A timestamp property value that indicates that an instance is newly instantiated
                            (unsaved), distinguishing it from transient instances that were saved or loaded
                            in a previous session. (<literal>undefined</literal> specifies that the identifier
                            property value should be used.)
                        </para>
                    </callout>
                    <callout arearefs="timestamp5">
                        <para>
                            <literal>generated</literal> (optional - defaults to <literal>never</literal>):
                            Specifies that this timestamp property value is actually generated by the database.
                            See the discussion of <xref linkend="mapping-generated">generated properties</xref>.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            
            <para>
                Note that <literal>&lt;timestamp&gt;</literal> is equivalent to
                <literal>&lt;version type="timestamp"&gt;</literal>.
            </para>
        </sect2>


        <sect2 id="mapping-declaration-property">
            <title>property</title>

            <para>
                The <literal>&lt;property&gt;</literal> element declares a persistent property
                of the class.
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="property1" coords="2 45"/>
                    <area id="property2" coords="3 45"/>
                    <area id="property3" coords="4 45"/>
                    <areaset id="property4-5" coords="">
                        <area id="property4" coords='5 45'/>
                        <area id="property5" coords='6 45'/>
                    </areaset>
                    <area id="property6" coords="7 45"/>
                    <area id="property7" coords="8 45"/>
                    <area id="property8" coords="9 45"/>
                    <area id="property9" coords="10 45" />
                    <area id="property10" coords="11 45" />
                </areaspec>
                <programlisting><![CDATA[<property
        name="propertyName"
        column="column_name"
        type="typename"
        update="true|false"
        insert="true|false"
        formula="arbitrary SQL expression"
        access="field|property|ClassName"
        optimistic-lock="true|false"
        generated="never|insert|always"
        lazy="true|false"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="property1">
                        <para>
                            <literal>name</literal>: the name of the property of your class.
                        </para>
                    </callout>
                    <callout arearefs="property2">
                        <para>
                            <literal>column</literal> (optional - defaults to the property name): the name
                            of the mapped database table column.
                        </para>
                    </callout>
                    <callout arearefs="property3">
                        <para>
                            <literal>type</literal> (optional): a name that indicates the NHibernate type.
                        </para>
                    </callout>
                    <callout arearefs="property4-5">
                        <para>
                            <literal>update, insert</literal> (optional - defaults to <literal>true</literal>) :
                            specifies that the mapped columns should be included in SQL <literal>UPDATE</literal>
                            and/or <literal>INSERT</literal> statements. Setting both to <literal>false</literal>
                            allows a pure "derived" property whose value is initialized from some other
                            property that maps to the same column(s) or by a trigger or other application.
                        </para>
                    </callout>
                    <callout arearefs="property6">
                        <para>
                            <literal>formula</literal> (optional): an SQL expression that defines the value for a
                            <emphasis>computed</emphasis> property. Computed properties do not have a column
                            mapping of their own.
                        </para>
                    </callout>
                   <callout arearefs="property7">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): The
                            strategy NHibernate should use for accessing the property value.
                        </para>
                    </callout>
                    <callout arearefs="property8">
                        <para>
                            <literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>):
                            Specifies that updates to this property do or do not require acquisition of the
                            optimistic lock. In other words, determines if a version increment should occur when 
                            this property is dirty.
                        </para>
                    </callout>
                    <callout arearefs="property9">
                        <para>
                            <literal>generated</literal> (optional - defaults to <literal>never</literal>):
                            Specifies that this property value is actually generated by the database.
                            See the discussion of <xref linkend="mapping-generated">generated properties</xref>.
                        </para>
                    </callout>
                    <callout arearefs="property10">
                        <para>
                            <literal>lazy</literal> (optional - defaults to <literal>false</literal>):
                            Specifies that this property is lazy. A lazy property is not loaded when
                            the object is initially loaded, unless the fetch mode has been overridden
                            in a specific query. Values for lazy properties are loaded when any lazy
                            property of the object is accessed.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                <emphasis>typename</emphasis> could be:
            </para>

            <orderedlist spacing="compact">
                <listitem>
                    <para>
                        The name of a NHibernate basic type (eg. <literal>Int32, String, Char,
                        DateTime, Timestamp, Single, Byte[], Object, ...</literal>).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The name of a .NET type with a default basic type (eg. <literal>System.Int16, System.Single,
                        System.Char, System.String, System.DateTime, System.Byte[], ...</literal>).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The name of an enumeration type (eg. <literal>Eg.Color, Eg</literal>).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The name of a serializable .NET type.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The class name of a custom type (eg. <literal>Illflow.Type.MyCustomType</literal>).
                    </para>
                </listitem>
            </orderedlist>

            <para>
                Note that you have to specify full <emphasis>assembly-qualified</emphasis> names for all
                except basic NHibernate types (unless you set <literal>assembly</literal>
                and/or <literal>namespace</literal> attributes of the
                <literal>&lt;hibernate-mapping&gt;</literal> element).
            </para>

            <para>
                NHibernate supports .NET 2.0 <literal>Nullable</literal> types. These types are
                mostly treated the same as plain non-<literal>Nullable</literal> types internally.
                For example, a property of type <literal>Nullable&lt;Int32&gt;</literal> can be mapped
                using <literal>type="Int32"</literal> or <literal>type="System.Int32"</literal>.
            </para>

            <para>
                If you do not specify a type, NHibernate will use reflection upon the named
                property to take a guess at the correct NHibernate type. NHibernate will try to
                interpret the name of the return class of the property getter using rules 2, 3,
                4 in that order. However, this is not always enough.
                In certain cases you will still need the <literal>type</literal>
                attribute. (For example, to distinguish between <literal>NHibernateUtil.DateTime</literal> and
                <literal>NHibernateUtil.Timestamp</literal>, or to specify a custom type.)
            </para>

            <para>
                See also <xref linkend="mapping-types" />.
            </para>

            <para>
                The <literal>access</literal> attribute lets you control how NHibernate will access
                the value of the property at runtime.  The value of the <literal>access</literal> attribute should
                be text formatted as <literal>access-strategy.naming-strategy</literal>.  The
                <literal>.naming-strategy</literal> is not always required.
                <table>
                    <title>Access Strategies</title>
                    <tgroup cols="2">
                        <thead>
                            <row>
                                <entry>Access Strategy Name</entry>
                                <entry>Description</entry>	
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><literal>property</literal></entry>
                                <entry>
                                    <para>
                                        The default implementation.  NHibernate uses the get/set accessors of
                                        the property.  No naming strategy should be used with this access strategy
                                        because the value of the <literal>name</literal> attribute is the name
                                        of the property.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>field</literal></entry>
                                <entry>
                                    <para>
                                        NHibernate will access the field directly.  NHibernate uses the value
                                        of the <literal>name</literal> attribute as the name of the field.
                                        This can be used when a property's getter and setter contain extra actions
                                        that you don't want to occur when NHibernate is populating or reading
                                        the object. If you want the name of the property and not the field to
                                        be what the consumers of your API use with HQL, then a naming strategy
                                        is needed.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>nosetter</literal></entry>
                                <entry>
                                    <para>
                                        NHibernate will access the field directly when setting the value and will use the
                                        Property when getting the value.  This can be used when a property only exposes
                                        a get accessor because the consumers of your API can't change the value directly.
                                        A naming strategy is required because NHibernate uses the value of the
                                        <literal>name</literal> attribute as the property name and needs to
                                        be told what the name of the field is.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>ClassName</literal></entry>
                                <entry>
                                    <para>
                                        If NHibernate's built in access strategies are not what is needed for your situation
                                        then you can build your own by implementing the interface 
                                        <literal>NHibernate.Property.IPropertyAccessor</literal>.  The value of the 
                                        <literal>access</literal> attribute should be an assembly-qualified name that can be
                                        loaded with <literal>Activator.CreateInstance(string assemblyQualifiedName)</literal>.
                                    </para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>
                <table>
                    <title>Naming Strategies</title>
                    <tgroup cols="2">
                        <thead>
                            <row>
                                <entry>Naming Strategy Name</entry>
                                <entry>Description</entry>	
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><literal>camelcase</literal></entry>
                                <entry>
                                    <para>
                                        The <literal>name</literal> attribute is converted to camel case to find the field.
                                        <literal>&lt;property name="FooBar" ... &gt;</literal> uses the field <literal>fooBar</literal>.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>camelcase-underscore</literal></entry>
                                <entry>
                                    <para>
                                        The <literal>name</literal> attribute is converted to camel case and prefixed with an
                                        underscore to find the field.
                                        <literal>&lt;property name="FooBar" ... &gt;</literal> uses the field <literal>_fooBar</literal>.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>camelcase-m-underscore</literal></entry>
                                <entry>
                                    <para>
                                        The <literal>name</literal> attribute is converted to camel case and prefixed with
                                        the character <literal>m</literal> and an underscore to find the field.
                                        <literal>&lt;property name="FooBar" ... &gt;</literal> uses the field <literal>m_fooBar</literal>.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>lowercase</literal></entry>
                                <entry>
                                    <para>
                                        The <literal>name</literal> attribute is converted to lower case to find the Field.
                                        <literal>&lt;property name="FooBar" ... &gt;</literal> uses the field <literal>foobar</literal>.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>lowercase-underscore</literal></entry>
                                <entry>
                                    <para>
                                        The <literal>name</literal> attribute is converted to lower case and prefixed with an
                                        underscore to find the Field.
                                        <literal>&lt;property name="FooBar" ... &gt;</literal> uses the field <literal>_foobar</literal>.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>pascalcase-underscore</literal></entry>
                                <entry>
                                    <para>
                                        The <literal>name</literal> attribute is prefixed with an underscore to find the field.
                                        <literal>&lt;property name="FooBar" ... &gt;</literal> uses the field <literal>_FooBar</literal>.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>pascalcase-m</literal></entry>
                                <entry>
                                    <para>
                                        The <literal>name</literal> attribute is prefixed with the character
                                        <literal>m</literal> to find the field.
                                        <literal>&lt;property name="FooBar" ... &gt;</literal> uses the field <literal>mFooBar</literal>.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><literal>pascalcase-m-underscore</literal></entry>
                                <entry>
                                    <para>
                                        The <literal>name</literal> attribute is prefixed with the character
                                        <literal>m</literal> and an underscore to find the field.
                                        <literal>&lt;property name="FooBar" ... &gt;</literal> uses the field <literal>m_FooBar</literal>.
                                    </para>
                                </entry>
                            </row>	
                        </tbody>
                    </tgroup>
                </table>
            </para>

        </sect2>

        <sect2 id="mapping-declaration-manytoone" revision="1">
            <title>many-to-one</title>

            <para>
                An ordinary association to another persistent class is declared using a
                <literal>many-to-one</literal> element. The relational model is a
                many-to-one association. (It's really just an object reference.)
            </para>

            <programlistingco>
                <areaspec>
                    <area id="manytoone1" coords="2 60"/>
                    <area id="manytoone2" coords="3 60"/>
                    <area id="manytoone3" coords="4 60"/>
                    <area id="manytoone4" coords="5 60"/>
                    <area id="manytoone5" coords="6 60"/>
                    <areaset id="manytoone6-7" coords="">
                        <area id="manytoone6" coords='7 60'/>
                        <area id="manytoone7" coords='8 60'/>
                    </areaset>
                    <area id="manytoone8" coords="9 60"/>
                    <area id="manytoone9" coords="10 60"/>
                    <area id="manytoone10" coords="11 60"/>
                    <area id="manytoone11" coords="12 60"/>
                    <area id="manytoone12" coords="13 60"/>
                </areaspec>
                <programlisting><![CDATA[<many-to-one
        name="PropertyName"
        column="column_name"
        class="ClassName"
        cascade="all|none|save-update|delete|delete-orphan|all-delete-orphan"
        fetch="join|select"
        update="true|false"
        insert="true|false"
        property-ref="PropertyNameFromAssociatedClass"
        access="field|property|nosetter|ClassName"
        unique="true|false"
        optimistic-lock="true|false"
        not-found="ignore|exception"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="manytoone1">
                        <para>
                            <literal>name</literal>: The name of the property.
                        </para>
                    </callout>
                    <callout arearefs="manytoone2">
                        <para>
                            <literal>column</literal> (optional): The name of the column.
                        </para>
                    </callout>
                    <callout arearefs="manytoone3">
                        <para>
                            <literal>class</literal> (optional - defaults to the property type
                            determined by reflection): The name of the associated class.
                        </para>
                    </callout>
                    <callout arearefs="manytoone4">
                        <para>
                            <literal>cascade</literal> (optional): Specifies which operations should
                            be cascaded from the parent object to the associated object.
                        </para>
                    </callout>
                    <callout arearefs="manytoone5">
                        <para>
                            <literal>fetch</literal> (optional - defaults to <literal>select</literal>):
                            Chooses between outer-join fetching or sequential select fetching.
                        </para>
                    </callout>
                    <callout arearefs="manytoone6-7">
                        <para>
                            <literal>update, insert</literal> (optional - defaults to <literal>true</literal>) 
                            specifies that the mapped columns should be included in SQL <literal>UPDATE</literal> 
                            and/or <literal>INSERT</literal> statements. Setting both to <literal>false</literal>
                            allows a pure "derived" association whose value is initialized from some other
                            property that maps to the same column(s) or by a trigger or other application.
                        </para>
                    </callout>
                    <callout arearefs="manytoone8">
                        <para>
                            <literal>property-ref</literal>: (optional) The name of a property of the associated
                            class that is joined to this foreign key. If not specified, the primary key of
                            the associated class is used.
                        </para>
                    </callout>
                   <callout arearefs="manytoone9">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): The
                            strategy NHibernate should use for accessing the property value.
                        </para>
                    </callout>
                    <callout arearefs="manytoone10">
                        <para>
                            <literal>unique</literal> (optional): Enable the DDL generation of a unique
                            constraint for the foreign-key column.
                        </para>
                    </callout>
                    <callout arearefs="manytoone11">
                        <para>
                            <literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>):
                            Specifies that updates to this property do or do not require acquisition of the
                            optimistic lock. In other words, determines if a version increment should occur when
                            this property is dirty.
                        </para>
                    </callout>
                    <callout arearefs="manytoone12">
                        <para>
                            <literal>not-found</literal> (optional - defaults to <literal>exception</literal>):
                            Specifies how foreign keys that reference missing rows will be handled:
                            <literal>ignore</literal> will treat a missing row as a null association.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                The <literal>cascade</literal> attribute permits the following values: 
                <literal>all</literal>, <literal>save-update</literal>, <literal>delete</literal>,
                <literal>delete-orphan</literal>, <literal>all-delete-orphan</literal> and
                <literal>none</literal>. Setting a value other than <literal>none</literal>
                will propagate certain operations to the associated (child) object.
                See "Lifecycle Objects" below.
            </para>

            <para>
                The <literal>fetch</literal> attribute accepts two different values:
            </para>

            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>join</literal> Fetch the association using an outer join
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>select</literal> Fetch the association using a separate query
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                A typical <literal>many-to-one</literal> declaration looks as simple as
            </para>

            <programlisting><![CDATA[<many-to-one name="product" class="Product" column="PRODUCT_ID"/>]]></programlisting>
            
            <para>
                The <literal>property-ref</literal> attribute should only be used for mapping legacy
                data where a foreign key refers to a unique key of the associated table other than
                the primary key. This is an ugly relational model. For example, suppose the 
                <literal>Product</literal> class had a unique serial number, that is not the primary
                key. (The <literal>unique</literal> attribute controls NHibernate's DDL generation with
                the SchemaExport tool.)
            </para>

            <programlisting><![CDATA[<property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/>]]></programlisting>

            <para>
                Then the mapping for <literal>OrderItem</literal> might use:
            </para>

            <programlisting><![CDATA[<many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/>]]></programlisting>
            
            <para>
                This is certainly not encouraged, however.
            </para>

        </sect2>

        <sect2 id="mapping-declaration-onetoone">
            <title>one-to-one</title>

            <para>
                A one-to-one association to another persistent class is declared using a
                <literal>one-to-one</literal> element.
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="onetoone1" coords="2 60"/>
                    <area id="onetoone2" coords="3 60"/>
                    <area id="onetoone3" coords="4 60"/>
                    <area id="onetoone4" coords="5 60"/>
                    <area id="onetoone5" coords="6 60"/>
                    <area id="onetoone6" coords="7 60"/>
                    <area id="onetoone7" coords="8 60"/>
                </areaspec>
                <programlisting><![CDATA[<one-to-one
        name="PropertyName"
        class="ClassName"
        cascade="all|none|save-update|delete|delete-orphan|all-delete-orphan"
        constrained="true|false"
        fetch="join|select"
        property-ref="PropertyNameFromAssociatedClass"
        access="field|property|nosetter|ClassName"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="onetoone1">
                        <para>
                            <literal>name</literal>: The name of the property.
                        </para>
                    </callout>
                    <callout arearefs="onetoone2">
                        <para>
                            <literal>class</literal> (optional - defaults to the property type
                            determined by reflection): The name of the associated class.
                        </para>
                    </callout>
                    <callout arearefs="onetoone3">
                        <para>
                            <literal>cascade</literal> (optional) specifies which operations should
                            be cascaded from the parent object to the associated object.
                        </para>
                    </callout>
                    <callout arearefs="onetoone4">
                        <para>
                            <literal>constrained</literal> (optional) specifies that a foreign key constraint
                            on the primary key of the mapped table references the table of the associated
                            class. This option affects the order in which <literal>Save()</literal> and
                            <literal>Delete()</literal> are cascaded (and is also used by the schema export
                            tool).
                        </para>
                    </callout>
                    <callout arearefs="onetoone5">
                        <para>
                            <literal>fetch</literal> (optional - defaults to <literal>select</literal>):
                            Chooses between outer-join fetching or sequential select fetching.
                        </para>
                    </callout>
                    <callout arearefs="onetoone6">
                        <para>
                            <literal>property-ref</literal>: (optional) The name of a property of the associated class
                            that is joined to the primary key of this class. If not specified, the primary key of
                            the associated class is used.
                        </para>
                    </callout>
                    <callout arearefs="onetoone7">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): The
                            strategy NHibernate should use for accessing the property value.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
        
            <para>
                There are two varieties of one-to-one association:
            </para>
            <itemizedlist>
            <listitem><para>
                primary key associations
            </para></listitem>
            <listitem><para>
                unique foreign key associations
            </para></listitem>
            </itemizedlist>
            
            <para>
                Primary key associations don't need an extra table column; if two rows are related by
                the association then the two table rows share the same primary key value. So if you want 
                two objects to be related by a primary key association, you must make sure that they
                are assigned the same identifier value!
            </para>
            
            <para>
                For a primary key association, add the following mappings to <literal>Employee</literal> and 
                <literal>Person</literal>, respectively.
            </para>

            <programlisting><![CDATA[<one-to-one name="Person" class="Person"/>]]></programlisting>
            <programlisting><![CDATA[<one-to-one name="Employee" class="Employee" constrained="true"/>]]></programlisting>

            <para>
                Now we must ensure that the primary keys of related rows in the PERSON and
                EMPLOYEE tables are equal. We use a special NHibernate identifier generation strategy
                called <literal>foreign</literal>:
            </para>

            <programlisting><![CDATA[<class name="Person" table="PERSON">
    <id name="Id" column="PERSON_ID">
        <generator class="foreign">
            <param name="property">Employee</param>
        </generator>
    </id>
    ...
    <one-to-one name="Employee"
        class="Employee"
        constrained="true"/>
</class>]]></programlisting>

            <para>
                A newly saved instance of <literal>Person</literal> is then assigned the same primary
                key value as the <literal>Employee</literal> instance referred with the <literal>Employee</literal>
                property of that <literal>Person</literal>.
            </para>

            <para>
                Alternatively, a foreign key with a unique constraint, from <literal>Employee</literal> to 
                <literal>Person</literal>, may be expressed as:
            </para>

            <programlisting><![CDATA[<many-to-one name="Person" class="Person" column="PERSON_ID" unique="true"/>]]></programlisting>

            <para>
                And this association may be made bidirectional by adding the following to the 
                <literal>Person</literal> mapping:
            </para>

           <programlisting><![CDATA[<one-to-one name="Employee" class="Employee" property-ref="Person"/>]]></programlisting>

        </sect2>

        <sect2 id="mapping-declaration-naturalid">
            <title>natural-id</title>

            <programlisting><![CDATA[<natural-id mutable="true|false"/>
        <property ... />
        <many-to-one ... />
        ......
</natural-id>]]></programlisting>

            <para>
                Even though we recommend the use of surrogate keys as primary keys, you should still try
                to identify natural keys for all entities. A natural key is a property or combination of
                properties that is unique and non-null. If it is also immutable, even better. Map the
                properties of the natural key inside the <literal>&lt;natural-id&gt;</literal> element.
                NHibernate will generate the necessary unique key and nullability constraints, and your
                mapping will be more self-documenting.
            </para>
            
            <para>
                We strongly recommend that you implement <literal>Equals()</literal> and
                <literal>GetHashCode()</literal> to compare the natural key properties of the entity.
            </para>
            
            <para>
                This mapping is not intended for use with entities with natural primary keys.
            </para>
            
            <itemizedlist spacing="compact">
                <listitem>
                    <para>
                        <literal>mutable</literal> (optional, defaults to <literal>false</literal>):
                        By default, natural identifier properties as assumed to be immutable (constant).
                    </para>
                </listitem>
            </itemizedlist>
            
        </sect2>
        
        <sect2 id="mapping-declaration-component">
            <title>component, dynamic-component</title>

            <para>
                The <literal>&lt;component&gt;</literal> element maps properties of a
                child object to columns of the table of a parent class. Components may, in
                turn, declare their own properties, components or collections. See
                "Components" below.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="component1" coords="2 60"/>
                    <area id="component2" coords="3 60"/>
                    <area id="component3" coords="4 60"/>
                    <area id="component4" coords="5 60"/>
                    <area id="component5" coords="6 60"/>
                    <area id="component6" coords="7 60"/>
                </areaspec>
                <programlisting><![CDATA[<component 
        name="PropertyName" 
        class="ClassName"
        insert="true|false"
        update="true|false"
        access="field|property|nosetter|ClassName"
        optimistic-lock="true|false">

        <property ...../>
        <many-to-one .... />
        ........
</component>]]></programlisting>
                <calloutlist>
                    <callout arearefs="component1">
                        <para>
                            <literal>name</literal>: The name of the property.
                        </para>
                    </callout>
                    <callout arearefs="component2">
                        <para>
                            <literal>class</literal> (optional - defaults to the property type
                            determined by reflection): The name of the component (child) class.
                        </para>
                    </callout>
                    <callout arearefs="component3">
                        <para>
                            <literal>insert</literal>: Do the mapped columns appear in SQL
                            <literal>INSERT</literal>s?
                        </para>
                    </callout>
                    <callout arearefs="component4">
                        <para>
                            <literal>update</literal>: Do the mapped columns appear in SQL
                            <literal>UPDATE</literal>s?
                        </para>
                    </callout>
                    <callout arearefs="component5">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): The
                            strategy NHibernate should use for accessing the property value.
                        </para>
                    </callout>
                    <callout arearefs="component6">
                        <para>
                            <literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>):
                            Specifies that updates to this component do or do not require acquisition of the
                            optimistic lock. In other words, determines if a version increment should occur when
                            this property is dirty.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                The child <literal>&lt;property&gt;</literal> tags map properties of the
                child class to table columns.
            </para>

            <para>
                The <literal>&lt;component&gt;</literal> element allows a <literal>&lt;parent&gt;</literal>
                sub-element that maps a property of the component class as a reference back to the
                containing entity.
            </para>

            <para>
                The <literal>&lt;dynamic-component&gt;</literal> element allows an <literal>IDictionary</literal>
                or <literal>IDictionary&lt;string, object&gt;</literal>to be mapped as a component, where the property 
                names refer to keys of the dictionary.
            </para>
            
        </sect2>

        <sect2 id="mapping-declaration-properties">
          <title>properties</title>

          <para>
            The <literal>&lt;properties&gt;</literal> element allows the
            definition of a named, logical grouping of the properties of a class.
            The most important use of the construct is that it allows a combination
            of properties to be the target of a <literal>property-ref</literal>. It
            is also a convenient way to define a multi-column unique constraint. For
            example:
          </para>

          <programlistingco>
            <areaspec>
              <area coords="2 60" id="properties1" />
              <area coords="3 60" id="properties2" />
              <area coords="4 60" id="properties3" />
              <area coords="5 60" id="properties4" />
              <area coords="6 60" id="properties5" />
            </areaspec>

            <programlisting><![CDATA[<properties
      name="logicalName"
      insert="true|false"
      update="true|false"
      optimistic-lock="true|false"
      unique="true|false">

      <property .../>
      <many-to-one .../>
      ........
</properties>]]></programlisting>

            <calloutlist>
              <callout arearefs="properties1">
                <para>
                  <literal>name</literal>: the logical name of the grouping.
                  It is <emphasis>not</emphasis> an actual property name.
                </para>
              </callout>

              <callout arearefs="properties2">
                <para>
                  <literal>insert</literal>: do the mapped columns appear in
                  SQL <literal>INSERTs</literal>?
                </para>
              </callout>

              <callout arearefs="properties3">
                <para>
                  <literal>update</literal>: do the mapped columns appear in
                  SQL <literal>UPDATEs</literal>?
                </para>
              </callout>

              <callout arearefs="properties4">
                <para>
                  <literal>optimistic-lock</literal> (optional - defaults to
                  <literal>true</literal>): specifies that updates to these
                  properties either do or do not require acquisition of the
                  optimistic lock. It determines if a version increment should occur
                  when these properties are dirty.
                </para>
              </callout>

              <callout arearefs="properties5">
                <para>
                  <literal>unique</literal> (optional - defaults to
                  <literal>false</literal>): specifies that a unique constraint
                  exists upon all mapped columns of the component.
                </para>
              </callout>
            </calloutlist>
          </programlistingco>

          <para>
            For example, if we have the following
            <literal><![CDATA[<properties>]]></literal> mapping:
          </para>

          <programlisting role="XML"><![CDATA[<class name="Person">
      <id name="personNumber" />
      <properties name="name" unique="true" update="false">
          <property name="firstName" />
          <property name="lastName" />
          <property name="initial" />
      </properties>
</class>]]></programlisting>

          <para>
            You might have some legacy data association that refers to this
            unique key of the <literal>Person</literal> table, instead of to the
            primary key:
          </para>

          <programlisting role="XML"><![CDATA[<many-to-one name="owner" class="Person" property-ref="name">
        <column name="firstName" />
        <column name="lastName" />
        <column name="initial" />
</many-to-one>]]></programlisting>

          <para>
            The use of this outside the context of mapping legacy data is not
            recommended.
          </para>
        </sect2>

        <sect2 id="mapping-declaration-subclass">
            <title>subclass</title>

            <para>
                Finally, polymorphic persistence requires the declaration of each subclass of
                the root persistent class. For the (recommended) table-per-class-hierarchy
                mapping strategy, the <literal>&lt;subclass&gt;</literal> declaration is used.
            </para>
            
            <programlistingco>
                <areaspec>
                    <area id="subclass1" coords="2 55"/>
                    <area id="subclass2" coords="3 55"/>
                    <area id="subclass3" coords="4 55"/>
                    <area id="subclass4" coords="5 55"/>
                </areaspec>
                <programlisting><![CDATA[<subclass
        name="ClassName"
        discriminator-value="discriminator_value"
        proxy="ProxyInterface"
        lazy="true|false"
        dynamic-update="true|false"
        dynamic-insert="true|false">

        <property .... />
        <properties .... />
        .....
</subclass>]]></programlisting>
                <calloutlist>
                    <callout arearefs="subclass1">
                        <para>
                            <literal>name</literal>: The fully qualified .NET class name of the
                            subclass, including its assembly name.
                        </para>
                    </callout>
                    <callout arearefs="subclass2">
                        <para>
                            <literal>discriminator-value</literal> (optional - defaults to the class name): A
                            value that distinguishes individual subclasses.
                        </para>
                    </callout>
                    <callout arearefs="subclass3">
                        <para>
                            <literal>proxy</literal> (optional): Specifies a class or interface to use for
                            lazy initializing proxies.
                        </para>
                    </callout>
                    <callout arearefs="subclass4">
                        <para>
                            <literal>lazy</literal> (optional, defaults to <literal>true</literal>): Setting
                            <literal>lazy="false"</literal> disables the use of lazy fetching.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                Each subclass should declare its own persistent properties and subclasses.
                <literal>&lt;version&gt;</literal> and <literal>&lt;id&gt;</literal> properties
                are assumed to be inherited from the root class. Each subclass in a hierarchy must
                define a unique <literal>discriminator-value</literal>. If none is specified, the
                fully qualified .NET class name is used.
            </para>

            <para>
                For information about inheritance mappings, see <xref linkend="inheritance"/>.
            </para>
            
        </sect2>

         <sect2 id="mapping-declaration-joinedsubclass" revision="1">
            <title>joined-subclass</title>

            <para>
                Alternatively, a subclass that is persisted to its own table (table-per-subclass
                mapping strategy) is declared using a <literal>&lt;joined-subclass&gt;</literal>
                element.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="joinedsubclass1" coords="2 45"/>
                    <area id="joinedsubclass2" coords="3 45"/>
                    <area id="joinedsubclass3" coords="4 45"/>
                </areaspec>
                <programlisting><![CDATA[<joined-subclass
        name="ClassName"
        proxy="ProxyInterface"
        lazy="true|false"
        dynamic-update="true|false"
        dynamic-insert="true|false">

        <key .... >

        <property .... />
        <properties .... />
        .....
</joined-subclass>]]></programlisting>
                <calloutlist>
                    <callout arearefs="joinedsubclass1">
                        <para>
                            <literal>name</literal>: The fully qualified class name of the subclass.
                        </para>
                    </callout>
                    <callout arearefs="joinedsubclass2">
                        <para>
                            <literal>proxy</literal> (optional): Specifies a class or interface to use
                            for lazy initializing proxies.
                        </para>
                    </callout>
                    <callout arearefs="joinedsubclass3">
                        <para>
                            <literal>lazy</literal> (optional): Setting <literal>lazy="true"</literal> is a shortcut
                            equivalent to specifying the name of the class itself as the <literal>proxy</literal>
                            interface.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                No discriminator column is required for this mapping strategy. Each subclass must,
                however, declare a table column holding the object identifier using the
                <literal>&lt;key&gt;</literal> element. The mapping at the start of the chapter
                would be re-written as:
            </para>
            
        <programlisting><![CDATA[<?xml version="1.0"?>
<hibernate-mapping xmlns="urn:nhibernate-mapping-2.2" assembly="Eg"
    namespace="Eg">

        <class name="Cat" table="CATS">
                <id name="Id" column="uid" type="Int64">
                        <generator class="hilo"/>
                </id>
                <property name="BirthDate" type="Date"/>
                <property name="Color" not-null="true"/>
                <property name="Sex" not-null="true"/>
                <property name="Weight"/>
                <many-to-one name="Mate"/>
                <set name="Kittens">
                        <key column="MOTHER"/>
                        <one-to-many class="Cat"/>
                </set>
                <joined-subclass name="DomesticCat" table="DOMESTIC_CATS">
                    <key column="CAT"/>
                        <property name="Name" type="String"/>
                </joined-subclass>
        </class>

        <class name="Dog">
                <!-- mapping for Dog could go here -->
        </class>

</hibernate-mapping>]]></programlisting>

            <para>
                For information about inheritance mappings, see <xref linkend="inheritance"/>.
            </para>

        </sect2>

        <sect2 id="mapping-declaration-unionsubclass" revision="2">
           <title>union-subclass</title>

           <para>
               A third option is to map only the concrete classes of an inheritance hierarchy
               to tables, (the table-per-concrete-class strategy) where each table defines all
               persistent state of the class, including inherited state. In NHibernate, it is
               not absolutely necessary to explicitly map such inheritance hierarchies. You
               can simply map each class with a separate <literal>&lt;class&gt;</literal>
               declaration. However, if you wish use polymorphic associations (e.g. an association
               to the superclass of your hierarchy), you need to
               use the <literal>&lt;union-subclass&gt;</literal> mapping.
           </para>

            <programlistingco>
                <areaspec>
                    <area id="unionsubclass1" coords="2 45"/>
                    <area id="unionsubclass2" coords="3 45"/>
                    <area id="unionsubclass3" coords="4 45"/>
                    <area id="unionsubclass4" coords="5 45"/>
                </areaspec>
                <programlisting><![CDATA[<union-subclass
        name="ClassName"
        table="tablename"
        proxy="ProxyInterface"
        lazy="true|false"
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        abstract="true|false"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name">

        <property .... />
        <properties .... />
        .....
</union-subclass>]]></programlisting>
                <calloutlist>
                    <callout arearefs="unionsubclass1">
                        <para>
                            <literal>name</literal>: The fully qualified class name of the subclass.
                        </para>
                    </callout>
                    <callout arearefs="unionsubclass2">
                        <para>
                            <literal>table</literal>: The name of the subclass table.
                        </para>
                    </callout>
                    <callout arearefs="unionsubclass3">
                        <para>
                            <literal>proxy</literal> (optional): Specifies a class or interface to use
                            for lazy initializing proxies.
                        </para>
                    </callout>
                    <callout arearefs="unionsubclass4">
                        <para>
                            <literal>lazy</literal> (optional, defaults to <literal>true</literal>): Setting
                            <literal>lazy="false"</literal> disables the use of lazy fetching.
                         </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                No discriminator column or key column is required for this mapping strategy.
            </para>

            <para>
                For information about inheritance mappings, see <xref linkend="inheritance"/>.
            </para>

        </sect2>

        <sect2 id="mapping-declaration-join" revision="1">
            <title>join</title>

            <para>
                Using the <literal>&lt;join&gt;</literal> element, it is possible to map
                properties of one class to several tables, when there's a 1-to-1 relationship between the tables.
            </para>

            <programlistingco>
                <areaspec>
                    <area id="join1" coords="2 50"/>
                    <area id="join2" coords="3 50"/>
                    <area id="join3" coords="4 50"/>
                    <area id="join4" coords="5 50"/>
                    <area id="join5" coords="6 50"/>
                </areaspec>
                <programlisting><![CDATA[<join
        table="tablename"
        schema="owner"
        fetch="join|select"
        inverse="true|false"
        optional="true|false">

        <key ... />

        <property ... />
        ...
</join>]]></programlisting>

                <calloutlist>
                    <callout arearefs="join1">
                        <para>
                            <literal>table</literal>: The name of the joined table.
                        </para>
                    </callout>
                    <callout arearefs="join2">
                        <para>
                            <literal>schema</literal> (optional): Override the schema name specified by
                            the root <literal>&lt;hibernate-mapping&gt;</literal> element.
                        </para>
                    </callout>

                    <callout arearefs="join3">
                        <para>
                            <literal>fetch</literal> (optional - defaults to <literal>join</literal>):
                            If set to <literal>join</literal>, the default, NHibernate will use an inner join
                            to retrieve a <literal>&lt;join&gt;</literal> defined by a class or its superclasses
                            and an outer join for a <literal>&lt;join&gt;</literal> defined by a subclass.
                            If set to <literal>select</literal> then NHibernate will use a sequential select for
                            a <literal>&lt;join&gt;</literal> defined on a subclass, which will be issued only
                            if a row turns out to represent an instance of the subclass. Inner joins will still
                            be used to retrieve a <literal>&lt;join&gt;</literal> defined by the class and its
                            superclasses.
                        </para>
                    </callout>
                    <callout arearefs="join4">
                        <para>
                            <literal>inverse</literal> (optional - defaults to <literal>false</literal>):
                            If enabled, NHibernate will not try to insert or update the properties defined
                            by this join.
                        </para>
                    </callout>
                    <callout arearefs="join5">
                        <para>
                            <literal>optional</literal> (optional - defaults to <literal>false</literal>):
                            If enabled, NHibernate will insert a row only if the properties defined by this
                            join are non-null and will always use an outer join to retrieve the properties.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

            <para>
                For example, the address information for a person can be mapped to a separate
                table (while preserving value type semantics for all properties):
            </para>

            <programlisting><![CDATA[<class name="Person"
    table="PERSON">

    <id name="id" column="PERSON_ID">...</id>

    <join table="ADDRESS">
        <key column="ADDRESS_ID"/>
        <property name="address"/>
        <property name="zip"/>
        <property name="country"/>
    </join>
    ...]]></programlisting>

            <para>
                This feature is often only useful for legacy data models, we recommend fewer
                tables than classes and a fine-grained domain model. However, it is useful
                for switching between inheritance mapping strategies in a single hierarchy, as
                explained later.
            </para>

        </sect2>

        <sect2 id="mapping-declaration-collections">
            <title>map, set, list, bag</title>

            <para>
                Collections are discussed later.
            </para>
        </sect2>

        <sect2 id="mapping-declaration-import" revision="1">
            <title>import</title>

            <para>
                Suppose your application has two persistent classes with the same name, and you don't want to
                specify the fully qualified name in NHibernate queries. Classes may be "imported" 
                explicitly, rather than relying upon <literal>auto-import="true"</literal>. You may even import 
                classes and interfaces that are not explicitly mapped.
            </para>
            
            <programlisting><![CDATA[<import class="System.Object" rename="Universe"/>]]></programlisting>
            
            <programlistingco>
                <areaspec>
                    <area id="import1" coords="2 40"/>
                    <area id="import2" coords="3 40"/>
                </areaspec>
                <programlisting><![CDATA[<import
        class="ClassName"
        rename="ShortName"
/>]]></programlisting>
                <calloutlist>
                    <callout arearefs="import1">
                        <para>
                            <literal>class</literal>: The fully qualified class name of any .NET class, including
                            its assembly name.
                        </para>
                    </callout>
                    <callout arearefs="import2">
                        <para>
                            <literal>rename</literal> (optional - defaults to the unqualified class name):
                            A name that may be used in the query language.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            
        </sect2>
    </sect1>

    <sect1 id="mapping-types">
        <title>NHibernate Types</title>

        <sect2 id="mapping-types-entitiesvalues" revision="1">
            <title>Entities and values</title>

            <para>
                To understand the behaviour of various .NET language-level objects with respect
                to the persistence service, we need to classify them into two groups:
            </para>

            <para>
                An <emphasis>entity</emphasis> exists independently of any other objects holding
                references to the entity. Contrast this with the usual .NET model where an
                unreferenced object is garbage collected. Entities must be explicitly saved and
                deleted (except that saves and deletions may be <emphasis>cascaded</emphasis>
                from a parent entity to its children). This is different from the ODMG model of
                object persistence by reachability - and corresponds more closely to how
                application objects are usually used in large systems. Entities support
                circular and shared references. They may also be versioned.
            </para>

            <para>
                An entity's persistent state consists of references to other entities and
                instances of <emphasis>value</emphasis> types. Values are primitives,
                collections, components and certain immutable objects. Unlike entities, values
                (in particular collections and components) <emphasis>are</emphasis>
                persisted and deleted by reachability. Since value objects (and primitives) are
                persisted and deleted along with their containing entity they may not be
                independently versioned. Values have no independent identity, so they cannot be
                shared by two entities or collections.
            </para>

            <para>
                All NHibernate types except collections support null semantics if the .NET type
                is nullable (i.e. not derived from <literal>System.ValueType</literal>).
            </para>

            <para>
                Up until now, we've been using the term "persistent class" to refer to
                entities. We will continue to do that. Strictly speaking, however, not all
                user-defined classes with persistent state are entities. A
                <emphasis>component</emphasis> is a user defined class with value semantics.
            </para>
        </sect2>

        <sect2 id="mapping-types-basictypes">
            <title>Basic value types</title>

            <para>
                The <emphasis>basic types</emphasis> may be roughly categorized into three groups - <literal>System.ValueType</literal>
                types, <literal>System.Object</literal> types, and <literal>System.Object</literal> types for large objects.  Just like
                Columns for System.ValueType types can handle <literal>null</literal> values only if the entity property is properly
                typed with a <literal>Nullable&lt;T&gt;</literal>. Otherwise <literal>null</literal> will be replaced by the default
                value for the type when reading, and then will be overwritten by it when persisting the entity, potentially leading to
                phantom updates.
            </para>
            <table>
                <title>System.ValueType Mapping Types</title>
                <tgroup cols="4">
                    <thead>
                        <row>
                            <entry>NHibernate Type</entry>
                            <entry>.NET Type</entry>
                            <entry>Database Type</entry>
                            <entry>Remarks</entry>
                        </row>
                    </thead>	
                    <tbody>
                        <row>
                            <entry><literal>AnsiChar</literal></entry>
                            <entry><literal>System.Char</literal></entry>
                            <entry><literal>DbType.AnsiStringFixedLength - 1 char</literal></entry>
                            <entry><literal>type="AnsiChar"</literal> must be specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Boolean</literal></entry>
                            <entry><literal>System.Boolean</literal></entry>
                            <entry><literal>DbType.Boolean</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Byte</literal></entry>
                            <entry><literal>System.Byte</literal></entry>
                            <entry><literal>DbType.Byte</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Char</literal></entry>
                            <entry><literal>System.Char</literal></entry>
                            <entry><literal>DbType.StringFixedLength - 1 char</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Currency</literal></entry>
                            <entry><literal>System.Decimal</literal></entry>
                            <entry><literal>DbType.Currency</literal></entry>
                            <entry><literal>type="Currency"</literal> must be specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Date</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry><literal>DbType.Date</literal></entry>
                            <entry><literal>type="Date"</literal> must be specified.</entry>
                        </row>
                        <row>
                            <entry><literal>DateTime</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry>
                                <literal>DbType.DateTime</literal> / <literal>DbType.DateTime2</literal><co id="basic_mapping.datetime-co" linkends="basic_mapping.datetime"/>
                            </entry>
                            <entry>
                                Default when no <literal>type</literal> attribute specified. Does no
                                longer ignore fractional seconds since NHibernate v5.0.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>DateTimeNoMs</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry>
                                <literal>DbType.DateTime</literal> / <literal>DbType.DateTime2</literal><coref linkend="basic_mapping.datetime-co" />
                            </entry>
                            <entry>
                                <literal>type="DateTimeNoMs"</literal> must be specified. Ignores fractional seconds.
                                Available since NHibernate v5.0.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>DateTime2</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry><literal>DbType.DateTime2</literal></entry>
                            <entry>
                                <literal>type="DateTime2"</literal> must be specified. Obsolete since
                                NHibernate v5.0, use <literal>DateTime</literal> instead.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>DateTimeOffset</literal></entry>
                            <entry><literal>System.DateTimeOffset</literal></entry>
                            <entry><literal>DbType.DateTimeOffset</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>DbTimestamp</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry>
                                <literal>DbType.DateTime</literal> / <literal>DbType.DateTime2</literal><coref linkend="basic_mapping.datetime-co" />
                            </entry>
                            <entry>
                                <literal>type="DbTimestamp"</literal> must be specified.  When used as a
                                <literal>version</literal> field, uses the database's current time retrieved
                                in dedicated queries, rather than the client's current time.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>Decimal</literal></entry>
                            <entry><literal>System.Decimal</literal></entry>
                            <entry><literal>DbType.Decimal</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Double</literal></entry>
                            <entry><literal>System.Double</literal></entry>
                            <entry><literal>DbType.Double</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Guid</literal></entry>
                            <entry><literal>System.Guid</literal></entry>
                            <entry><literal>DbType.Guid</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Int16</literal></entry>
                            <entry><literal>System.Int16</literal></entry>
                            <entry><literal>DbType.Int16</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Int32</literal></entry>
                            <entry><literal>System.Int32</literal></entry>
                            <entry><literal>DbType.Int32</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Int64</literal></entry>
                            <entry><literal>System.Int64</literal></entry>
                            <entry><literal>DbType.Int64</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>LocalDateTime</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry>
                                <literal>DbType.DateTime</literal> / <literal>DbType.DateTime2</literal><coref linkend="basic_mapping.datetime-co" />
                            </entry>
                            <entry>
                                <literal>type="LocalDateTime"</literal> must be specified. Ensures the
                                <literal>DateTimeKind</literal> is set to <literal>DateTimeKind.Local</literal>.
                                Throws if set with a date having another kind.
                                Does no longer ignore fractional seconds since NHibernate v5.0.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>LocalDateTimeNoMs</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry>
                                <literal>DbType.DateTime</literal> / <literal>DbType.DateTime2</literal><coref linkend="basic_mapping.datetime-co" />
                            </entry>
                            <entry>
                                <literal>type="LocalDateTimeNoMs"</literal> must be specified. Similar to
                                <literal>LocalDateTime</literal> but ignores fractional seconds.
                                Available since NHibernate v5.0.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>PersistentEnum</literal></entry>
                            <entry>A <literal>System.Enum</literal></entry>
                            <entry>The <literal>DbType</literal> for the underlying value.</entry>
                            <entry>Do not specify <literal>type="PersistentEnum"</literal> in the mapping.  Instead 
                            specify the Assembly Qualified Name of the Enum or let NHibernate use Reflection to "guess" the Type.
                            The UnderlyingType of the Enum is used to determine the correct <literal>DbType</literal>.</entry>
                        </row>
                        <row>
                            <entry><literal>SByte</literal></entry>
                            <entry><literal>System.SByte</literal></entry>
                            <entry><literal>DbType.SByte</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Single</literal></entry>
                            <entry><literal>System.Single</literal></entry>
                            <entry><literal>DbType.Single</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Ticks</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry><literal>DbType.Int64</literal></entry>
                            <entry><literal>type="Ticks"</literal> must be specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Time</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry><literal>DbType.Time</literal></entry>
                            <entry><literal>type="Time"</literal> must be specified.</entry>
                        </row>
                        <row>
                            <entry><literal>TimeAsTimeSpan</literal></entry>
                            <entry><literal>System.TimeSpan</literal></entry>
                            <entry><literal>DbType.Time</literal></entry>
                            <entry><literal>type="TimeAsTimeSpan"</literal> must be specified.</entry>
                        </row>
                        <row>
                            <entry><literal>TimeSpan</literal></entry>
                            <entry><literal>System.TimeSpan</literal></entry>
                            <entry><literal>DbType.Int64</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Timestamp</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry>
                                <literal>DbType.DateTime</literal> / <literal>DbType.DateTime2</literal><coref linkend="basic_mapping.datetime-co" />
                            </entry>
                            <entry>
                                Obsolete, its <literal>Timestamp</literal> alias will be remapped to
                                <literal>DateTime</literal> in a future version.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>TrueFalse</literal></entry>
                            <entry><literal>System.Boolean</literal></entry>
                            <entry><literal>DbType.AnsiStringFixedLength</literal> - 1 char either 'T' or 'F'</entry>
                            <entry><literal>type="TrueFalse"</literal> must be specified.</entry>
                        </row>
                        <row>
                            <entry><literal>UInt16</literal></entry>
                            <entry><literal>System.UInt16</literal></entry>
                            <entry><literal>DbType.UInt16</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>UInt32</literal></entry>
                            <entry><literal>System.UInt32</literal></entry>
                            <entry><literal>DbType.UInt32</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>UInt64</literal></entry>
                            <entry><literal>System.UInt64</literal></entry>
                            <entry><literal>DbType.UInt64</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>UtcDateTime</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry>
                                <literal>DbType.DateTime</literal> / <literal>DbType.DateTime2</literal><coref linkend="basic_mapping.datetime-co" />
                            </entry>
                            <entry>
                                Ensures the <literal>DateTimeKind</literal> is set to <literal>DateTimeKind.Utc</literal>.
                                Throws if set with a date having another kind.
                                Does no longer ignore fractional seconds since NHibernate v5.0.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>UtcDateTimeNoMs</literal></entry>
                            <entry><literal>System.DateTime</literal></entry>
                            <entry>
                                <literal>DbType.DateTime</literal> / <literal>DbType.DateTime2</literal><coref linkend="basic_mapping.datetime-co" />
                            </entry>
                            <entry>
                                <literal>type="UtcDateTimeNoMs"</literal> must be specified. Similar to
                                <literal>UtcDateTime</literal> but ignores fractional seconds.
                                Available since NHibernate v5.0.
                            </entry>
                        </row>
                        <row>
                            <entry><literal>YesNo</literal></entry>
                            <entry><literal>System.Boolean</literal></entry>
                            <entry><literal>DbType.AnsiStringFixedLength</literal> - 1 char either 'Y' or 'N'</entry>
                            <entry><literal>type="YesNo"</literal> must be specified.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

            <calloutlist>
              <callout arearefs="basic_mapping.datetime-co" id="basic_mapping.datetime">
                <para>
                  Since NHibernate v5.0 and if the dialect supports it, <literal>DbType.DateTime2</literal>
                  is used instead of <literal>DbType.DateTime</literal>. This may be disabled by setting
                  <literal>sql_types.keep_datetime</literal> to <literal>true</literal>.
                </para>
              </callout>
            </calloutlist>

            <table>
                <title>System.Object Mapping Types</title>
                <tgroup cols="4">
                    <thead>
                        <row>
                            <entry>NHibernate Type</entry>
                            <entry>.NET Type</entry>
                            <entry>Database Type</entry>
                            <entry>Remarks</entry>	
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><literal>AnsiString</literal></entry>
                            <entry><literal>System.String</literal></entry>
                            <entry><literal>DbType.AnsiString</literal></entry>
                            <entry><literal>type="AnsiString"</literal> must be specified.</entry>
                        </row>
                        <row>
                            <entry><literal>CultureInfo</literal></entry>
                            <entry><literal>System.Globalization.CultureInfo</literal></entry>
                            <entry><literal>DbType.String</literal> - 5 chars for culture</entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Binary</literal></entry>
                            <entry><literal>System.Byte[]</literal></entry>
                            <entry><literal>DbType.Binary</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Type</literal></entry>
                            <entry><literal>System.Type</literal></entry>
                            <entry><literal>DbType.String</literal> holding Assembly Qualified Name.</entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>String</literal></entry>
                            <entry><literal>System.String</literal></entry>
                            <entry><literal>DbType.String</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                        <row>
                            <entry><literal>Uri</literal></entry>
                            <entry><literal>System.Uri</literal></entry>
                            <entry><literal>DbType.String</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

            <table>
                <title>Large Object Mapping Types</title>
                <tgroup cols="4">
                    <thead>
                        <row>
                            <entry>NHibernate Type</entry>
                            <entry>.NET Type</entry>
                            <entry>Database Type</entry>
                            <entry>Remarks</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><literal>StringClob</literal></entry>
                            <entry><literal>System.String</literal></entry>
                            <entry><literal>DbType.String</literal></entry>
                            <entry><literal>type="StringClob"</literal> must be specified.  Entire field is read into memory.</entry>
                        </row>
                        <row>
                            <entry><literal>BinaryBlob</literal></entry>
                            <entry><literal>System.Byte[]</literal></entry>
                            <entry><literal>DbType.Binary</literal></entry>
                            <entry><literal>type="BinaryBlob"</literal> must be specified.  Entire field is read into memory.</entry>
                        </row>
                        <row>
                            <entry><literal>Serializable</literal></entry>
                            <entry>Any <literal>System.Object</literal> that is marked with SerializableAttribute.</entry>
                            <entry><literal>DbType.Binary</literal></entry>
                            <entry><literal>type="Serializable"</literal> should be specified.  This is the fallback type
                            if no NHibernate Type can be found for the Property.</entry>
                        </row>
                        <row>
                            <entry><literal>XDoc</literal></entry>
                            <entry><literal>System.Xml.Linq.XDocument</literal></entry>
                            <entry><literal>DbType.Xml</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.  Entire field is read into memory.</entry>
                        </row>
                        <row>
                            <entry><literal>XmlDoc</literal></entry>
                            <entry><literal>System.Xml.XmlDocument</literal></entry>
                            <entry><literal>DbType.Xml</literal></entry>
                            <entry>Default when no <literal>type</literal> attribute specified.  Entire field is read into memory.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

            <para>
                NHibernate supports some additional type names for compatibility with Java's Hibernate (useful for those coming over from
                Hibernate or using some of the tools to generate <literal>hbm.xml</literal> files).
                A <literal>type="integer"</literal> or <literal>type="int"</literal> will map to an <literal>Int32</literal>
                NHibernate type, <literal>type="short"</literal> to an <literal>Int16</literal> NHibernateType.
                To see all of the conversions you can view the source of static constructor of the class
                <literal>NHibernate.Type.TypeFactory</literal>.
            </para>

            <para>
                Default NHibernate types used when no <literal>type</literal> attribute is specified can be overridden by using
                the <literal>NHibernate.Type.TypeFactory.RegisterType</literal> static method before configuring and building
                session factories.
            </para>

        </sect2>

        <sect2 id="mapping-types-custom">
            <title>Custom value types</title>

            <para>
                It is relatively easy for developers to create their own value types. For example,
                you might want to persist properties of type <literal>Int64</literal>
                to <literal>VARCHAR</literal> columns. NHibernate does not provide a built-in type
                for this. But custom types are not limited to mapping a property (or collection element)
                to a single table column. So, for example, you might have a property
                <literal>Name { get; set; }</literal> of type
                <literal>String</literal> that is persisted to the columns
                <literal>FIRST_NAME</literal>, <literal>INITIAL</literal>, <literal>SURNAME</literal>.
            </para>
            
            <para>
                To implement a custom type, implement either <literal>NHibernate.UserTypes.IUserType</literal>
                or <literal>NHibernate.UserTypes.ICompositeUserType</literal> and declare properties using the
                fully qualified name of the type. Check out
                <literal>NHibernate.DomainModel.DoubleStringType</literal> to see the kind of things that
                are possible.
            </para>

            <programlisting><![CDATA[<property name="TwoStrings"
    type="NHibernate.DomainModel.DoubleStringType, NHibernate.DomainModel">
  <column name="first_string"/>
  <column name="second_string"/>
</property>]]></programlisting>

            <para>
                Notice the use of <literal>&lt;column&gt;</literal> tags to map a property to multiple
                columns.
            </para>

            <para>
                The <literal>ICompositeUserType</literal>, <literal>IEnhancedUserType</literal>,
                <literal>INullableUserType</literal>, <literal>IUserCollectionType</literal>,
                and <literal>IUserVersionType</literal> interfaces provide support for more specialized
                uses.
            </para>
            
            <para>
                You may even supply parameters to an <literal>IUserType</literal> in the mapping file. To
                do this, your <literal>IUserType</literal> must implement the
                <literal>NHibernate.UserTypes.IParameterizedType</literal> interface. To supply parameters
                to your custom type, you can use the <literal>&lt;type&gt;</literal> element in your mapping
                files.
            </para>
            
            <programlisting><![CDATA[<property name="priority">
    <type name="MyCompany.UserTypes.DefaultValueIntegerType">
        <param name="default">0</param>
    </type>
</property>]]></programlisting>

            <para>
                The <literal>IUserType</literal> can now retrieve the value for the parameter named 
                <literal>default</literal> from the <literal>IDictionary</literal> object passed to it.
            </para>
            <para>
                If you use a certain <literal>UserType</literal> very often, it may be useful to define a
                shorter name for it. You can do this using the <literal>&lt;typedef&gt;</literal> element.
                Typedefs assign a name to a custom type, and may also contain a list of default
                parameter values if the type is parameterized.
            </para>

            <programlisting><![CDATA[<typedef class="MyCompany.UserTypes.DefaultValueIntegerType" name="default_zero">
    <param name="default">0</param>
</typedef>]]></programlisting>

            <programlisting><![CDATA[<property name="priority" type="default_zero"/>]]></programlisting>
            
            <para>
                It is also possible to override the parameters supplied in a typedef on a case-by-case basis
                by using type parameters on the property mapping.
            </para>

            <para>
                Even though NHibernate's rich range of built-in types and support for components means you
                will very rarely <emphasis>need</emphasis> to use a custom type, it is nevertheless
                considered good form to use custom types for (non-entity) classes that occur frequently
                in your application. For example, a <literal>MonetaryAmount</literal> class is a good
                candidate for an <literal>ICompositeUserType</literal>, even though it could easily be mapped
                as a component. One motivation for this is abstraction. With a custom type, your mapping
                documents would be future-proofed against possible changes in your way of representing
                monetary values.
            </para>

        </sect2>

        <sect2 id="mapping-types-anymapping">
            <title>Any type mappings</title>

            <para>
                There is one further type of property mapping. The <literal>&lt;any&gt;</literal> mapping element
                defines a polymorphic association to classes from multiple tables. This type of mapping always
                requires more than one column. The first column holds the type of the associated entity.
                The remaining columns hold the identifier. It is impossible to specify a foreign key constraint
                for this kind of association, so this is most certainly not meant as the usual way of mapping
                (polymorphic) associations. You should use this only in very special cases (eg. audit logs,
                user session data, etc).
            </para>

            <programlisting><![CDATA[<any name="AnyEntity" id-type="Int64" meta-type="Eg.Custom.Class2TablenameType">
    <column name="table_name"/>
    <column name="id"/>
</any>]]></programlisting>

            <para>
                 The <literal>meta-type</literal> attribute lets the application specify a custom type that
                 maps database column values to persistent classes which have identifier properties of the
                 type specified by <literal>id-type</literal>. If the meta-type returns instances of
                 <literal>System.Type</literal>, nothing else is required. On the other hand, if it is
                 a basic type like <literal>String</literal> or <literal>Char</literal>, you must
                 specify the mapping from values to classes.
            </para>

            <programlisting><![CDATA[<any name="AnyEntity" id-type="Int64" meta-type="String">
    <meta-value value="TBL_ANIMAL" class="Animal"/>
    <meta-value value="TBL_HUMAN" class="Human"/>
    <meta-value value="TBL_ALIEN" class="Alien"/>
    <column name="table_name"/>
    <column name="id"/>
</any>]]></programlisting>

            <programlistingco>
                <areaspec>
                    <area id="any1" coords="2 60"/>
                    <area id="any2" coords="3 60"/>
                    <area id="any3" coords="4 60"/>
                    <area id="any4" coords="5 60"/>
                    <area id="any5" coords="6 60"/>
                    <area id="any6" coords="7 60"/>
                </areaspec>
                <programlisting><![CDATA[<any
        name="PropertyName"
        id-type="idtypename"
        meta-type="metatypename"
        cascade="none|all|save-update"
        access="field|property|nosetter|ClassName"
        optimistic-lock="true|false"
>
        <meta-value ... />
        <meta-value ... />
        .....
        <column .... />
        <column .... />
        .....
</any>]]></programlisting>
                <calloutlist>
                    <callout arearefs="any1">
                        <para>
                            <literal>name</literal>: the property name.
                        </para>
                    </callout>
                    <callout arearefs="any2">
                        <para>
                            <literal>id-type</literal>: the identifier type.
                        </para>
                    </callout>
                    <callout arearefs="any3">
                        <para>
                            <literal>meta-type</literal> (optional - defaults to <literal>Type</literal>):
                            a type that maps <literal>System.Type</literal> to a single database column
                            or, alternatively, a type that is allowed for a discriminator mapping.
                        </para>
                    </callout>
                    <callout arearefs="any4">
                        <para>
                            <literal>cascade</literal> (optional - defaults to <literal>none</literal>):
                            the cascade style.
                        </para>
                    </callout>
                    <callout arearefs="any5">
                        <para>
                            <literal>access</literal> (optional - defaults to <literal>property</literal>): The
                            strategy NHibernate should use for accessing the property value.
                        </para>
                    </callout>
                    <callout arearefs="any6">
                        <para>
                            <literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>):
                            Specifies that updates to this property do or do not require acquisition of the
                            optimistic lock. In other words, define if a version increment should occur if this
                            property is dirty.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>

        </sect2>

    </sect1>

    <sect1 id="mapping-quotedidentifiers">
        <title>SQL quoted identifiers</title>
        <para>
            You may force NHibernate to quote an identifier in the generated SQL by enclosing the table or
            column name in back-ticks in the mapping document. NHibernate will use the correct quotation
            style for the SQL <literal>Dialect</literal> (usually double quotes, but brackets for SQL
            Server and back-ticks for MySQL).
        </para>

        <programlisting><![CDATA[<class name="LineItem" table="`Line Item`">
    <id name="Id" column="`Item Id`"/><generator class="assigned"/></id>
    <property name="ItemNumber" column="`Item #`"/>
    ...
</class>]]></programlisting>

        <para>
            Quoting column identifiers is required if a table contains two columns differing only by case.
            Ensure you use consistent casing when quoting identifiers.
        </para>

    </sect1>

   <sect1 id="mapping-modularfiles">
       <title>Modular mapping files</title>
       <para>
            It is possible to define <literal>subclass</literal> and <literal>joined-subclass</literal>
            mappings in separate mapping documents, directly beneath <literal>hibernate-mapping</literal>.
            This allows you to extend a class hierarchy just by adding a new mapping file. You must
            specify an <literal>extends</literal> attribute in the subclass mapping, naming a previously
            mapped superclass. Use of this feature makes the ordering of the mapping documents important!
        </para>

        <programlisting><![CDATA[
<hibernate-mapping>
        <subclass name="Eg.Subclass.DomesticCat, Eg"
            extends="Eg.Cat, Eg" discriminator-value="D">
             <property name="name" type="string"/>
        </subclass>
</hibernate-mapping>]]></programlisting>

    </sect1>

    <sect1 id="mapping-generated">
        <title>Generated Properties</title>
        <para>
            Generated properties are properties which have their values generated by the
            database.  Typically, NHibernate applications needed to <literal>Refresh</literal>
            objects which contain any properties for which the database was generating values.
            Marking properties as generated, however, lets the application delegate this
            responsibility to NHibernate.  Essentially, whenever NHibernate issues an SQL INSERT
            or UPDATE for an entity which has defined generated properties, it immediately
            issues a select afterwards to retrieve the generated values.
        </para>
        <para>
            Properties marked as generated must additionally be non-insertable and non-updatable.
            Only <xref linkend="mapping-declaration-version">versions</xref>,
            <xref linkend="mapping-declaration-timestamp">timestamps</xref>, and
            <xref linkend="mapping-declaration-property">simple properties</xref> can be marked as
            generated.
        </para>
        <para>
            <literal>never</literal> (the default) - means that the given property value
            is not generated within the database.
        </para>
        <para>
            <literal>insert</literal> - states that the given property value is generated on
            insert, but is not regenerated on subsequent updates.  Things like created-date would
            fall into this category.  Note that even though
            <xref linkend="mapping-declaration-version">version</xref> and
            <xref linkend="mapping-declaration-timestamp">timestamp</xref> properties can
            be marked as generated, this option is not available there...
        </para>
        <para>
            <literal>always</literal> - states that the property value is generated both
            on insert and on update.
        </para>
    </sect1>

    <sect1 id="mapping-database-object">
        <title>Auxiliary Database Objects</title>
        <para>
            Allows CREATE and DROP of arbitrary database objects, in conjunction with
            NHibernate's schema evolution tools, to provide the ability to fully define
            a user schema within the NHibernate mapping files.  Although designed specifically
            for creating and dropping things like triggers or stored procedures, really any
            SQL command that can be run via a <literal>DbCommand.ExecuteNonQuery()</literal>
            method is valid here (ALTERs, INSERTS, etc).  There are essentially two modes for
            defining auxiliary database objects.
        </para>
        <para>
            The first mode is to explicitly list the CREATE and DROP commands out in the mapping
            file:
        </para>
        <programlisting><![CDATA[<nhibernate-mapping>
    ...
    <database-object>
        <create>CREATE TRIGGER my_trigger ...</create>
        <drop>DROP TRIGGER my_trigger</drop>
    </database-object>
</nhibernate-mapping>]]></programlisting>
        <para>
            The second mode is to supply a custom class which knows how to construct the
            CREATE and DROP commands.  This custom class must implement the
            <literal>NHibernate.Mapping.IAuxiliaryDatabaseObject</literal> interface.
        </para>
        <programlisting><![CDATA[<hibernate-mapping>
    ...
    <database-object>
        <definition class="MyTriggerDefinition, MyAssembly"/>
    </database-object>
</hibernate-mapping>]]></programlisting>
        <para>
            You may also specify parameters to be passed to the database object:
        </para>
        <programlisting><![CDATA[<hibernate-mapping>
    ...
    <database-object>
        <definition class="MyTriggerDefinition, MyAssembly">
            <param name="parameterName">parameterValue</param>
        </definition>
    </database-object>
</hibernate-mapping>]]></programlisting>
        <para>
            NHibernate will call <literal>IAuxiliaryDatabaseObject.SetParameterValues</literal>
            passing it a dictionary of parameter names and values.
        </para>
        <para>
            Additionally, these database objects can be optionally scoped such that they only
            apply when certain dialects are used.
        </para>
        <programlisting><![CDATA[<hibernate-mapping>
    ...
    <database-object>
        <definition class="MyTriggerDefinition"/>
        <dialect-scope name="NHibernate.Dialect.Oracle9iDialect"/>
        <dialect-scope name="NHibernate.Dialect.Oracle8iDialect"/>
    </database-object>
</hibernate-mapping>]]></programlisting>
    </sect1>

</chapter>
