//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using NHibernate.Type;
using NUnit.Framework;

namespace NHibernate.Test.TypesTest
{
	using System.Threading.Tasks;
	using System.Threading;
	/// <summary>
	/// Test fixture for type <see cref="TimestampUtcType"/>.
	/// </summary>
	[TestFixture]
	public class TimestampUtcTypeFixtureAsync : TypeFixtureBase
	{
		readonly TimestampUtcType _type = NHibernateUtil.TimestampUtc;
		readonly DateTime _utc = new DateTime(1976, 11, 30, 10, 0, 0, 300, DateTimeKind.Utc);
		readonly DateTime _local = new DateTime(1976, 11, 30, 10, 0, 0, 300, DateTimeKind.Local);
		readonly DateTime _unspecified = new DateTime(1976, 11, 30, 10, 0, 0, 300, DateTimeKind.Unspecified);

		/// <summary>
		/// 1976-11-30T10:00:00.3000000
		/// </summary>
		const long DateInTicks = 623537928003000000;
		
		protected override string TypeName => "TimestampUtc";

		[Test]
		public async Task NextAsync()
		{
			var current = DateTime.Parse("2004-01-01");
			var next = (DateTime)await (_type.NextAsync(current, null, CancellationToken.None));

			Assert.AreEqual(DateTimeKind.Utc, next.Kind, "Kind is not Utc");
			Assert.IsTrue(next > current, "next should be greater than current (could be equal depending on how quickly this occurs)");
		}

		/// <summary>
		/// Perform a 'seed' and check if the result is a datetime with kind set to Utc.
		/// </summary>
		[Test]
		public async Task SeedAsync()
		{
			var type = NHibernateUtil.TimestampUtc;
			Assert.IsTrue(await (type.SeedAsync(null, CancellationToken.None)) is DateTime, "Seed should be DateTime");

			var value = (DateTime)await (type.SeedAsync(null, CancellationToken.None));
			Assert.AreEqual(DateTimeKind.Utc, value.Kind, "Kind should be Utc");
		}

		/// <summary>
		/// Perform a basis write with a DateTime value where Kind is Local which should fail.
		/// </summary>
		[Test]
		[TestCase(DateTimeKind.Unspecified)]
		[TestCase(DateTimeKind.Local)]
		public async Task LocalReadWrite_FailAsync(DateTimeKind kind)
		{
			var entity = new TimestampUtcClass
			{
				Id = 1,
				Value = DateTime.SpecifyKind(DateTime.Now, kind)
			};

			using(var session = OpenSession())
			using(var tx = session.BeginTransaction())
			{
				await (session.SaveAsync(entity));
				Assert.That(() => session.FlushAsync(), Throws.TypeOf<PropertyValueException>());
				await (tx.RollbackAsync());
			}
		}

		/// <summary>
		/// Create two session. Write entity in the first and read it in the second and compare if
		/// the retrieved timestamp value still equals the original value.
		/// </summary>
		/// <remarks> This test takes the database precision into consideration.</remarks>
		[Test]
		public async Task UtcReadWrite_SuccessAsync()
		{
			TimestampUtcClass entity;

			// Save
			using(var session = OpenSession())
			using(var tx = session.BeginTransaction())
			{
				// Create a new datetime value and round it to the precision that the database supports. This
				// code basically the same as in the implementation but here to guard posible changes.
				var resolution = session.GetSessionImplementation().Factory.Dialect.TimestampResolutionInTicks;
				var next = DateTime.UtcNow;
				next = next.AddTicks(-(next.Ticks % resolution));

				entity = new TimestampUtcClass
				{
					Id = 1,
					Value = next
				};

				await (session.SaveAsync(entity));
				await (tx.CommitAsync());
				session.Close();
			}

			// Retrieve and compare
			using (var session = OpenSession())
			using (var tx = session.BeginTransaction())
			{
				var result = await (session.GetAsync<TimestampUtcClass>(entity.Id));
				Assert.IsNotNull(result, "Entity not saved or cannot be retrieved by its key.");

				// Property: Value
				Assert.AreEqual(DateTimeKind.Utc, result.Value.Kind, "Kind is NOT Utc");
				Assert.AreEqual(entity.Value.Ticks, result.Value.Ticks, "Value should be the same.");

				// Property: Revision
				var revision = result.Revision;
				Assert.AreEqual(DateTimeKind.Utc, revision.Kind, "Kind is NOT Utc");

				var differenceInMinutes = Math.Abs((revision - DateTime.UtcNow).TotalMinutes);
				// Take a wide margin for accounting for sometimes bad build servers performances.
				Assert.Less(differenceInMinutes, 2, "Difference should be less than 2 minutes.");

				await (tx.CommitAsync());
				session.Close();
			}

			// Delete
			using (var session = OpenSession())
			using (var tx = session.BeginTransaction())
			{
				var result = await (session.GetAsync<TimestampUtcClass>(entity.Id));
				await (session.DeleteAsync(result));
				await (tx.CommitAsync());
				session.Close();
			}
		}
	}
}
