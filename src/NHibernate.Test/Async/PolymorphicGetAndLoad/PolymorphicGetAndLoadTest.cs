//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using NHibernate.Engine;
using NHibernate.Proxy;
using NUnit.Framework;

namespace NHibernate.Test.PolymorphicGetAndLoad
{
	using System.Threading.Tasks;
	[TestFixture]
	public class PolymorphicGetAndLoadTestAsync: TestCase
	{
		protected override string MappingsAssembly
		{
			get { return "NHibernate.Test"; }
		}

		protected override string[] Mappings
		{
			get { return new[] { "PolymorphicGetAndLoad.Mappings.hbm.xml" }; }
		}

		public class ScenarioWithA : IDisposable
		{
			private readonly ISessionFactory factory;
			private readonly A a;

			public ScenarioWithA(ISessionFactory factory)
			{
				this.factory = factory;
				a = new A { Name = "Patrick" };
				using (var s = factory.OpenSession())
				{
					s.Save(a);
					s.Flush();
				}
			}

			public A A
			{
				get { return a; }
			}

			public void Dispose()
			{
				using (var s = factory.OpenSession())
				{
					s.Delete(a);
					s.Flush();
				}
			}
		}

		public class ScenarioWithB : IDisposable
		{
			private readonly ISessionFactory factory;
			private readonly B b;

			public ScenarioWithB(ISessionFactory factory)
			{
				this.factory = factory;
				b = new B { Name = "Patrick", Occupation = "hincha pelotas (en el buen sentido), but good candidate to be committer."};
				using (var s = factory.OpenSession())
				{
					s.Save(b);
					s.Flush();
				}
			}

			public B B
			{
				get { return b; }
			}

			public void Dispose()
			{
				using (var s = factory.OpenSession())
				{
					s.Delete(b);
					s.Flush();
				}
			}
		}

		[Test]
		public void WhenSaveDeleteBaseClassCastedToInterfaceThenNotThrowsAsync()
		{
			INamed a = new A { Name = "Patrick" };
			Assert.That(async () =>
			{
				using (var s = OpenSession())
				{
					await (s.SaveAsync(a));
					await (s.FlushAsync());
				}
			}, Throws.Nothing);

			Assert.That(async () =>
			{
				using (var s = OpenSession())
				{
					await (s.DeleteAsync(a));
					await (s.FlushAsync());
				}
			}, Throws.Nothing);
		}

		[Test]
		public void WhenLoadBaseClassUsingInterfaceThenNotThrowsAsync()
		{
			using (var scenario = new ScenarioWithA(Sfi))
			{
				using (var s = OpenSession())
				{
					Assert.That(() => s.LoadAsync<INamed>(scenario.A.Id), Throws.Nothing);
				}
			}
		}

		[Test]
		public void WhenGetBaseClassUsingInterfaceThenNotThrowsAsync()
		{
			using (var scenario = new ScenarioWithA(Sfi))
			{
				using (var s = OpenSession())
				{
					Assert.That(() => s.GetAsync<INamed>(scenario.A.Id), Throws.Nothing);
				}
			}
		}

		[Test]
		public void WhenLoadInheritedClassUsingInterfaceThenNotThrowsAsync()
		{
			using (var scenario = new ScenarioWithB(Sfi))
			{
				using (var s = OpenSession())
				{
					Assert.That(() => s.LoadAsync<INamed>(scenario.B.Id), Throws.Nothing);
				}
			}
		}

		[Test]
		public async Task WhenLoadInheritedClassUsingInterfaceThenShouldAllowNarrowingProxyAsync()
		{
			using (var scenario = new ScenarioWithB(Sfi))
			{
				using (var s = OpenSession())
				{
					INamed loadedEntity = null;
					Assert.That(async () => loadedEntity = await (s.LoadAsync<INamed>(scenario.B.Id)), Throws.Nothing);
					Assert.That(NHibernateProxyHelper.GetClassWithoutInitializingProxy(loadedEntity), Is.EqualTo(typeof(A)));

					var narrowedProxy = await (s.LoadAsync<B>(scenario.B.Id));

					Assert.That(NHibernateProxyHelper.GetClassWithoutInitializingProxy(narrowedProxy), Is.EqualTo(typeof(B)));

					var firstLoadedImpl = ((INHibernateProxy)loadedEntity).HibernateLazyInitializer.GetImplementation((ISessionImplementor)s);
					var secondLoadedImpl = ((INHibernateProxy)narrowedProxy).HibernateLazyInitializer.GetImplementation((ISessionImplementor)s);
					Assert.That(firstLoadedImpl, Is.SameAs(secondLoadedImpl));
				}
			}
		}

		[Test]
		public async Task WhenLoadInterfaceThenShouldAllowNarrowingProxyAsync()
		{
			using (var scenario = new ScenarioWithB(Sfi))
			{
				using (var s = OpenSession())
				{
					INamed loadedEntity = null;
					Assert.That(async () => loadedEntity = await (s.LoadAsync<INamed>(scenario.B.Id)), Throws.Nothing);
					Assert.That(NHibernateProxyHelper.GetClassWithoutInitializingProxy(loadedEntity), Is.EqualTo(typeof(A)));

					var narrowedProxy = await (s.LoadAsync<IOccuped>(scenario.B.Id));

					Assert.That(NHibernateProxyHelper.GetClassWithoutInitializingProxy(narrowedProxy), Is.EqualTo(typeof(B)));

					var firstLoadedImpl = ((INHibernateProxy)loadedEntity).HibernateLazyInitializer.GetImplementation((ISessionImplementor)s);
					var secondLoadedImpl = ((INHibernateProxy)narrowedProxy).HibernateLazyInitializer.GetImplementation((ISessionImplementor)s);
					Assert.That(firstLoadedImpl, Is.SameAs(secondLoadedImpl));
				}
			}
		}

		[Test]
		public void WhenGetInheritedClassUsingInterfaceThenNotThrowsAsync()
		{
			using (var scenario = new ScenarioWithB(Sfi))
			{
				using (var s = OpenSession())
				{
					INamed loadedEntity = null;
					Assert.That(async () => loadedEntity = await (s.GetAsync<INamed>(scenario.B.Id)), Throws.Nothing);
					Assert.That(loadedEntity, Is.TypeOf<B>());
				}
			}
		}

		[Test]
		public void WhenLoadClassUsingInterfaceOfMultippleHierarchyThenThrowsAsync()
		{
			using (var s = OpenSession())
			{
				Assert.That(() => s.LoadAsync<IMultiGraphNamed>(1), Throws.TypeOf<HibernateException>()
																	 .And.Message.Contains("Ambiguous")
																	 .And.Message.Contains("GraphA")
																	 .And.Message.Contains("GraphB")
																	 .And.Message.Contains("IMultiGraphNamed"));
			}
		}

		[Test]
		public void WhenGetClassUsingInterfaceOfMultippleHierarchyThenThrowsAsync()
		{
			using (var s = OpenSession())
			{
				Assert.That(() => s.GetAsync<IMultiGraphNamed>(1),
							Throws.TypeOf<HibernateException>()
								  .And.Message.Contains("Ambiguous")
								  .And.Message.Contains("GraphA")
								  .And.Message.Contains("GraphB")
								  .And.Message.Contains("IMultiGraphNamed"));
			}
		}

		[Test]
		public async Task WhenGetBaseClassUsingInterfaceFromSessionCacheThenNotThrowsAsync()
		{
			using (var scenario = new ScenarioWithA(Sfi))
			{
				using (var s = OpenSession())
				{
					var id = scenario.A.Id;
					await (s.GetAsync<A>(id));
					Assert.That(() => s.GetAsync<INamed>(id), Throws.Nothing);
				}
			}
		}

		[Test]
		public async Task WhenGetInheritedClassUsingInterfaceFromSessionCacheThenNotThrowsAsync()
		{
			using (var scenario = new ScenarioWithB(Sfi))
			{
				using (var s = OpenSession())
				{
					var id = scenario.B.Id;
					await (s.GetAsync<B>(id));
					Assert.That(() => s.GetAsync<INamed>(id), Throws.Nothing);
				}
			}
		}
	}
}
