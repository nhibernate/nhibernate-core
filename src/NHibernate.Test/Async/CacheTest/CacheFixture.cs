//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using System.Threading;
using NHibernate.Cache;
using NHibernate.Cache.Access;
using NUnit.Framework;

namespace NHibernate.Test.CacheTest
{
	using System.Threading.Tasks;
	[TestFixture]
	public class CacheFixtureAsync: TestCase
	{
		[Test]
		public async Task TestSimpleReadWriteCacheAsync()
		{
			await (DoTestCacheAsync(new HashtableCacheProvider()));
		}

		protected CacheKey CreateCacheKey(string text)
		{
			return new CacheKey(text, NHibernateUtil.String, "Foo", null, null);
		}

		public async Task DoTestCacheAsync(ICacheProvider cacheProvider, CancellationToken cancellationToken = default(CancellationToken))
		{
			var cache = (CacheBase) cacheProvider.BuildCache(typeof(String).FullName, new Dictionary<string, string>());

			long longBefore = Timestamper.Next();

			await (Task.Delay(15, cancellationToken));

			long before = Timestamper.Next();

			await (Task.Delay(15, cancellationToken));

			ICacheConcurrencyStrategy ccs = CreateCache(cache);

			// cache something
			CacheKey fooKey = CreateCacheKey("foo");

			Assert.IsTrue(await (ccs.PutAsync(fooKey, "foo", before, null, null, false, cancellationToken)));

			await (Task.Delay(15, cancellationToken));

			long after = Timestamper.Next();

			Assert.IsNull(await (ccs.GetAsync(fooKey, longBefore, cancellationToken)));
			Assert.AreEqual("foo", await (ccs.GetAsync(fooKey, after, cancellationToken)));
			Assert.IsFalse(await (ccs.PutAsync(fooKey, "foo", before, null, null, true, cancellationToken)));
			Assert.IsTrue(await (ccs.PutAsync(fooKey, "foo", before, null, null, false, cancellationToken)));

			// update it;

			ISoftLock fooLock = await (ccs.LockAsync(fooKey, null, cancellationToken));

			Assert.IsNull(await (ccs.GetAsync(fooKey, after, cancellationToken)));
			Assert.IsNull(await (ccs.GetAsync(fooKey, longBefore, cancellationToken)));
			Assert.IsFalse(await (ccs.PutAsync(fooKey, "foo", before, null, null, false, cancellationToken)));

			await (Task.Delay(15, cancellationToken));

			long whileLocked = Timestamper.Next();

			Assert.IsFalse(await (ccs.PutAsync(fooKey, "foo", whileLocked, null, null, false, cancellationToken)));

			await (Task.Delay(15, cancellationToken));

			await (ccs.ReleaseAsync(fooKey, fooLock, cancellationToken));

			Assert.IsNull(await (ccs.GetAsync(fooKey, after, cancellationToken)));
			Assert.IsNull(await (ccs.GetAsync(fooKey, longBefore, cancellationToken)));
			Assert.IsFalse(await (ccs.PutAsync(fooKey, "bar", whileLocked, null, null, false, cancellationToken)));
			Assert.IsFalse(await (ccs.PutAsync(fooKey, "bar", after, null, null, false, cancellationToken)));

			await (Task.Delay(15, cancellationToken));

			long longAfter = Timestamper.Next();

			Assert.IsTrue(await (ccs.PutAsync(fooKey, "baz", longAfter, null, null, false, cancellationToken)));
			Assert.IsNull(await (ccs.GetAsync(fooKey, after, cancellationToken)));
			Assert.IsNull(await (ccs.GetAsync(fooKey, whileLocked, cancellationToken)));

			await (Task.Delay(15, cancellationToken));

			long longLongAfter = Timestamper.Next();

			Assert.AreEqual("baz", await (ccs.GetAsync(fooKey, longLongAfter, cancellationToken)));

			// update it again, with multiple locks

			ISoftLock fooLock1 = await (ccs.LockAsync(fooKey, null, cancellationToken));
			ISoftLock fooLock2 = await (ccs.LockAsync(fooKey, null, cancellationToken));

			Assert.IsNull(await (ccs.GetAsync(fooKey, longLongAfter, cancellationToken)));

			await (Task.Delay(15, cancellationToken));

			whileLocked = Timestamper.Next();

			Assert.IsFalse(await (ccs.PutAsync(fooKey, "foo", whileLocked, null, null, false, cancellationToken)));

			await (Task.Delay(15, cancellationToken));

			await (ccs.ReleaseAsync(fooKey, fooLock2, cancellationToken));

			await (Task.Delay(15, cancellationToken));

			long betweenReleases = Timestamper.Next();

			Assert.IsFalse(await (ccs.PutAsync(fooKey, "bar", betweenReleases, null, null, false, cancellationToken)));
			Assert.IsNull(await (ccs.GetAsync(fooKey, betweenReleases, cancellationToken)));

			await (Task.Delay(15, cancellationToken));

			await (ccs.ReleaseAsync(fooKey, fooLock1, cancellationToken));

			Assert.IsFalse(await (ccs.PutAsync(fooKey, "bar", whileLocked, null, null, false, cancellationToken)));

			await (Task.Delay(15, cancellationToken));

			longAfter = Timestamper.Next();

			Assert.IsTrue(await (ccs.PutAsync(fooKey, "baz", longAfter, null, null, false, cancellationToken)));
			Assert.IsNull(await (ccs.GetAsync(fooKey, whileLocked, cancellationToken)));

			await (Task.Delay(15, cancellationToken));

			longLongAfter = Timestamper.Next();

			Assert.AreEqual("baz", await (ccs.GetAsync(fooKey, longLongAfter, cancellationToken)));
		}

		private async Task DoTestMinValueTimestampOnStrategyAsync(CacheBase cache, ICacheConcurrencyStrategy strategy, CancellationToken cancellationToken = default(CancellationToken))
		{
			CacheKey key = CreateCacheKey("key");
			strategy.Cache = cache;
			await (strategy.PutAsync(key, "value", long.MinValue, 0, null, false, cancellationToken));

			Assert.IsNull(await (strategy.GetAsync(key, long.MinValue, cancellationToken)), "{0} strategy fails the test", strategy.GetType());
			Assert.IsNull(await (strategy.GetAsync(key, long.MaxValue, cancellationToken)), "{0} strategy fails the test", strategy.GetType());
		}

		[Test]
		public async Task MinValueTimestampAsync()
		{
			var cache = new HashtableCacheProvider().BuildCache("region", new Dictionary<string, string>());

			await (DoTestMinValueTimestampOnStrategyAsync(cache, CreateCache(cache)));
			await (DoTestMinValueTimestampOnStrategyAsync(cache, CreateCache(cache, CacheFactory.NonstrictReadWrite)));
			await (DoTestMinValueTimestampOnStrategyAsync(cache, CreateCache(cache, CacheFactory.ReadOnly)));
		}

		protected virtual ICacheConcurrencyStrategy CreateCache(CacheBase cache, string strategy = CacheFactory.ReadWrite)
		{
			return CacheFactory.CreateCache(strategy, cache, Sfi.Settings);
		}

		protected override string[] Mappings => Array.Empty<string>();
	}
}
