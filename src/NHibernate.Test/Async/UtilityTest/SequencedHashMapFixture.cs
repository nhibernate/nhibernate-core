//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using NHibernate.Util;
using NUnit.Framework;

namespace NHibernate.Test.UtilityTest
{
	using System.Threading.Tasks;
	/// <summary>
	/// Summary description for SequencedHashMapFixture.
	/// </summary>
	[TestFixture]
	public class SequencedHashMapFixtureAsync
	{
		private SequencedHashMap _shm;
		private SequencedHashMap _emptyShm;
		private IList _expectedKeys;
		private IList _expectedValues;

		[SetUp]
		public void SetUp()
		{
			_shm = new SequencedHashMap();
			_emptyShm = new SequencedHashMap();

			_expectedKeys = new ArrayList();
			_expectedKeys.Add("test1");
			_expectedKeys.Add("test2");
			_expectedKeys.Add("test3");

			_expectedValues = new ArrayList();
			_expectedValues.Add(1);
			_expectedValues.Add("2");
			_expectedValues.Add(true);

			for (int i = 0; i < _expectedKeys.Count; i++)
			{
				_shm[_expectedKeys[i]] = _expectedValues[i];
			}
		}

		[Test, Explicit]
		public async Task PerformanceAsync()
		{
			// set the hashtable and SequencedHashMap to be the 
			IDictionary hashtable;
			IDictionary sequenced;
			IDictionary list;

			int numOfRuns = 4;

			int numOfEntries = Int16.MaxValue;

			long hashStart;
			long[] hashPopulateTicks = new long[numOfRuns];
			long[] hashItemTicks = new long[numOfRuns];

			long seqStart;
			long[] seqPopulateTicks = new long[numOfRuns];
			long[] seqItemTicks = new long[numOfRuns];

			long listStart;
			long[] listPopulateTicks = new long[numOfRuns];
			long[] listItemTicks = new long[numOfRuns];

			for (int runIndex = 0; runIndex < numOfRuns; runIndex++)
			{
				object key;
				object value;
				hashtable = new Hashtable();
				sequenced = new SequencedHashMap();
				list = new ListDictionary();

				hashStart = DateTime.Now.Ticks;

				for (int i = 0; i < numOfEntries; i++)
				{
					hashtable.Add("test" + i, new object());
				}

				hashPopulateTicks[runIndex] = DateTime.Now.Ticks - hashStart;

				hashStart = DateTime.Now.Ticks;
				for (int i = 0; i < numOfEntries; i++)
				{
					key = "test" + i;
					value = hashtable[key];
				}

				hashItemTicks[runIndex] = DateTime.Now.Ticks - hashStart;

				hashtable.Clear();

				seqStart = DateTime.Now.Ticks;

				for (int i = 0; i < numOfEntries; i++)
				{
					sequenced.Add("test" + i, new object());
				}

				seqPopulateTicks[runIndex] = DateTime.Now.Ticks - seqStart;

				seqStart = DateTime.Now.Ticks;
				for (int i = 0; i < numOfEntries; i++)
				{
					key = "test" + i;
					value = sequenced[key];
				}

				seqItemTicks[runIndex] = DateTime.Now.Ticks - seqStart;

				sequenced.Clear();

				listStart = DateTime.Now.Ticks;

				for (int i = 0; i < numOfEntries; i++)
				{
					list.Add("test" + i, new object());
				}

				listPopulateTicks[runIndex] = DateTime.Now.Ticks - listStart;

				listStart = DateTime.Now.Ticks;
				for (int i = 0; i < numOfEntries; i++)
				{
					key = "test" + i;
					value = list[key];
				}

				listItemTicks[runIndex] = DateTime.Now.Ticks - listStart;

				list.Clear();
			}

			for (int runIndex = 0; runIndex < numOfRuns; runIndex++)
			{
				decimal seqPopulateOverhead = ((decimal) seqPopulateTicks[runIndex] / (decimal) hashPopulateTicks[runIndex]);
				decimal seqItemOverhead = ((decimal) seqItemTicks[runIndex] / (decimal) hashItemTicks[runIndex]);

				string errMessage = "SequenceHashMap vs Hashtable:";
				errMessage += "\n POPULATE:";
				errMessage += "\n\t seqPopulateTicks[" + runIndex + "] took " + seqPopulateTicks[runIndex] + " ticks.";
				errMessage += "\n\t hashPopulateTicks[" + runIndex + "] took " + hashPopulateTicks[runIndex] + " ticks.";
				errMessage += "\n\t for an overhead of " + seqPopulateOverhead.ToString();
				errMessage += "\n ITEM:";
				errMessage += "\n\t seqItemTicks[" + runIndex + "] took " + seqItemTicks[runIndex] + " ticks.";
				errMessage += "\n\t hashItemTicks[" + runIndex + "] took " + hashItemTicks[runIndex] + " ticks.";
				errMessage += "\n\t for an overhead of " + seqItemOverhead.ToString();

				await (Console.Out.WriteLineAsync(errMessage));

				decimal listPopulateOverhead = ((decimal) listPopulateTicks[runIndex] / (decimal) seqPopulateTicks[runIndex]);
				decimal listItemOverhead = ((decimal) listItemTicks[runIndex] / (decimal) seqItemTicks[runIndex]);

				errMessage = "ListDictionary vs SequenceHashMap:";
				errMessage += "\n POPULATE:";
				errMessage += "\n\t listPopulateTicks[" + runIndex + "] took " + listPopulateTicks[runIndex] + " ticks.";
				errMessage += "\n\t seqPopulateTicks[" + runIndex + "] took " + seqPopulateTicks[runIndex] + " ticks.";
				errMessage += "\n\t for an overhead of " + listPopulateOverhead.ToString();
				errMessage += "\n ITEM:";
				errMessage += "\n\t listItemTicks[" + runIndex + "] took " + listItemTicks[runIndex] + " ticks.";
				errMessage += "\n\t seqItemTicks[" + runIndex + "] took " + seqItemTicks[runIndex] + " ticks.";
				errMessage += "\n\t for an overhead of " + listItemOverhead.ToString();

				await (Console.Out.WriteLineAsync(errMessage));
			}
		}
	}
}
