//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using NHibernate.Util;
using NUnit.Framework;

namespace NHibernate.Test.UtilityTest
{
	using System.Threading.Tasks;
	[TestFixture]
	public class LinkedHashMapFixtureAsync
	{
		private static readonly Player[] players = {
		                                  	new Player("12341", "Boeta Dippenaar"), new Player("23432", "Gary Kirsten"),
		                                  	new Player("23411", "Graeme Smith"), new Player("55221", "Jonty Rhodes"),
		                                  	new Player("61234", "Monde Zondeki"), new Player("23415", "Paul Adams")
		                                  };

		private static void Fill(IDictionary<string, Player> lhm)
		{
			foreach (Player player in players)
				lhm.Add(player.Id, player);
		}

		[Test, Explicit]
		public async Task ShowDiffAsync()
		{
			IDictionary<string, Player> dict = new Dictionary<string, Player>();
			IDictionary<string, Player> lhm = new LinkedHashMap<string, Player>();
			Fill(dict);
			Fill(lhm);
			// Override the first element
			Player o = new Player("12341", "Ovirride");
			dict[o.Id] = o;
			lhm[o.Id] = o;
			await (Console.Out.WriteLineAsync("Dictionary order:"));
			foreach (KeyValuePair<string, Player> pair in dict)
			{
				Console.Out.WriteLine("Key->{0}", pair.Key);
			}
			await (Console.Out.WriteLineAsync("LinkedHashMap order:"));
			foreach (KeyValuePair<string, Player> pair in lhm)
			{
				Console.Out.WriteLine("Key->{0}", pair.Key);
			}
		}

		[Test, Explicit]
		public async Task PerformanceAsync()
		{
			// Take care with this test because the result is not the same every times

			int numOfRuns = 4;

			int numOfEntries = Int16.MaxValue;

			long[] dictPopulateTicks = new long[numOfRuns];
			long[] dictItemTicks = new long[numOfRuns];

			long[] linkPopulateTicks = new long[numOfRuns];
			long[] linkItemTicks = new long[numOfRuns];

			for (int runIndex = 0; runIndex < numOfRuns; runIndex++)
			{
				string key;
				object value;
				IDictionary<string, object> dictionary = new Dictionary<string, object>();
				IDictionary<string, object> linked = new LinkedHashMap<string, object>();

				long dictStart = DateTime.Now.Ticks;

				for (int i = 0; i < numOfEntries; i++)
				{
					dictionary.Add("test" + i, new object());
				}

				dictPopulateTicks[runIndex] = DateTime.Now.Ticks - dictStart;

				dictStart = DateTime.Now.Ticks;
				for (int i = 0; i < numOfEntries; i++)
				{
					key = "test" + i;
					value = dictionary[key];
				}
				dictItemTicks[runIndex] = DateTime.Now.Ticks - dictStart;

				dictionary.Clear();

				long linkStart = DateTime.Now.Ticks;

				for (int i = 0; i < numOfEntries; i++)
				{
					linked.Add("test" + i, new object());
				}

				linkPopulateTicks[runIndex] = DateTime.Now.Ticks - linkStart;

				linkStart = DateTime.Now.Ticks;
				for (int i = 0; i < numOfEntries; i++)
				{
					key = "test" + i;
					value = linked[key];
				}

				linkItemTicks[runIndex] = DateTime.Now.Ticks - linkStart;

				linked.Clear();
			}

			for (int runIndex = 0; runIndex < numOfRuns; runIndex++)
			{
				decimal linkPopulateOverhead = (linkPopulateTicks[runIndex] / (decimal)dictPopulateTicks[runIndex]);
				decimal linkItemOverhead = (linkItemTicks[runIndex] / (decimal)dictItemTicks[runIndex]);

				string message = string.Format("LinkedHashMap vs Dictionary (Run-{0}) :",runIndex+1);
				message += "\n POPULATE:";
				message += "\n\t linked took " + linkPopulateTicks[runIndex] + " ticks.";
				message += "\n\t dictionary took " + dictPopulateTicks[runIndex] + " ticks.";
				message += "\n\t for an overhead of " + linkPopulateOverhead;
				message += "\n RETRIVE:";
				message += "\n\t linked took " + linkItemTicks[runIndex] + " ticks.";
				message += "\n\t dictionary took " + dictItemTicks[runIndex] + " ticks.";
				message += "\n\t for an overhead of " + linkItemOverhead;

				await (Console.Out.WriteLineAsync(message));
				await (Console.Out.WriteLineAsync());
			}
		}
	}
}
