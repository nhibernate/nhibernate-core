//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System.Data;
using NUnit.Framework;

namespace NHibernate.Test.NHSpecificTest.NH1632
{
	using System.Transactions;
	using Cache;
	using Cfg;
	using Engine;
	using Id;
	using System.Threading.Tasks;
	using System.Threading;

	[TestFixture]
	public class FixtureAsync : BugTestCase
	{
		protected override bool AppliesTo(ISessionFactoryImplementor factory) =>
			factory.ConnectionProvider.Driver.SupportsSystemTransactions;

		protected override void Configure(Configuration configuration)
		{
			configuration
				.SetProperty(Environment.UseSecondLevelCache, "true")
				.SetProperty(Environment.CacheProvider, typeof(HashtableCacheProvider).AssemblyQualifiedName);
		}

		[Test]
		public async Task When_using_DTC_HiLo_knows_to_create_isolated_DTC_transactionAsync()
		{
			if (!Dialect.SupportsConcurrentWritingConnections)
				Assert.Ignore(Dialect.GetType().Name + " does not support concurrent writing connections, can not isolate work.");

			object scalar1, scalar2;

			using (var session = Sfi.OpenSession())
			using (var command = session.Connection.CreateCommand())
			{
				command.CommandText = "select next_hi from hibernate_unique_key";
				scalar1 = await (command.ExecuteScalarAsync());
			}

			using (new TransactionScope(TransactionScopeAsyncFlowOption.Enabled))
			{
				var generator = Sfi.GetIdentifierGenerator(typeof(Person).FullName);
				Assert.That(generator, Is.InstanceOf<TableHiLoGenerator>());

				using (var session = OpenSession())
				{
					// Force connection acquisition for having it enlisted.
					Assert.That(session.Connection.State, Is.EqualTo(ConnectionState.Open));
					await (generator.GenerateAsync((ISessionImplementor)session, new Person(), CancellationToken.None));
				}

				// intentionally dispose without committing
			}

			using (var session = Sfi.OpenSession())
			using (var command = session.Connection.CreateCommand())
			{
				command.CommandText = "select next_hi from hibernate_unique_key";
				scalar2 = await (command.ExecuteScalarAsync());
			}

			Assert.AreNotEqual(scalar1, scalar2, "HiLo must run with in its own transaction");
		}

		[Test]
		public async Task When_commiting_items_in_DTC_transaction_will_add_items_to_2nd_level_cacheAsync()
		{
			using (var tx = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled))
			{
				using (var s = Sfi.OpenSession())
				{
					await (s.SaveAsync(new Nums { ID = 29, NumA = 1, NumB = 3 }));
				}
				tx.Complete();
			}
			try
			{
				using (var tx = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled))
				{
					using (var s = OpenSession())
					{
						var nums = await (s.LoadAsync<Nums>(29));
						Assert.AreEqual(1, nums.NumA);
						Assert.AreEqual(3, nums.NumB);
					}
					tx.Complete();
				}

				//closing the connection to ensure we can't really use it.
				var connection = await (Sfi.ConnectionProvider.GetConnectionAsync(CancellationToken.None));
				Sfi.ConnectionProvider.CloseConnection(connection);

				// The session is supposed to succeed because the second level cache should have the
				// entity to load, allowing the session to not use the connection at all.
				// Will fail if a transaction manager tries to enlist user supplied connection. Do
				// not add a transaction scope below.
				using (var s = Sfi.WithOptions().Connection(connection).OpenSession())
				{
					Nums nums = null;
					Assert.DoesNotThrowAsync(async () => nums = await (s.LoadAsync<Nums>(29)), "Failed loading entity from second level cache.");
					Assert.AreEqual(1, nums.NumA);
					Assert.AreEqual(3, nums.NumB);
				}
			}
			finally
			{
				using (var s = OpenSession())
				using (var tx = s.BeginTransaction())
				{
					var nums = await (s.LoadAsync<Nums>(29));
					await (s.DeleteAsync(nums));
					await (tx.CommitAsync());
				}
			}
		}

		[Test]
		public async Task When_committing_transaction_scope_will_commit_transactionAsync()
		{
			object id;
			using (var tx = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled))
			{
				using (ISession s = Sfi.OpenSession())
				{
					id = await (s.SaveAsync(new Nums { NumA = 1, NumB = 2, ID = 5 }));
				}
				tx.Complete();
			}

			using (ISession s = Sfi.OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				Nums nums = await (s.GetAsync<Nums>(id));
				Assert.IsNotNull(nums);
				await (s.DeleteAsync(nums));

				await (tx.CommitAsync());
			}
		}

		[Test]
		public async Task Will_not_save_when_flush_mode_is_neverAsync()
		{
			object id;
			using (var tx = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled))
			{
				using (ISession s = Sfi.OpenSession())
				{
					s.FlushMode = FlushMode.Manual;
					id = await (s.SaveAsync(new Nums { NumA = 1, NumB = 2, ID = 5 }));
				}
				tx.Complete();
			}

			using (ISession s = Sfi.OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				Nums nums = await (s.GetAsync<Nums>(id));
				Assert.IsNull(nums);
				await (tx.CommitAsync());
			}
		}

		[Test]
		public async Task When_using_two_sessions_with_explicit_flushAsync()
		{
			if (!Dialect.SupportsConcurrentWritingConnectionsInSameTransaction)
				Assert.Ignore(Dialect.GetType().Name + " does not support concurrent connections in same transaction.");
			if (!Dialect.SupportsDistributedTransactions)
				Assert.Ignore(Dialect.GetType().Name + " does not support distributed transactions.");

			object id1, id2;
			using (var tx = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled))
			{
				using (ISession s1 = Sfi.OpenSession())
				using (ISession s2 = Sfi.OpenSession())
				{
					id1 = await (s1.SaveAsync(new Nums { NumA = 1, NumB = 2, ID = 5 }));
					await (s1.FlushAsync());

					id2 = await (s2.SaveAsync(new Nums { NumA = 1, NumB = 2, ID = 6 }));
					await (s2.FlushAsync());

					tx.Complete();
				}
			}

			using (ISession s = Sfi.OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				Nums nums = await (s.GetAsync<Nums>(id1));
				Assert.IsNotNull(nums);
				await (s.DeleteAsync(nums));

				nums = await (s.GetAsync<Nums>(id2));
				Assert.IsNotNull(nums);
				await (s.DeleteAsync(nums));

				await (tx.CommitAsync());
			}
		}

		[Test]
		public async Task When_using_two_sessionsAsync()
		{
			if (!Dialect.SupportsConcurrentWritingConnectionsInSameTransaction)
				Assert.Ignore(Dialect.GetType().Name + " does not support concurrent connections in same transaction.");
			if (!Dialect.SupportsDistributedTransactions)
				Assert.Ignore(Dialect.GetType().Name + " does not support distributed transactions.");

			object id1, id2;
			using (var tx = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled))
			{
				using (ISession s1 = Sfi.OpenSession())
				using (ISession s2 = Sfi.OpenSession())
				{
					id1 = await (s1.SaveAsync(new Nums { NumA = 1, NumB = 2, ID = 5 }));

					id2 = await (s2.SaveAsync(new Nums { NumA = 1, NumB = 2, ID = 6 }));

					tx.Complete();
				}
			}

			using (ISession s = Sfi.OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				Nums nums = await (s.GetAsync<Nums>(id1));
				Assert.IsNotNull(nums);
				await (s.DeleteAsync(nums));

				nums = await (s.GetAsync<Nums>(id2));
				Assert.IsNotNull(nums);
				await (s.DeleteAsync(nums));

				await (tx.CommitAsync());
			}
		}
	}
}
