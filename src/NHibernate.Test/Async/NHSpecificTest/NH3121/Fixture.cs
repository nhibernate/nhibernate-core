//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Drawing;
using System.Linq;
using System.Reflection;
using NHibernate.Dialect;
using NHibernate.Driver;
using NUnit.Framework;

namespace NHibernate.Test.NHSpecificTest.NH3121
{
	using System.Threading.Tasks;
	using System.Threading;
	[TestFixture]
	public class FixtureAsync : BugTestCase
	{
		protected override bool AppliesTo(Dialect.Dialect dialect)
		{
			return dialect is MsSql2000Dialect; // All MS dialects.
		}

		// Some notes:
		// Mappings for all three properties use either unspecified length (defaulting to 8000 bytes)
		// or a length specified to a value smaller than 8001 bytes. This is since for larger values
		// the driver will increase the parameter size to int.MaxValue/2.

		[Test]
		public void ShouldThrowWhenByteArrayTooLongAsync()
		{
			// For SQL Server only the SqlClientDriver sets parameter lengths
			// even when there is no length specified in the mapping. The ODBC
			// driver won't cause the truncation issue and hence not the exception.
			if (!(Sfi.ConnectionProvider.Driver is SqlClientDriver))
				Assert.Ignore("Test limited to drivers that sets parameter length even with no length specified in the mapping.");

			const int reportSize = 17158;
			var random = new Random();

			var reportImage = new Byte[reportSize];
			random.NextBytes(reportImage);

			var report = new Report { UnsizedArray = reportImage };

			var ex = Assert.ThrowsAsync<PropertyValueException>(() => PersistReportAsync(report));

			Assert.That(ex.Message, Does.Contain("Report.UnsizedArray"));
			Assert.That(ex.InnerException, Is.TypeOf<HibernateException>());
			Assert.That(ex.InnerException.Message,
						Is.EqualTo("The length of the byte[] value exceeds the length configured in the mapping/parameter."));
		}


		[Test]
		public void ShouldThrowWhenImageTooLargeAsync()
		{
			var stream = typeof(FixtureAsync).Assembly.GetManifestResourceStream("NHibernate.Test.NHSpecificTest.NH2484.food-photo.jpg");
			var image = Image.FromStream(stream);

			var report = new Report { Image = image };

			var ex = Assert.ThrowsAsync<PropertyValueException>(() => PersistReportAsync(report));

			Assert.That(ex.Message, Does.Contain("Report.Image"));
			Assert.That(ex.InnerException, Is.TypeOf<HibernateException>());
			Assert.That(ex.InnerException.Message,
						Is.EqualTo("The length of the byte[] value exceeds the length configured in the mapping/parameter."));
		}


		[Test]
		public void ShouldThrowWhenImageAsISerializableTooLargeAsync()
		{
			var stream = typeof(FixtureAsync).Assembly.GetManifestResourceStream("NHibernate.Test.NHSpecificTest.NH2484.food-photo.jpg");
			var image = Image.FromStream(stream);

			var report = new Report { SerializableImage = image };

			var ex = Assert.ThrowsAsync<PropertyValueException>(() => PersistReportAsync(report));

			Assert.That(ex.Message, Does.Contain("Report.SerializableImage"));
			Assert.That(ex.InnerException, Is.TypeOf<HibernateException>());
			Assert.That(ex.InnerException.Message,
						Is.EqualTo("The length of the byte[] value exceeds the length configured in the mapping/parameter."));
		}


		private async Task PersistReportAsync(Report report, CancellationToken cancellationToken = default(CancellationToken))
		{
			using (var session = OpenSession())
			using (session.BeginTransaction())
			{
				await (session.SaveAsync(report, cancellationToken));
				await (session.FlushAsync(cancellationToken));
				// No commit to avoid DB pollution (test success means we should throw and never insert anyway).
			}
		}
	}
}
