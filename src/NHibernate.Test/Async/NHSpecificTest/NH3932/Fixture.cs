//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System.Collections;
using NHibernate.Test.NHSpecificTest.NH3932.Model;
using NUnit.Framework;

namespace NHibernate.Test.NHSpecificTest.NH3932
{
	using System.Threading.Tasks;
	[TestFixture]
	public abstract class FixtureAsync : BugTestCase
	{
		private IParent storedParent;
		protected abstract bool CareAboutOrder { get; }

		[Test]
		public async Task ShouldKeepDirtyCollectionDirtyAfterMergingCloneAsync()
		{
			using (var s = OpenSession())
			{
				using (s.BeginTransaction())
				{
					await (s.LockAsync(storedParent, LockMode.None));
					storedParent.ClearChildren();
					Assert.IsTrue(await (s.IsDirtyAsync()));

					var loadedClone = storedParent.Clone();
					await (s.MergeAsync(loadedClone));
					Assert.IsTrue(await (s.IsDirtyAsync()));
				}
			}
		}

		[Test]
		public async Task ShouldCareAboutOrder_MergeObjectNotInSessionAsync()
		{
			var parent = CreateParent(2);
			using (var s = OpenSession())
			{
				using (var tx = s.BeginTransaction())
				{
					await (s.SaveAsync(parent));
					await (tx.CommitAsync());
				}
			}
			var parentClone = parent.Clone();
			parentClone.ReverseChildren();
			using (var s = OpenSession())
			{
				s.SessionFactory.Statistics.Clear();
				using (var tx = s.BeginTransaction())
				{
					await (s.MergeAsync(parentClone));
					await (tx.CommitAsync());
				}
				Assert.That(s.SessionFactory.Statistics.EntityUpdateCount, CareAboutOrder ? Is.EqualTo(1) : Is.EqualTo(0));
			}
		}

		[Test]
		public async Task ShouldCareAboutOrder_MergeObjectInSessionAsync()
		{
			var parent = CreateParent(2);
			using (var s = OpenSession())
			{
				using (var tx = s.BeginTransaction())
				{
					await (s.SaveAsync(parent));
					await (tx.CommitAsync());
				}
			}
			var parentClone = parent.Clone();
			parentClone.ReverseChildren();
			using (var s = OpenSession())
			{
				s.SessionFactory.Statistics.Clear();
				using (var tx = s.BeginTransaction())
				{
					await (s.LockAsync(parent, LockMode.None));
					await (s.MergeAsync(parentClone));
					await (tx.CommitAsync());
				}
				Assert.That(s.SessionFactory.Statistics.EntityUpdateCount, CareAboutOrder ? Is.EqualTo(1) : Is.EqualTo(0));
			}
		}

		[Test]
		public async Task MergeCleanCloneShouldNotResultInUpdateAsync()
		{
			var parentClone = storedParent.Clone();
			using (var s = OpenSession())
			{
				s.SessionFactory.Statistics.Clear();
				using (var tx = s.BeginTransaction())
				{
					await (s.MergeAsync(parentClone));
					await (tx.CommitAsync());
				}
				Assert.That(s.SessionFactory.Statistics.EntityUpdateCount, Is.EqualTo(0));
			}
		}

		[Test]
		public async Task MergeCleanCloneShouldNotMakeSessionDirtyAsync()
		{
			var parentClone = storedParent.Clone();
			using (var s = OpenSession())
			{
				s.SessionFactory.Statistics.Clear();
				using (var tx = s.BeginTransaction())
				{
					await (s.MergeAsync(parentClone));
					Assert.That(await (s.IsDirtyAsync()), Is.False);
					await (tx.CommitAsync());
				}
			}
		}

		[Test]
		public async Task MergeCloneOnNonCloneShouldNotResultInUpdateAsync()
		{
			var parentClone = storedParent.Clone();
			using (var s = OpenSession())
			{
				s.SessionFactory.Statistics.Clear();
				using (var tx = s.BeginTransaction())
				{
					await (s.LockAsync(storedParent, LockMode.None));
					await (s.MergeAsync(parentClone));
					await (tx.CommitAsync());
				}
				Assert.That(s.SessionFactory.Statistics.EntityUpdateCount, Is.EqualTo(0));
			}
		}

		[Test]
		public async Task MergeCloneOnNonCloneShouldNotMakeSessionDirtyAsync()
		{
			var parentClone = storedParent.Clone();
			using (var s = OpenSession())
			{
				s.SessionFactory.Statistics.Clear();
				using (var tx = s.BeginTransaction())
				{
					await (s.LockAsync(storedParent, LockMode.None));
					await (s.MergeAsync(parentClone));
					Assert.That(await (s.IsDirtyAsync()), Is.False);
					await (tx.CommitAsync());
				}
			}
		}

		[Test]
		public async Task MoreElementsInTargetShouldBeTreatedAsDirtyAsync()
		{
			var parent = CreateParent(2);
			using (var s = OpenSession())
			{
				using (var tx = s.BeginTransaction())
				{
					await (s.SaveAsync(parent));
					await (tx.CommitAsync());
				}
			}
			var parentClone = parent.Clone();
			parentClone.RemoveLastChild();
			using (var s = OpenSession())
			{
				s.SessionFactory.Statistics.Clear();
				using (var tx = s.BeginTransaction())
				{
					await (s.MergeAsync(parentClone));
					await (tx.CommitAsync());
				}
				Assert.That(s.SessionFactory.Statistics.EntityUpdateCount, Is.EqualTo(1));
			}
		}

		protected abstract IParent CreateParent(int numberOfChildren);

		protected override void OnSetUp()
		{
			storedParent = CreateParent(1);
			using (var s = OpenSession())
			{
				using (var tx = s.BeginTransaction())
				{
					s.Save(storedParent);
					tx.Commit();
				}
			}
		}

		protected override void OnTearDown()
		{
			using (var s = Sfi.OpenSession())
			{
				using (var tx = s.BeginTransaction())
				{
					s.Delete("from " + storedParent.GetType());
					tx.Commit();
				}
			}
		}

		protected override void Configure(Cfg.Configuration configuration)
		{
			configuration.SetProperty(Cfg.Environment.GenerateStatistics, "true");
		}

		protected override string[] Mappings => new[] { "Model.Mappings.hbm.xml" };
	}
}
