//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Linq.Expressions;
using NHibernate.Cache;
using NHibernate.Cfg;
using NHibernate.Cfg.MappingSchema;
using NHibernate.Mapping.ByCode;
using NUnit.Framework;

namespace NHibernate.Test.NHSpecificTest.NH3848
{
	using System.Threading.Tasks;
	using System.Threading;
	[TestFixture]
	public abstract class FixtureAsync : TestCaseMappingByCode
	{
		protected Customer Customer1;
		protected Customer Customer2;
		protected Customer Customer3;
		protected const int OrderNumber = 2;

		protected override HbmMapping GetMappings()
		{
			var mapper = new ModelMapper();
			mapper.Class<Customer>(rc =>
			{
				rc.Table("Customers");
				rc.Id(x => x.Id, m => m.Generator(Generators.GuidComb));
				rc.Property(x => x.Name);
				rc.Set(x => x.Orders, m =>
				{
					m.Inverse(true);
					m.Key(k =>
					{
						k.Column("CustomerId");
						k.NotNullable(true);
					});
					m.Cascade(Mapping.ByCode.Cascade.All.Include(Mapping.ByCode.Cascade.DeleteOrphans));
					m.Cache(c => c.Usage(CacheUsage.ReadWrite));
				}, m => m.OneToMany());

				rc.Set(x => x.Companies, m =>
				{
					m.Inverse(true);
					m.Key(k =>
					{
						k.Column("CustomerId");
						k.NotNullable(true);
					});
					m.Cascade(Mapping.ByCode.Cascade.All.Include(Mapping.ByCode.Cascade.DeleteOrphans));
					m.Cache(c => c.Usage(CacheUsage.ReadWrite));
				}, m => m.OneToMany());
			});

			mapper.Class<Order>(rc =>
			{
				rc.Table("Orders");
				rc.Id(x => x.Id, m => m.Generator(Generators.GuidComb));
				rc.Property(x => x.Number, m => m.Column("`Number`"));
				rc.ManyToOne(x => x.Customer, m => m.Column("CustomerId"));
				rc.Cache(c => c.Usage(CacheUsage.ReadWrite));
			});

			mapper.Class<Company>(rc =>
			{
				rc.Table("Companies");
				rc.Id(x => x.Id, m => m.Generator(Generators.GuidComb));
				rc.Property(x => x.Name);
				rc.ManyToOne(x => x.Customer, m => m.Column("CustomerId"));
				rc.Cache(c => c.Usage(CacheUsage.ReadWrite));
			});

			return mapper.CompileMappingForAllExplicitlyAddedEntities();
		}

		protected override void Configure(Configuration configuration)
		{
			base.Configure(configuration);
			configuration.Cache(c =>
			{
				c.UseQueryCache = true;
				c.Provider<HashtableCacheProvider>();
			});
		}

		protected override void OnSetUp()
		{
			using (var session = OpenSession())
			using (var transaction = session.BeginTransaction())
			{
				Customer1 = new Customer { Name = "First Customer" };

				Customer2 = new Customer { Name = "Second Customer" };

				Customer3 = new Customer { Name = "Third Customer" };

				var customer1Order1 = new Order { Number = 1 };
				var customer1Company1 = new Company { Name = "First" };
				Customer1.AddOrder(customer1Order1);
				Customer1.AddCompany(customer1Company1);

				var customer1Order2 = new Order { Number = 2 };
				var customer1Company2 = new Company { Name = "Second" };
				Customer1.AddOrder(customer1Order2);
				Customer1.AddCompany(customer1Company2);

				var customer2Order1 = new Order { Number = 1 };
				var customer2Company1 = new Company { Name = "First" };
				Customer2.AddOrder(customer2Order1);
				Customer2.AddCompany(customer2Company1);

				var customer2Order2 = new Order { Number = 2 };
				var customer2Company2 = new Company { Name = "Second" };
				Customer2.AddOrder(customer2Order2);
				Customer2.AddCompany(customer2Company2);

				var customer3Company1 = new Company { Name = "First" };
				var customer3Order1 = new Order { Number = 1 };
				Customer3.AddOrder(customer3Order1);
				Customer3.AddCompany(customer3Company1);

				session.Save(Customer1);
				session.Save(Customer2);
				session.Save(Customer3);

				transaction.Commit();
				session.Flush();
			}
		}

		protected override void OnTearDown()
		{
			ClearSecondLevelCacheFor(typeof(Customer));
			ClearCollectionCache<Customer>(n => n.Orders);
			ClearCollectionCache<Customer>(n => n.Companies);
			ClearSecondLevelCacheFor(typeof(Order));

			using (var session = OpenSession())
			using (var transaction = session.BeginTransaction())
			{
				session.Delete("from System.Object");

				session.Flush();
				transaction.Commit();
			}
		}

		[Test]
		public virtual async Task ChildCollectionsFromLeftOuterJoinWithOnClauseRestrictionOnCollectionShouldNotBeInSecondLevelCacheAsync()
		{
			var firstSession = OpenSession();
			var customersWithOrderNumberEqualsTo2 = await (GetCustomersByOrderNumberUsingOnClauseAsync(firstSession, OrderNumber));

			var secondSession = OpenSession();
			var customers = await (GetAllCustomersAsync(secondSession));

			Assert.That(customersWithOrderNumberEqualsTo2.Single(n => n.Id == Customer1.Id).Orders, Has.Count.EqualTo(Customer1.Orders.Count(n => n.Number == OrderNumber)));
			Assert.That(customersWithOrderNumberEqualsTo2.Single(n => n.Id == Customer2.Id).Orders, Has.Count.EqualTo(Customer2.Orders.Count(n => n.Number == OrderNumber)));
			Assert.That(customersWithOrderNumberEqualsTo2.Single(n => n.Id == Customer3.Id).Orders, Has.Count.EqualTo(Customer3.Orders.Count(n => n.Number == OrderNumber)));

			Assert.That(customers.Single(n => n.Id == Customer1.Id).Orders, Has.Count.EqualTo(Customer1.Orders.Count));
			Assert.That(customers.Single(n => n.Id == Customer2.Id).Orders, Has.Count.EqualTo(Customer2.Orders.Count));
			Assert.That(customers.Single(n => n.Id == Customer3.Id).Orders, Has.Count.EqualTo(Customer3.Orders.Count));

			firstSession.Dispose();
			secondSession.Dispose();
		}

		[Test]
		public async Task ChildCollectionsFromLeftOuterJoinWithWhereClauseRestrictionOnCollectionShouldNotBeInSecondLevelCacheAsync()
		{
			var firstSession = OpenSession();
			var customersWithOrderNumberEqualsTo2 = await (GetCustomersByOrderNumberUsingWhereClauseAsync(firstSession, OrderNumber));

			var secondSession = OpenSession();
			var customers = await (GetAllCustomersAsync(secondSession));

			Assert.That(customersWithOrderNumberEqualsTo2.Single(n => n.Id == Customer1.Id).Orders, Has.Count.EqualTo(Customer1.Orders.Count(n => n.Number == OrderNumber)));
			Assert.That(customersWithOrderNumberEqualsTo2.Single(n => n.Id == Customer2.Id).Orders, Has.Count.EqualTo(Customer2.Orders.Count(n => n.Number == OrderNumber)));

			Assert.That(customers.Single(n => n.Id == Customer3.Id).Orders, Has.Count.EqualTo(Customer3.Orders.Count));
			Assert.That(customers.Single(n => n.Id == Customer1.Id).Orders, Has.Count.EqualTo(Customer1.Orders.Count));
			Assert.That(customers.Single(n => n.Id == Customer2.Id).Orders, Has.Count.EqualTo(Customer2.Orders.Count));

			firstSession.Dispose();
			secondSession.Dispose();
		}

		[Test]
		public async Task ChildCollectionsEagerFetchedShouldBeInSecondLevelCacheAsync()
		{
			var firstSession = OpenSession();
			var customersWithOrderNumberEqualsTo2 = await (GetCustomersWithOrdersEagerLoadedAsync(firstSession));

			using (var session = OpenSession())
			using (IDbCommand cmd = session.Connection.CreateCommand())
			{
				cmd.CommandText = "DELETE FROM Orders";
				cmd.ExecuteNonQuery();
				cmd.Connection.Close();
			}

			var secondSession = OpenSession();
			var customers = await (GetAllCustomersAsync(secondSession));

			Assert.That(customersWithOrderNumberEqualsTo2.Single(n => n.Id == Customer1.Id).Orders, Has.Count.EqualTo(Customer1.Orders.Count));
			Assert.That(customersWithOrderNumberEqualsTo2.Single(n => n.Id == Customer2.Id).Orders, Has.Count.EqualTo(Customer2.Orders.Count));

			Assert.That(customers.Single(n => n.Id == Customer3.Id).Orders, Has.Count.EqualTo(Customer3.Orders.Count));
			Assert.That(customers.Single(n => n.Id == Customer1.Id).Orders, Has.Count.EqualTo(Customer1.Orders.Count));
			Assert.That(customers.Single(n => n.Id == Customer2.Id).Orders, Has.Count.EqualTo(Customer2.Orders.Count));

			firstSession.Dispose();
			secondSession.Dispose();
		}

		[Test]
		public async Task ChildCollectionsFromLeftOuterJoinWithWhereClauseRestrictionOnRootShouldBeInSecondLevelCacheAsync()
		{
			var firstSession = OpenSession();
			var customersWithOrderNumberEqualsTo2 = await (GetCustomersByNameUsingWhereClauseAsync(firstSession, "First Customer"));

			using (var session = OpenSession())
			using (IDbCommand cmd = session.Connection.CreateCommand())
			{
				cmd.CommandText = "DELETE FROM Orders";
				cmd.ExecuteNonQuery();
				cmd.Connection.Close();
			}

			var secondSession = OpenSession();
			var customers = await (secondSession.GetAsync<Customer>(Customer1.Id));

			Assert.That(customersWithOrderNumberEqualsTo2.Single(n => n.Id == Customer1.Id).Orders, Has.Count.EqualTo(Customer1.Orders.Count));
			Assert.That(customers.Orders, Has.Count.EqualTo(Customer1.Orders.Count));

			firstSession.Dispose();
			secondSession.Dispose();
		}

		[Test]
		public async Task ChildCollectionsFromLeftOuterJoinShouldBeInSecondLevelCacheIfQueryContainsSubqueryWithRestrictionOnLeftOuterJoinAsync()
		{
			var firstSession = OpenSession();
			var customersWithOrderNumberEqualsTo2 = await (GetCustomersByOrderNumberUsingSubqueriesAndByNameUsingWhereClauseAsync(firstSession, OrderNumber, Customer1.Name));

			var secondSession = OpenSession();
			var customers = await (GetAllCustomersAsync(secondSession));

			Assert.That(customersWithOrderNumberEqualsTo2.Single(n => n.Id == Customer1.Id).Orders, Has.Count.EqualTo(Customer1.Orders.Count));

			using (var thirdSession = OpenSession())
			using (IDbCommand cmd = thirdSession.Connection.CreateCommand())
			{
				cmd.CommandText = "DELETE FROM Orders";
				cmd.ExecuteNonQuery();
				cmd.Connection.Close();
			}

			Assert.That(customers.Single(n => n.Id == Customer1.Id).Orders, Has.Count.EqualTo(Customer1.Orders.Count));
			Assert.That(customers.Single(n => n.Id == Customer2.Id).Orders, Has.Count.EqualTo(0));
			Assert.That(customers.Single(n => n.Id == Customer3.Id).Orders, Has.Count.EqualTo(0));

			firstSession.Dispose();
			secondSession.Dispose();
		}

		[Test]
		public virtual async Task ChildCollectionsFromLeftOuterJoinOnlyWithRestrictionShouldNotBeIn2LvlCacheAsync()
		{
			var firstSession = OpenSession();
			var customersWithOrderNumberEqualsTo2AndCompanies = await (GetCustomersWithCompaniesByOrderNumberUsingOnClauseAsync(firstSession, OrderNumber));

			using (var session = OpenSession())
			using (IDbCommand cmd = session.Connection.CreateCommand())
			{
				cmd.CommandText = "DELETE FROM Orders";
				cmd.ExecuteNonQuery();
				cmd.Connection.Close();
			}

			using (var session = OpenSession())
			using (IDbCommand cmd = session.Connection.CreateCommand())
			{
				cmd.CommandText = "DELETE FROM Companies";
				cmd.ExecuteNonQuery();
				cmd.Connection.Close();
			}

			var secondSession = OpenSession();
			var customers = await (GetAllCustomersAsync(secondSession));

			Assert.That(customersWithOrderNumberEqualsTo2AndCompanies.First(n => n.Id == Customer1.Id).Orders, Has.Count.EqualTo(Customer1.Orders.Count(n => n.Number == OrderNumber)));
			Assert.That(customersWithOrderNumberEqualsTo2AndCompanies.First(n => n.Id == Customer2.Id).Orders, Has.Count.EqualTo(Customer2.Orders.Count(n => n.Number == OrderNumber)));
			Assert.That(customersWithOrderNumberEqualsTo2AndCompanies.First(n => n.Id == Customer3.Id).Orders, Has.Count.EqualTo(Customer3.Orders.Count(n => n.Number == OrderNumber)));

			Assert.That(customersWithOrderNumberEqualsTo2AndCompanies.First(n => n.Id == Customer1.Id).Companies, Has.Count.EqualTo(Customer1.Companies.Count()));
			Assert.That(customersWithOrderNumberEqualsTo2AndCompanies.First(n => n.Id == Customer2.Id).Companies, Has.Count.EqualTo(Customer2.Companies.Count()));
			Assert.That(customersWithOrderNumberEqualsTo2AndCompanies.First(n => n.Id == Customer3.Id).Companies, Has.Count.EqualTo(Customer3.Companies.Count()));

			Assert.That(customers.Single(n => n.Id == Customer1.Id).Orders, Has.Count.EqualTo(0));
			Assert.That(customers.Single(n => n.Id == Customer2.Id).Orders, Has.Count.EqualTo(0));
			Assert.That(customers.Single(n => n.Id == Customer3.Id).Orders, Has.Count.EqualTo(0));

			Assert.That(customers.Single(n => n.Id == Customer1.Id).Companies, Has.Count.EqualTo(Customer1.Companies.Count));
			Assert.That(customers.Single(n => n.Id == Customer2.Id).Companies, Has.Count.EqualTo(Customer2.Companies.Count));
			Assert.That(customers.Single(n => n.Id == Customer3.Id).Companies, Has.Count.EqualTo(Customer3.Companies.Count));

			firstSession.Dispose();
			secondSession.Dispose();
		}

		protected async Task ClearSecondLevelCacheForAsync(System.Type entity, CancellationToken cancellationToken = default(CancellationToken))
		{
			var entityName = entity.FullName;
			await (Sfi.EvictEntityAsync(entityName, cancellationToken));
			var entityPersister = Sfi.GetEntityPersister(entityName);
			if (!entityPersister.HasCache)
				return;

			var querySpaces = entityPersister.QuerySpaces.Cast<string>().ToList().AsReadOnly();
			await (Sfi.UpdateTimestampsCache.PreInvalidateAsync(querySpaces, cancellationToken));
		}

		protected void ClearSecondLevelCacheFor(System.Type entity)
		{
			var entityName = entity.FullName;
			Sfi.EvictEntity(entityName);
			var entityPersister = Sfi.GetEntityPersister(entityName);
			if (!entityPersister.HasCache)
				return;

			var querySpaces = entityPersister.QuerySpaces.Cast<string>().ToList().AsReadOnly();
			Sfi.UpdateTimestampsCache.PreInvalidate(querySpaces);
		}

		protected Task ClearCollectionCacheAsync<T>(Expression<Func<T, IEnumerable>> pathToCollection, CancellationToken cancellationToken = default(CancellationToken))
		{
			try
			{
				var rootEntityTypeFullPath = typeof(T).FullName;
				var memberExpression = pathToCollection.Body as MemberExpression;
				if (memberExpression == null)
					return Task.FromException<object>(new ArgumentException("pathToCollection should be member expression"));

				var role = string.Format("{0}.{1}", rootEntityTypeFullPath, memberExpression.Member.Name);
				return Sfi.EvictCollectionAsync(role, cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		protected void ClearCollectionCache<T>(Expression<Func<T, IEnumerable>> pathToCollection)
		{
			var rootEntityTypeFullPath = typeof(T).FullName;
			var memberExpression = pathToCollection.Body as MemberExpression;
			if (memberExpression == null)
				throw new ArgumentException("pathToCollection should be member expression");

			var role = string.Format("{0}.{1}", rootEntityTypeFullPath, memberExpression.Member.Name);
			Sfi.EvictCollection(role);
		}

		protected abstract Task<IList<Customer>> GetCustomersWithFetchedOrdersWithoutRestrictionsAsync(ISession session, CancellationToken cancellationToken = default(CancellationToken));
		protected abstract Task<IList<Customer>> GetCustomersWithOrdersEagerLoadedAsync(ISession session, CancellationToken cancellationToken = default(CancellationToken));
		protected abstract Task<IList<Customer>> GetCustomersByOrderNumberUsingOnClauseAsync(ISession session, int orderNumber, CancellationToken cancellationToken = default(CancellationToken));
		protected abstract Task<IList<Customer>> GetCustomersByOrderNumberUsingWhereClauseAsync(ISession session, int orderNumber, CancellationToken cancellationToken = default(CancellationToken));
		protected abstract Task<IList<Customer>> GetCustomersByNameUsingWhereClauseAsync(ISession session, string customerName, CancellationToken cancellationToken = default(CancellationToken));
		protected abstract Task<IList<Customer>> GetCustomersByOrderNumberUsingSubqueriesAndByNameUsingWhereClauseAsync(ISession session, int orderNumber, string customerName, CancellationToken cancellationToken = default(CancellationToken));
		protected abstract Task<IList<Customer>> GetCustomersWithCompaniesByOrderNumberUsingOnClauseAsync(ISession session, int orderNumber, CancellationToken cancellationToken = default(CancellationToken));
		protected abstract Task<IList<Customer>> GetAllCustomersAsync(ISession session, CancellationToken cancellationToken = default(CancellationToken));
	}
}
