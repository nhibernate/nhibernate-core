//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System.Data.Common;
#if !NETCOREAPP2_0
using System.Data.Odbc;
#endif
using System.Data.SqlClient;
using System.Configuration;
using System.Transactions;
using NHibernate.Dialect;
using NUnit.Framework;

using Environment = NHibernate.Cfg.Environment;

namespace NHibernate.Test.NHSpecificTest.NH2420
{
	using System.Threading.Tasks;
	[TestFixture]
	public class FixtureAsync : BugTestCase
	{
		public override string BugNumber
		{
			get { return "NH2420"; }
		}

		protected override bool AppliesTo(Dialect.Dialect dialect)
		{
			return (dialect is MsSql2005Dialect);
		}

		private string FetchConnectionStringFromConfiguration()
		{
			string connectionString;
			if (cfg.Properties.TryGetValue(Environment.ConnectionString, out connectionString))
			{
				Assert.That(connectionString, Is.Not.Null.Or.Empty);
				return connectionString;
			}
			string connectionStringName;
			if (cfg.Properties.TryGetValue(Environment.ConnectionStringName, out connectionStringName))
			{
				var connectionStringSettings = ConfigurationManager.ConnectionStrings[connectionStringName];
				Assert.That(connectionStringSettings, Is.Not.Null);
				connectionString = connectionStringSettings.ConnectionString;
				Assert.That(connectionString, Is.Not.Null.Or.Empty);
				return connectionString;
			}
			else
			{
				Assert.Fail("Unable to find a connection string or connection string name");
				return string.Empty;
			}
		}

		[Test]
#if NETCOREAPP2_0
		[Ignore("This platform does not support distributed transactions.")]
#endif
		public async Task ShouldBeAbleToReleaseSuppliedConnectionAfterDistributedTransactionAsync()
		{
			string connectionString = FetchConnectionStringFromConfiguration();
			ISession s;
			DbConnection connection = null;
			try
			{
				using (var ts = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled))
				{
					// Enlisting DummyEnlistment as a durable resource manager will start
					// a DTC transaction
					System.Transactions.Transaction.Current.EnlistDurable(
						DummyEnlistment.Id,
						new DummyEnlistment(),
						EnlistmentOptions.None);

#if !NETCOREAPP2_0
					if (Sfi.ConnectionProvider.Driver.GetType().IsOdbcDriver())
					{
						connection = new OdbcConnection(connectionString);
					}
					else
#endif
					{
						connection = new SqlConnection(connectionString);
					}

					await (connection.OpenAsync());
					using (s = Sfi.WithOptions().Connection(connection).OpenSession())
					{
						await (s.SaveAsync(new MyTable { String = "hello!" }));
					}
					// The ts disposal may try to flush the session, which, depending on the native generator
					// implementation for current dialect, may have something to do and will then try to use
					// the supplied connection. dispose connection here => flaky test, failing for dialects
					// not mandating an immediate insert on native generator save.
					// Delaying the connection disposal to after ts disposal.

					ts.Complete();
				}
			}
			finally
			{
				connection?.Dispose();
			}

			// It appears neither the second phase of the 2PC nor TransactionCompleted 
			// event are guaranteed to be executed before exiting transaction scope disposal.
			// When having only 2PC, the second phase tends to occur after reaching that point
			// here. When having TransactionCompleted event, this event and the second phase
			// tend to occur before reaching here. But some other NH cases demonstrate that
			// TransactionCompleted may also occur "too late".
			s.GetSessionImplementation().TransactionContext?.Wait();

			// Prior to the patch, an InvalidOperationException exception would occur in the
			// TransactionCompleted delegate at this point with the message, "Disconnect cannot
			// be called while a transaction is in progress". Although the exception can be
			// seen reported in the IDE, NUnit fails to see it. The TransactionCompleted event
			// fires *after* the transaction is committed and so it doesn't affect the success
			// of the transaction.
			Assert.That(s.IsConnected, Is.False);
			Assert.That(s.GetSessionImplementation().ConnectionManager.IsConnected, Is.False);
			Assert.That(s.GetSessionImplementation().IsClosed, Is.True);
		}

		protected override void OnTearDown()
		{
			using (ISession s = OpenSession())
			{
				s.Delete("from MyTable");
				s.Flush();
			}
		}
	}
}
