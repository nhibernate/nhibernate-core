//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Linq;
using System.Linq.Expressions;
using NHibernate.Cfg.MappingSchema;
using NHibernate.Linq;
using NHibernate.Mapping.ByCode;
using NUnit.Framework;

namespace NHibernate.Test.NHSpecificTest.NH3918
{
	using System.Threading.Tasks;
	using System.Threading;
	[TestFixture]
	public class ByCodeFixtureAsync : TestCaseMappingByCode
	{
		protected override HbmMapping GetMappings()
		{
			var mapper = new ModelMapper();
			mapper.Class<Owner>(rc =>
			{
				rc.Id(x => x.Id, m => m.Generator(Generators.GuidComb));
				rc.Property(x => x.Name);
			});
			mapper.Class<Entity>(rc =>
			{
				rc.Id(x => x.Id, m => m.Generator(Generators.GuidComb));
				rc.Property(x => x.Name);
				rc.ManyToOne(m => m.Owner, m =>
				{
					m.Column("OwnerId");
				});
			});

			return mapper.CompileMappingForAllExplicitlyAddedEntities();
		}

		protected override void OnSetUp()
		{
			using (ISession session = OpenSession())
			using (ITransaction transaction = session.BeginTransaction())
			{
				var bob =  CreateOwner(session, "Bob");
				var carl = CreateOwner(session, "Carl");
				var doug = CreateOwner(session, "Doug");

				CreateEntity(session, "Test 1", bob);
				CreateEntity(session, "Test 2", carl);
				CreateEntity(session, "Test 3", doug);
				CreateEntity(session, "Test 4", bob);
				CreateEntity(session, "Test 5", carl);
				CreateEntity(session, "Test 6", doug);

				session.Flush();
				transaction.Commit();
			}
		}

		protected async Task<Owner> CreateOwnerAsync(ISession session, string name, CancellationToken cancellationToken = default(CancellationToken))
		{
			var t = new Owner { Name = name };
			await (session.SaveAsync(t, cancellationToken));
			return t;
		}

		protected Owner CreateOwner(ISession session, string name)
		{
			var t = new Owner { Name = name };
			session.Save(t);
			return t;
		}

		protected Task CreateEntityAsync(ISession session, string name, Owner owner, CancellationToken cancellationToken = default(CancellationToken))
		{
			try
			{
				var t = new Entity
			{
				Name = name,
				Owner = owner,
			};
				return session.SaveAsync(t, cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		protected void CreateEntity(ISession session, string name, Owner owner)
		{
			var t = new Entity
			{
				Name = name,
				Owner = owner,
			};
			session.Save(t);
		}

		protected override void OnTearDown()
		{
			using (ISession session = OpenSession())
			using (ITransaction transaction = session.BeginTransaction())
			{
				session.Delete("from Entity");
				session.Delete("from Owner");

				session.Flush();
				transaction.Commit();
			}
		}

		[Test]
		public async Task EntityComparisonTestAsync()
		{
			using (ISession session = OpenSession())
			using (session.BeginTransaction())
			{
				var bob = await (session.Query<Owner>().SingleAsync(o => o.Name == "Bob"));

				var queryWithWhere = session.Query<Entity>()
										.Where(WhereExpression(bob))
										.Select(e => e.Name);
				var queryWithSelect = session.Query<Entity>()
										.Select(SelectExpression(bob));

				var resultsFromWhere = await (queryWithWhere.ToListAsync());
				var resultsFromSelect = await (queryWithSelect.ToListAsync());

				Assert.That(resultsFromSelect.Where(x => (bool)x[1]).Select(x => (string)x[0]), Is.EquivalentTo(resultsFromWhere));
			}
		}

		[Test]
		public async Task EntityComparisonTestAgainAsync()
		{
			// When the entire fixture is run this will execute the test again within the same ISessionFactory which will test caching
			await (EntityComparisonTestAsync());
		}

		protected Expression<Func<Entity, bool>> WhereExpression(Owner owner)
		{
			return e => e.Owner == owner;
		}

		protected Expression<Func<Entity, object[]>> SelectExpression(Owner owner)
		{
			return e => new object[]
			{
				e.Name,
				e.Owner == owner
			};
		}
	}
}
