//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System.Collections;

using NHibernate.Impl;

using NUnit.Framework;

namespace NHibernate.Test.NHSpecificTest.Logs
{
	using System;
	using System.IO;
	using System.Text;
	using log4net;
	using log4net.Appender;
	using log4net.Core;
	using log4net.Layout;
	using log4net.Repository.Hierarchy;
	using System.Threading.Tasks;

	[TestFixture]
	public class LogsFixtureAsync : TestCase
	{
		protected override IList Mappings
		{
			get { return new[] { "NHSpecificTest.Logs.Mappings.hbm.xml" }; }
		}

		protected override string MappingsAssembly
		{
			get { return "NHibernate.Test"; }
		}

		[Test]
		public async Task WillGetSessionIdFromSessionLogsAsync()
		{
			GlobalContext.Properties["sessionId"] = new SessionIdCapturer();

			using (var spy = new TextLogSpy("NHibernate.SQL", "%message | SessionId: %property{sessionId}"))
			using (var s = Sfi.OpenSession())
			{
				var sessionId = ((SessionImpl)s).SessionId;

				await (s.GetAsync<Person>(1));//will execute some sql

				var loggingEvent = spy.GetWholeLog();
				Assert.That(loggingEvent.Contains(sessionId.ToString()), Is.True);
			}
		}

		// IFixingRequired interface ensures the value is evaluated at log time rather than at log buffer flush time.
		public class SessionIdCapturer : IFixingRequired
		{
			public object GetFixedObject() => ToString();

			public override string ToString()
			{
				return SessionIdLoggingContext.SessionId.ToString();
			}
		}

		public class TextLogSpy : IDisposable
		{
			private readonly TextWriterAppender appender;
			private readonly Logger loggerImpl;
			private readonly StringBuilder stringBuilder;
			private readonly Level previousLevel;

			public TextLogSpy(string loggerName, string pattern)
			{
				stringBuilder = new StringBuilder();
				appender = new TextWriterAppender
				{
					Layout = new PatternLayout(pattern),
					Threshold = Level.All,
					Writer = new StringWriter(stringBuilder)
				};
				loggerImpl = (Logger)LogManager.GetLogger(typeof(LogsFixtureAsync).Assembly, loggerName).Logger;
				loggerImpl.AddAppender(appender);
				previousLevel = loggerImpl.Level;
				loggerImpl.Level = Level.All;
			}

			public string GetWholeLog()
			{
				return stringBuilder.ToString();
			}

			public void Dispose()
			{
				loggerImpl.RemoveAppender(appender);
				loggerImpl.Level = previousLevel;
			}
		}
	}


}
