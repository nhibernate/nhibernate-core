//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text;
using NHibernate.Dialect;
using NHibernate.Linq;
using NHibernate.Util;
using NUnit.Framework;

namespace NHibernate.Test.NHSpecificTest.NH3850
{
	using System.Threading.Tasks;
	using System.Threading;
	[TestFixture]
	public class MainFixtureAsync : FixtureBaseAsync
	{
		// Failing case till NH-3850 is fixed
		[Test]
		public async Task AggregateGBaseAsync()
		{
			using (var session = OpenSession())
			{
				// This case should work because the aggregate is insensitive to ordering.
				var query = session.Query<DomainClassGExtendedByH>()
				                   .OrderBy(dc => dc.Id)
				                   .Select(dc => dc.Id);
				var result = query.Aggregate((p, n) => p + n);
				Assert.That(result, Is.EqualTo(10));
				var futureQuery = query.ToFutureValue(qdc => qdc.Aggregate((p, n) => p + n));
				Assert.That(await (futureQuery.GetValueAsync()), Is.EqualTo(10), "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task AggregateMutableSeedGBaseAsync()
		{
			using (var session = OpenSession())
			{
				// This case works because the ordering accidentally matches with classes ordering.
				// (And moreover, with current dataset, selected values are same whatever the classes.)
				var query = session.Query<DomainClassGExtendedByH>()
				                    .OrderBy(dc => dc.Id);
				var seed = new StringBuilder();
				var result = query.Aggregate(seed, (s, dc) => s.Append(dc.Name).Append(","));
				var expectedResult = SearchName1 + "," + SearchName2 + "," + SearchName1 + "," + SearchName2 + ",";
				Assert.That(result.ToString(), Is.EqualTo(expectedResult));
				// We are dodging another bug here: the seed is cached in query plan... So giving another seed to Future
				// keeps re-using the seed used for non future above.
				seed.Clear();
				var futureQuery = query.ToFutureValue(qdc => qdc.Aggregate(seed, (s, dc) => s.Append(dc.Name).Append(",")));
				Assert.That((await (futureQuery.GetValueAsync())).ToString(), Is.EqualTo(expectedResult), "Future");
			}
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task AggregateSeedGBaseAsync()
		{
			using (var session = OpenSession())
			{
				// This case should work because the aggregate is insensitive to ordering.
				var query = session.Query<DomainClassGExtendedByH>()
				                   .OrderBy(dc => dc.Id);
				var result = query.Aggregate(5, (s, dc) => s + dc.Id);
				Assert.That(result, Is.EqualTo(15));
				var futureQuery = query.ToFutureValue(qdc => qdc.Aggregate(5, (s, dc) => s + dc.Id));
				Assert.That(await (futureQuery.GetValueAsync()), Is.EqualTo(15), "Future");
			}
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task AllBBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassBExtendedByA>().AllAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.False);
				result = await (session.Query<DomainClassBExtendedByA>().ToFutureValue(qdc => qdc.All(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.False, "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task AllCBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassCExtendedByD>().AllAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.False);
				result = await (session.Query<DomainClassCExtendedByD>().ToFutureValue(qdc => qdc.All(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.False, "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task AllEWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassE>().AllAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.False);
				result = await (session.Query<DomainClassE>().ToFutureValue(qdc => qdc.All(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.False, "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task AllFWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassF>().AllAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.True);
				result = await (session.Query<DomainClassF>().ToFutureValue(qdc => qdc.All(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.True, "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task AllGBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassGExtendedByH>().AllAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.False);
				result = await (session.Query<DomainClassGExtendedByH>().ToFutureValue(qdc => qdc.All(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.False, "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task AllGBaseWithNameFilteredByNameAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassGExtendedByH>()
				                   .Where(dc => dc.Name == SearchName1);
				var result = await (query.AllAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.True);
				var futureQuery = query.ToFutureValue(qdc => qdc.All(dc => dc.Name == SearchName1));
				Assert.That(await (futureQuery.GetValueAsync()), Is.True, "Future");
			}
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task AnyBBaseAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassBExtendedByA>().AnyAsync());
				Assert.That(result, Is.True);
				result = await (session.Query<DomainClassBExtendedByA>().ToFutureValue(qdc => qdc.Any()).GetValueAsync());
				Assert.That(result, Is.True, "Future");
			}
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task AnyBBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassBExtendedByA>().AnyAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.True);
				result = await (session.Query<DomainClassBExtendedByA>().ToFutureValue(qdc => qdc.Any(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.True, "Future");
			}
		}

		[Test]
		public async Task ContainsBBaseAsync()
		{
			using (var session = OpenSession())
			{
				var item = await (session.Query<DomainClassBExtendedByA>().FirstAsync(dc => dc.Name == SearchName1));
				var result = session.Query<DomainClassBExtendedByA>().Contains(item);
				Assert.That(result, Is.True);
			}
		}

		// Non-reg case
		[Test]
		public async Task AnyCBaseAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassCExtendedByD>().AnyAsync());
				Assert.That(result, Is.True);
				result = await (session.Query<DomainClassCExtendedByD>().ToFutureValue(qdc => qdc.Any()).GetValueAsync());
				Assert.That(result, Is.True, "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task AnyCBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassCExtendedByD>().AnyAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.True);
				result = await (session.Query<DomainClassCExtendedByD>().ToFutureValue(qdc => qdc.Any(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.True, "Future");
			}
		}

		[Test]
		public async Task ContainsCBaseAsync()
		{
			using (var session = OpenSession())
			{
				var item = await (session.Query<DomainClassCExtendedByD>().FirstAsync(dc => dc.Name == SearchName1));
				var result = session.Query<DomainClassCExtendedByD>().Contains(item);
				Assert.That(result, Is.True);
			}
		}

		// Non-reg case
		[Test]
		public async Task AnyEAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassE>().AnyAsync());
				Assert.That(result, Is.True);
				result = await (session.Query<DomainClassE>().ToFutureValue(qdc => qdc.Any()).GetValueAsync());
				Assert.That(result, Is.True, "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task AnyEWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassE>().AnyAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.True);
				result = await (session.Query<DomainClassE>().ToFutureValue(qdc => qdc.Any(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.True, "Future");
			}
		}

		[Test]
		public async Task ContainsEAsync()
		{
			using (var session = OpenSession())
			{
				var item = await (session.Query<DomainClassE>().FirstAsync(dc => dc.Name == SearchName1));
				var result = session.Query<DomainClassE>().Contains(item);
				Assert.That(result, Is.True);
			}
		}

		// Non-reg case
		[Test]
		public async Task AnyFAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassF>().AnyAsync());
				Assert.That(result, Is.False);
				result = await (session.Query<DomainClassF>().ToFutureValue(qdc => qdc.Any()).GetValueAsync());
				Assert.That(result, Is.False, "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task AnyFWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassF>().AnyAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.False);
				result = await (session.Query<DomainClassF>().ToFutureValue(qdc => qdc.Any(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.False, "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task AnyGBaseAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassGExtendedByH>().AnyAsync());
				Assert.That(result, Is.True);
				result = await (session.Query<DomainClassGExtendedByH>().ToFutureValue(qdc => qdc.Any()).GetValueAsync());
				Assert.That(result, Is.True, "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task AnyGBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassGExtendedByH>().AnyAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.True);
				result = await (session.Query<DomainClassGExtendedByH>().ToFutureValue(qdc => qdc.Any(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.True, "Future");
			}
		}

		[Test]
		public async Task ContainsGBaseAsync()
		{
			using (var session = OpenSession())
			{
				var item = await (session.Query<DomainClassGExtendedByH>().FirstAsync(dc => dc.Name == SearchName1));
				var result = session.Query<DomainClassGExtendedByH>().Contains(item);
				Assert.That(result, Is.True);
			}
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task AnyObjectAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<object>().AnyAsync());
				Assert.That(result, Is.True);
				result = await (session.Query<object>().ToFutureValue(qdc => qdc.Any()).GetValueAsync());
				Assert.That(result, Is.True, "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task AverageEAsync()
		{
			await (AverageAsync<DomainClassE>(1.5m));
		}

		// Non-reg case
		[Test]
		public async Task AverageFAsync()
		{
			await (AverageAsync<DomainClassF>(null));
		}

		private async Task AverageAsync<DC>(decimal? expectedResult, CancellationToken cancellationToken = default(CancellationToken)) where DC : DomainClassBase
		{
			using (var session = OpenSession())
			{
				var dcQuery = session.Query<DC>();
				var integ = await (dcQuery.AverageAsync(dc => dc.Integer, cancellationToken));
				Assert.AreEqual(expectedResult, integ, "Integer average has failed");
				var futureInteg = dcQuery.ToFutureValue(qdc => qdc.Average(dc => dc.Integer));
				Assert.That(await (futureInteg.GetValueAsync(cancellationToken)), Is.EqualTo(expectedResult), "Future integer average has failed");

				var longInt = await (dcQuery.AverageAsync(dc => dc.Long, cancellationToken));
				Assert.AreEqual(expectedResult, longInt, "Long integer average has failed");
				var futureLongInt = dcQuery.ToFutureValue(qdc => qdc.Average(dc => dc.Long));
				Assert.That(await (futureLongInt.GetValueAsync(cancellationToken)), Is.EqualTo(expectedResult), "Future long integer average has failed");

				var dec = await (dcQuery.AverageAsync(dc => dc.Decimal, cancellationToken));
				Assert.AreEqual(expectedResult, dec, "Decimal average has failed");
				var futureDec = dcQuery.ToFutureValue(qdc => qdc.Average(dc => dc.Decimal));
				Assert.That(await (futureDec.GetValueAsync(cancellationToken)), Is.EqualTo(expectedResult), "Future decimal average has failed");

				var dbl = await (dcQuery.AverageAsync(dc => dc.Double, cancellationToken));
				Assert.That(dbl.HasValue, Is.EqualTo(expectedResult.HasValue),"Double average has failed");
				if (expectedResult.HasValue)
					Assert.That(dbl.Value, Is.EqualTo(expectedResult).Within(0.001d), "Double average has failed");
				var futureDbl = dcQuery.ToFutureValue(qdc => qdc.Average(dc => dc.Double));
				Assert.That((await (futureDbl.GetValueAsync(cancellationToken))).HasValue, Is.EqualTo(expectedResult.HasValue),"Future double average has failed");
				if (expectedResult.HasValue)
					Assert.That((await (futureDbl.GetValueAsync(cancellationToken))).Value, Is.EqualTo(expectedResult).Within(0.001d), "Future double average has failed");

				if (expectedResult.HasValue)
				{
					var nonNullableDecimal = -1m;
					Assert.That(async () => nonNullableDecimal = await (dcQuery.AverageAsync(dc => dc.NonNullableDecimal, cancellationToken)), Throws.Nothing, "Non nullable decimal average has failed");
					Assert.That(nonNullableDecimal, Is.EqualTo(expectedResult), "Non nullable decimal average has failed");
					var futureNonNullableDec = dcQuery.ToFutureValue(qdc => qdc.Average(dc => dc.NonNullableDecimal));
					Assert.That(async () => nonNullableDecimal = await (futureNonNullableDec.GetValueAsync(cancellationToken)), Throws.Nothing, "Future non nullable decimal average has failed");
					Assert.That(nonNullableDecimal, Is.EqualTo(expectedResult), "Future non nullable decimal average has failed");
				}
				else
				{
					Assert.That(() => dcQuery.AverageAsync(dc => dc.NonNullableDecimal, cancellationToken),
					            // After fix
					            Throws.InstanceOf<InvalidOperationException>()
					                  // Before fix
					                  .Or.InnerException.InstanceOf<ArgumentNullException>(),
					            "Non nullable decimal average has failed");
					var futureNonNullableDec = dcQuery.ToFutureValue(qdc => qdc.Average(dc => dc.NonNullableDecimal));
					Assert.That(() => futureNonNullableDec.GetValueAsync(cancellationToken),
					            Throws.InstanceOf<ArgumentNullException>()
					                  // When multi-queries are not supported, we have a discrepancy here.
					                  .Or.InnerException.InstanceOf<ArgumentNullException>(),
					            "Future non nullable decimal average has failed");
				}
			}
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task CountBBaseAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassBExtendedByA>().CountAsync());
				Assert.That(result, Is.EqualTo(2));
				result = await (session.Query<DomainClassBExtendedByA>().ToFutureValue(qdc => qdc.Count()).GetValueAsync());
				Assert.That(result, Is.EqualTo(2), "Future");
			}
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task CountBBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassBExtendedByA>().CountAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.EqualTo(1));
				result = await (session.Query<DomainClassBExtendedByA>().ToFutureValue(qdc => qdc.Count(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.EqualTo(1), "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task CountCBaseAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassCExtendedByD>().CountAsync());
				Assert.That(result, Is.EqualTo(2));
				result = await (session.Query<DomainClassCExtendedByD>().ToFutureValue(qdc => qdc.Count()).GetValueAsync());
				Assert.That(result, Is.EqualTo(2), "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task CountCBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassCExtendedByD>().CountAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.EqualTo(1));
				result = await (session.Query<DomainClassCExtendedByD>().ToFutureValue(qdc => qdc.Count(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.EqualTo(1), "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task CountEAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassE>().CountAsync());
				Assert.That(result, Is.EqualTo(2));
				result = await (session.Query<DomainClassE>().ToFutureValue(qdc => qdc.Count()).GetValueAsync());
				Assert.That(result, Is.EqualTo(2), "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task CountEWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassE>().CountAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.EqualTo(1));
				result = await (session.Query<DomainClassE>().ToFutureValue(qdc => qdc.Count(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.EqualTo(1), "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task CountFAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassF>().CountAsync());
				Assert.That(result, Is.EqualTo(0));
				result = await (session.Query<DomainClassF>().ToFutureValue(qdc => qdc.Count()).GetValueAsync());
				Assert.That(result, Is.EqualTo(0), "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task CountFWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassF>().CountAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.EqualTo(0));
				result = await (session.Query<DomainClassF>().ToFutureValue(qdc => qdc.Count(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.EqualTo(0), "Future");
			}
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task CountGBaseAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassGExtendedByH>().CountAsync());
				Assert.That(result, Is.EqualTo(4));
				result = await (session.Query<DomainClassGExtendedByH>().ToFutureValue(qdc => qdc.Count()).GetValueAsync());
				Assert.That(result, Is.EqualTo(4), "Future");
			}
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task CountGBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassGExtendedByH>().CountAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.EqualTo(2));
				result = await (session.Query<DomainClassGExtendedByH>().ToFutureValue(qdc => qdc.Count(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.EqualTo(2), "Future");
			}
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task CountObjectAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<object>().CountAsync());
				Assert.That(result, Is.EqualTo(TotalEntityCount));
				result = await (session.Query<object>().ToFutureValue(qdc => qdc.Count()).GetValueAsync());
				Assert.That(result, Is.EqualTo(TotalEntityCount), "Future");
			}
		}

		// Non-reg case
		[Test]
		public void FirstOrDefaultBBaseAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassBExtendedByA>();
				DomainClassBExtendedByA result = null;
				Assert.That(async () => result = await (query.FirstOrDefaultAsync()), Throws.Nothing);
				Assert.That(result, Is.Not.Null);
				Assert.That(result, Is.TypeOf<DomainClassBExtendedByA>());
				var futureQuery = query.ToFutureValue(qdc => qdc.FirstOrDefault());
				Assert.That(async () => result = await (futureQuery.GetValueAsync()), Throws.Nothing, "Future");
				Assert.That(result, Is.Not.Null, "Future");
				Assert.That(result, Is.TypeOf<DomainClassBExtendedByA>(), "Future");
			}
		}

		// Non-reg case
		[Test]
		public void FirstOrDefaultBBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassBExtendedByA>();
				DomainClassBExtendedByA result = null;
				Assert.That(async () => result = await (query.FirstOrDefaultAsync(dc => dc.Name == SearchName1)), Throws.Nothing);
				Assert.That(result, Is.Not.Null);
				Assert.That(result.Name, Is.EqualTo(SearchName1));
				Assert.That(result, Is.TypeOf<DomainClassBExtendedByA>());
				var futureQuery = query.ToFutureValue(qdc => qdc.FirstOrDefault(dc => dc.Name == SearchName1));
				Assert.That(async () => result = await (futureQuery.GetValueAsync()), Throws.Nothing, "Future");
				Assert.That(result, Is.Not.Null, "Future");
				Assert.That(result.Name, Is.EqualTo(SearchName1), "Future");
				Assert.That(result, Is.TypeOf<DomainClassBExtendedByA>(), "Future");
			}
		}

		// Non-reg case
		[Test]
		public void FirstOrDefaultCBaseAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassCExtendedByD>();
				DomainClassCExtendedByD result = null;
				Assert.That(async () => result = await (query.FirstOrDefaultAsync()), Throws.Nothing);
				Assert.That(result, Is.Not.Null);
				Assert.That(result, Is.TypeOf<DomainClassCExtendedByD>());
				var futureQuery = query.ToFutureValue(qdc => qdc.FirstOrDefault());
				Assert.That(async () => result = await (futureQuery.GetValueAsync()), Throws.Nothing, "Future");
				Assert.That(result, Is.Not.Null, "Future");
				Assert.That(result, Is.TypeOf<DomainClassCExtendedByD>(), "Future");
			}
		}

		// Non-reg case
		[Test]
		public void FirstOrDefaultCBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassCExtendedByD>();
				DomainClassCExtendedByD result = null;
				Assert.That(async () => result = await (query.FirstOrDefaultAsync(dc => dc.Name == SearchName1)), Throws.Nothing);
				Assert.That(result, Is.Not.Null);
				Assert.That(result.Name, Is.EqualTo(SearchName1));
				Assert.That(result, Is.TypeOf<DomainClassCExtendedByD>());
				var futureQuery = query.ToFutureValue(qdc => qdc.FirstOrDefault(dc => dc.Name == SearchName1));
				Assert.That(async () => result = await (futureQuery.GetValueAsync()), Throws.Nothing, "Future");
				Assert.That(result, Is.Not.Null, "Future");
				Assert.That(result.Name, Is.EqualTo(SearchName1), "Future");
				Assert.That(result, Is.TypeOf<DomainClassCExtendedByD>(), "Future");
			}
		}

		// Non-reg case
		[Test]
		public void FirstOrDefaultEAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassE>();
				DomainClassE result = null;
				Assert.That(async () => result = await (query.FirstOrDefaultAsync()), Throws.Nothing);
				Assert.That(result, Is.Not.Null);
				var futureQuery = query.ToFutureValue(qdc => qdc.FirstOrDefault());
				Assert.That(async () => result = await (futureQuery.GetValueAsync()), Throws.Nothing, "Future");
				Assert.That(result, Is.Not.Null, "Future");
			}
		}

		// Non-reg case
		[Test]
		public void FirstOrDefaultEWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassE>();
				DomainClassE result = null;
				Assert.That(async () => result = await (query.FirstOrDefaultAsync(dc => dc.Name == SearchName1)), Throws.Nothing);
				Assert.That(result, Is.Not.Null);
				Assert.That(result.Name, Is.EqualTo(SearchName1));
				var futureQuery = query.ToFutureValue(qdc => qdc.FirstOrDefault(dc => dc.Name == SearchName1));
				Assert.That(async () => result = await (futureQuery.GetValueAsync()), Throws.Nothing, "Future");
				Assert.That(result, Is.Not.Null, "Future");
				Assert.That(result.Name, Is.EqualTo(SearchName1), "Future");
			}
		}

		// Non-reg case
		[Test]
		public void FirstOrDefaultFAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassF>();
				DomainClassF result = null;
				Assert.That(async () => result = await (query.FirstOrDefaultAsync()), Throws.Nothing);
				Assert.That(result, Is.Null);
				var futureQuery = query.ToFutureValue(qdc => qdc.FirstOrDefault());
				Assert.That(async () => result = await (futureQuery.GetValueAsync()), Throws.Nothing, "Future");
				Assert.That(result, Is.Null, "Future");
			}
		}

		// Non-reg case
		[Test]
		public void FirstOrDefaultFWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassF>();
				DomainClassF result = null;
				Assert.That(async () => result = await (query.FirstOrDefaultAsync(dc => dc.Name == SearchName1)), Throws.Nothing);
				Assert.That(result, Is.Null);
				var futureQuery = query.ToFutureValue(qdc => qdc.FirstOrDefault(dc => dc.Name == SearchName1));
				Assert.That(async () => result = await (futureQuery.GetValueAsync()), Throws.Nothing, "Future");
				Assert.That(result, Is.Null, "Future");
			}
		}

		// Non-reg case
		[Test]
		public void FirstOrDefaultGBaseAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassGExtendedByH>();
				DomainClassGExtendedByH result = null;
				Assert.That(async () => result = await (query.FirstOrDefaultAsync()), Throws.Nothing);
				Assert.That(result, Is.Not.Null);
				// If class type assert starts failing, maybe just ignore it: order of first on polymorphic queries looks unspecified to me.
				Assert.That(result, Is.TypeOf<DomainClassGExtendedByH>());
				var futureQuery = query.ToFutureValue(qdc => qdc.FirstOrDefault());
				Assert.That(async () => result = await (futureQuery.GetValueAsync()), Throws.Nothing, "Future");
				Assert.That(result, Is.Not.Null, "Future");
				// If class type assert starts failing, maybe just ignore it: order of first on polymorphic queries looks unspecified to me.
				Assert.That(result, Is.TypeOf<DomainClassGExtendedByH>(), "Future");
			}
		}

		// Non-reg case
		[Test]
		public void FirstOrDefaultGBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassGExtendedByH>();
				DomainClassGExtendedByH result = null;
				Assert.That(async () => result = await (query.FirstOrDefaultAsync(dc => dc.Name == SearchName1)), Throws.Nothing);
				Assert.That(result, Is.Not.Null);
				Assert.That(result.Name, Is.EqualTo(SearchName1));
				// If class type assert starts failing, maybe just ignore it: order of first on polymorphic queries looks unspecified to me.
				Assert.That(result, Is.TypeOf<DomainClassGExtendedByH>());
				var futureQuery = query.ToFutureValue(qdc => qdc.FirstOrDefault(dc => dc.Name == SearchName1));
				Assert.That(async () => result = await (futureQuery.GetValueAsync()), Throws.Nothing, "Future");
				Assert.That(result, Is.Not.Null, "Future");
				Assert.That(result.Name, Is.EqualTo(SearchName1), "Future");
				// If class type assert starts failing, maybe just ignore it: order of first on polymorphic queries looks unspecified to me.
				Assert.That(result, Is.TypeOf<DomainClassGExtendedByH>(), "Future");
			}
		}

		// Non-reg case
		[Test]
		public void FirstOrDefaultObjectAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<object>();
				object result = null;
				Assert.That(async () => result = await (query.FirstOrDefaultAsync()), Throws.Nothing);
				Assert.That(result, Is.Not.Null);
				// If class type assert starts failing, maybe just ignore it: order of first on polymorphic queries looks unspecified to me.
				Assert.That(result, Is.TypeOf<DomainClassBExtendedByA>());
				var futureQuery = query.ToFutureValue(qdc => qdc.FirstOrDefault());
				Assert.That(async () => result = await (futureQuery.GetValueAsync()), Throws.Nothing, "Future");
				Assert.That(result, Is.Not.Null, "Future");
				// If class type assert starts failing, maybe just ignore it: order of first on polymorphic queries looks unspecified to me.
				Assert.That(result, Is.TypeOf<DomainClassBExtendedByA>(), "Future");
			}
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task LongCountBBaseAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassBExtendedByA>().LongCountAsync());
				Assert.That(result, Is.EqualTo(2));
				result = await (session.Query<DomainClassBExtendedByA>().ToFutureValue(qdc => qdc.LongCount()).GetValueAsync());
				Assert.That(result, Is.EqualTo(2), "Future");
			}
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task LongCountBBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassBExtendedByA>().LongCountAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.EqualTo(1));
				result = await (session.Query<DomainClassBExtendedByA>().ToFutureValue(qdc => qdc.LongCount(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.EqualTo(1), "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task LongCountCBaseAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassCExtendedByD>().LongCountAsync());
				Assert.That(result, Is.EqualTo(2));
				result = await (session.Query<DomainClassCExtendedByD>().ToFutureValue(qdc => qdc.LongCount()).GetValueAsync());
				Assert.That(result, Is.EqualTo(2), "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task LongCountCBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassCExtendedByD>().LongCountAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.EqualTo(1));
				result = await (session.Query<DomainClassCExtendedByD>().ToFutureValue(qdc => qdc.LongCount(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.EqualTo(1), "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task LongCountEAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassE>().LongCountAsync());
				Assert.That(result, Is.EqualTo(2));
				result = await (session.Query<DomainClassE>().ToFutureValue(qdc => qdc.LongCount()).GetValueAsync());
				Assert.That(result, Is.EqualTo(2), "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task LongCountEWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassE>().LongCountAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.EqualTo(1));
				result = await (session.Query<DomainClassE>().ToFutureValue(qdc => qdc.LongCount(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.EqualTo(1), "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task LongCountFAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassF>().LongCountAsync());
				Assert.That(result, Is.EqualTo(0));
				result = await (session.Query<DomainClassF>().ToFutureValue(qdc => qdc.LongCount()).GetValueAsync());
				Assert.That(result, Is.EqualTo(0), "Future");
			}
		}

		// Non-reg case
		[Test]
		public async Task LongCountFWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassF>().LongCountAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.EqualTo(0));
				result = await (session.Query<DomainClassF>().ToFutureValue(qdc => qdc.LongCount(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.EqualTo(0), "Future");
			}
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task LongCountGBaseAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassGExtendedByH>().LongCountAsync());
				Assert.That(result, Is.EqualTo(4));
				result = await (session.Query<DomainClassGExtendedByH>().ToFutureValue(qdc => qdc.LongCount()).GetValueAsync());
				Assert.That(result, Is.EqualTo(4), "Future");
			}
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task LongCountGBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<DomainClassGExtendedByH>().LongCountAsync(dc => dc.Name == SearchName1));
				Assert.That(result, Is.EqualTo(2));
				result = await (session.Query<DomainClassGExtendedByH>().ToFutureValue(qdc => qdc.LongCount(dc => dc.Name == SearchName1)).GetValueAsync());
				Assert.That(result, Is.EqualTo(2), "Future");
			}
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task LongCountObjectAsync()
		{
			using (var session = OpenSession())
			{
				var result = await (session.Query<object>().LongCountAsync());
				Assert.That(result, Is.EqualTo(TotalEntityCount));
				result = await (session.Query<object>().ToFutureValue(qdc => qdc.LongCount()).GetValueAsync());
				Assert.That(result, Is.EqualTo(TotalEntityCount), "Future");
			}
		}

		protected override async Task MaxAsync<TDc>(int? expectedResult, CancellationToken cancellationToken = default(CancellationToken))
		{
			using (var session = OpenSession())
			{
				var dcQuery = session.Query<TDc>();
				var name = await (dcQuery.MaxAsync(dc => dc.Name, cancellationToken));
				Assert.That(name, Is.EqualTo(expectedResult.HasValue ? SearchName2 : null), "String max has failed");
				var futureName = dcQuery.ToFutureValue(qdc => qdc.Max(dc => dc.Name));
				Assert.That(await (futureName.GetValueAsync(cancellationToken)), Is.EqualTo(expectedResult.HasValue ? SearchName2 : null), "Future string max has failed");

				var integ = await (dcQuery.MaxAsync(dc => dc.Integer, cancellationToken));
				Assert.That(integ, Is.EqualTo(expectedResult), "Integer max has failed");
				var futureInteg = dcQuery.ToFutureValue(qdc => qdc.Max(dc => dc.Integer));
				Assert.That(await (futureInteg.GetValueAsync(cancellationToken)), Is.EqualTo(expectedResult), "Future integer max has failed");

				var longInt = await (dcQuery.MaxAsync(dc => dc.Long, cancellationToken));
				Assert.That(longInt, Is.EqualTo(expectedResult), "Long integer max has failed");
				var futureLongInt = dcQuery.ToFutureValue(qdc => qdc.Max(dc => dc.Long));
				Assert.That(await (futureLongInt.GetValueAsync(cancellationToken)), Is.EqualTo(expectedResult), "Future long integer max has failed");

				var dec = await (dcQuery.MaxAsync(dc => dc.Decimal, cancellationToken));
				Assert.That(dec, Is.EqualTo(expectedResult), "Decimal max has failed");
				var futureDec = dcQuery.ToFutureValue(qdc => qdc.Max(dc => dc.Decimal));
				Assert.That(await (futureDec.GetValueAsync(cancellationToken)), Is.EqualTo(expectedResult), "Future decimal max has failed");

				var dbl = await (dcQuery.MaxAsync(dc => dc.Double, cancellationToken));
				Assert.That(dbl.HasValue, Is.EqualTo(expectedResult.HasValue),"Double max has failed");
				if (expectedResult.HasValue)
					Assert.That(dbl.Value, Is.EqualTo(expectedResult).Within(0.001d), "Double max has failed");
				var futureDbl = dcQuery.ToFutureValue(qdc => qdc.Max(dc => dc.Double));
				Assert.That((await (futureDbl.GetValueAsync(cancellationToken))).HasValue, Is.EqualTo(expectedResult.HasValue),"Future double max has failed");
				if (expectedResult.HasValue)
					Assert.That((await (futureDbl.GetValueAsync(cancellationToken))).Value, Is.EqualTo(expectedResult).Within(0.001d), "Future double max has failed");

				var date = await (dcQuery.MaxAsync(dc => dc.DateTime, cancellationToken));
				var futureDate = dcQuery.ToFutureValue(qdc => qdc.Max(dc => dc.DateTime));
				if (expectedResult.HasValue)
				{
					Assert.That(date, Is.GreaterThan(TestDate), "DateTime max has failed");
					Assert.That(await (futureDate.GetValueAsync(cancellationToken)), Is.GreaterThan(TestDate), "Future DateTime max has failed");
				}
				else
				{
					Assert.That(date, Is.Null, "DateTime max has failed");
					Assert.That(await (futureDate.GetValueAsync(cancellationToken)), Is.Null, "Future DateTime max has failed");
				}

				if (expectedResult.HasValue)
				{
					var nonNullableDecimal = -1m;
					Assert.That(async () => nonNullableDecimal = await (dcQuery.MaxAsync(dc => dc.NonNullableDecimal, cancellationToken)), Throws.Nothing, "Non nullable decimal max has failed");
					Assert.That(nonNullableDecimal, Is.EqualTo(expectedResult), "Non nullable decimal max has failed");
					var futureNonNullableDec = dcQuery.ToFutureValue(qdc => qdc.Max(dc => dc.NonNullableDecimal));
					Assert.That(async () => nonNullableDecimal = await (futureNonNullableDec.GetValueAsync(cancellationToken)), Throws.Nothing, "Future non nullable decimal max has failed");
					Assert.That(nonNullableDecimal, Is.EqualTo(expectedResult), "Future non nullable decimal max has failed");
				}
				else
				{
					Assert.That(() => dcQuery.MaxAsync(dc => dc.NonNullableDecimal, cancellationToken),
					            // After fix
					            Throws.InstanceOf<InvalidOperationException>()
					                  // Before fix
					                  .Or.InnerException.InstanceOf<ArgumentNullException>(),
					            "Non nullable decimal max has failed");
					var futureNonNullableDec = dcQuery.ToFutureValue(qdc => qdc.Max(dc => dc.NonNullableDecimal));
					Assert.That(() => futureNonNullableDec.GetValueAsync(cancellationToken),
					            Throws.TargetInvocationException.And.InnerException.InstanceOf<InvalidOperationException>(),
					            "Future non nullable decimal max has failed");
				}
			}
		}

		protected override async Task MinAsync<TDc>(int? expectedResult, CancellationToken cancellationToken = default(CancellationToken))
		{
			using (var session = OpenSession())
			{
				var dcQuery = session.Query<TDc>();
				var name = await (dcQuery.MinAsync(dc => dc.Name, cancellationToken));
				Assert.That(name, Is.EqualTo(expectedResult.HasValue ? SearchName1 : null), "String min has failed");
				var futureName = dcQuery.ToFutureValue(qdc => qdc.Min(dc => dc.Name));
				Assert.That(await (futureName.GetValueAsync(cancellationToken)), Is.EqualTo(expectedResult.HasValue ? SearchName1 : null), "Future string min has failed");

				var integ = await (dcQuery.MinAsync(dc => dc.Integer, cancellationToken));
				Assert.That(integ, Is.EqualTo(expectedResult), "Integer min has failed");
				var futureInteg = dcQuery.ToFutureValue(qdc => qdc.Min(dc => dc.Integer));
				Assert.That(await (futureInteg.GetValueAsync(cancellationToken)), Is.EqualTo(expectedResult), "Future integer min has failed");

				var longInt = await (dcQuery.MinAsync(dc => dc.Long, cancellationToken));
				Assert.That(longInt, Is.EqualTo(expectedResult), "Long integer min has failed");
				var futureLongInt = dcQuery.ToFutureValue(qdc => qdc.Min(dc => dc.Long));
				Assert.That(await (futureLongInt.GetValueAsync(cancellationToken)), Is.EqualTo(expectedResult), "Future long integer min has failed");

				var dec = await (dcQuery.MinAsync(dc => dc.Decimal, cancellationToken));
				Assert.That(dec, Is.EqualTo(expectedResult), "Decimal min has failed");
				var futureDec = dcQuery.ToFutureValue(qdc => qdc.Min(dc => dc.Decimal));
				Assert.That(await (futureDec.GetValueAsync(cancellationToken)), Is.EqualTo(expectedResult), "Future decimal min has failed");

				var dbl = await (dcQuery.MinAsync(dc => dc.Double, cancellationToken));
				Assert.That(dbl.HasValue, Is.EqualTo(expectedResult.HasValue),"Double min has failed");
				if (expectedResult.HasValue)
					Assert.That(dbl.Value, Is.EqualTo(expectedResult).Within(0.001d), "Double min has failed");
				var futureDbl = dcQuery.ToFutureValue(qdc => qdc.Min(dc => dc.Double));
				Assert.That((await (futureDbl.GetValueAsync(cancellationToken))).HasValue, Is.EqualTo(expectedResult.HasValue),"Future double min has failed");
				if (expectedResult.HasValue)
					Assert.That((await (futureDbl.GetValueAsync(cancellationToken))).Value, Is.EqualTo(expectedResult).Within(0.001d), "Future double min has failed");

				var date = await (dcQuery.MinAsync(dc => dc.DateTime, cancellationToken));
				var futureDate = dcQuery.ToFutureValue(qdc => qdc.Min(dc => dc.DateTime));
				if (expectedResult.HasValue)
				{
					Assert.That(date, Is.LessThan(TestDate), "DateTime min has failed");
					Assert.That(await (futureDate.GetValueAsync(cancellationToken)), Is.LessThan(TestDate), "Future DateTime min has failed");
				}
				else
				{
					Assert.That(date, Is.Null, "DateTime min has failed");
					Assert.That(await (futureDate.GetValueAsync(cancellationToken)), Is.Null, "Future DateTime min has failed");
				}

				if (expectedResult.HasValue)
				{
					var nonNullableDecimal = -1m;
					Assert.That(async () => nonNullableDecimal = await (dcQuery.MinAsync(dc => dc.NonNullableDecimal, cancellationToken)), Throws.Nothing, "Non nullable decimal min has failed");
					Assert.That(nonNullableDecimal, Is.EqualTo(expectedResult), "Non nullable decimal min has failed");
					var futureNonNullableDec = dcQuery.ToFutureValue(qdc => qdc.Min(dc => dc.NonNullableDecimal));
					Assert.That(async () => nonNullableDecimal = await (futureNonNullableDec.GetValueAsync(cancellationToken)), Throws.Nothing, "Future non nullable decimal min has failed");
					Assert.That(nonNullableDecimal, Is.EqualTo(expectedResult), "Future non nullable decimal min has failed");
				}
				else
				{
					Assert.That(() => dcQuery.MinAsync(dc => dc.NonNullableDecimal, cancellationToken),
					            // After fix
					            Throws.InstanceOf<InvalidOperationException>()
					                  // Before fix
					                  .Or.InnerException.InstanceOf<ArgumentNullException>(),
					            "Non nullable decimal min has failed");
					var futureNonNullableDec = dcQuery.ToFutureValue(qdc => qdc.Min(dc => dc.NonNullableDecimal));
					Assert.That(() => futureNonNullableDec.GetValueAsync(cancellationToken),
					            Throws.TargetInvocationException.And.InnerException.InstanceOf<InvalidOperationException>(),
					            "Future non nullable decimal min has failed");
				}
			}
		}

		// Non-reg case
		[Test]
		public void SingleOrDefaultBBaseAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassBExtendedByA>();
				Assert.That(() => query.SingleOrDefaultAsync(), Throws.InvalidOperationException);
				var futureQuery = query.ToFutureValue(qdc => qdc.SingleOrDefault());
				Assert.That(() => futureQuery.GetValueAsync(), Throws.TargetInvocationException.And.InnerException.TypeOf<InvalidOperationException>(), "Future");
			}
		}

		// Non-reg case
		[Test]
		public void SingleOrDefaultBBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassBExtendedByA>();
				DomainClassBExtendedByA result = null;
				Assert.That(async () => result = await (query.SingleOrDefaultAsync(dc => dc.Name == SearchName1)), Throws.Nothing);
				Assert.That(result, Is.Not.Null);
				Assert.That(result.Name, Is.EqualTo(SearchName1));
				Assert.That(result, Is.TypeOf<DomainClassBExtendedByA>());
				var futureQuery = query.ToFutureValue(qdc => qdc.SingleOrDefault(dc => dc.Name == SearchName1));
				Assert.That(async () => result = await (futureQuery.GetValueAsync()), Throws.Nothing, "Future");
				Assert.That(result, Is.Not.Null, "Future");
				Assert.That(result.Name, Is.EqualTo(SearchName1), "Future");
				Assert.That(result, Is.TypeOf<DomainClassBExtendedByA>(), "Future");
			}
		}

		// Non-reg case
		[Test]
		public void SingleOrDefaultCBaseAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassCExtendedByD>();
				Assert.That(() => query.SingleOrDefaultAsync(), Throws.InvalidOperationException);
				var futureQuery = query.ToFutureValue(qdc => qdc.SingleOrDefault());
				Assert.That(() => futureQuery.GetValueAsync(), Throws.TargetInvocationException.And.InnerException.TypeOf<InvalidOperationException>(), "Future");
			}
		}

		// Non-reg case
		[Test]
		public void SingleOrDefaultCBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassCExtendedByD>();
				DomainClassCExtendedByD result = null;
				Assert.That(async () => result = await (query.SingleOrDefaultAsync(dc => dc.Name == SearchName1)), Throws.Nothing);
				Assert.That(result, Is.Not.Null);
				Assert.That(result.Name, Is.EqualTo(SearchName1));
				Assert.That(result, Is.TypeOf<DomainClassCExtendedByD>());
				var futureQuery = query.ToFutureValue(qdc => qdc.SingleOrDefault(dc => dc.Name == SearchName1));
				Assert.That(async () => result = await (futureQuery.GetValueAsync()), Throws.Nothing, "Future");
				Assert.That(result, Is.Not.Null, "Future");
				Assert.That(result.Name, Is.EqualTo(SearchName1), "Future");
				Assert.That(result, Is.TypeOf<DomainClassCExtendedByD>(), "Future");
			}
		}

		// Non-reg case
		[Test]
		public void SingleOrDefaultEAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassE>();
				Assert.That(() => query.SingleOrDefaultAsync(), Throws.InvalidOperationException);
				var futureQuery = query.ToFutureValue(qdc => qdc.SingleOrDefault());
				Assert.That(() => futureQuery.GetValueAsync(), Throws.TargetInvocationException.And.InnerException.TypeOf<InvalidOperationException>(), "Future");
			}
		}

		// Non-reg case
		[Test]
		public void SingleOrDefaultEWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassE>();
				DomainClassE result = null;
				Assert.That(async () => result = await (query.SingleOrDefaultAsync(dc => dc.Name == SearchName1)), Throws.Nothing);
				Assert.That(result, Is.Not.Null);
				Assert.That(result.Name, Is.EqualTo(SearchName1));
				var futureQuery = query.ToFutureValue(qdc => qdc.SingleOrDefault(dc => dc.Name == SearchName1));
				Assert.That(async () => result = await (futureQuery.GetValueAsync()), Throws.Nothing, "Future");
				Assert.That(result, Is.Not.Null, "Future");
				Assert.That(result.Name, Is.EqualTo(SearchName1), "Future");
			}
		}

		// Non-reg case
		[Test]
		public void SingleOrDefaultFAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassF>();
				DomainClassF result = null;
				Assert.That(async () => result = await (query.SingleOrDefaultAsync()), Throws.Nothing);
				Assert.That(result, Is.Null);
				var futureQuery = query.ToFutureValue(qdc => qdc.SingleOrDefault());
				Assert.That(async () => result = await (futureQuery.GetValueAsync()), Throws.Nothing, "Future");
				Assert.That(result, Is.Null, "Future");
			}
		}

		// Non-reg case
		[Test]
		public void SingleOrDefaultFWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassF>();
				DomainClassF result = null;
				Assert.That(async () => result = await (query.SingleOrDefaultAsync(dc => dc.Name == SearchName1)), Throws.Nothing);
				Assert.That(result, Is.Null);
				var futureQuery = query.ToFutureValue(qdc => qdc.SingleOrDefault(dc => dc.Name == SearchName1));
				Assert.That(async () => result = await (futureQuery.GetValueAsync()), Throws.Nothing, "Future");
				Assert.That(result, Is.Null, "Future");
			}
		}

		// Non-reg case
		[Test]
		public void SingleOrDefaultGBaseAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassGExtendedByH>();
				Assert.That(() => query.SingleOrDefaultAsync(), Throws.InvalidOperationException);
				var futureQuery = query.ToFutureValue(qdc => qdc.SingleOrDefault());
				Assert.That(() => futureQuery.GetValueAsync(), Throws.TargetInvocationException.And.InnerException.TypeOf<InvalidOperationException>(), "Future");
			}
		}

		// Non-reg case
		[Test]
		public void SingleOrDefaultGBaseWithNameAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<DomainClassGExtendedByH>();
				Assert.That(() => query.SingleOrDefaultAsync(dc => dc.Name == SearchName1), Throws.InvalidOperationException);
				var futureQuery = query.ToFutureValue(qdc => qdc.SingleOrDefault(dc => dc.Name == SearchName1));
				Assert.That(() => futureQuery.GetValueAsync(), Throws.TargetInvocationException.And.InnerException.TypeOf<InvalidOperationException>(), "Future");
			}
		}

		// Non-reg case
		[Test]
		public void SingleOrDefaultObjectAsync()
		{
			using (var session = OpenSession())
			{
				var query = session.Query<object>();
				Assert.That(() => query.SingleOrDefaultAsync(), Throws.InvalidOperationException);
				var futureQuery = query.ToFutureValue(qdc => qdc.SingleOrDefault());
				Assert.That(() => futureQuery.GetValueAsync(), Throws.TargetInvocationException.And.InnerException.TypeOf<InvalidOperationException>(), "Future");
			}
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task SumBBaseAsync()
		{
			await (SumAsync<DomainClassBExtendedByA>(3));
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task SumCBaseAsync()
		{
			await (SumAsync<DomainClassCExtendedByD>(3));
		}

		// Non-reg case
		[Test]
		public async Task SumEAsync()
		{
			await (SumAsync<DomainClassE>(3));
		}

		// Non-reg case
		[Test]
		public async Task SumFAsync()
		{
			await (SumAsync<DomainClassF>(null));
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task SumGBaseAsync()
		{
			await (SumAsync<DomainClassGExtendedByH>(10));
		}

		// Failing case till NH-3850 is fixed
		[Test]
		public async Task SumObjectAsync()
		{
			if (Dialect is MsSqlCeDialect)
			{
				// Fails with an unhelpful message: "The command contained one or more errors.", without additional data
				Assert.Ignore("This test is not supported by SQL Server CE");
			}

			using (var session = OpenSession())
			{
				var result = await (session.Query<object>().SumAsync(o => (int?)2));
				Assert.That(result, Is.EqualTo(TotalEntityCount * 2));
			}
		}

		private async Task SumAsync<DC>(int? expectedResult, CancellationToken cancellationToken = default(CancellationToken)) where DC : DomainClassBase
		{
			using (var session = OpenSession())
			{
				var dcQuery = session.Query<DC>();
				var integ = await (dcQuery.SumAsync(dc => dc.Integer, cancellationToken));
				Assert.That(integ, Is.EqualTo(expectedResult), "Integer sum has failed");
				var futureInteg = dcQuery.ToFutureValue(qdc => qdc.Sum(dc => dc.Integer));
				Assert.That(await (futureInteg.GetValueAsync(cancellationToken)), Is.EqualTo(expectedResult), "Future integer sum has failed");

				var longInt = await (dcQuery.SumAsync(dc => dc.Long, cancellationToken));
				Assert.That(longInt, Is.EqualTo(expectedResult), "Long integer sum has failed");
				var futureLongInt = dcQuery.ToFutureValue(qdc => qdc.Sum(dc => dc.Long));
				Assert.That(await (futureLongInt.GetValueAsync(cancellationToken)), Is.EqualTo(expectedResult), "Future long integer sum has failed");

				var dec = await (dcQuery.SumAsync(dc => dc.Decimal, cancellationToken));
				Assert.That(dec, Is.EqualTo(expectedResult), "Decimal sum has failed");
				var futureDec = dcQuery.ToFutureValue(qdc => qdc.Sum(dc => dc.Decimal));
				Assert.That(await (futureDec.GetValueAsync(cancellationToken)), Is.EqualTo(expectedResult), "Future decimal sum has failed");

				var dbl = await (dcQuery.SumAsync(dc => dc.Double, cancellationToken));
				Assert.That(dbl.HasValue, Is.EqualTo(expectedResult.HasValue), "Double sum has failed");
				if (expectedResult.HasValue)
					Assert.That(dbl.Value, Is.EqualTo(expectedResult).Within(0.001d), "Double sum has failed");
				var futureDbl = dcQuery.ToFutureValue(qdc => qdc.Sum(dc => dc.Double));
				Assert.That((await (futureDbl.GetValueAsync(cancellationToken))).HasValue, Is.EqualTo(expectedResult.HasValue), "Future double sum has failed");
				if (expectedResult.HasValue)
					Assert.That((await (futureDbl.GetValueAsync(cancellationToken))).Value, Is.EqualTo(expectedResult).Within(0.001d), "Future double sum has failed");

				if (expectedResult.HasValue)
				{
					var nonNullableDecimal = -1m;
					Assert.That(async () => nonNullableDecimal = await (dcQuery.SumAsync(dc => dc.NonNullableDecimal, cancellationToken)), Throws.Nothing, "Non nullable decimal sum has failed");
					Assert.That(nonNullableDecimal, Is.EqualTo(expectedResult), "Non nullable decimal sum has failed");
					var futureNonNullableDec = dcQuery.ToFutureValue(qdc => qdc.Sum(dc => dc.NonNullableDecimal));
					Assert.That(async () => nonNullableDecimal = await (futureNonNullableDec.GetValueAsync(cancellationToken)), Throws.Nothing, "Future non nullable decimal sum has failed");
					Assert.That(nonNullableDecimal, Is.EqualTo(expectedResult), "Future non nullable decimal sum has failed");
				}
				else
				{
					Assert.That(() => dcQuery.SumAsync(dc => dc.NonNullableDecimal, cancellationToken),
					            // After fix
					            Throws.InstanceOf<InvalidOperationException>()
					                  // Before fix
					                  .Or.InnerException.InstanceOf<ArgumentNullException>(),
					            "Non nullable decimal sum has failed");
					var futureNonNullableDec = dcQuery.ToFutureValue(qdc => qdc.Sum(dc => dc.NonNullableDecimal));
					Assert.That(() => futureNonNullableDec.GetValueAsync(cancellationToken),
					            Throws.TargetInvocationException.And.InnerException.InstanceOf<InvalidOperationException>(),
					            "Future non nullable decimal sum has failed");
				}
			}
		}
	}
}
