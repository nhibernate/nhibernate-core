//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.IO;
using System.Threading;
using System.Transactions;
using log4net;
using log4net.Layout;
using log4net.Repository.Hierarchy;
using NUnit.Framework;

using SysTran = System.Transactions.Transaction;

namespace NHibernate.Test.SystemTransactions
{
	using System.Threading.Tasks;
	/// <summary>
	/// Holds tests for checking MSDTC resource managers behavior. They are not actual NHibernate tests,
	/// they are here to help understand how NHibernate should implement its own resource manager.
	/// </summary>
	[TestFixture]
	[Explicit("Does not test NHibernate but MSDTC")]
	public class ResourceManagerFixtureAsync
	{

		#region Distributed
		#region Commit

		#endregion
		#region Failure

		[Test]
		[Explicit("Failing")]
		public async Task DistributedTransactionFromCompletionEventShouldBeTheOneToWhichTheEventIsAttachedAsync()
		{
			SysTran clone = null;
			SysTran eventTransaction = null;
			try
			{
				using (CreateDistributedTransactionScope())
				{
					_log.InfoFormat(
						"Scope opened, id {0}, distributed id {1}",
						SysTran.Current.TransactionInformation.LocalIdentifier,
						SysTran.Current.TransactionInformation.DistributedIdentifier);
					clone = SysTran.Current.Clone();
					clone.TransactionCompleted += Clone_TransactionCompleted;
					_log.Info("Scope not completed");
				}
				_log.Info("Scope disposed");
				while (eventTransaction == null)
					await (Task.Delay(10));
				_log.Info("Event transaction received");
				Assert.That(eventTransaction, Is.SameAs(clone));
			}
			finally
			{
				clone?.Dispose();
			}

			void Clone_TransactionCompleted(object sender, TransactionEventArgs e)
			{
				eventTransaction = e.Transaction;
			}
		}

		#endregion
		#region Rollback

		[Test]
		public async Task DistributedTransactionStatusFromCompletionEventShouldNotBeActiveOnRollbackAsync()
		{
			SysTran clone = null;
			SysTran eventTransaction = null;
			TransactionStatus? cloneStatusAtCompletion = null;
			try
			{
				using (CreateDistributedTransactionScope())
				{
					_log.InfoFormat(
						"Scope opened, id {0}, distributed id {1}",
						SysTran.Current.TransactionInformation.LocalIdentifier,
						SysTran.Current.TransactionInformation.DistributedIdentifier);
					clone = SysTran.Current.Clone();
					clone.TransactionCompleted += Clone_TransactionCompleted;
					_log.Info("Scope not completed");
				}
				_log.Info("Scope disposed");
				while (eventTransaction == null)
					await (Task.Delay(10));
				_log.Info("Event transaction received");
				Assert.That(cloneStatusAtCompletion, Is.Not.EqualTo(TransactionStatus.Active));
			}
			finally
			{
				clone?.Dispose();
			}

			void Clone_TransactionCompleted(object sender, TransactionEventArgs e)
			{
				cloneStatusAtCompletion = FailsafeGetTransactionStatus(clone);
				eventTransaction = e.Transaction;
			}
		}

		#endregion
		#endregion
		#region Non distributed
		#region Commit

		#endregion
		#region In-doubt

		#endregion
		#region Rollback

		#endregion

		#region Failure

		[Test]
		[Explicit("Failing")]
		public async Task TransactionFromCompletionEventShouldBeTheOneToWhichTheEventIsAttachedAsync()
		{
			SysTran clone = null;
			SysTran eventTransaction = null;
			try
			{
				using (new TransactionScope(TransactionScopeAsyncFlowOption.Enabled))
				{
					_log.InfoFormat(
						"Scope opened, id {0}, distributed id {1}",
						SysTran.Current.TransactionInformation.LocalIdentifier,
						SysTran.Current.TransactionInformation.DistributedIdentifier);
					clone = SysTran.Current.Clone();
					clone.TransactionCompleted += Clone_TransactionCompleted;
					_log.Info("Scope not completed");
				}
				_log.Info("Scope disposed");
				while (eventTransaction == null)
					await (Task.Delay(10));
				_log.Info("Event transaction received");
				Assert.That(eventTransaction, Is.SameAs(clone));
			}
			finally
			{
				clone?.Dispose();
			}

			void Clone_TransactionCompleted(object sender, TransactionEventArgs e)
			{
				eventTransaction = e.Transaction;
			}
		}

		#endregion

		#endregion

		#region Tests setup/teardown/utils

		private static readonly ILog _log = LogManager.GetLogger(typeof(ResourceManagerFixtureAsync));
		private LogSpy _spy;

		[OneTimeSetUp]
		public void TestFixtureSetUp()
		{
			_spy = new LogSpy(_log);
			_spy.Appender.Layout = new PatternLayout("%d{ABSOLUTE} [%t] - %m%n");
		}

		[OneTimeTearDown]
		public void TestFixtureTearDown()
		{
			_spy.Dispose();
		}

		[SetUp]
		public void SetUp()
		{
			EnlistResource.Counter = 0;
		}

		[TearDown]
		public void TearDown()
		{
			// Account for MSDTC async second phase, for collecting all logs
			Thread.Sleep(200);

			using (var wholeMessage = new StringWriter())
			{
				foreach (var loggingEvent in _spy.Appender.PopAllEvents())
				{
					_spy.Appender.Layout.Format(wholeMessage, loggingEvent);
				}
				// R# console ignores logs from other threads.
				_log.Info(
					@"

All threads log:
" + wholeMessage);
			}
			_spy.Appender.Clear();
		}

		// Taken from NH-3023 test.
		private static TransactionScope CreateDistributedTransactionScope()
		{
			var scope = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled);
			//
			// Forces promotion to distributed transaction
			//
			TransactionInterop.GetTransmitterPropagationToken(System.Transactions.Transaction.Current);
			return scope;
		}

		private static TransactionStatus? FailsafeGetTransactionStatus(SysTran transaction)
		{
			try
			{
				return transaction.TransactionInformation.Status;
			}
			catch (Exception ex)
			{
				// Only log exception message for avoid bloating the log for a minor case
				_log.InfoFormat("Failed getting transaction status, {0}", ex.Message);
				return null;
			}
		}

		public class EnlistResource : IEnlistmentNotification
		{
			// Causes concurrency to be more obvious.
			public static int SleepTime { get; set; } = 2;

			public static int Counter { get; set; }

			protected bool ShouldRollBack { get; }
			protected bool ShouldGoInDoubt { get; }
			protected bool FailInSecondPhase { get; }
			protected string Name { get; }

			public static void EnlistVolatile(bool shouldRollBack = false)
				=> EnlistVolatile(shouldRollBack, false);

			public static void EnlistVolatile(bool shouldRollBack, bool supportsSinglePhase)
				=> Enlist(false, supportsSinglePhase, shouldRollBack);

			public static void EnlistWithPrepareEnlistmentVolatile(bool shouldRollBack = false)
				=> Enlist(false, false, shouldRollBack, false, false, true);

			public static void EnlistDurable(bool shouldRollBack = false)
				=> EnlistDurable(shouldRollBack, false);

			public static void EnlistDurable(bool shouldRollBack, bool supportsSinglePhase)
				=> Enlist(true, supportsSinglePhase, shouldRollBack);

			public static void EnlistInDoubtDurable()
				=> Enlist(true, true, false, true);

			public static void EnlistSecondPhaseFailingDurable()
				=> Enlist(true, false, false, false, true);

			private static void Enlist(bool durable, bool supportsSinglePhase, bool shouldRollBack, bool inDoubt = false,
				bool failInSecondPhase = false, bool enlistInPrepareOption = false)
			{
				Counter++;

				var name = $"{(durable ? "Durable" : "Volatile")} resource {Counter}";
				EnlistResource resource;
				var options = enlistInPrepareOption ? EnlistmentOptions.EnlistDuringPrepareRequired : EnlistmentOptions.None;
				if (supportsSinglePhase)
				{
					var spResource = new EnlistSinglePhaseResource(shouldRollBack, name, inDoubt, failInSecondPhase);
					resource = spResource;
					if (durable)
						SysTran.Current.EnlistDurable(Guid.NewGuid(), spResource, options);
					else
						SysTran.Current.EnlistVolatile(spResource, options);
				}
				else
				{
					resource = new EnlistResource(shouldRollBack, name, inDoubt, failInSecondPhase);
					// Not duplicate code with above, that is not the same overload which ends up called.
					if (durable)
						SysTran.Current.EnlistDurable(Guid.NewGuid(), resource, options);
					else
						SysTran.Current.EnlistVolatile(resource, options);
				}

				SysTran.Current.TransactionCompleted += resource.Current_TransactionCompleted;

				_log.Info(name + ": enlisted");
			}

			protected EnlistResource(bool shouldRollBack, string name, bool inDoubt, bool failInSecondPhase)
			{
				ShouldRollBack = shouldRollBack;
				ShouldGoInDoubt = inDoubt;
				FailInSecondPhase = failInSecondPhase;
				Name = name;
			}

			public void Prepare(PreparingEnlistment preparingEnlistment)
			{
				_log.Info(Name + ": prepare phase start");
				Thread.Sleep(SleepTime);
				if (ShouldRollBack)
				{
					_log.Info(Name + ": prepare phase, calling rollback-ed");
					preparingEnlistment.ForceRollback();
				}
				else if (ShouldGoInDoubt)
				{
					throw new InvalidOperationException("In-doubt mode currently supported only by durable in single phase.");
				}
				else
				{
					_log.Info(Name + ": prepare phase, calling prepared");
					preparingEnlistment.Prepared();
				}
				Thread.Sleep(SleepTime);
				_log.Info(Name + ": prepare phase end");
			}

			public void Commit(Enlistment enlistment)
			{
				_log.Info(Name + ": commit phase start");
				Thread.Sleep(SleepTime);
				if (FailInSecondPhase)
					throw new InvalidOperationException("Asked to fail");
				_log.Info(Name + ": commit phase, calling done");
				enlistment.Done();
				Thread.Sleep(SleepTime);
				_log.Info(Name + ": commit phase end");
			}

			public void Rollback(Enlistment enlistment)
			{
				_log.Info(Name + ": rollback phase start");
				Thread.Sleep(SleepTime);
				if (FailInSecondPhase)
					throw new InvalidOperationException("Asked to fail");
				_log.Info(Name + ": rollback phase, calling done");
				enlistment.Done();
				Thread.Sleep(SleepTime);
				_log.Info(Name + ": rollback phase end");
			}

			public void InDoubt(Enlistment enlistment)
			{
				_log.Info(Name + ": in-doubt phase start");
				Thread.Sleep(SleepTime);
				if (FailInSecondPhase)
					throw new InvalidOperationException("Asked to fail");
				_log.Info(Name + ": in-doubt phase, calling done");
				enlistment.Done();
				Thread.Sleep(SleepTime);
				_log.Info(Name + ": in-doubt phase end");
			}

			private void Current_TransactionCompleted(object sender, TransactionEventArgs e)
			{
				_log.Info(Name + ": transaction completed start");
				Thread.Sleep(SleepTime);
				_log.Info(Name + ": transaction completed middle");
				Thread.Sleep(SleepTime);
				_log.Info(Name + ": transaction completed end");
			}

			private class EnlistSinglePhaseResource : EnlistResource, ISinglePhaseNotification
			{
				public EnlistSinglePhaseResource(bool shouldRollBack, string name, bool inDoubt, bool failInSecondPhase) :
					base(shouldRollBack, "Single phase " + name, inDoubt, failInSecondPhase)
				{
				}

				public void SinglePhaseCommit(SinglePhaseEnlistment singlePhaseEnlistment)
				{
					_log.Info(Name + ": transaction single phase start");
					Thread.Sleep(SleepTime);
					if (ShouldRollBack)
					{
						_log.Info(Name + ": transaction single phase, calling aborted");
						singlePhaseEnlistment.Aborted();
					}
					else if (ShouldGoInDoubt)
					{
						_log.Info(Name + ": transaction single phase, calling in doubt");
						singlePhaseEnlistment.InDoubt();
					}
					else
					{
						_log.Info(Name + ": transaction single phase, calling committed");
						singlePhaseEnlistment.Committed();
					}
					Thread.Sleep(SleepTime);
					_log.Info(Name + ": transaction single phase end");
				}
			}
		}

		#endregion
	}
}
