//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using NHibernate.Criterion;
using NUnit.Framework;

namespace NHibernate.Test.Operations
{
	using System.Threading.Tasks;
	using System.Threading;
	[TestFixture]
	public class MergeFixtureAsync : AbstractOperationTestCase
	{
		protected override bool AppliesTo(Dialect.Dialect dialect)
		{
			return !(dialect is Dialect.FirebirdDialect); // Firebird has no CommandTimeout, and locks up during the tear-down of this fixture
		}

		protected override void OnTearDown()
		{
			Cleanup();
		}

		private async Task CleanupAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			using (ISession s = OpenSession())
			{
				using (ITransaction tx = s.BeginTransaction())
				{
					await (s.DeleteAsync("from NumberedNode where parent is not null", cancellationToken));
					await (s.DeleteAsync("from NumberedNode", cancellationToken));

					await (s.DeleteAsync("from Node where parent is not null", cancellationToken));
					await (s.DeleteAsync("from Node", cancellationToken));

					await (s.DeleteAsync("from VersionedEntity where parent is not null", cancellationToken));
					await (s.DeleteAsync("from VersionedEntity", cancellationToken));
					await (s.DeleteAsync("from TimestampedEntity", cancellationToken));

					await (s.DeleteAsync("from Competitor", cancellationToken));
					await (s.DeleteAsync("from Competition", cancellationToken));

					await (s.DeleteAsync("from Employer", cancellationToken));

					await (tx.CommitAsync(cancellationToken));
				}
			}
		}

		private void Cleanup()
		{
			using (ISession s = OpenSession())
			{
				using (ITransaction tx = s.BeginTransaction())
				{
					s.Delete("from NumberedNode where parent is not null");
					s.Delete("from NumberedNode");

					s.Delete("from Node where parent is not null");
					s.Delete("from Node");

					s.Delete("from VersionedEntity where parent is not null");
					s.Delete("from VersionedEntity");
					s.Delete("from TimestampedEntity");

					s.Delete("from Competitor");
					s.Delete("from Competition");

					s.Delete("from Employer");

					tx.Commit();
				}
			}
		}

		[Test]
		public async Task DeleteAndMergeAsync()
		{
			using (ISession s = OpenSession())
			{
				s.BeginTransaction();
				var jboss = new Employer();
				await (s.PersistAsync(jboss));
				await (s.Transaction.CommitAsync());
				s.Clear();

				s.BeginTransaction();
				var otherJboss = await (s.GetAsync<Employer>(jboss.Id));
				await (s.DeleteAsync(otherJboss));
				await (s.Transaction.CommitAsync());
				s.Clear();
				jboss.Vers = 1;
				s.BeginTransaction();
				await (s.MergeAsync(jboss));
				await (s.Transaction.CommitAsync());
			}
		}

		[Test]
		public async Task MergeBidiForeignKeyOneToOneAsync()
		{
			Person p;
			Address a;
			using (ISession s = OpenSession())
			{
				using (ITransaction tx = s.BeginTransaction())
				{
					p = new Person {Name = "steve"};
					a = new Address {StreetAddress = "123 Main", City = "Austin", Country = "US", Resident = p};
					await (s.PersistAsync(a));
					await (s.PersistAsync(p));
					await (tx.CommitAsync());
				}
			}

			ClearCounts();

			p.Address.StreetAddress = "321 Main";

			using (ISession s = OpenSession())
			{
				using (s.BeginTransaction())
				{
					p = (Person) await (s.MergeAsync(p));
					await (s.Transaction.CommitAsync());
				}
			}

			AssertInsertCount(0);
			AssertUpdateCount(0); // no cascade
			AssertDeleteCount(0);

			using (ISession s = OpenSession())
			{
				using (ITransaction tx = s.BeginTransaction())
				{
					await (s.DeleteAsync(a));
					await (s.DeleteAsync(p));
					await (tx.CommitAsync());
				}
			}
		}

		[Test, Ignore("Need some more investigation about id sync.")]
		public async Task MergeBidiPrimayKeyOneToOneAsync()
		{
			Person p;
			using (ISession s = OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				p = new Person {Name = "steve"};
				new PersonalDetails {SomePersonalDetail = "I have big feet", Person = p};
				await (s.PersistAsync(p));
				await (tx.CommitAsync());
			}

			ClearCounts();

			p.Details.SomePersonalDetail = p.Details.SomePersonalDetail + " and big hands too";
			using (ISession s = OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				p = (Person) await (s.MergeAsync(p));
				await (tx.CommitAsync());
			}

			AssertInsertCount(0);
			AssertUpdateCount(1);
			AssertDeleteCount(0);

			using (ISession s = OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				await (s.DeleteAsync(p));
				await (tx.CommitAsync());
			}
		}

		[Test]
		public async Task MergeDeepTreeAsync()
		{
			ClearCounts();

			var root = new Node
			{
				Created = RoundForDialect(DateTime.Now),
				Name = "root"
			};
			var child = new Node
			{
				Created = RoundForDialect(DateTime.Now),
				Name = "child"
			};
			var grandchild = new Node
			{
				Created = RoundForDialect(DateTime.Now),
				Name = "grandchild"
			};

			using (ISession s = OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				root.AddChild(child);
				child.AddChild(grandchild);
				await (s.MergeAsync(root));
				await (tx.CommitAsync());
			}

			AssertInsertCount(3);
			AssertUpdateCount(0);
			ClearCounts();

			grandchild.Description = "the grand child";
			var grandchild2 = new Node
			{
				Created = RoundForDialect(DateTime.Now),
				Name = "grandchild2"
			};
			child.AddChild(grandchild2);

			using (var s = OpenSession())
			using (var tx = s.BeginTransaction())
			{
				await (s.MergeAsync(root));
				await (tx.CommitAsync());
			}

			AssertInsertCount(1);
			AssertUpdateCount(1);
			ClearCounts();

			var child2 = new Node
			{
				Created = RoundForDialect(DateTime.Now),
				Name = "child2"
			};
			var grandchild3 = new Node
			{
				Created = RoundForDialect(DateTime.Now),
				Name = "grandchild3"
			};
			child2.AddChild(grandchild3);
			root.AddChild(child2);

			using (var s = OpenSession())
			using (var tx = s.BeginTransaction())
			{
				await (s.MergeAsync(root));
				await (tx.CommitAsync());
			}

			AssertInsertCount(2);
			AssertUpdateCount(0);
			ClearCounts();

			using (var s = OpenSession())
			using (var tx = s.BeginTransaction())
			{
				await (s.DeleteAsync(grandchild));
				await (s.DeleteAsync(grandchild2));
				await (s.DeleteAsync(grandchild3));
				await (s.DeleteAsync(child));
				await (s.DeleteAsync(child2));
				await (s.DeleteAsync(root));
				await (tx.CommitAsync());
			}
		}

		[Test]
		public async Task MergeDeepTreeWithGeneratedIdAsync()
		{
			ClearCounts();

			NumberedNode root;
			NumberedNode child;
			NumberedNode grandchild;
			using (ISession s = OpenSession())
			{
				ITransaction tx = s.BeginTransaction();
				root = new NumberedNode("root", RoundForDialect(DateTime.Now));
				child = new NumberedNode("child", RoundForDialect(DateTime.Now));
				grandchild = new NumberedNode("grandchild", RoundForDialect(DateTime.Now));
				root.AddChild(child);
				child.AddChild(grandchild);
				root = (NumberedNode) await (s.MergeAsync(root));
				await (tx.CommitAsync());
			}

			AssertInsertCount(3);
			AssertUpdateCount(0);
			ClearCounts();

			IEnumerator<NumberedNode> rit = root.Children.GetEnumerator();
			rit.MoveNext();
			child = rit.Current;
			IEnumerator<NumberedNode> cit = child.Children.GetEnumerator();
			cit.MoveNext();
			grandchild = cit.Current;
			grandchild.Description = "the grand child";
			var grandchild2 = new NumberedNode("grandchild2", RoundForDialect(DateTime.Now));
			child.AddChild(grandchild2);

			using (ISession s = OpenSession())
			{
				ITransaction tx = s.BeginTransaction();
				root = (NumberedNode) await (s.MergeAsync(root));
				await (tx.CommitAsync());
			}

			AssertInsertCount(1);
			AssertUpdateCount(1);
			ClearCounts();

			await (Sfi.EvictAsync(typeof (NumberedNode)));

			var child2 = new NumberedNode("child2", RoundForDialect(DateTime.Now));
			var grandchild3 = new NumberedNode("grandchild3", RoundForDialect(DateTime.Now));
			child2.AddChild(grandchild3);
			root.AddChild(child2);

			using (ISession s = OpenSession())
			{
				ITransaction tx = s.BeginTransaction();
				root = (NumberedNode) await (s.MergeAsync(root));
				await (tx.CommitAsync());
			}

			AssertInsertCount(2);
			AssertUpdateCount(0);
			ClearCounts();

			using (ISession s = OpenSession())
			{
				ITransaction tx = s.BeginTransaction();
				await (s.DeleteAsync("from NumberedNode where name like 'grand%'"));
				await (s.DeleteAsync("from NumberedNode where name like 'child%'"));
				await (s.DeleteAsync("from NumberedNode"));
				await (tx.CommitAsync());
			}
		}

		[Test]
		public async Task MergeManagedAsync()
		{
			using (ISession s = OpenSession())
			{
				NumberedNode root;
				using (ITransaction tx = s.BeginTransaction())
				{
					root = new NumberedNode("root", RoundForDialect(DateTime.Now));
					await (s.PersistAsync(root));
					await (tx.CommitAsync());
				}
				ClearCounts();

				NumberedNode mergedChild;
				using (var tx = s.BeginTransaction())
				{
					var child = new NumberedNode("child", RoundForDialect(DateTime.Now));
					root.AddChild(child);
					Assert.That(await (s.MergeAsync(root)), Is.SameAs(root));
					IEnumerator<NumberedNode> rit = root.Children.GetEnumerator();
					rit.MoveNext();
					mergedChild = rit.Current;
					Assert.That(mergedChild, Is.Not.SameAs(child));
					Assert.That(s.Contains(mergedChild));
					Assert.That(!s.Contains(child));
					Assert.That(root.Children.Count, Is.EqualTo(1));
					Assert.That(root.Children.Contains(mergedChild));
					//assertNotSame( mergedChild, s.Merge(child) ); //yucky :(
					await (tx.CommitAsync());
				}

				AssertInsertCount(1);
				AssertUpdateCount(0);

				Assert.That(root.Children.Count, Is.EqualTo(1));
				Assert.That(root.Children.Contains(mergedChild));

				using (var tx = s.BeginTransaction())
				{
					Assert.That(
						await (s.CreateCriteria(typeof(NumberedNode)).SetProjection(Projections.RowCount()).UniqueResultAsync()),
						Is.EqualTo(2));
					await (tx.RollbackAsync());
				}
			}
		}

		[Test]
		public async Task MergeManyToManyWithCollectionDeferenceAsync()
		{
			if (!TestDialect.SupportsEmptyInsertsOrHasNonIdentityNativeGenerator)
				Assert.Ignore("Support of empty inserts is required");

			// setup base data...
			Competition competition;
			using (ISession s = OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				competition = new Competition();
				competition.Competitors.Add(new Competitor {Name = "Name"});
				competition.Competitors.Add(new Competitor());
				competition.Competitors.Add(new Competitor());
				await (s.PersistAsync(competition));
				await (tx.CommitAsync());
			}

			// the competition graph is now detached:
			//   1) create a new List reference to represent the competitors
			Competition competition2;
			using (var s = OpenSession())
			using (var tx = s.BeginTransaction())
			{
				var newComp = new List<Competitor>();
				Competitor originalCompetitor = competition.Competitors[0];
				originalCompetitor.Name = "Name2";
				newComp.Add(originalCompetitor);
				newComp.Add(new Competitor());
				//   2) set that new List reference unto the Competition reference
				competition.Competitors = newComp;
				//   3) attempt the merge
				competition2 = (Competition) await (s.MergeAsync(competition));
				await (tx.CommitAsync());
			}

			Assert.That(!(competition == competition2));
			Assert.That(!(competition.Competitors == competition2.Competitors));
			Assert.That(competition2.Competitors.Count, Is.EqualTo(2));

			using (var s = OpenSession())
			using (var tx = s.BeginTransaction())
			{
				competition = await (s.GetAsync<Competition>(competition.Id));
				Assert.That(competition.Competitors.Count, Is.EqualTo(2));
				await (s.DeleteAsync(competition));
				await (tx.CommitAsync());
			}
		}

		[Test]
		public async Task MergeStaleVersionFailsAsync()
		{
			var entity = new VersionedEntity {Id = "entity", Name = "entity"};
			using(ISession s = OpenSession())
			using(s.BeginTransaction())
			{
				await (s.PersistAsync(entity));
				await (s.Transaction.CommitAsync());
			}

			// make the detached 'entity' reference stale...
			using(var s = OpenSession())
			using (s.BeginTransaction())
			{
				var entity2 = await (s.GetAsync<VersionedEntity>(entity.Id));
				entity2.Name = "entity-name";
				await (s.Transaction.CommitAsync());
			}

			// now try to reattch it
			ISession s2 = null;
			try
			{
				s2 = OpenSession();
				s2.BeginTransaction();

				await (s2.MergeAsync(entity));
				await (s2.Transaction.CommitAsync());
				Assert.Fail("was expecting staleness error");
			}
			catch (StaleObjectStateException)
			{
				// expected outcome...
			}
			finally
			{
				if (s2 != null)
				{
					await (s2.Transaction.RollbackAsync());
					s2.Close();
				}
				await (CleanupAsync());
			}
		}

		[Test]
		public async Task MergeTreeAsync()
		{
			ClearCounts();

			var root = new Node
			{
				Created = RoundForDialect(DateTime.Now),
				Name = "root"
			};
			var child = new Node
			{
				Created = RoundForDialect(DateTime.Now),
				Name = "child"
			};
			using(ISession s = OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				root.AddChild(child);
				await (s.PersistAsync(root));
				await (tx.CommitAsync());
			}

			AssertInsertCount(2);
			ClearCounts();

			root.Description = "The root node";
			child.Description = "The child node";

			var secondChild = new Node
			{
				Created = RoundForDialect(DateTime.Now),
				Name = "second child"
			};

			root.AddChild(secondChild);

			using(var s = OpenSession())
			using (var tx = s.BeginTransaction())
			{
				await (s.MergeAsync(root));
				await (tx.CommitAsync());
			}

			AssertInsertCount(1);
			AssertUpdateCount(2);
		}

		[Test]
		public async Task MergeTreeWithGeneratedIdAsync()
		{
			ClearCounts();

			var root = new NumberedNode("root", RoundForDialect(DateTime.Now));
			var child = new NumberedNode("child", RoundForDialect(DateTime.Now));
			using(ISession s = OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				root.AddChild(child);
				await (s.PersistAsync(root));
				await (tx.CommitAsync());
			}

			AssertInsertCount(2);
			ClearCounts();

			root.Description = "The root node";
			child.Description = "The child node";

			var secondChild = new NumberedNode("second child", RoundForDialect(DateTime.Now));

			root.AddChild(secondChild);

			using(var s = OpenSession())
			using (var tx = s.BeginTransaction())
			{
				await (s.MergeAsync(root));
				await (tx.CommitAsync());
			}

			AssertInsertCount(1);
			AssertUpdateCount(2);
		}

		[Test]
		public async Task NoExtraUpdatesOnMergeAsync()
		{
			var node = new Node
			{
				Created = RoundForDialect(DateTime.Now),
				Name = "test"
			};
			using(ISession s = OpenSession())
			using (s.BeginTransaction())
			{
				await (s.PersistAsync(node));
				await (s.Transaction.CommitAsync());
			}

			ClearCounts();

			// node is now detached, but we have made no changes.  so attempt to merge it
			// into this new session; this should cause no updates...
			using(var s = OpenSession())
			using (s.BeginTransaction())
			{
				node = (Node) await (s.MergeAsync(node));
				await (s.Transaction.CommitAsync());
			}

			AssertUpdateCount(0);
			AssertInsertCount(0);

			///////////////////////////////////////////////////////////////////////
			// as a control measure, now update the node while it is detached and
			// make sure we get an update as a result...
			node.Description = "new description";
			using(var s = OpenSession())
			using (s.BeginTransaction())
			{
				node = (Node) await (s.MergeAsync(node));
				await (s.Transaction.CommitAsync());
			}
			AssertUpdateCount(1);
			AssertInsertCount(0);
			///////////////////////////////////////////////////////////////////////
		}

		[Test]
		public async Task NoExtraUpdatesOnMergeVersionedAsync()
		{
			var entity = new VersionedEntity {Id = "entity", Name = "entity"};
			using (ISession s = OpenSession())
			using (s.BeginTransaction())
			{
				await (s.PersistAsync(entity));
				await (s.Transaction.CommitAsync());
			}

			ClearCounts();

			// entity is now detached, but we have made no changes.  so attempt to merge it
			// into this new session; this should cause no updates...
			VersionedEntity mergedEntity;
			using (var s = OpenSession())
			using (s.BeginTransaction())
			{
				mergedEntity = (VersionedEntity) await (s.MergeAsync(entity));
				await (s.Transaction.CommitAsync());
			}

			AssertUpdateCount(0);
			AssertInsertCount(0);
			Assert.That(entity.Version, Is.EqualTo(mergedEntity.Version), "unexpected version increment");

			///////////////////////////////////////////////////////////////////////
			// as a control measure, now update the node while it is detached and
			// make sure we get an update as a result...
			entity.Name = "new name";
			using(var s = OpenSession())
			using (s.BeginTransaction())
			{
				entity = (VersionedEntity) await (s.MergeAsync(entity));
				await (s.Transaction.CommitAsync());
			}
			AssertUpdateCount(1);
			AssertInsertCount(0);
			///////////////////////////////////////////////////////////////////////
		}

		[Test]
		public async Task NoExtraUpdatesOnMergeVersionedWithCollectionAsync()
		{
			var parent = new VersionedEntity {Id = "parent", Name = "parent"};
			var child = new VersionedEntity {Id = "child", Name = "child"};

			using(ISession s = OpenSession())
			using (s.BeginTransaction())
			{
				parent.Children.Add(child);
				child.Parent = parent;
				await (s.PersistAsync(parent));
				await (s.Transaction.CommitAsync());
			}

			ClearCounts();

			// parent is now detached, but we have made no changes.  so attempt to merge it
			// into this new session; this should cause no updates...
			VersionedEntity mergedParent;
			using(var s = OpenSession())
			using (s.BeginTransaction())
			{
				mergedParent = (VersionedEntity) await (s.MergeAsync(parent));
				await (s.Transaction.CommitAsync());
			}

			AssertUpdateCount(0);
			AssertInsertCount(0);
			Assert.That(parent.Version, Is.EqualTo(mergedParent.Version), "unexpected parent version increment");
			IEnumerator<VersionedEntity> it = mergedParent.Children.GetEnumerator();
			it.MoveNext();
			VersionedEntity mergedChild = it.Current;
			Assert.That(child.Version, Is.EqualTo(mergedChild.Version), "unexpected child version increment");

			///////////////////////////////////////////////////////////////////////
			// as a control measure, now update the node while it is detached and
			// make sure we get an update as a result...
			mergedParent.Name = "new name";
			mergedParent.Children.Add(new VersionedEntity {Id = "child2", Name = "new child"});
			using(var s = OpenSession())
			using (s.BeginTransaction())
			{
				parent = (VersionedEntity) await (s.MergeAsync(mergedParent));
				await (s.Transaction.CommitAsync());
			}
			AssertUpdateCount(1);
			AssertInsertCount(1);
			///////////////////////////////////////////////////////////////////////
		}

		[Test]
		public async Task NoExtraUpdatesOnMergeWithCollectionAsync()
		{
			var parent = new Node
			{
				Created = RoundForDialect(DateTime.Now),
				Name = "parent"
			};
			using(ISession s = OpenSession())
			using (s.BeginTransaction())
			{
				var child = new Node
				{
					Created = RoundForDialect(DateTime.Now),
					Name = "child"
				};
				parent.Children.Add(child);
				child.Parent = parent;
				await (s.PersistAsync(parent));
				await (s.Transaction.CommitAsync());
			}

			ClearCounts();

			// parent is now detached, but we have made no changes.  so attempt to merge it
			// into this new session; this should cause no updates...
			using(var s = OpenSession())
			using (s.BeginTransaction())
			{
				parent = (Node) await (s.MergeAsync(parent));
				await (s.Transaction.CommitAsync());
			}

			AssertUpdateCount(0);
			AssertInsertCount(0);

			///////////////////////////////////////////////////////////////////////
			// as a control measure, now update the node while it is detached and
			// make sure we get an update as a result...
			IEnumerator<Node> it = parent.Children.GetEnumerator();
			it.MoveNext();
			it.Current.Description = "child's new description";
			parent.Children.Add(
				new Node
				{
					Created = RoundForDialect(DateTime.Now),
					Name = "second child"
				});
			using(var s = OpenSession())
			using (s.BeginTransaction())
			{
				parent = (Node) await (s.MergeAsync(parent));
				await (s.Transaction.CommitAsync());
			}
			AssertUpdateCount(1);
			AssertInsertCount(1);
			///////////////////////////////////////////////////////////////////////
		}

		[Test]
		public async Task PersistThenMergeInSameTxnWithTimestampAsync()
		{
			using(ISession s = OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				var entity = new TimestampedEntity {Id = "test", Name = "test"};
				await (s.PersistAsync(entity));
				await (s.MergeAsync(new TimestampedEntity {Id = "test", Name = "test-2"}));

				try
				{
					// control operation...
					await (s.SaveOrUpdateAsync(new TimestampedEntity {Id = "test", Name = "test-3"}));
					Assert.Fail("saveOrUpdate() should fail here");
				}
				catch (NonUniqueObjectException)
				{
					// expected behavior
				}

				await (tx.CommitAsync());
			}
		}

		[Test]
		public async Task PersistThenMergeInSameTxnWithVersionAsync()
		{
			using(ISession s = OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				var entity = new VersionedEntity {Id = "test", Name = "test"};
				await (s.PersistAsync(entity));
				await (s.MergeAsync(new VersionedEntity {Id = "test", Name = "test-2"}));

				try
				{
					// control operation...
					await (s.SaveOrUpdateAsync(new VersionedEntity {Id = "test", Name = "test-3"}));
					Assert.Fail("saveOrUpdate() should fail here");
				}
				catch (NonUniqueObjectException)
				{
					// expected behavior
				}

				await (tx.CommitAsync());
			}
		}

		[Test]
		public async Task RecursiveMergeTransientAsync()
		{
			if (!TestDialect.SupportsEmptyInsertsOrHasNonIdentityNativeGenerator)
				Assert.Ignore("Support of empty inserts is required");

			using (ISession s = OpenSession())
			{
				using (ITransaction tx = s.BeginTransaction())
				{
					var jboss = new Employer();
					var gavin = new Employee();
					jboss.Employees = new List<Employee> {gavin};
					await (s.MergeAsync(jboss));
					await (s.FlushAsync());
					jboss = await (s.CreateQuery("from Employer e join fetch e.Employees").UniqueResultAsync<Employer>());
					Assert.That(NHibernateUtil.IsInitialized(jboss.Employees));
					Assert.That(jboss.Employees.Count, Is.EqualTo(1));
					s.Clear();
					IEnumerator<Employee> it = jboss.Employees.GetEnumerator();
					it.MoveNext();

					await (s.MergeAsync(it.Current));
					await (tx.CommitAsync());
				}
			}
		}
	}
}
