//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System.Collections.Generic;
using NHibernate.Driver;
using NHibernate.Linq;
using NUnit.Framework;
using System.Linq;

namespace NHibernate.Test.Futures
{
	using System.Threading.Tasks;
	[TestFixture]
	public class LinqFutureFixtureAsync : FutureFixture
	{
		[Test]
		public async Task DefaultReadOnlyTestAsync()
		{
			//NH-3575
			using (var s = Sfi.OpenSession())
			{
				s.DefaultReadOnly = true;

				var persons = s.Query<Person>().ToFuture();

				Assert.IsTrue((await (persons.GetEnumerableAsync())).All(p => s.IsReadOnly(p)));
			}
		}

		[Test]
		public async Task CoalesceShouldWorkForFuturesAsync()
		{
			int personId;
			using (ISession s = OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				var p1 = new Person { Name = "inserted name" };
				var p2 = new Person { Name = null };

				await (s.SaveAsync(p1));
				await (s.SaveAsync(p2));
				personId = p2.Id;
				await (tx.CommitAsync());
			}

			using (ISession s = OpenSession())
			using (s.BeginTransaction())
			{
				var person = s.Query<Person>().Where(p => (p.Name ?? "e") == "e").ToFutureValue();
				Assert.AreEqual(personId, (await (person.GetValueAsync())).Id);
			}

			using (ISession s = OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				await (s.DeleteAsync("from Person"));
				await (tx.CommitAsync());
			}
		}

		[Test]
		public async Task CanUseToFutureWithContainsAsync()
		{
			using (var s = Sfi.OpenSession())
			{
				var ids = new[] { 1, 2, 3 };
				var persons10 = (await (s.Query<Person>()
					.Where(p => ids.Contains(p.Id))
					.FetchMany(p => p.Children)
					.Skip(5)
					.Take(10)
					.ToFuture().GetEnumerableAsync())).ToList();

				Assert.IsNotNull(persons10);
			}
		}

		[Test]
		public async Task CanUseToFutureWithContains2Async()
		{
			using (var s = Sfi.OpenSession())
			{
				var ids = new[] { 1, 2, 3 };
				var persons10 = (await (s.Query<Person>()
					.Where(p => ids.Contains(p.Id))
					.ToFuture()
					.GetEnumerableAsync()))
					.ToList();

				Assert.IsNotNull(persons10);
			}
		}

		[Test]
		public async Task CanUseSkipAndFetchManyWithToFutureAsync()
		{
			IgnoreThisTestIfMultipleQueriesArentSupportedByDriver();

			using (var s = Sfi.OpenSession())
			using (var tx = s.BeginTransaction())
			{
				var p1 = new Person { Name = "Parent" };
				var p2 = new Person { Parent = p1, Name = "Child" };
				p1.Children.Add(p2);
				await (s.SaveAsync(p1));
				await (s.SaveAsync(p2));
				await (tx.CommitAsync());

				s.Clear(); // we don't want caching
			}

			using (var s = Sfi.OpenSession())
			{
				var persons10 = s.Query<Person>()
					.FetchMany(p => p.Children)
					.Skip(5)
					.Take(10)
					.ToFuture();

				var persons5 = s.Query<Person>()
					.ToFuture();

				using (var logSpy = new SqlLogSpy())
				{
					foreach (var person in await (persons5.GetEnumerableAsync())) { }

					foreach (var person in await (persons10.GetEnumerableAsync())) { }

					var events = logSpy.Appender.GetEvents();
					Assert.AreEqual(1, events.Length);
				}
			}

			using (ISession s = OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				await (s.DeleteAsync("from Person"));
				await (tx.CommitAsync());
			}
		}

		[Test]
		public async Task CanUseFutureQueryAsync()
		{
			IgnoreThisTestIfMultipleQueriesArentSupportedByDriver();

			using (var s = Sfi.OpenSession())
			{
				var persons10 = s.Query<Person>()
					.Take(10)
					.ToFuture();
				var persons5 = s.Query<Person>()
					.Take(5)
					.ToFuture();

				using (var logSpy = new SqlLogSpy())
				{
					foreach (var person in await (persons5.GetEnumerableAsync()))
					{
					}

					foreach (var person in await (persons10.GetEnumerableAsync()))
					{
					}

					var events = logSpy.Appender.GetEvents();
					Assert.AreEqual(1, events.Length);
				}
			}
		}

		[Test]
		public async Task CanUseFutureQueryAndQueryOverForSatelessSessionAsync()
		{
			IgnoreThisTestIfMultipleQueriesArentSupportedByDriver();

			using (var s = Sfi.OpenStatelessSession())
			{
				var persons10 = s.Query<Person>()
					.Take(10)
					.ToFuture();
				var persons5 = s.QueryOver<Person>()
					.Take(5)
					.Future();

				using (var logSpy = new SqlLogSpy())
				{
					foreach (var person in await (persons5.GetEnumerableAsync()))
					{
					}

					foreach (var person in await (persons10.GetEnumerableAsync()))
					{
					}

					var events = logSpy.Appender.GetEvents();
					Assert.AreEqual(1, events.Length);
				}
			}
		}

		[Test]
		public async Task CanUseFutureQueryWithAnonymousTypeAsync()
		{
			IgnoreThisTestIfMultipleQueriesArentSupportedByDriver();

			using (var s = Sfi.OpenSession())
			{
				var persons = s.Query<Person>()
					.Select(p => new { Id = p.Id, Name = p.Name })
					.ToFuture();
				var persons5 = s.Query<Person>()
					.Select(p => new { Id = p.Id, Name = p.Name })
					.Take(5)
					.ToFuture();

				using (var logSpy = new SqlLogSpy())
				{
					(await (persons5.GetEnumerableAsync())).ToList(); // initialize the enumerable
					(await (persons.GetEnumerableAsync())).ToList();

					var events = logSpy.Appender.GetEvents();
					Assert.AreEqual(1, events.Length);
				}
			}
		}

		[Test]
		public async Task CanUseFutureFetchQueryAsync()
		{
			IgnoreThisTestIfMultipleQueriesArentSupportedByDriver();

			using (var s = Sfi.OpenSession())
			using (var tx = s.BeginTransaction())
			{
				var p1 = new Person { Name = "Parent" };
				var p2 = new Person { Parent = p1, Name = "Child" };
				p1.Children.Add(p2);
				await (s.SaveAsync(p1));
				await (s.SaveAsync(p2));
				await (tx.CommitAsync());

				s.Clear(); // we don't want caching
			}

			using (var s = Sfi.OpenSession())
			{
				var persons = s.Query<Person>()
					.FetchMany(p => p.Children)
					.ToFuture();
				var persons10 = s.Query<Person>()
					.FetchMany(p => p.Children)
					.Take(10)
					.ToFuture();

				using (var logSpy = new SqlLogSpy())
				{

					Assert.That((await (persons.GetEnumerableAsync())).Any(x => x.Children.Any()), "No children found");
					Assert.That((await (persons10.GetEnumerableAsync())).Any(x => x.Children.Any()), "No children found");

					var events = logSpy.Appender.GetEvents();
					Assert.AreEqual(1, events.Length);
				}
			}

			using (var s = OpenSession())
			using (var tx = s.BeginTransaction())
			{
				await (s.DeleteAsync("from Person"));
				await (tx.CommitAsync());
			}
		}

		[Test]
		public async Task TwoFuturesRunInTwoRoundTripsAsync()
		{
			IgnoreThisTestIfMultipleQueriesArentSupportedByDriver();

			using (var s = Sfi.OpenSession())
			{
				using (var logSpy = new SqlLogSpy())
				{
					var persons10 = s.Query<Person>()
						.Take(10)
						.ToFuture();

					foreach (var person in await (persons10.GetEnumerableAsync())) { } // fire first future round-trip

					var persons5 = s.Query<Person>()
						.Take(5)
						.ToFuture();

					foreach (var person in await (persons5.GetEnumerableAsync())) { } // fire second future round-trip

					var events = logSpy.Appender.GetEvents();
					Assert.AreEqual(2, events.Length);
				}
			}
		}

		[Test]
		public async Task CanCombineSingleFutureValueWithEnumerableFuturesAsync()
		{
			IgnoreThisTestIfMultipleQueriesArentSupportedByDriver();

			using (var s = Sfi.OpenSession())
			{
				var persons = s.Query<Person>()
					.Take(10)
					.ToFuture();

				var personCount = s.Query<Person>()
					.Select(x => x.Id)
					.ToFutureValue();

				using (var logSpy = new SqlLogSpy())
				{
					long count = await (personCount.GetValueAsync());

					foreach (var person in await (persons.GetEnumerableAsync()))
					{
					}

					var events = logSpy.Appender.GetEvents();
					Assert.AreEqual(1, events.Length);
				}
			}
		}

		[Test(Description = "NH-2385")]
		public async Task CanCombineSingleFutureValueWithFetchManyAsync()
		{
			int personId;
			using (var s = OpenSession())
			using (var tx = s.BeginTransaction())
			{
				var p1 = new Person { Name = "inserted name" };
				var p2 = new Person { Name = null };

				await (s.SaveAsync(p1));
				await (s.SaveAsync(p2));
				personId = p2.Id;
				await (tx.CommitAsync());
			}

			using (var s = Sfi.OpenSession())
			{
				var meContainer = s.Query<Person>()
								   .Where(x => x.Id == personId)
								   .FetchMany(x => x.Children)
								   .ToFutureValue();

				Assert.AreEqual(personId, (await (meContainer.GetValueAsync())).Id);
			}

			using (var s = OpenSession())
			using (var tx = s.BeginTransaction())
			{
				await (s.DeleteAsync("from Person"));
				await (tx.CommitAsync());
			}
		}

		[Test]
		public async Task CanExecuteMultipleQueriesOnSameExpressionAsync()
		{
			using (var s = Sfi.OpenSession())
			{
				IgnoreThisTestIfMultipleQueriesArentSupportedByDriver();

				var meContainer = s.Query<Person>()
					.Where(x => x.Id == 1)
					.ToFutureValue();

				var possiblefriends = s.Query<Person>()
					.Where(x => x.Id != 2)
					.ToFuture();

				using (var logSpy = new SqlLogSpy())
				{
					var me = await (meContainer.GetValueAsync());

					foreach (var person in await (possiblefriends.GetEnumerableAsync()))
					{
					}

					var events = logSpy.Appender.GetEvents();
					Assert.AreEqual(1, events.Length);
					var wholeLog = logSpy.GetWholeLog();
					string paramPrefix = ((DriverBase) Sfi.ConnectionProvider.Driver).NamedPrefix;
					Assert.That(
						wholeLog,
						Does.Contain(paramPrefix + "p0 = 1 [Type: Int32 (0:0:0)], " + paramPrefix + "p1 = 2 [Type: Int32 (0:0:0)]"));
				}
			}
		}

		[Test]
		public async Task UsingManyParametersAndQueries_DoesNotCauseParameterNameCollisionsAsync()
		{
			//GH-1357
			using (var s = OpenSession())
			using (var tx = s.BeginTransaction())
			{
				var p1 = new Person { Name = "Person name", Age = 15};
				var p2 = new Person { Name = "Person name", Age = 5 };

				await (s.SaveAsync(p1));
				await (s.SaveAsync(p2));
				await (tx.CommitAsync());
			}
			using (var s = Sfi.OpenSession())
			{
				var list = new List<IFutureEnumerable<Person>>();
				for (var i = 0; i < 12; i++)
				{
					var query = s.Query<Person>();
					for (var j = 0; j < 12; j++)
					{
						query = query.Where(x => x.Age > j);
					}
					list.Add(query.WithOptions(x => x.SetCacheable(true)).ToFuture());
				}
				foreach (var query in list)
				{
					var result = query.ToList();
					Assert.That(result.Count,Is.EqualTo(1));
				}
			}
			using (var s = OpenSession())
			using (var tx = s.BeginTransaction())
			{
				await (s.DeleteAsync("from Person"));
				await (tx.CommitAsync());
			}
		}

		[Test]
		public async Task FutureCombineCachedAndNonCachedQueriesAsync()
		{
			using (var s = OpenSession())
			using (var tx = s.BeginTransaction())
			{
				var p1 = new Person
				{
					Name = "Person name",
					Age = 15
				};
				var p2 = new Person
				{
					Name = "Person name",
					Age = 20
				};

				await (s.SaveAsync(p1));
				await (s.SaveAsync(p2));
				await (tx.CommitAsync());
			}

			using (var s = Sfi.OpenSession())
			{
				var list = new List<IFutureEnumerable<Person>>();
				for (var i = 0; i < 5; i++)
				{
					var i1 = i;
					var query = s.Query<Person>().Where(x => x.Age > i1);
					list.Add(query.WithOptions(x => x.SetCacheable(true)).ToFuture());
				}

				foreach (var query in list)
				{
					var result = (await (query.GetEnumerableAsync())).ToList();
					Assert.That(result.Count, Is.EqualTo(2));
				}
			}

			//Check query.List returns data from cache
			Sfi.Statistics.IsStatisticsEnabled = true;
			using (var s = Sfi.OpenSession())
			{
				var list = new List<IEnumerable<Person>>();
				for (var i = 0; i < 5; i++)
				{
					var i1 = i;
					var query = s.Query<Person>().Where(x => x.Age > i1);

					list.Add(await (query.WithOptions(x => x.SetCacheable(true)).ToListAsync()));
				}

				foreach (var query in list)
				{
					var result = query.ToList();
					Assert.That(result.Count, Is.EqualTo(2));
				}

				Assert.That(Sfi.Statistics.PrepareStatementCount, Is.EqualTo(0), "Queries must be retrieved from cache");
			}

			//Check another Future returns data from cache
			Sfi.Statistics.Clear();
			using (var s = Sfi.OpenSession())
			{
				var list = new List<IFutureEnumerable<Person>>();
				//Reverse order of queries added to cache
				for (var i = 5 - 1; i >= 0; i--)
				{
					var i1 = i;
					var query = s.Query<Person>().Where(x => x.Age > i1);

					list.Add(query.WithOptions(x => x.SetCacheable(true)).ToFuture());
				}

				foreach (var query in list)
				{
					var result = (await (query.GetEnumerableAsync())).ToList();
					Assert.That(result.Count, Is.EqualTo(2));
				}

				Assert.That(Sfi.Statistics.PrepareStatementCount , Is.EqualTo(0), "Future queries must be retrieved from cache");
			}

			using (var s = OpenSession())
			using (var tx = s.BeginTransaction())
			{
				await (s.DeleteAsync("from Person"));
				await (tx.CommitAsync());
			}
		}

		[Test]
		public async Task FutureAutoFlushAsync()
		{
			using (var s = OpenSession())
			using (var tx = s.BeginTransaction())
			{
				s.FlushMode = FlushMode.Auto;
				var p1 = new Person
				{
					Name = "Person name",
					Age = 15
				};
				await (s.SaveAsync(p1));
				await (s.FlushAsync());

				await (s.DeleteAsync(p1));
				var count = await (s.QueryOver<Person>().ToRowCountQuery().FutureValue<int>().GetValueAsync());
				await (tx.CommitAsync());

				Assert.That(count, Is.EqualTo(0), "Session wasn't auto flushed.");
			}
		}
	}
}
