solution:
  filePath: NHibernate.sln
  concurrentRun: true
  applyChanges: true
  projects:
  - name: NHibernate
    analyzation:
      methodConversion:
      - conversion: Ignore
        hasAttributeName: ObsoleteAttribute
      - conversion: Ignore
        name: PostProcessInsert
        containingTypeName: HqlSqlWalker
      - conversion: Ignore
        name: Intercept
        containingTypeName: IInterceptor
      - conversion: Ignore
        name: Intercept
        containingTypeName: IFieldInterceptor
      - conversion: Ignore
        name: InitializeOrGetAssociation
        containingTypeName: AbstractFieldInterceptor
      - conversion: Ignore
        name: InitializeLazyProperty
        containingTypeName: ILazyPropertyInitializer
      - conversion: Ignore
        name: InitializeLazyPropertiesFromDatastore
        containingTypeName: AbstractEntityPersister
      - conversion: Ignore
        name: InitializeLazyPropertiesFromCache
        containingTypeName: AbstractEntityPersister
      - conversion: Ignore
        name: Invoke
        containingTypeName: BasicLazyInitializer
      - conversion: Ignore
        name: SetReadOnly
        containingTypeName: StatefulPersistenceContext
      - conversion: Ignore
        name: Unproxy
        containingTypeName: StatefulPersistenceContext
      - conversion: Ignore
        name: Contains
        containingTypeName: CollectionType
      - conversion: Ignore
        name: GuessClass
        containingTypeName: NHibernateProxyHelper
      - conversion: Ignore
        name: IsPropertyInitialized
        containingTypeName: NHibernateUtil
      - conversion: Ignore
        name: BestGuessEntityName
        containingTypeName: ISession
      - conversion: Ignore
        name: Contains
        containingTypeName: ISession
      - conversion: Ignore
        name: BestGuessEntityName
        containingTypeName: ISessionImplementor
      - conversion: Ignore
        name: Contains
        containingTypeName: ISessionImplementor
      - conversion: Ignore
        name: GetUnsavedVersionValue
        containingTypeName: UnsavedValueFactory
      - conversion: Ignore
        name: ReadSize
        containingTypeName: AbstractPersistentCollection
      - conversion: Ignore
        name: ReadIndexExistence
        containingTypeName: AbstractPersistentCollection
      - conversion: Ignore
        name: ReadElementExistence
        containingTypeName: AbstractPersistentCollection
      - conversion: Ignore
        name: ReadElementByIndex
        containingTypeName: AbstractPersistentCollection
      - conversion: Ignore
        name: Read
        containingTypeName: AbstractPersistentCollection
      - conversion: Ignore
        name: Write
        containingTypeName: AbstractPersistentCollection
      - conversion: Ignore
        name: GetSize
        containingTypeName: ICollectionPersister
      - conversion: Ignore
        name: IndexExists
        containingTypeName: ICollectionPersister
      - conversion: Ignore
        name: ElementExists
        containingTypeName: ICollectionPersister
      - conversion: Ignore
        name: GetElementByIndex
        containingTypeName: ICollectionPersister
      - conversion: Ignore
        name: Exists
        containingTypeName: ICollectionPersister
      - conversion: Ignore
        name: Exists
        containingTypeName: AbstractCollectionPersister
      - conversion: ToAsync
        name: ExecuteReader
        containingTypeName: IBatcher
      - conversion: ToAsync
        name: ExecuteNonQuery
        containingTypeName: IBatcher
      - conversion: ToAsync
        rule: EventListener
      ignoreSearchForAsyncCounterparts:
      - name: GetFieldValue
      - name: IsDBNull
      - name: WriteLine
      callForwarding: true
      cancellationTokens:
        guards: true
        methodParameter:
        - anyInterfaceRule: PubliclyExposedType
          parameter: Optional
        - parameter: Optional
          rule: PubliclyExposedType
        - parameter: Required
        requiresCancellationToken:
        - rule: EventListener
      scanMethodBody: true
    transformation:
      configureAwaitArgument: false
      localFunctions: true
      asyncLock:
        type: NHibernate.Util.AsyncLock
        methodName: LockAsync
      documentationComments:
        addOrReplaceMethodSummary:
          - name: Commit
            containingTypeName: AdoTransaction
            content: |
                /// Commits the <see cref="ITransaction"/> by flushing asynchronously the <see cref="ISession"/>
                /// then committing synchronously the <see cref="DbTransaction"/>.
    registerPlugin:
    - type: AsyncGenerator.Core.Plugins.TransactionScopeAsyncFlowAdder
      assemblyName: AsyncGenerator.Core
    - type: AsyncGenerator.Core.Plugins.EmptyRegionRemover
      assemblyName: AsyncGenerator.Core
  - name: NHibernate.DomainModel
    analyzation:
      scanMethodBody: true
      scanForMissingAsyncMembers:
      - all: true
  - name: NHibernate.Test
    analyzation:
      methodConversion:
      - conversion: Ignore
        hasAttributeName: IgnoreAttribute
      - conversion: Smart
        hasAttributeName: TestAttribute
      preserveReturnType:
      - hasAttributeName: TestAttribute
      typeConversion:
      - conversion: Ignore
        name: NorthwindDbCreator
      - conversion: Ignore
        name: ObjectAssert
      - conversion: Ignore
        name: LinqReadonlyTestsContext
      - conversion: Ignore
        hasAttributeName: IgnoreAttribute
      - conversion: NewType
        hasAttributeName: TestFixtureAttribute
      - conversion: Ignore
        rule: IsTestCase
      - conversion: Ignore
        anyBaseTypeRule: IsTestCase
      ignoreDocuments:
      - filePathEndsWith: Linq\MathTests.cs
      - filePathEndsWith: Linq\ExpressionSessionLeakTest.cs
      cancellationTokens:
        withoutCancellationToken:
        - hasAttributeName: TestAttribute
      scanMethodBody: true
      scanForMissingAsyncMembers:
      - anyInterfaceRule: NHibernateAssembly
    registerPlugin:
    - type: AsyncGenerator.Core.Plugins.TransactionScopeAsyncFlowAdder
      assemblyName: AsyncGenerator.Core
    - type: LinqAsyncCounterpartsFinder
    - type: NUnitAsyncCountepartFinder
methodRules:
- filters:
  - containingTypeName: IAutoFlushEventListener
  - containingTypeName: IFlushEventListener
  - containingTypeName: IDeleteEventListener
  - containingTypeName: ISaveOrUpdateEventListener
  - containingTypeName: IPostCollectionRecreateEventListener
  - containingTypeName: IPostCollectionRemoveEventListener
  - containingTypeName: IPostCollectionUpdateEventListener
  - containingTypeName: IPostDeleteEventListener
  - containingTypeName: IPostInsertEventListener
  - containingTypeName: IPostUpdateEventListener
  - containingTypeName: IPreCollectionRecreateEventListener
  - containingTypeName: IPreCollectionRemoveEventListener
  - containingTypeName: IPreCollectionUpdateEventListener
  - containingTypeName: IPreDeleteEventListener
  - containingTypeName: IPreInsertEventListener
  - containingTypeName: IPreLoadEventListener
  - containingTypeName: IPreUpdateEventListener
  name: EventListener
- filters:
  - containingNamespace: NHibernate
  - containingType: NHibernate.Tool.hbm2ddl.SchemaUpdate
  - containingType: NHibernate.Tool.hbm2ddl.SchemaValidator
  - containingType: NHibernate.Tool.hbm2ddl.SchemaExport
  name: PubliclyExposedType
typeRules:
- filters:
  - containingAssemblyName: NHibernate
  name: NHibernateAssembly
- filters:
  - name: TestCase
  name: IsTestCase
cSharpScript: | 
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    using AsyncGenerator.Analyzation;
    using AsyncGenerator.Configuration;
    using AsyncGenerator.Core;
    using AsyncGenerator.Core.Configuration;
    using AsyncGenerator.Core.Plugins;
    using AsyncGenerator.Core.Transformation;
    using AsyncGenerator.Extensions;
    using AsyncGenerator.Extensions.Internal;
    using AsyncGenerator.Plugins;
    using AsyncGenerator.Transformation;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using Microsoft.CodeAnalysis.CSharp;
    using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

    public class NUnitAsyncCountepartFinder : IAsyncCounterpartsFinder
    {
        public Task Initialize(Project project, IProjectConfiguration configuration)
        {
            return Task.CompletedTask;
        }

        public IEnumerable<IMethodSymbol> FindAsyncCounterparts(IMethodSymbol syncMethodSymbol, ITypeSymbol invokedFromType, AsyncCounterpartsSearchOptions options)
        {
            if (syncMethodSymbol.Name != "That" || syncMethodSymbol.ContainingType.Name != "Assert" ||syncMethodSymbol.ContainingType.ContainingNamespace.ToString() != "NUnit.Framework")
            {
                yield break;
            }

            var firstParamType = syncMethodSymbol.Parameters.First().Type;
            if (firstParamType.Name == "ActualValueDelegate" || firstParamType.Name == "TestDelegate")
            {
                yield return syncMethodSymbol;
            }
        }
    }

    public class LinqAsyncCounterpartsFinder : IAsyncCounterpartsFinder, IDocumentTransformer
    {
        private HashSet<IMethodSymbol> _linqMethods;
        private ILookup<string, IMethodSymbol> _linqMethodsLookup;

        public async Task Initialize(Project project, IProjectConfiguration configuration)
        {
            var nhProject = project.Solution.Projects.First(o => o.Name == "NHibernate");
            var doc = nhProject.Documents.First(o => o.Name == "LinqExtensionMethods.cs");
            var rootNode = await doc.GetSyntaxRootAsync().ConfigureAwait(false);
            var semanticModel = await doc.GetSemanticModelAsync().ConfigureAwait(false);
            _linqMethods = new HashSet<IMethodSymbol>(rootNode.DescendantNodes()
                .OfType<MethodDeclarationSyntax>()
                .Where(o => o.Identifier.ValueText.EndsWith("Async"))
                .Select(o => semanticModel.GetDeclaredSymbol(o)));
            _linqMethodsLookup = _linqMethods.ToLookup(o => o.Name);
        }

        public CompilationUnitSyntax Transform(IDocumentTransformationResult transformationResult)
        {
            if (!transformationResult.AnalyzationResult.GetAllTypes()
                .SelectMany(o => o.GetSelfAndDescendantsTypes())
                .Any(o => o.Methods.Any(m => m.MethodReferences.Any(r => _linqMethods.Contains(r.AsyncCounterpartSymbol)))) ||
                transformationResult.Transformed.Usings.Any(o => o.Name.ToString() == "NHibernate.Linq"))
            {
                return null;
            }
            return transformationResult.Transformed
                .AddUsings(
                    UsingDirective(QualifiedName(IdentifierName("NHibernate"), IdentifierName("Linq")))
                        .WithUsingKeyword(Token(TriviaList(), SyntaxKind.UsingKeyword, TriviaList(Space)))
                        .WithSemicolonToken(Token(TriviaList(), SyntaxKind.SemicolonToken, TriviaList(transformationResult.EndOfLineTrivia))));
        }

        public IEnumerable<IMethodSymbol> FindAsyncCounterparts(IMethodSymbol symbol, ITypeSymbol invokedFromType, AsyncCounterpartsSearchOptions options)
        {
            var ns = symbol.ContainingNamespace?.ToString() ?? "";
            var isToList = symbol.ContainingType.Name == "Enumerable" && symbol.Name == "ToList";
            if (!ns.StartsWith("System.Linq") || (!isToList && symbol.ContainingType.Name != "Queryable"))
            {
                yield break;
            }
            var asyncName = symbol.Name + "Async";
            foreach (var asyncCandidate in _linqMethodsLookup[asyncName])
            {
                if (!symbol.IsAsyncCounterpart(invokedFromType, asyncCandidate, true, true, false))
                {
                    continue;
                }
                yield return asyncCandidate;
                yield break;
            }
        }
    }