using System.Collections;
using System.Data;
using System.Text;
using System.Text.RegularExpressions;
using log4net;
using NHibernate.Driver;
using NHibernate.SqlCommand;

namespace NHibernate.JetDriver
{
	/// <summary>
	/// Implementation of IDriver for Jet database engine.
	/// Because of the weird JOIN clause syntax, this class has to translate the queries generated by NHibernate
	/// into the Jet syntax. This cannot be done anywhere else without having to heavily modify the logic of query creation.
	/// The translations of queries are cached.
	/// 
	/// <p>
	/// Author: <a href="mailto:lukask@welldatatech.com">Lukas Krejci</a>
	/// </p>
	/// </summary>
	public class JetDriver : OleDbDriver
	{
		private static ILog logger = LogManager.GetLogger( typeof( JetDriver ) );

		private IDictionary _queryCache = new Hashtable();

		public override IDbCommand GenerateCommand( Dialect.Dialect dialect, CommandType type, SqlString sqlString )
		{
			SqlString final;
			if (IsSelectStatement(sqlString))
			{
				final = FinalizeJoins(sqlString);
			}
			//else if(IsCreateOrAlterStatement(sqlString)) final = FinalizeDDL(sqlString);
			else
			{
				final = sqlString;
			}

			return base.GenerateCommand( dialect, type, final );
		}

		/// <summary></summary>
		public override System.Type CommandType
		{
			get { return typeof( JetDbCommand ); }
		}

		/// <summary></summary>
		public override System.Type ConnectionType
		{
			get { return typeof( JetDbConnection ); }
		}

		/// <summary></summary>
		public override IDbConnection CreateConnection()
		{
			return new JetDbConnection();
		}

		/// <summary>
		/// We have to have a special db command type to support conversion of data types, because Access is weird.
		/// </summary>
		public override IDbCommand CreateCommand()
		{
			return new JetDbCommand();
		}

		/// <summary>
		/// MS Access expects @paramName
		/// </summary>
		public override bool UseNamedPrefixInParameter
		{
			get { return true; }
		}

		public override string NamedPrefix
		{
			get { return "@"; }
		}

		#region Query transformations

		/// <summary>
		///Jet engine has the following from clause syntax:
		///<code>
		///		tableexpression[, tableexpression]*
		///</code>
		///where tableexpression is:
		///<code>
		///		tablename [(INNER |LEFT | RIGHT) JOIN [(] tableexpression [)] ON ...]
		///</code>
		///where the parenthesises are necessary if the "inner" tableexpression is not just a single tablename.
		///Additionally INNER JOIN cannot be nested in LEFT | RIGHT JOIN.
		///To translate the simple non-parenthesized joins to the jet syntax, the following transformation must be done:
		///<code>
		///		A join B on ... join C on ... join D on ..., E join F on ... join G on ..., H join I on ..., J
		///has to be translated as:
		///		(select * from ((A join B on ...) join C on ...) join D on ...) as crazyAlias1, (select * from (E join F on ...) join G on ...) as crazyAlias2, (select * from H join I on ...) as crazyAlias3, J
		///</code>
		/// </summary>
		/// <param name="sqlString">the sqlstring to transform</param>
		/// <returns>sqlstring with parenthesized joins.</returns>
		private SqlString FinalizeJoins( SqlString sqlString )
		{
			if( _queryCache.Contains( sqlString ) ) return ( SqlString ) _queryCache[ sqlString ];

			SqlStringBuilder beginning = new SqlStringBuilder( sqlString.SqlParts.Length );
			StringBuilder toTransform = new StringBuilder( sqlString.SqlParts.Length );
			SqlStringBuilder end = new SqlStringBuilder( sqlString.SqlParts.Length );

			int startIndex = GetFromPartIndex( sqlString );

			int endIndex = GetWherePartIndex( sqlString );
			endIndex = endIndex == -1 ? sqlString.SqlParts.Length : endIndex;

			int currentIndex = 0;

			foreach( object p in sqlString.SqlParts )
			{
				string spart = p as string;
				if( currentIndex > startIndex && currentIndex < endIndex )
				{
					if( spart != null )
					{
						toTransform.Append( spart );
					}
				}
				else if( currentIndex <= startIndex )
				{
					if( spart != null ) beginning.Add( spart );
					else beginning.AddObject( p );
				}
				else
				{
					if( spart != null ) end.Add( spart );
					else end.AddObject( p );
				}

				currentIndex++;
			}

			//now transform the "from" part of the query
			string transformed = "";
			string[] blocks = toTransform.ToString().Split( ",".ToCharArray() );
			if( blocks.Length > 1 )
			{
				for( int i = 0; i < blocks.Length; i++ )
				{
					string tr = TransformJoinBlock( blocks[ i ] );
					if( tr.IndexOf( " join " ) > -1 )
						blocks[ i ] = "(select * from " + tr + ") as jetJoinAlias" + i.ToString();
					else
						blocks[ i ] = tr;
				}

				transformed = string.Join( ",", blocks );
			}
			else
			{
				transformed = TransformJoinBlock( blocks[ 0 ] );
			}

			//put it all together again
			beginning.Add( transformed );
			beginning.Add( end.ToSqlString() );

			SqlString ret = beginning.ToSqlString();
			_queryCache[ sqlString ] = ret;

			return ret;
		}

		/// <summary>
		/// Access has a special data type for identity/autoincrement columns. This is not compatible with NHibernate way
		/// of doing things and so I have to translate sql strings once more.. :(
		/// In addition just INT is supported to be an identity otherwise QueryException is thrown.
		/// </summary>
		/// <param name="sqlString"></param>
		/// <returns></returns>
//Moved to JetDbCommand because NHibernate schema creation does not use Drivers to get the db commands :(
//		private SqlString FinalizeDDL(SqlString sqlString) {
//			if (_queryCache.Contains(sqlString)) return (SqlString)_queryCache[sqlString];			
//
//			SqlStringBuilder builder = new SqlStringBuilder(sqlString.SqlParts.Length);
//			
//			string fullIdentitySpec = "INT " + IdentitySpecPlaceHolder;
//
//			foreach(object p in sqlString.SqlParts) {
//				string sp = p as string;
//				if (sp != null) {
//					if (sp.IndexOf(IdentitySpecPlaceHolder) > -1) {
//						if (sp.IndexOf(fullIdentitySpec) == -1) {
//							throw new QueryException("Identity columns have to map to MS Access type INT.");
//						} else {
//							builder.Add(sp.Replace(fullIdentitySpec, "COUNTER"));
//						}
//					} else {
//						builder.Add(sp);
//					}
//				} else {
//					builder.AddObject(p);
//				}
//			}
//			SqlString ret = builder.ToSqlString();
//			_queryCache[sqlString] = ret;
//
//			return ret;
//		}
		/// <summary>
		/// 
		/// </summary>
		/// <param name="blockParts">A string representing one join block.</param>
		private string TransformJoinBlock( string block )
		{
			int parenthesisCount = 0;

			Regex re = new Regex( " join" );
			string[] blockParts = re.Split( block );

			if( blockParts.Length > 1 )
			{
				string firstPart = blockParts[ 0 ];
				for( int i = 1; i < blockParts.Length; i++ )
				{
					string part = blockParts[ i ];
					int parenthesisIndex = -1;

					if( part.EndsWith( " inner" ) )
					{
						parenthesisIndex = part.Length - 6;
					}
					else if( part.EndsWith( " left outer" ) )
					{
						parenthesisIndex = part.Length - 11;
					}
					else if( part.EndsWith( " right outer" ) )
					{
						parenthesisIndex = part.Length - 12;
					}

					if( parenthesisIndex == -1 )
					{
						if( i < blockParts.Length - 1 )
						{
							logger.Error( "Invalid join syntax. Could not parenthesize the join block properly." );
							throw new QueryException( "Invalid join syntax. Could not parenthesize the join block properly." );
						}

						//everything went ok. I'm processing the last block part and I've got no parenthesis to add.
						StringBuilder b = new StringBuilder( " " );
						for( int j = 0; j < parenthesisCount; j++ ) b.Append( "(" );
						b.Append( string.Join( " join", blockParts ) );

						return b.ToString();
					}
					else
					{
						parenthesisCount++;
						blockParts[ i ] = part.Insert( parenthesisIndex, ")" );
					}
				}

				//the last block part contained the join. This should not happen.
				logger.Error( "Invalid join syntax. Could not parenthesize the join block properly." );
				throw new QueryException( "Invalid join syntax. Could not parenthesize the join block properly." );
			}
			else
			{
				return blockParts[ 0 ];
			}
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="sqlString"></param>
		/// <returns>index of the sqlPart in sqlString where the "from" part of 
		/// the sql statement begins or -1 if it doesn't find any.</returns>
		private int GetFromPartIndex( SqlString sqlString )
		{
			int index = 0;
			foreach( object o in sqlString.SqlParts )
			{
				string s = o as string;
				if( s != null )
				{
					if( s.Trim().ToLower().Equals( "from" ) ) return index;
				}
				index++;
			}
			return -1; //this should not happen
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="sqlString"></param>
		/// <returns>index of the sqlPart in sqlString where the "where" part of 
		/// the sql statement begins or -1 if it doesn't find any.</returns>
		private int GetWherePartIndex( SqlString sqlString )
		{
			int index = 0;
			foreach( object o in sqlString.SqlParts )
			{
				string s = o as string;
				if( s != null )
				{
					if( s.Trim().ToLower().Equals( "where" ) ) return index;
				}
				index++;
			}
			return -1; //this should not happen
		}

		private string GetFirstStringPart( SqlString sqlString )
		{
			string firstStringPart = null;

			foreach( object p in sqlString.SqlParts )
			{
				string sp = p as string;
				if( sp != null )
				{
					firstStringPart = sp;
					break;
				}
			}

			return firstStringPart;
		}

		private bool IsSelectStatement( SqlString sqlString )
		{
			if( sqlString.SqlParts == null || sqlString.SqlParts.Length == 0 ) return false;

			string firstStringPart = GetFirstStringPart( sqlString );

			if( firstStringPart == null ) return false;

			return firstStringPart.Trim().ToLower().StartsWith( "select" );
		}

		private bool IsCreateOrAlterStatement( SqlString sqlString )
		{
			if( sqlString.SqlParts == null || sqlString.SqlParts.Length == 0 ) return false;

			string firstStringPart = GetFirstStringPart( sqlString );

			if( firstStringPart == null ) return false;

			firstStringPart = firstStringPart.Trim().ToLower();

			return firstStringPart.StartsWith( "create" ) || firstStringPart.StartsWith( "alter" );
		}

		#endregion
	}
}