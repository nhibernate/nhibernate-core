//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 Hql.g 2015-05-03 23:15:27

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using NHibernate.Hql.Ast.ANTLR.Tree;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  NHibernate.Hql.Ast.ANTLR 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
[System.CLSCompliant(false)]
public partial class HqlParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AGGREGATE", "ALIAS", "ALL", "AND", "ANY", "AS", "ASCENDING", "AVG", "BAND", "BETWEEN", "BNOT", "BOR", "BOTH", "BXOR", "CASE", "CASE2", "CLASS", "CLOSE", "CLOSE_BRACKET", "COLON", "COMMA", "CONCAT", "CONSTANT", "CONSTRUCTOR", "COUNT", "DELETE", "DESCENDING", "DISTINCT", "DIV", "DOT", "ELEMENTS", "ELSE", "EMPTY", "END", "EQ", "ESCAPE", "ESCqs", "EXISTS", "EXPONENT", "EXPR_LIST", "FALSE", "FETCH", "FILTER_ENTITY", "FLOAT_SUFFIX", "FROM", "FULL", "GE", "GROUP", "GT", "HAVING", "HEX_DIGIT", "IDENT", "ID_LETTER", "ID_START_LETTER", "IN", "INDEX_OP", "INDICES", "INNER", "INSERT", "INTO", "IN_LIST", "IS", "IS_NOT_NULL", "IS_NULL", "JAVA_CONSTANT", "JOIN", "LE", "LEADING", "LEFT", "LIKE", "LITERAL_by", "LT", "MAX", "MEMBER", "METHOD_CALL", "MIN", "MINUS", "NE", "NEW", "NOT", "NOT_BETWEEN", "NOT_IN", "NOT_LIKE", "NULL", "NUM_DECIMAL", "NUM_DOUBLE", "NUM_FLOAT", "NUM_INT", "NUM_LONG", "OBJECT", "OF", "ON", "OPEN", "OPEN_BRACKET", "OR", "ORDER", "ORDER_ELEMENT", "OUTER", "PARAM", "PLUS", "PROPERTIES", "QUERY", "QUOTED_String", "RANGE", "RIGHT", "ROW_STAR", "SELECT", "SELECT_FROM", "SET", "SKIP", "SOME", "SQL_NE", "STAR", "SUM", "TAKE", "THEN", "TRAILING", "TRUE", "UNARY_MINUS", "UNARY_PLUS", "UNION", "UPDATE", "VECTOR_EXPR", "VERSIONED", "WEIRD_IDENT", "WHEN", "WHERE", "WITH", "WS", "'ascending'", "'descending'"
	};
	public const int EOF=-1;
	public const int AGGREGATE=4;
	public const int ALIAS=5;
	public const int ALL=6;
	public const int AND=7;
	public const int ANY=8;
	public const int AS=9;
	public const int ASCENDING=10;
	public const int AVG=11;
	public const int BAND=12;
	public const int BETWEEN=13;
	public const int BNOT=14;
	public const int BOR=15;
	public const int BOTH=16;
	public const int BXOR=17;
	public const int CASE=18;
	public const int CASE2=19;
	public const int CLASS=20;
	public const int CLOSE=21;
	public const int CLOSE_BRACKET=22;
	public const int COLON=23;
	public const int COMMA=24;
	public const int CONCAT=25;
	public const int CONSTANT=26;
	public const int CONSTRUCTOR=27;
	public const int COUNT=28;
	public const int DELETE=29;
	public const int DESCENDING=30;
	public const int DISTINCT=31;
	public const int DIV=32;
	public const int DOT=33;
	public const int ELEMENTS=34;
	public const int ELSE=35;
	public const int EMPTY=36;
	public const int END=37;
	public const int EQ=38;
	public const int ESCAPE=39;
	public const int ESCqs=40;
	public const int EXISTS=41;
	public const int EXPONENT=42;
	public const int EXPR_LIST=43;
	public const int FALSE=44;
	public const int FETCH=45;
	public const int FILTER_ENTITY=46;
	public const int FLOAT_SUFFIX=47;
	public const int FROM=48;
	public const int FULL=49;
	public const int GE=50;
	public const int GROUP=51;
	public const int GT=52;
	public const int HAVING=53;
	public const int HEX_DIGIT=54;
	public const int IDENT=55;
	public const int ID_LETTER=56;
	public const int ID_START_LETTER=57;
	public const int IN=58;
	public const int INDEX_OP=59;
	public const int INDICES=60;
	public const int INNER=61;
	public const int INSERT=62;
	public const int INTO=63;
	public const int IN_LIST=64;
	public const int IS=65;
	public const int IS_NOT_NULL=66;
	public const int IS_NULL=67;
	public const int JAVA_CONSTANT=68;
	public const int JOIN=69;
	public const int LE=70;
	public const int LEADING=71;
	public const int LEFT=72;
	public const int LIKE=73;
	public const int LITERAL_by=74;
	public const int LT=75;
	public const int MAX=76;
	public const int MEMBER=77;
	public const int METHOD_CALL=78;
	public const int MIN=79;
	public const int MINUS=80;
	public const int NE=81;
	public const int NEW=82;
	public const int NOT=83;
	public const int NOT_BETWEEN=84;
	public const int NOT_IN=85;
	public const int NOT_LIKE=86;
	public const int NULL=87;
	public const int NUM_DECIMAL=88;
	public const int NUM_DOUBLE=89;
	public const int NUM_FLOAT=90;
	public const int NUM_INT=91;
	public const int NUM_LONG=92;
	public const int OBJECT=93;
	public const int OF=94;
	public const int ON=95;
	public const int OPEN=96;
	public const int OPEN_BRACKET=97;
	public const int OR=98;
	public const int ORDER=99;
	public const int ORDER_ELEMENT=100;
	public const int OUTER=101;
	public const int PARAM=102;
	public const int PLUS=103;
	public const int PROPERTIES=104;
	public const int QUERY=105;
	public const int QUOTED_String=106;
	public const int RANGE=107;
	public const int RIGHT=108;
	public const int ROW_STAR=109;
	public const int SELECT=110;
	public const int SELECT_FROM=111;
	public const int SET=112;
	public const int SKIP=113;
	public const int SOME=114;
	public const int SQL_NE=115;
	public const int STAR=116;
	public const int SUM=117;
	public const int TAKE=118;
	public const int THEN=119;
	public const int TRAILING=120;
	public const int TRUE=121;
	public const int UNARY_MINUS=122;
	public const int UNARY_PLUS=123;
	public const int UNION=124;
	public const int UPDATE=125;
	public const int VECTOR_EXPR=126;
	public const int VERSIONED=127;
	public const int WEIRD_IDENT=128;
	public const int WHEN=129;
	public const int WHERE=130;
	public const int WITH=131;
	public const int WS=132;
	public const int T__133=133;
	public const int T__134=134;

	public HqlParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public HqlParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return HqlParser.tokenNames; } }
	public override string GrammarFileName { get { return "Hql.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_statement();
	partial void LeaveRule_statement();
	// $ANTLR start "statement"
	// Hql.g:129:8: public statement : ({...}? ( updateStatement | deleteStatement | insertStatement ) | selectStatement ) EOF !;
	[GrammarRule("statement")]
	public AstParserRuleReturnScope<IASTNode, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 1);
		TraceIn("statement", 1);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken EOF5 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> updateStatement1 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> deleteStatement2 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> insertStatement3 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> selectStatement4 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode EOF5_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(129, 1);
		try
		{
			// Hql.g:130:2: ( ({...}? ( updateStatement | deleteStatement | insertStatement ) | selectStatement ) EOF !)
			DebugEnterAlt(1);
			// Hql.g:131:2: ({...}? ( updateStatement | deleteStatement | insertStatement ) | selectStatement ) EOF !
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(131, 2);
			// Hql.g:131:2: ({...}? ( updateStatement | deleteStatement | insertStatement ) | selectStatement )
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if ((LA2_1==DELETE||LA2_1==INSERT||LA2_1==UPDATE))
			{
				alt2 = 1;
			}
			else if ((LA2_1==EOF||LA2_1==FROM||LA2_1==GROUP||LA2_1==HAVING||LA2_1==ORDER||LA2_1==SELECT||LA2_1==SKIP||LA2_1==TAKE||LA2_1==WHERE))
			{
				alt2 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:132:3: {...}? ( updateStatement | deleteStatement | insertStatement )
				{
				DebugLocation(132, 3);
				if (!(( !filter )))
				{
					throw new FailedPredicateException(input, "statement", " !filter ");
				}
				DebugLocation(132, 16);
				// Hql.g:132:16: ( updateStatement | deleteStatement | insertStatement )
				int alt1=3;
				try { DebugEnterSubRule(1);
				try { DebugEnterDecision(1, false);
				switch (input.LA(1))
				{
				case UPDATE:
					{
					alt1 = 1;
					}
					break;
				case DELETE:
					{
					alt1 = 2;
					}
					break;
				case INSERT:
					{
					alt1 = 3;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:132:18: updateStatement
					{
					DebugLocation(132, 18);
					PushFollow(Follow._updateStatement_in_statement620);
					updateStatement1=updateStatement();
					PopFollow();

					adaptor.AddChild(root_0, updateStatement1.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:132:36: deleteStatement
					{
					DebugLocation(132, 36);
					PushFollow(Follow._deleteStatement_in_statement624);
					deleteStatement2=deleteStatement();
					PopFollow();

					adaptor.AddChild(root_0, deleteStatement2.Tree);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Hql.g:132:54: insertStatement
					{
					DebugLocation(132, 54);
					PushFollow(Follow._insertStatement_in_statement628);
					insertStatement3=insertStatement();
					PopFollow();

					adaptor.AddChild(root_0, insertStatement3.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(1); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:133:5: selectStatement
				{
				DebugLocation(133, 5);
				PushFollow(Follow._selectStatement_in_statement637);
				selectStatement4=selectStatement();
				PopFollow();

				adaptor.AddChild(root_0, selectStatement4.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(134, 7);
			EOF5=(IToken)Match(input,EOF,Follow._EOF_in_statement642); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 1);
			LeaveRule("statement", 1);
			LeaveRule_statement();
		}
		DebugLocation(135, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_updateStatement();
	partial void LeaveRule_updateStatement();
	// $ANTLR start "updateStatement"
	// Hql.g:137:1: updateStatement : UPDATE ^ ( VERSIONED )? optionalFromTokenFromClause setClause ( whereClause )? ;
	[GrammarRule("updateStatement")]
	private AstParserRuleReturnScope<IASTNode, IToken> updateStatement()
	{
		EnterRule_updateStatement();
		EnterRule("updateStatement", 2);
		TraceIn("updateStatement", 2);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken UPDATE6 = default(IToken);
		IToken VERSIONED7 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> optionalFromTokenFromClause8 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> setClause9 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> whereClause10 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode UPDATE6_tree = default(IASTNode);
		IASTNode VERSIONED7_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "updateStatement");
		DebugLocation(137, 1);
		try
		{
			// Hql.g:138:2: ( UPDATE ^ ( VERSIONED )? optionalFromTokenFromClause setClause ( whereClause )? )
			DebugEnterAlt(1);
			// Hql.g:138:4: UPDATE ^ ( VERSIONED )? optionalFromTokenFromClause setClause ( whereClause )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(138, 10);
			UPDATE6=(IToken)Match(input,UPDATE,Follow._UPDATE_in_updateStatement654); 
			UPDATE6_tree = (IASTNode)adaptor.Create(UPDATE6);
			root_0 = (IASTNode)adaptor.BecomeRoot(UPDATE6_tree, root_0);
			DebugLocation(138, 12);
			// Hql.g:138:12: ( VERSIONED )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1==VERSIONED))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:138:13: VERSIONED
				{
				DebugLocation(138, 13);
				VERSIONED7=(IToken)Match(input,VERSIONED,Follow._VERSIONED_in_updateStatement658); 
				VERSIONED7_tree = (IASTNode)adaptor.Create(VERSIONED7);
				adaptor.AddChild(root_0, VERSIONED7_tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(139, 3);
			PushFollow(Follow._optionalFromTokenFromClause_in_updateStatement664);
			optionalFromTokenFromClause8=optionalFromTokenFromClause();
			PopFollow();

			adaptor.AddChild(root_0, optionalFromTokenFromClause8.Tree);
			DebugLocation(140, 3);
			PushFollow(Follow._setClause_in_updateStatement668);
			setClause9=setClause();
			PopFollow();

			adaptor.AddChild(root_0, setClause9.Tree);
			DebugLocation(141, 3);
			// Hql.g:141:3: ( whereClause )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1==WHERE))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:141:4: whereClause
				{
				DebugLocation(141, 4);
				PushFollow(Follow._whereClause_in_updateStatement673);
				whereClause10=whereClause();
				PopFollow();

				adaptor.AddChild(root_0, whereClause10.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("updateStatement", 2);
			LeaveRule("updateStatement", 2);
			LeaveRule_updateStatement();
		}
		DebugLocation(142, 1);
		} finally { DebugExitRule(GrammarFileName, "updateStatement"); }
		return retval;

	}
	// $ANTLR end "updateStatement"

	partial void EnterRule_setClause();
	partial void LeaveRule_setClause();
	// $ANTLR start "setClause"
	// Hql.g:144:1: setClause : ( SET ^ assignment ( COMMA ! assignment )* ) ;
	[GrammarRule("setClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> setClause()
	{
		EnterRule_setClause();
		EnterRule("setClause", 3);
		TraceIn("setClause", 3);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken SET11 = default(IToken);
		IToken COMMA13 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> assignment12 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> assignment14 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode SET11_tree = default(IASTNode);
		IASTNode COMMA13_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "setClause");
		DebugLocation(144, 1);
		try
		{
			// Hql.g:145:2: ( ( SET ^ assignment ( COMMA ! assignment )* ) )
			DebugEnterAlt(1);
			// Hql.g:145:4: ( SET ^ assignment ( COMMA ! assignment )* )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(145, 4);
			// Hql.g:145:4: ( SET ^ assignment ( COMMA ! assignment )* )
			DebugEnterAlt(1);
			// Hql.g:145:5: SET ^ assignment ( COMMA ! assignment )*
			{
			DebugLocation(145, 8);
			SET11=(IToken)Match(input,SET,Follow._SET_in_setClause687); 
			SET11_tree = (IASTNode)adaptor.Create(SET11);
			root_0 = (IASTNode)adaptor.BecomeRoot(SET11_tree, root_0);
			DebugLocation(145, 10);
			PushFollow(Follow._assignment_in_setClause690);
			assignment12=assignment();
			PopFollow();

			adaptor.AddChild(root_0, assignment12.Tree);
			DebugLocation(145, 21);
			// Hql.g:145:21: ( COMMA ! assignment )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1==COMMA))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:145:22: COMMA ! assignment
					{
					DebugLocation(145, 27);
					COMMA13=(IToken)Match(input,COMMA,Follow._COMMA_in_setClause693); 
					DebugLocation(145, 29);
					PushFollow(Follow._assignment_in_setClause696);
					assignment14=assignment();
					PopFollow();

					adaptor.AddChild(root_0, assignment14.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("setClause", 3);
			LeaveRule("setClause", 3);
			LeaveRule_setClause();
		}
		DebugLocation(146, 1);
		} finally { DebugExitRule(GrammarFileName, "setClause"); }
		return retval;

	}
	// $ANTLR end "setClause"

	partial void EnterRule_assignment();
	partial void LeaveRule_assignment();
	// $ANTLR start "assignment"
	// Hql.g:148:1: assignment : stateField EQ ^ newValue ;
	[GrammarRule("assignment")]
	private AstParserRuleReturnScope<IASTNode, IToken> assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 4);
		TraceIn("assignment", 4);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken EQ16 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> stateField15 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> newValue17 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode EQ16_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(148, 1);
		try
		{
			// Hql.g:149:2: ( stateField EQ ^ newValue )
			DebugEnterAlt(1);
			// Hql.g:149:4: stateField EQ ^ newValue
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(149, 4);
			PushFollow(Follow._stateField_in_assignment710);
			stateField15=stateField();
			PopFollow();

			adaptor.AddChild(root_0, stateField15.Tree);
			DebugLocation(149, 17);
			EQ16=(IToken)Match(input,EQ,Follow._EQ_in_assignment712); 
			EQ16_tree = (IASTNode)adaptor.Create(EQ16);
			root_0 = (IASTNode)adaptor.BecomeRoot(EQ16_tree, root_0);
			DebugLocation(149, 19);
			PushFollow(Follow._newValue_in_assignment715);
			newValue17=newValue();
			PopFollow();

			adaptor.AddChild(root_0, newValue17.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignment", 4);
			LeaveRule("assignment", 4);
			LeaveRule_assignment();
		}
		DebugLocation(150, 1);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return retval;

	}
	// $ANTLR end "assignment"

	partial void EnterRule_stateField();
	partial void LeaveRule_stateField();
	// $ANTLR start "stateField"
	// Hql.g:154:1: stateField : path ;
	[GrammarRule("stateField")]
	private AstParserRuleReturnScope<IASTNode, IToken> stateField()
	{
		EnterRule_stateField();
		EnterRule("stateField", 5);
		TraceIn("stateField", 5);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> path18 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		try { DebugEnterRule(GrammarFileName, "stateField");
		DebugLocation(154, 1);
		try
		{
			// Hql.g:155:2: ( path )
			DebugEnterAlt(1);
			// Hql.g:155:4: path
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(155, 4);
			PushFollow(Follow._path_in_stateField728);
			path18=path();
			PopFollow();

			adaptor.AddChild(root_0, path18.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stateField", 5);
			LeaveRule("stateField", 5);
			LeaveRule_stateField();
		}
		DebugLocation(156, 1);
		} finally { DebugExitRule(GrammarFileName, "stateField"); }
		return retval;

	}
	// $ANTLR end "stateField"

	partial void EnterRule_newValue();
	partial void LeaveRule_newValue();
	// $ANTLR start "newValue"
	// Hql.g:160:1: newValue : concatenation ;
	[GrammarRule("newValue")]
	private AstParserRuleReturnScope<IASTNode, IToken> newValue()
	{
		EnterRule_newValue();
		EnterRule("newValue", 6);
		TraceIn("newValue", 6);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> concatenation19 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		try { DebugEnterRule(GrammarFileName, "newValue");
		DebugLocation(160, 1);
		try
		{
			// Hql.g:161:2: ( concatenation )
			DebugEnterAlt(1);
			// Hql.g:161:4: concatenation
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(161, 4);
			PushFollow(Follow._concatenation_in_newValue741);
			concatenation19=concatenation();
			PopFollow();

			adaptor.AddChild(root_0, concatenation19.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("newValue", 6);
			LeaveRule("newValue", 6);
			LeaveRule_newValue();
		}
		DebugLocation(162, 1);
		} finally { DebugExitRule(GrammarFileName, "newValue"); }
		return retval;

	}
	// $ANTLR end "newValue"

	partial void EnterRule_deleteStatement();
	partial void LeaveRule_deleteStatement();
	// $ANTLR start "deleteStatement"
	// Hql.g:164:1: deleteStatement : DELETE ^ ( optionalFromTokenFromClause ) ( whereClause )? ;
	[GrammarRule("deleteStatement")]
	private AstParserRuleReturnScope<IASTNode, IToken> deleteStatement()
	{
		EnterRule_deleteStatement();
		EnterRule("deleteStatement", 7);
		TraceIn("deleteStatement", 7);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken DELETE20 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> optionalFromTokenFromClause21 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> whereClause22 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode DELETE20_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "deleteStatement");
		DebugLocation(164, 1);
		try
		{
			// Hql.g:165:2: ( DELETE ^ ( optionalFromTokenFromClause ) ( whereClause )? )
			DebugEnterAlt(1);
			// Hql.g:165:4: DELETE ^ ( optionalFromTokenFromClause ) ( whereClause )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(165, 10);
			DELETE20=(IToken)Match(input,DELETE,Follow._DELETE_in_deleteStatement752); 
			DELETE20_tree = (IASTNode)adaptor.Create(DELETE20);
			root_0 = (IASTNode)adaptor.BecomeRoot(DELETE20_tree, root_0);
			DebugLocation(166, 3);
			// Hql.g:166:3: ( optionalFromTokenFromClause )
			DebugEnterAlt(1);
			// Hql.g:166:4: optionalFromTokenFromClause
			{
			DebugLocation(166, 4);
			PushFollow(Follow._optionalFromTokenFromClause_in_deleteStatement758);
			optionalFromTokenFromClause21=optionalFromTokenFromClause();
			PopFollow();

			adaptor.AddChild(root_0, optionalFromTokenFromClause21.Tree);

			}

			DebugLocation(167, 3);
			// Hql.g:167:3: ( whereClause )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1==WHERE))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:167:4: whereClause
				{
				DebugLocation(167, 4);
				PushFollow(Follow._whereClause_in_deleteStatement764);
				whereClause22=whereClause();
				PopFollow();

				adaptor.AddChild(root_0, whereClause22.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("deleteStatement", 7);
			LeaveRule("deleteStatement", 7);
			LeaveRule_deleteStatement();
		}
		DebugLocation(168, 1);
		} finally { DebugExitRule(GrammarFileName, "deleteStatement"); }
		return retval;

	}
	// $ANTLR end "deleteStatement"

	partial void EnterRule_optionalFromTokenFromClause();
	partial void LeaveRule_optionalFromTokenFromClause();
	// $ANTLR start "optionalFromTokenFromClause"
	// Hql.g:172:1: optionalFromTokenFromClause : optionalFromTokenFromClause2 path ( asAlias )? -> ^( FROM ^( RANGE path ( asAlias )? ) ) ;
	[GrammarRule("optionalFromTokenFromClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> optionalFromTokenFromClause()
	{
		EnterRule_optionalFromTokenFromClause();
		EnterRule("optionalFromTokenFromClause", 8);
		TraceIn("optionalFromTokenFromClause", 8);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> optionalFromTokenFromClause223 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> path24 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> asAlias25 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		RewriteRuleSubtreeStream stream_optionalFromTokenFromClause2=new RewriteRuleSubtreeStream(adaptor,"rule optionalFromTokenFromClause2");
		RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
		RewriteRuleSubtreeStream stream_asAlias=new RewriteRuleSubtreeStream(adaptor,"rule asAlias");
		try { DebugEnterRule(GrammarFileName, "optionalFromTokenFromClause");
		DebugLocation(172, 1);
		try
		{
			// Hql.g:173:2: ( optionalFromTokenFromClause2 path ( asAlias )? -> ^( FROM ^( RANGE path ( asAlias )? ) ) )
			DebugEnterAlt(1);
			// Hql.g:173:4: optionalFromTokenFromClause2 path ( asAlias )?
			{
			DebugLocation(173, 4);
			PushFollow(Follow._optionalFromTokenFromClause2_in_optionalFromTokenFromClause779);
			optionalFromTokenFromClause223=optionalFromTokenFromClause2();
			PopFollow();

			stream_optionalFromTokenFromClause2.Add(optionalFromTokenFromClause223.Tree);
			DebugLocation(173, 33);
			PushFollow(Follow._path_in_optionalFromTokenFromClause781);
			path24=path();
			PopFollow();

			stream_path.Add(path24.Tree);
			DebugLocation(173, 38);
			// Hql.g:173:38: ( asAlias )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1==AS||LA7_1==IDENT))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:173:39: asAlias
				{
				DebugLocation(173, 39);
				PushFollow(Follow._asAlias_in_optionalFromTokenFromClause784);
				asAlias25=asAlias();
				PopFollow();

				stream_asAlias.Add(asAlias25.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(7); }



			{
			// AST REWRITE
			// elements: path, asAlias
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 174:3: -> ^( FROM ^( RANGE path ( asAlias )? ) )
			{
				DebugLocation(174, 6);
				// Hql.g:174:6: ^( FROM ^( RANGE path ( asAlias )? ) )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(174, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(FROM, "FROM"), root_1);

				DebugLocation(174, 13);
				// Hql.g:174:13: ^( RANGE path ( asAlias )? )
				{
				IASTNode root_2 = (IASTNode)adaptor.Nil();
				DebugLocation(174, 15);
				root_2 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(RANGE, "RANGE"), root_2);

				DebugLocation(174, 21);
				adaptor.AddChild(root_2, stream_path.NextTree());
				DebugLocation(174, 26);
				// Hql.g:174:26: ( asAlias )?
				if (stream_asAlias.HasNext)
				{
					DebugLocation(174, 26);
					adaptor.AddChild(root_2, stream_asAlias.NextTree());

				}
				stream_asAlias.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("optionalFromTokenFromClause", 8);
			LeaveRule("optionalFromTokenFromClause", 8);
			LeaveRule_optionalFromTokenFromClause();
		}
		DebugLocation(175, 1);
		} finally { DebugExitRule(GrammarFileName, "optionalFromTokenFromClause"); }
		return retval;

	}
	// $ANTLR end "optionalFromTokenFromClause"

	partial void EnterRule_optionalFromTokenFromClause2();
	partial void LeaveRule_optionalFromTokenFromClause2();
	// $ANTLR start "optionalFromTokenFromClause2"
	// Hql.g:177:1: optionalFromTokenFromClause2 : ( FROM )? ;
	[GrammarRule("optionalFromTokenFromClause2")]
	private AstParserRuleReturnScope<IASTNode, IToken> optionalFromTokenFromClause2()
	{
		EnterRule_optionalFromTokenFromClause2();
		EnterRule("optionalFromTokenFromClause2", 9);
		TraceIn("optionalFromTokenFromClause2", 9);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken FROM26 = default(IToken);

		IASTNode FROM26_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "optionalFromTokenFromClause2");
		DebugLocation(177, 1);
		try
		{
			// Hql.g:178:2: ( ( FROM )? )
			DebugEnterAlt(1);
			// Hql.g:178:4: ( FROM )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(178, 4);
			// Hql.g:178:4: ( FROM )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==FROM))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:178:4: FROM
				{
				DebugLocation(178, 4);
				FROM26=(IToken)Match(input,FROM,Follow._FROM_in_optionalFromTokenFromClause2815); 
				FROM26_tree = (IASTNode)adaptor.Create(FROM26);
				adaptor.AddChild(root_0, FROM26_tree);

				}
				break;

			}
			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("optionalFromTokenFromClause2", 9);
			LeaveRule("optionalFromTokenFromClause2", 9);
			LeaveRule_optionalFromTokenFromClause2();
		}
		DebugLocation(179, 1);
		} finally { DebugExitRule(GrammarFileName, "optionalFromTokenFromClause2"); }
		return retval;

	}
	// $ANTLR end "optionalFromTokenFromClause2"

	partial void EnterRule_selectStatement();
	partial void LeaveRule_selectStatement();
	// $ANTLR start "selectStatement"
	// Hql.g:181:1: selectStatement : q= queryRule -> ^( QUERY[\"query\"] $q) ;
	[GrammarRule("selectStatement")]
	private AstParserRuleReturnScope<IASTNode, IToken> selectStatement()
	{
		EnterRule_selectStatement();
		EnterRule("selectStatement", 10);
		TraceIn("selectStatement", 10);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> q = default(AstParserRuleReturnScope<IASTNode, IToken>);

		RewriteRuleSubtreeStream stream_queryRule=new RewriteRuleSubtreeStream(adaptor,"rule queryRule");
		try { DebugEnterRule(GrammarFileName, "selectStatement");
		DebugLocation(181, 1);
		try
		{
			// Hql.g:183:2: (q= queryRule -> ^( QUERY[\"query\"] $q) )
			DebugEnterAlt(1);
			// Hql.g:183:4: q= queryRule
			{
			DebugLocation(183, 5);
			PushFollow(Follow._queryRule_in_selectStatement830);
			q=queryRule();
			PopFollow();

			stream_queryRule.Add(q.Tree);


			{
			// AST REWRITE
			// elements: q
			// token labels: 
			// rule labels: q, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_q=new RewriteRuleSubtreeStream(adaptor,"rule q",q!=null?q.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 184:2: -> ^( QUERY[\"query\"] $q)
			{
				DebugLocation(184, 5);
				// Hql.g:184:5: ^( QUERY[\"query\"] $q)
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(184, 7);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(QUERY, "query"), root_1);

				DebugLocation(184, 23);
				adaptor.AddChild(root_1, stream_q.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selectStatement", 10);
			LeaveRule("selectStatement", 10);
			LeaveRule_selectStatement();
		}
		DebugLocation(185, 1);
		} finally { DebugExitRule(GrammarFileName, "selectStatement"); }
		return retval;

	}
	// $ANTLR end "selectStatement"

	partial void EnterRule_insertStatement();
	partial void LeaveRule_insertStatement();
	// $ANTLR start "insertStatement"
	// Hql.g:187:1: insertStatement : INSERT ^ intoClause selectStatement ;
	[GrammarRule("insertStatement")]
	private AstParserRuleReturnScope<IASTNode, IToken> insertStatement()
	{
		EnterRule_insertStatement();
		EnterRule("insertStatement", 11);
		TraceIn("insertStatement", 11);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken INSERT27 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> intoClause28 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> selectStatement29 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode INSERT27_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "insertStatement");
		DebugLocation(187, 1);
		try
		{
			// Hql.g:191:2: ( INSERT ^ intoClause selectStatement )
			DebugEnterAlt(1);
			// Hql.g:191:4: INSERT ^ intoClause selectStatement
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(191, 10);
			INSERT27=(IToken)Match(input,INSERT,Follow._INSERT_in_insertStatement859); 
			INSERT27_tree = (IASTNode)adaptor.Create(INSERT27);
			root_0 = (IASTNode)adaptor.BecomeRoot(INSERT27_tree, root_0);
			DebugLocation(191, 12);
			PushFollow(Follow._intoClause_in_insertStatement862);
			intoClause28=intoClause();
			PopFollow();

			adaptor.AddChild(root_0, intoClause28.Tree);
			DebugLocation(191, 23);
			PushFollow(Follow._selectStatement_in_insertStatement864);
			selectStatement29=selectStatement();
			PopFollow();

			adaptor.AddChild(root_0, selectStatement29.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("insertStatement", 11);
			LeaveRule("insertStatement", 11);
			LeaveRule_insertStatement();
		}
		DebugLocation(192, 1);
		} finally { DebugExitRule(GrammarFileName, "insertStatement"); }
		return retval;

	}
	// $ANTLR end "insertStatement"

	partial void EnterRule_intoClause();
	partial void LeaveRule_intoClause();
	// $ANTLR start "intoClause"
	// Hql.g:194:1: intoClause : INTO ^ path insertablePropertySpec ;
	[GrammarRule("intoClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> intoClause()
	{
		EnterRule_intoClause();
		EnterRule("intoClause", 12);
		TraceIn("intoClause", 12);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken INTO30 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> path31 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> insertablePropertySpec32 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode INTO30_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "intoClause");
		DebugLocation(194, 1);
		try
		{
			// Hql.g:195:2: ( INTO ^ path insertablePropertySpec )
			DebugEnterAlt(1);
			// Hql.g:195:4: INTO ^ path insertablePropertySpec
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(195, 8);
			INTO30=(IToken)Match(input,INTO,Follow._INTO_in_intoClause875); 
			INTO30_tree = (IASTNode)adaptor.Create(INTO30);
			root_0 = (IASTNode)adaptor.BecomeRoot(INTO30_tree, root_0);
			DebugLocation(195, 10);
			PushFollow(Follow._path_in_intoClause878);
			path31=path();
			PopFollow();

			adaptor.AddChild(root_0, path31.Tree);
			DebugLocation(195, 15);
			 WeakKeywords(); 
			DebugLocation(195, 35);
			PushFollow(Follow._insertablePropertySpec_in_intoClause882);
			insertablePropertySpec32=insertablePropertySpec();
			PopFollow();

			adaptor.AddChild(root_0, insertablePropertySpec32.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("intoClause", 12);
			LeaveRule("intoClause", 12);
			LeaveRule_intoClause();
		}
		DebugLocation(196, 1);
		} finally { DebugExitRule(GrammarFileName, "intoClause"); }
		return retval;

	}
	// $ANTLR end "intoClause"

	partial void EnterRule_insertablePropertySpec();
	partial void LeaveRule_insertablePropertySpec();
	// $ANTLR start "insertablePropertySpec"
	// Hql.g:198:1: insertablePropertySpec : OPEN primaryExpression ( COMMA primaryExpression )* CLOSE -> ^( RANGE[\"column-spec\"] ( primaryExpression )* ) ;
	[GrammarRule("insertablePropertySpec")]
	private AstParserRuleReturnScope<IASTNode, IToken> insertablePropertySpec()
	{
		EnterRule_insertablePropertySpec();
		EnterRule("insertablePropertySpec", 13);
		TraceIn("insertablePropertySpec", 13);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken OPEN33 = default(IToken);
		IToken COMMA35 = default(IToken);
		IToken CLOSE37 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> primaryExpression34 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> primaryExpression36 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode OPEN33_tree = default(IASTNode);
		IASTNode COMMA35_tree = default(IASTNode);
		IASTNode CLOSE37_tree = default(IASTNode);
		RewriteRuleITokenStream stream_OPEN=new RewriteRuleITokenStream(adaptor,"token OPEN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_CLOSE=new RewriteRuleITokenStream(adaptor,"token CLOSE");
		RewriteRuleSubtreeStream stream_primaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule primaryExpression");
		try { DebugEnterRule(GrammarFileName, "insertablePropertySpec");
		DebugLocation(198, 1);
		try
		{
			// Hql.g:199:2: ( OPEN primaryExpression ( COMMA primaryExpression )* CLOSE -> ^( RANGE[\"column-spec\"] ( primaryExpression )* ) )
			DebugEnterAlt(1);
			// Hql.g:199:4: OPEN primaryExpression ( COMMA primaryExpression )* CLOSE
			{
			DebugLocation(199, 4);
			OPEN33=(IToken)Match(input,OPEN,Follow._OPEN_in_insertablePropertySpec893);  
			stream_OPEN.Add(OPEN33);

			DebugLocation(199, 9);
			PushFollow(Follow._primaryExpression_in_insertablePropertySpec895);
			primaryExpression34=primaryExpression();
			PopFollow();

			stream_primaryExpression.Add(primaryExpression34.Tree);
			DebugLocation(199, 27);
			// Hql.g:199:27: ( COMMA primaryExpression )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1==COMMA))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:199:29: COMMA primaryExpression
					{
					DebugLocation(199, 29);
					COMMA35=(IToken)Match(input,COMMA,Follow._COMMA_in_insertablePropertySpec899);  
					stream_COMMA.Add(COMMA35);

					DebugLocation(199, 35);
					PushFollow(Follow._primaryExpression_in_insertablePropertySpec901);
					primaryExpression36=primaryExpression();
					PopFollow();

					stream_primaryExpression.Add(primaryExpression36.Tree);

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(199, 56);
			CLOSE37=(IToken)Match(input,CLOSE,Follow._CLOSE_in_insertablePropertySpec906);  
			stream_CLOSE.Add(CLOSE37);



			{
			// AST REWRITE
			// elements: primaryExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 200:3: -> ^( RANGE[\"column-spec\"] ( primaryExpression )* )
			{
				DebugLocation(200, 6);
				// Hql.g:200:6: ^( RANGE[\"column-spec\"] ( primaryExpression )* )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(200, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(RANGE, "column-spec"), root_1);

				DebugLocation(200, 29);
				// Hql.g:200:29: ( primaryExpression )*
				while ( stream_primaryExpression.HasNext )
				{
					DebugLocation(200, 29);
					adaptor.AddChild(root_1, stream_primaryExpression.NextTree());

				}
				stream_primaryExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("insertablePropertySpec", 13);
			LeaveRule("insertablePropertySpec", 13);
			LeaveRule_insertablePropertySpec();
		}
		DebugLocation(201, 1);
		} finally { DebugExitRule(GrammarFileName, "insertablePropertySpec"); }
		return retval;

	}
	// $ANTLR end "insertablePropertySpec"

	partial void EnterRule_queryRule();
	partial void LeaveRule_queryRule();
	// $ANTLR start "queryRule"
	// Hql.g:206:1: queryRule : selectFrom ( whereClause )? ( groupByClause )? ( havingClause )? ( orderByClause )? ( skipClause )? ( takeClause )? ;
	[GrammarRule("queryRule")]
	private AstParserRuleReturnScope<IASTNode, IToken> queryRule()
	{
		EnterRule_queryRule();
		EnterRule("queryRule", 14);
		TraceIn("queryRule", 14);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> selectFrom38 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> whereClause39 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> groupByClause40 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> havingClause41 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> orderByClause42 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> skipClause43 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> takeClause44 = default(AstParserRuleReturnScope<IASTNode, IToken>);


				++queryDepth;
			
		try { DebugEnterRule(GrammarFileName, "queryRule");
		DebugLocation(206, 2);
		try
		{
			// Hql.g:213:2: ( selectFrom ( whereClause )? ( groupByClause )? ( havingClause )? ( orderByClause )? ( skipClause )? ( takeClause )? )
			DebugEnterAlt(1);
			// Hql.g:213:4: selectFrom ( whereClause )? ( groupByClause )? ( havingClause )? ( orderByClause )? ( skipClause )? ( takeClause )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(213, 4);
			PushFollow(Follow._selectFrom_in_queryRule944);
			selectFrom38=selectFrom();
			PopFollow();

			adaptor.AddChild(root_0, selectFrom38.Tree);
			DebugLocation(214, 3);
			// Hql.g:214:3: ( whereClause )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==WHERE))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:214:4: whereClause
				{
				DebugLocation(214, 4);
				PushFollow(Follow._whereClause_in_queryRule949);
				whereClause39=whereClause();
				PopFollow();

				adaptor.AddChild(root_0, whereClause39.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(215, 3);
			// Hql.g:215:3: ( groupByClause )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_1 = input.LA(1);

			if ((LA11_1==GROUP))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:215:4: groupByClause
				{
				DebugLocation(215, 4);
				PushFollow(Follow._groupByClause_in_queryRule956);
				groupByClause40=groupByClause();
				PopFollow();

				adaptor.AddChild(root_0, groupByClause40.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(216, 3);
			// Hql.g:216:3: ( havingClause )?
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_1 = input.LA(1);

			if ((LA12_1==HAVING))
			{
				alt12 = 1;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:216:4: havingClause
				{
				DebugLocation(216, 4);
				PushFollow(Follow._havingClause_in_queryRule963);
				havingClause41=havingClause();
				PopFollow();

				adaptor.AddChild(root_0, havingClause41.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(12); }

			DebugLocation(217, 3);
			// Hql.g:217:3: ( orderByClause )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_1 = input.LA(1);

			if ((LA13_1==ORDER))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:217:4: orderByClause
				{
				DebugLocation(217, 4);
				PushFollow(Follow._orderByClause_in_queryRule970);
				orderByClause42=orderByClause();
				PopFollow();

				adaptor.AddChild(root_0, orderByClause42.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(13); }

			DebugLocation(218, 3);
			// Hql.g:218:3: ( skipClause )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_1 = input.LA(1);

			if ((LA14_1==SKIP))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:218:4: skipClause
				{
				DebugLocation(218, 4);
				PushFollow(Follow._skipClause_in_queryRule977);
				skipClause43=skipClause();
				PopFollow();

				adaptor.AddChild(root_0, skipClause43.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(14); }

			DebugLocation(219, 3);
			// Hql.g:219:3: ( takeClause )?
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_1 = input.LA(1);

			if ((LA15_1==TAKE))
			{
				alt15 = 1;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:219:4: takeClause
				{
				DebugLocation(219, 4);
				PushFollow(Follow._takeClause_in_queryRule984);
				takeClause44=takeClause();
				PopFollow();

				adaptor.AddChild(root_0, takeClause44.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(15); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);


					--queryDepth;
				
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("queryRule", 14);
			LeaveRule("queryRule", 14);
			LeaveRule_queryRule();
		}
		DebugLocation(220, 2);
		} finally { DebugExitRule(GrammarFileName, "queryRule"); }
		return retval;

	}
	// $ANTLR end "queryRule"

	partial void EnterRule_selectFrom();
	partial void LeaveRule_selectFrom();
	// $ANTLR start "selectFrom"
	// Hql.g:222:1: selectFrom : (s= selectClause )? (f= fromClause )? -> {$f.tree == null && filter}? ^( SELECT_FROM FROM[\"{filter-implied FROM}\"] ( selectClause )? ) -> ^( SELECT_FROM ( fromClause )? ( selectClause )? ) ;
	[GrammarRule("selectFrom")]
	private AstParserRuleReturnScope<IASTNode, IToken> selectFrom()
	{
		EnterRule_selectFrom();
		EnterRule("selectFrom", 15);
		TraceIn("selectFrom", 15);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> s = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> f = default(AstParserRuleReturnScope<IASTNode, IToken>);

		RewriteRuleSubtreeStream stream_selectClause=new RewriteRuleSubtreeStream(adaptor,"rule selectClause");
		RewriteRuleSubtreeStream stream_fromClause=new RewriteRuleSubtreeStream(adaptor,"rule fromClause");
		try { DebugEnterRule(GrammarFileName, "selectFrom");
		DebugLocation(222, 1);
		try
		{
			// Hql.g:223:2: ( (s= selectClause )? (f= fromClause )? -> {$f.tree == null && filter}? ^( SELECT_FROM FROM[\"{filter-implied FROM}\"] ( selectClause )? ) -> ^( SELECT_FROM ( fromClause )? ( selectClause )? ) )
			DebugEnterAlt(1);
			// Hql.g:223:5: (s= selectClause )? (f= fromClause )?
			{
			DebugLocation(223, 5);
			// Hql.g:223:5: (s= selectClause )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if ((LA16_1==SELECT))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:223:6: s= selectClause
				{
				DebugLocation(223, 7);
				PushFollow(Follow._selectClause_in_selectFrom1002);
				s=selectClause();
				PopFollow();

				stream_selectClause.Add(s.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(223, 23);
			// Hql.g:223:23: (f= fromClause )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_1 = input.LA(1);

			if ((LA17_1==FROM))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:223:24: f= fromClause
				{
				DebugLocation(223, 25);
				PushFollow(Follow._fromClause_in_selectFrom1009);
				f=fromClause();
				PopFollow();

				stream_fromClause.Add(f.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(17); }

			DebugLocation(224, 3);

						if ((f!=null?((IASTNode)f.Tree):default(IASTNode)) == null && !(filter && queryDepth == 1)) 
							throw new RecognitionException("FROM expected (non-filter queries must contain a FROM clause)");
					


			{
			// AST REWRITE
			// elements: selectClause, fromClause, selectClause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 228:3: -> {$f.tree == null && filter}? ^( SELECT_FROM FROM[\"{filter-implied FROM}\"] ( selectClause )? )
			if ((f!=null?((IASTNode)f.Tree):default(IASTNode)) == null && filter)
			{
				DebugLocation(228, 35);
				// Hql.g:228:35: ^( SELECT_FROM FROM[\"{filter-implied FROM}\"] ( selectClause )? )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(228, 37);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(SELECT_FROM, "SELECT_FROM"), root_1);

				DebugLocation(228, 49);
				adaptor.AddChild(root_1, (IASTNode)adaptor.Create(FROM, "{filter-implied FROM}"));
				DebugLocation(228, 79);
				// Hql.g:228:79: ( selectClause )?
				if (stream_selectClause.HasNext)
				{
					DebugLocation(228, 79);
					adaptor.AddChild(root_1, stream_selectClause.NextTree());

				}
				stream_selectClause.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}
			else // 229:3: -> ^( SELECT_FROM ( fromClause )? ( selectClause )? )
			{
				DebugLocation(229, 6);
				// Hql.g:229:6: ^( SELECT_FROM ( fromClause )? ( selectClause )? )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(229, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(SELECT_FROM, "SELECT_FROM"), root_1);

				DebugLocation(229, 20);
				// Hql.g:229:20: ( fromClause )?
				if (stream_fromClause.HasNext)
				{
					DebugLocation(229, 20);
					adaptor.AddChild(root_1, stream_fromClause.NextTree());

				}
				stream_fromClause.Reset();
				DebugLocation(229, 32);
				// Hql.g:229:32: ( selectClause )?
				if (stream_selectClause.HasNext)
				{
					DebugLocation(229, 32);
					adaptor.AddChild(root_1, stream_selectClause.NextTree());

				}
				stream_selectClause.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selectFrom", 15);
			LeaveRule("selectFrom", 15);
			LeaveRule_selectFrom();
		}
		DebugLocation(230, 1);
		} finally { DebugExitRule(GrammarFileName, "selectFrom"); }
		return retval;

	}
	// $ANTLR end "selectFrom"

	partial void EnterRule_selectClause();
	partial void LeaveRule_selectClause();
	// $ANTLR start "selectClause"
	// Hql.g:233:1: selectClause : SELECT ^ ( DISTINCT )? ( selectedPropertiesList | newExpression | selectObject ) ;
	[GrammarRule("selectClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> selectClause()
	{
		EnterRule_selectClause();
		EnterRule("selectClause", 16);
		TraceIn("selectClause", 16);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken SELECT45 = default(IToken);
		IToken DISTINCT46 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> selectedPropertiesList47 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> newExpression48 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> selectObject49 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode SELECT45_tree = default(IASTNode);
		IASTNode DISTINCT46_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "selectClause");
		DebugLocation(233, 1);
		try
		{
			// Hql.g:234:2: ( SELECT ^ ( DISTINCT )? ( selectedPropertiesList | newExpression | selectObject ) )
			DebugEnterAlt(1);
			// Hql.g:234:4: SELECT ^ ( DISTINCT )? ( selectedPropertiesList | newExpression | selectObject )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(234, 10);
			SELECT45=(IToken)Match(input,SELECT,Follow._SELECT_in_selectClause1058); 
			SELECT45_tree = (IASTNode)adaptor.Create(SELECT45);
			root_0 = (IASTNode)adaptor.BecomeRoot(SELECT45_tree, root_0);
			DebugLocation(235, 3);
			 WeakKeywords(); 
			DebugLocation(236, 3);
			// Hql.g:236:3: ( DISTINCT )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_1 = input.LA(1);

			if ((LA18_1==DISTINCT))
			{
				alt18 = 1;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:236:4: DISTINCT
				{
				DebugLocation(236, 4);
				DISTINCT46=(IToken)Match(input,DISTINCT,Follow._DISTINCT_in_selectClause1070); 
				DISTINCT46_tree = (IASTNode)adaptor.Create(DISTINCT46);
				adaptor.AddChild(root_0, DISTINCT46_tree);

				}
				break;

			}
			} finally { DebugExitSubRule(18); }

			DebugLocation(236, 15);
			// Hql.g:236:15: ( selectedPropertiesList | newExpression | selectObject )
			int alt19=3;
			try { DebugEnterSubRule(19);
			try { DebugEnterDecision(19, false);
			switch (input.LA(1))
			{
			case ALL:
			case ANY:
			case AVG:
			case BNOT:
			case CASE:
			case COLON:
			case COUNT:
			case ELEMENTS:
			case EMPTY:
			case EXISTS:
			case FALSE:
			case IDENT:
			case INDICES:
			case MAX:
			case MIN:
			case MINUS:
			case NOT:
			case NULL:
			case NUM_DECIMAL:
			case NUM_DOUBLE:
			case NUM_FLOAT:
			case NUM_INT:
			case NUM_LONG:
			case OPEN:
			case PARAM:
			case PLUS:
			case QUOTED_String:
			case SOME:
			case SUM:
			case TRUE:
				{
				alt19 = 1;
				}
				break;
			case NEW:
				{
				alt19 = 2;
				}
				break;
			case OBJECT:
				{
				alt19 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 19, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:236:17: selectedPropertiesList
				{
				DebugLocation(236, 17);
				PushFollow(Follow._selectedPropertiesList_in_selectClause1076);
				selectedPropertiesList47=selectedPropertiesList();
				PopFollow();

				adaptor.AddChild(root_0, selectedPropertiesList47.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:236:42: newExpression
				{
				DebugLocation(236, 42);
				PushFollow(Follow._newExpression_in_selectClause1080);
				newExpression48=newExpression();
				PopFollow();

				adaptor.AddChild(root_0, newExpression48.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:236:58: selectObject
				{
				DebugLocation(236, 58);
				PushFollow(Follow._selectObject_in_selectClause1084);
				selectObject49=selectObject();
				PopFollow();

				adaptor.AddChild(root_0, selectObject49.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(19); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selectClause", 16);
			LeaveRule("selectClause", 16);
			LeaveRule_selectClause();
		}
		DebugLocation(237, 1);
		} finally { DebugExitRule(GrammarFileName, "selectClause"); }
		return retval;

	}
	// $ANTLR end "selectClause"

	partial void EnterRule_newExpression();
	partial void LeaveRule_newExpression();
	// $ANTLR start "newExpression"
	// Hql.g:239:1: newExpression : ( NEW path ) op= OPEN selectedPropertiesList CLOSE -> ^( CONSTRUCTOR[$op] path selectedPropertiesList ) ;
	[GrammarRule("newExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> newExpression()
	{
		EnterRule_newExpression();
		EnterRule("newExpression", 17);
		TraceIn("newExpression", 17);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken op = default(IToken);
		IToken NEW50 = default(IToken);
		IToken CLOSE53 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> path51 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> selectedPropertiesList52 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode op_tree = default(IASTNode);
		IASTNode NEW50_tree = default(IASTNode);
		IASTNode CLOSE53_tree = default(IASTNode);
		RewriteRuleITokenStream stream_NEW=new RewriteRuleITokenStream(adaptor,"token NEW");
		RewriteRuleITokenStream stream_OPEN=new RewriteRuleITokenStream(adaptor,"token OPEN");
		RewriteRuleITokenStream stream_CLOSE=new RewriteRuleITokenStream(adaptor,"token CLOSE");
		RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
		RewriteRuleSubtreeStream stream_selectedPropertiesList=new RewriteRuleSubtreeStream(adaptor,"rule selectedPropertiesList");
		try { DebugEnterRule(GrammarFileName, "newExpression");
		DebugLocation(239, 1);
		try
		{
			// Hql.g:240:2: ( ( NEW path ) op= OPEN selectedPropertiesList CLOSE -> ^( CONSTRUCTOR[$op] path selectedPropertiesList ) )
			DebugEnterAlt(1);
			// Hql.g:240:4: ( NEW path ) op= OPEN selectedPropertiesList CLOSE
			{
			DebugLocation(240, 4);
			// Hql.g:240:4: ( NEW path )
			DebugEnterAlt(1);
			// Hql.g:240:5: NEW path
			{
			DebugLocation(240, 5);
			NEW50=(IToken)Match(input,NEW,Follow._NEW_in_newExpression1098);  
			stream_NEW.Add(NEW50);

			DebugLocation(240, 9);
			PushFollow(Follow._path_in_newExpression1100);
			path51=path();
			PopFollow();

			stream_path.Add(path51.Tree);

			}

			DebugLocation(240, 17);
			op=(IToken)Match(input,OPEN,Follow._OPEN_in_newExpression1105);  
			stream_OPEN.Add(op);

			DebugLocation(240, 23);
			PushFollow(Follow._selectedPropertiesList_in_newExpression1107);
			selectedPropertiesList52=selectedPropertiesList();
			PopFollow();

			stream_selectedPropertiesList.Add(selectedPropertiesList52.Tree);
			DebugLocation(240, 46);
			CLOSE53=(IToken)Match(input,CLOSE,Follow._CLOSE_in_newExpression1109);  
			stream_CLOSE.Add(CLOSE53);



			{
			// AST REWRITE
			// elements: path, selectedPropertiesList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 241:3: -> ^( CONSTRUCTOR[$op] path selectedPropertiesList )
			{
				DebugLocation(241, 6);
				// Hql.g:241:6: ^( CONSTRUCTOR[$op] path selectedPropertiesList )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(241, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(CONSTRUCTOR, op), root_1);

				DebugLocation(241, 25);
				adaptor.AddChild(root_1, stream_path.NextTree());
				DebugLocation(241, 30);
				adaptor.AddChild(root_1, stream_selectedPropertiesList.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("newExpression", 17);
			LeaveRule("newExpression", 17);
			LeaveRule_newExpression();
		}
		DebugLocation(242, 1);
		} finally { DebugExitRule(GrammarFileName, "newExpression"); }
		return retval;

	}
	// $ANTLR end "newExpression"

	partial void EnterRule_selectObject();
	partial void LeaveRule_selectObject();
	// $ANTLR start "selectObject"
	// Hql.g:244:1: selectObject : OBJECT ^ OPEN ! identifier CLOSE !;
	[GrammarRule("selectObject")]
	private AstParserRuleReturnScope<IASTNode, IToken> selectObject()
	{
		EnterRule_selectObject();
		EnterRule("selectObject", 18);
		TraceIn("selectObject", 18);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken OBJECT54 = default(IToken);
		IToken OPEN55 = default(IToken);
		IToken CLOSE57 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> identifier56 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode OBJECT54_tree = default(IASTNode);
		IASTNode OPEN55_tree = default(IASTNode);
		IASTNode CLOSE57_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "selectObject");
		DebugLocation(244, 3);
		try
		{
			// Hql.g:245:4: ( OBJECT ^ OPEN ! identifier CLOSE !)
			DebugEnterAlt(1);
			// Hql.g:245:6: OBJECT ^ OPEN ! identifier CLOSE !
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(245, 12);
			OBJECT54=(IToken)Match(input,OBJECT,Follow._OBJECT_in_selectObject1135); 
			OBJECT54_tree = (IASTNode)adaptor.Create(OBJECT54);
			root_0 = (IASTNode)adaptor.BecomeRoot(OBJECT54_tree, root_0);
			DebugLocation(245, 18);
			OPEN55=(IToken)Match(input,OPEN,Follow._OPEN_in_selectObject1138); 
			DebugLocation(245, 20);
			PushFollow(Follow._identifier_in_selectObject1141);
			identifier56=identifier();
			PopFollow();

			adaptor.AddChild(root_0, identifier56.Tree);
			DebugLocation(245, 36);
			CLOSE57=(IToken)Match(input,CLOSE,Follow._CLOSE_in_selectObject1143); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selectObject", 18);
			LeaveRule("selectObject", 18);
			LeaveRule_selectObject();
		}
		DebugLocation(246, 3);
		} finally { DebugExitRule(GrammarFileName, "selectObject"); }
		return retval;

	}
	// $ANTLR end "selectObject"

	partial void EnterRule_fromClause();
	partial void LeaveRule_fromClause();
	// $ANTLR start "fromClause"
	// Hql.g:252:1: fromClause : FROM ^ fromRange ( fromJoin | COMMA ! fromRange )* ;
	[GrammarRule("fromClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> fromClause()
	{
		EnterRule_fromClause();
		EnterRule("fromClause", 19);
		TraceIn("fromClause", 19);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken FROM58 = default(IToken);
		IToken COMMA61 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> fromRange59 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> fromJoin60 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> fromRange62 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode FROM58_tree = default(IASTNode);
		IASTNode COMMA61_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "fromClause");
		DebugLocation(252, 1);
		try
		{
			// Hql.g:253:2: ( FROM ^ fromRange ( fromJoin | COMMA ! fromRange )* )
			DebugEnterAlt(1);
			// Hql.g:253:4: FROM ^ fromRange ( fromJoin | COMMA ! fromRange )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(253, 8);
			FROM58=(IToken)Match(input,FROM,Follow._FROM_in_fromClause1161); 
			FROM58_tree = (IASTNode)adaptor.Create(FROM58);
			root_0 = (IASTNode)adaptor.BecomeRoot(FROM58_tree, root_0);
			DebugLocation(253, 10);
			 WeakKeywords(); 
			DebugLocation(253, 30);
			PushFollow(Follow._fromRange_in_fromClause1166);
			fromRange59=fromRange();
			PopFollow();

			adaptor.AddChild(root_0, fromRange59.Tree);
			DebugLocation(253, 40);
			// Hql.g:253:40: ( fromJoin | COMMA ! fromRange )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=3;
				try { DebugEnterDecision(20, false);
				int LA20_1 = input.LA(1);

				if ((LA20_1==FULL||LA20_1==INNER||LA20_1==JOIN||LA20_1==LEFT||LA20_1==RIGHT))
				{
					alt20 = 1;
				}
				else if ((LA20_1==COMMA))
				{
					alt20 = 2;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:253:42: fromJoin
					{
					DebugLocation(253, 42);
					PushFollow(Follow._fromJoin_in_fromClause1170);
					fromJoin60=fromJoin();
					PopFollow();

					adaptor.AddChild(root_0, fromJoin60.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:253:53: COMMA ! fromRange
					{
					DebugLocation(253, 58);
					COMMA61=(IToken)Match(input,COMMA,Follow._COMMA_in_fromClause1174); 
					DebugLocation(253, 60);
					 WeakKeywords(); 
					DebugLocation(253, 80);
					PushFollow(Follow._fromRange_in_fromClause1179);
					fromRange62=fromRange();
					PopFollow();

					adaptor.AddChild(root_0, fromRange62.Tree);

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fromClause", 19);
			LeaveRule("fromClause", 19);
			LeaveRule_fromClause();
		}
		DebugLocation(254, 1);
		} finally { DebugExitRule(GrammarFileName, "fromClause"); }
		return retval;

	}
	// $ANTLR end "fromClause"

	partial void EnterRule_fromJoin();
	partial void LeaveRule_fromJoin();
	// $ANTLR start "fromJoin"
	// Hql.g:256:1: fromJoin : ( ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? path ( asAlias )? ( propertyFetch )? ( withClause )? | ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? ELEMENTS ! OPEN ! path CLOSE ! ( asAlias )? ( propertyFetch )? ( withClause )? );
	[GrammarRule("fromJoin")]
	private AstParserRuleReturnScope<IASTNode, IToken> fromJoin()
	{
		EnterRule_fromJoin();
		EnterRule("fromJoin", 20);
		TraceIn("fromJoin", 20);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken set63 = default(IToken);
		IToken OUTER64 = default(IToken);
		IToken FULL65 = default(IToken);
		IToken INNER66 = default(IToken);
		IToken JOIN67 = default(IToken);
		IToken FETCH68 = default(IToken);
		IToken set73 = default(IToken);
		IToken OUTER74 = default(IToken);
		IToken FULL75 = default(IToken);
		IToken INNER76 = default(IToken);
		IToken JOIN77 = default(IToken);
		IToken FETCH78 = default(IToken);
		IToken ELEMENTS79 = default(IToken);
		IToken OPEN80 = default(IToken);
		IToken CLOSE82 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> path69 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> asAlias70 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> propertyFetch71 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> withClause72 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> path81 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> asAlias83 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> propertyFetch84 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> withClause85 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode set63_tree = default(IASTNode);
		IASTNode OUTER64_tree = default(IASTNode);
		IASTNode FULL65_tree = default(IASTNode);
		IASTNode INNER66_tree = default(IASTNode);
		IASTNode JOIN67_tree = default(IASTNode);
		IASTNode FETCH68_tree = default(IASTNode);
		IASTNode set73_tree = default(IASTNode);
		IASTNode OUTER74_tree = default(IASTNode);
		IASTNode FULL75_tree = default(IASTNode);
		IASTNode INNER76_tree = default(IASTNode);
		IASTNode JOIN77_tree = default(IASTNode);
		IASTNode FETCH78_tree = default(IASTNode);
		IASTNode ELEMENTS79_tree = default(IASTNode);
		IASTNode OPEN80_tree = default(IASTNode);
		IASTNode CLOSE82_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "fromJoin");
		DebugLocation(256, 1);
		try
		{
			// Hql.g:257:2: ( ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? path ( asAlias )? ( propertyFetch )? ( withClause )? | ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? ELEMENTS ! OPEN ! path CLOSE ! ( asAlias )? ( propertyFetch )? ( withClause )? )
			int alt33=2;
			try { DebugEnterDecision(33, false);
			switch (input.LA(1))
			{
			case LEFT:
			case RIGHT:
				{
				int LA33_2 = input.LA(2);

				if ((LA33_2==OUTER))
				{
					int LA33_3 = input.LA(3);

					if ((LA33_3==JOIN))
					{
						switch (input.LA(4))
						{
						case FETCH:
							{
							int LA33_5 = input.LA(5);

							if ((LA33_5==IDENT))
							{
								alt33 = 1;
							}
							else if ((LA33_5==ELEMENTS))
							{
								alt33 = 2;
							}
							else
							{
								NoViableAltException nvae = new NoViableAltException("", 33, 6, input, 5);
								DebugRecognitionException(nvae);
								throw nvae;
							}
							}
							break;
						case IDENT:
							{
							alt33 = 1;
							}
							break;
						case ELEMENTS:
							{
							alt33 = 2;
							}
							break;
						default:
							{
								NoViableAltException nvae = new NoViableAltException("", 33, 4, input, 4);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}

					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 33, 5, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA33_2==JOIN))
				{
					switch (input.LA(3))
					{
					case FETCH:
						{
						int LA33_4 = input.LA(4);

						if ((LA33_4==IDENT))
						{
							alt33 = 1;
						}
						else if ((LA33_4==ELEMENTS))
						{
							alt33 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 33, 6, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case IDENT:
						{
						alt33 = 1;
						}
						break;
					case ELEMENTS:
						{
						alt33 = 2;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 33, 4, input, 3);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 33, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case FULL:
				{
				int LA33_2 = input.LA(2);

				if ((LA33_2==JOIN))
				{
					switch (input.LA(3))
					{
					case FETCH:
						{
						int LA33_4 = input.LA(4);

						if ((LA33_4==IDENT))
						{
							alt33 = 1;
						}
						else if ((LA33_4==ELEMENTS))
						{
							alt33 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 33, 6, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case IDENT:
						{
						alt33 = 1;
						}
						break;
					case ELEMENTS:
						{
						alt33 = 2;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 33, 4, input, 3);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 33, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INNER:
				{
				int LA33_2 = input.LA(2);

				if ((LA33_2==JOIN))
				{
					switch (input.LA(3))
					{
					case FETCH:
						{
						int LA33_4 = input.LA(4);

						if ((LA33_4==IDENT))
						{
							alt33 = 1;
						}
						else if ((LA33_4==ELEMENTS))
						{
							alt33 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 33, 6, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case IDENT:
						{
						alt33 = 1;
						}
						break;
					case ELEMENTS:
						{
						alt33 = 2;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 33, 4, input, 3);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 33, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case JOIN:
				{
				switch (input.LA(2))
				{
				case FETCH:
					{
					int LA33_3 = input.LA(3);

					if ((LA33_3==IDENT))
					{
						alt33 = 1;
					}
					else if ((LA33_3==ELEMENTS))
					{
						alt33 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 33, 6, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case IDENT:
					{
					alt33 = 1;
					}
					break;
				case ELEMENTS:
					{
					alt33 = 2;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 33, 4, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 33, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(33); }
			switch (alt33)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:257:4: ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? path ( asAlias )? ( propertyFetch )? ( withClause )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(257, 4);
				// Hql.g:257:4: ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )?
				int alt22=4;
				try { DebugEnterSubRule(22);
				try { DebugEnterDecision(22, false);
				switch (input.LA(1))
				{
				case LEFT:
				case RIGHT:
					{
					alt22 = 1;
					}
					break;
				case FULL:
					{
					alt22 = 2;
					}
					break;
				case INNER:
					{
					alt22 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(22); }
				switch (alt22)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:257:6: ( ( LEFT | RIGHT ) ( OUTER )? )
					{
					DebugLocation(257, 6);
					// Hql.g:257:6: ( ( LEFT | RIGHT ) ( OUTER )? )
					DebugEnterAlt(1);
					// Hql.g:257:8: ( LEFT | RIGHT ) ( OUTER )?
					{
					DebugLocation(257, 8);

					set63=(IToken)input.LT(1);
					if (input.LA(1)==LEFT||input.LA(1)==RIGHT)
					{
						input.Consume();
						adaptor.AddChild(root_0, (IASTNode)adaptor.Create(set63));
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(257, 25);
					// Hql.g:257:25: ( OUTER )?
					int alt21=2;
					try { DebugEnterSubRule(21);
					try { DebugEnterDecision(21, false);
					int LA21_1 = input.LA(1);

					if ((LA21_1==OUTER))
					{
						alt21 = 1;
					}
					} finally { DebugExitDecision(21); }
					switch (alt21)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:257:26: OUTER
						{
						DebugLocation(257, 26);
						OUTER64=(IToken)Match(input,OUTER,Follow._OUTER_in_fromJoin1208); 
						OUTER64_tree = (IASTNode)adaptor.Create(OUTER64);
						adaptor.AddChild(root_0, OUTER64_tree);

						}
						break;

					}
					} finally { DebugExitSubRule(21); }


					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:257:38: FULL
					{
					DebugLocation(257, 38);
					FULL65=(IToken)Match(input,FULL,Follow._FULL_in_fromJoin1216); 
					FULL65_tree = (IASTNode)adaptor.Create(FULL65);
					adaptor.AddChild(root_0, FULL65_tree);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Hql.g:257:45: INNER
					{
					DebugLocation(257, 45);
					INNER66=(IToken)Match(input,INNER,Follow._INNER_in_fromJoin1220); 
					INNER66_tree = (IASTNode)adaptor.Create(INNER66);
					adaptor.AddChild(root_0, INNER66_tree);

					}
					break;

				}
				} finally { DebugExitSubRule(22); }

				DebugLocation(257, 58);
				JOIN67=(IToken)Match(input,JOIN,Follow._JOIN_in_fromJoin1225); 
				JOIN67_tree = (IASTNode)adaptor.Create(JOIN67);
				root_0 = (IASTNode)adaptor.BecomeRoot(JOIN67_tree, root_0);
				DebugLocation(257, 60);
				// Hql.g:257:60: ( FETCH )?
				int alt23=2;
				try { DebugEnterSubRule(23);
				try { DebugEnterDecision(23, false);
				int LA23_1 = input.LA(1);

				if ((LA23_1==FETCH))
				{
					alt23 = 1;
				}
				} finally { DebugExitDecision(23); }
				switch (alt23)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:257:61: FETCH
					{
					DebugLocation(257, 61);
					FETCH68=(IToken)Match(input,FETCH,Follow._FETCH_in_fromJoin1229); 
					FETCH68_tree = (IASTNode)adaptor.Create(FETCH68);
					adaptor.AddChild(root_0, FETCH68_tree);

					}
					break;

				}
				} finally { DebugExitSubRule(23); }

				DebugLocation(257, 69);
				PushFollow(Follow._path_in_fromJoin1233);
				path69=path();
				PopFollow();

				adaptor.AddChild(root_0, path69.Tree);
				DebugLocation(257, 74);
				// Hql.g:257:74: ( asAlias )?
				int alt24=2;
				try { DebugEnterSubRule(24);
				try { DebugEnterDecision(24, false);
				int LA24_1 = input.LA(1);

				if ((LA24_1==AS||LA24_1==IDENT))
				{
					alt24 = 1;
				}
				} finally { DebugExitDecision(24); }
				switch (alt24)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:257:75: asAlias
					{
					DebugLocation(257, 75);
					PushFollow(Follow._asAlias_in_fromJoin1236);
					asAlias70=asAlias();
					PopFollow();

					adaptor.AddChild(root_0, asAlias70.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(24); }

				DebugLocation(257, 85);
				// Hql.g:257:85: ( propertyFetch )?
				int alt25=2;
				try { DebugEnterSubRule(25);
				try { DebugEnterDecision(25, false);
				int LA25_1 = input.LA(1);

				if ((LA25_1==FETCH))
				{
					alt25 = 1;
				}
				} finally { DebugExitDecision(25); }
				switch (alt25)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:257:86: propertyFetch
					{
					DebugLocation(257, 86);
					PushFollow(Follow._propertyFetch_in_fromJoin1241);
					propertyFetch71=propertyFetch();
					PopFollow();

					adaptor.AddChild(root_0, propertyFetch71.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(25); }

				DebugLocation(257, 102);
				// Hql.g:257:102: ( withClause )?
				int alt26=2;
				try { DebugEnterSubRule(26);
				try { DebugEnterDecision(26, false);
				int LA26_1 = input.LA(1);

				if ((LA26_1==WITH))
				{
					alt26 = 1;
				}
				} finally { DebugExitDecision(26); }
				switch (alt26)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:257:103: withClause
					{
					DebugLocation(257, 103);
					PushFollow(Follow._withClause_in_fromJoin1246);
					withClause72=withClause();
					PopFollow();

					adaptor.AddChild(root_0, withClause72.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(26); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:258:4: ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ^ ( FETCH )? ELEMENTS ! OPEN ! path CLOSE ! ( asAlias )? ( propertyFetch )? ( withClause )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(258, 4);
				// Hql.g:258:4: ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )?
				int alt28=4;
				try { DebugEnterSubRule(28);
				try { DebugEnterDecision(28, false);
				switch (input.LA(1))
				{
				case LEFT:
				case RIGHT:
					{
					alt28 = 1;
					}
					break;
				case FULL:
					{
					alt28 = 2;
					}
					break;
				case INNER:
					{
					alt28 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(28); }
				switch (alt28)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:258:6: ( ( LEFT | RIGHT ) ( OUTER )? )
					{
					DebugLocation(258, 6);
					// Hql.g:258:6: ( ( LEFT | RIGHT ) ( OUTER )? )
					DebugEnterAlt(1);
					// Hql.g:258:8: ( LEFT | RIGHT ) ( OUTER )?
					{
					DebugLocation(258, 8);

					set73=(IToken)input.LT(1);
					if (input.LA(1)==LEFT||input.LA(1)==RIGHT)
					{
						input.Consume();
						adaptor.AddChild(root_0, (IASTNode)adaptor.Create(set73));
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(258, 25);
					// Hql.g:258:25: ( OUTER )?
					int alt27=2;
					try { DebugEnterSubRule(27);
					try { DebugEnterDecision(27, false);
					int LA27_1 = input.LA(1);

					if ((LA27_1==OUTER))
					{
						alt27 = 1;
					}
					} finally { DebugExitDecision(27); }
					switch (alt27)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:258:26: OUTER
						{
						DebugLocation(258, 26);
						OUTER74=(IToken)Match(input,OUTER,Follow._OUTER_in_fromJoin1268); 
						OUTER74_tree = (IASTNode)adaptor.Create(OUTER74);
						adaptor.AddChild(root_0, OUTER74_tree);

						}
						break;

					}
					} finally { DebugExitSubRule(27); }


					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:258:38: FULL
					{
					DebugLocation(258, 38);
					FULL75=(IToken)Match(input,FULL,Follow._FULL_in_fromJoin1276); 
					FULL75_tree = (IASTNode)adaptor.Create(FULL75);
					adaptor.AddChild(root_0, FULL75_tree);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Hql.g:258:45: INNER
					{
					DebugLocation(258, 45);
					INNER76=(IToken)Match(input,INNER,Follow._INNER_in_fromJoin1280); 
					INNER76_tree = (IASTNode)adaptor.Create(INNER76);
					adaptor.AddChild(root_0, INNER76_tree);

					}
					break;

				}
				} finally { DebugExitSubRule(28); }

				DebugLocation(258, 58);
				JOIN77=(IToken)Match(input,JOIN,Follow._JOIN_in_fromJoin1285); 
				JOIN77_tree = (IASTNode)adaptor.Create(JOIN77);
				root_0 = (IASTNode)adaptor.BecomeRoot(JOIN77_tree, root_0);
				DebugLocation(258, 60);
				// Hql.g:258:60: ( FETCH )?
				int alt29=2;
				try { DebugEnterSubRule(29);
				try { DebugEnterDecision(29, false);
				int LA29_1 = input.LA(1);

				if ((LA29_1==FETCH))
				{
					alt29 = 1;
				}
				} finally { DebugExitDecision(29); }
				switch (alt29)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:258:61: FETCH
					{
					DebugLocation(258, 61);
					FETCH78=(IToken)Match(input,FETCH,Follow._FETCH_in_fromJoin1289); 
					FETCH78_tree = (IASTNode)adaptor.Create(FETCH78);
					adaptor.AddChild(root_0, FETCH78_tree);

					}
					break;

				}
				} finally { DebugExitSubRule(29); }

				DebugLocation(258, 77);
				ELEMENTS79=(IToken)Match(input,ELEMENTS,Follow._ELEMENTS_in_fromJoin1293); 
				DebugLocation(258, 83);
				OPEN80=(IToken)Match(input,OPEN,Follow._OPEN_in_fromJoin1296); 
				DebugLocation(258, 85);
				PushFollow(Follow._path_in_fromJoin1299);
				path81=path();
				PopFollow();

				adaptor.AddChild(root_0, path81.Tree);
				DebugLocation(258, 95);
				CLOSE82=(IToken)Match(input,CLOSE,Follow._CLOSE_in_fromJoin1301); 
				DebugLocation(258, 97);
				// Hql.g:258:97: ( asAlias )?
				int alt30=2;
				try { DebugEnterSubRule(30);
				try { DebugEnterDecision(30, false);
				int LA30_1 = input.LA(1);

				if ((LA30_1==AS||LA30_1==IDENT))
				{
					alt30 = 1;
				}
				} finally { DebugExitDecision(30); }
				switch (alt30)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:258:98: asAlias
					{
					DebugLocation(258, 98);
					PushFollow(Follow._asAlias_in_fromJoin1305);
					asAlias83=asAlias();
					PopFollow();

					adaptor.AddChild(root_0, asAlias83.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(30); }

				DebugLocation(258, 108);
				// Hql.g:258:108: ( propertyFetch )?
				int alt31=2;
				try { DebugEnterSubRule(31);
				try { DebugEnterDecision(31, false);
				int LA31_1 = input.LA(1);

				if ((LA31_1==FETCH))
				{
					alt31 = 1;
				}
				} finally { DebugExitDecision(31); }
				switch (alt31)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:258:109: propertyFetch
					{
					DebugLocation(258, 109);
					PushFollow(Follow._propertyFetch_in_fromJoin1310);
					propertyFetch84=propertyFetch();
					PopFollow();

					adaptor.AddChild(root_0, propertyFetch84.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(31); }

				DebugLocation(258, 125);
				// Hql.g:258:125: ( withClause )?
				int alt32=2;
				try { DebugEnterSubRule(32);
				try { DebugEnterDecision(32, false);
				int LA32_1 = input.LA(1);

				if ((LA32_1==WITH))
				{
					alt32 = 1;
				}
				} finally { DebugExitDecision(32); }
				switch (alt32)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:258:126: withClause
					{
					DebugLocation(258, 126);
					PushFollow(Follow._withClause_in_fromJoin1315);
					withClause85=withClause();
					PopFollow();

					adaptor.AddChild(root_0, withClause85.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(32); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fromJoin", 20);
			LeaveRule("fromJoin", 20);
			LeaveRule_fromJoin();
		}
		DebugLocation(259, 1);
		} finally { DebugExitRule(GrammarFileName, "fromJoin"); }
		return retval;

	}
	// $ANTLR end "fromJoin"

	partial void EnterRule_withClause();
	partial void LeaveRule_withClause();
	// $ANTLR start "withClause"
	// Hql.g:261:1: withClause : WITH ^ logicalExpression ;
	[GrammarRule("withClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> withClause()
	{
		EnterRule_withClause();
		EnterRule("withClause", 21);
		TraceIn("withClause", 21);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken WITH86 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> logicalExpression87 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode WITH86_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "withClause");
		DebugLocation(261, 1);
		try
		{
			// Hql.g:262:2: ( WITH ^ logicalExpression )
			DebugEnterAlt(1);
			// Hql.g:262:4: WITH ^ logicalExpression
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(262, 8);
			WITH86=(IToken)Match(input,WITH,Follow._WITH_in_withClause1328); 
			WITH86_tree = (IASTNode)adaptor.Create(WITH86);
			root_0 = (IASTNode)adaptor.BecomeRoot(WITH86_tree, root_0);
			DebugLocation(262, 10);
			PushFollow(Follow._logicalExpression_in_withClause1331);
			logicalExpression87=logicalExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalExpression87.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("withClause", 21);
			LeaveRule("withClause", 21);
			LeaveRule_withClause();
		}
		DebugLocation(263, 1);
		} finally { DebugExitRule(GrammarFileName, "withClause"); }
		return retval;

	}
	// $ANTLR end "withClause"

	partial void EnterRule_fromRange();
	partial void LeaveRule_fromRange();
	// $ANTLR start "fromRange"
	// Hql.g:265:1: fromRange : ( fromClassOrOuterQueryPath | inClassDeclaration | inCollectionDeclaration | inCollectionElementsDeclaration );
	[GrammarRule("fromRange")]
	private AstParserRuleReturnScope<IASTNode, IToken> fromRange()
	{
		EnterRule_fromRange();
		EnterRule("fromRange", 22);
		TraceIn("fromRange", 22);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> fromClassOrOuterQueryPath88 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> inClassDeclaration89 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> inCollectionDeclaration90 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> inCollectionElementsDeclaration91 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		try { DebugEnterRule(GrammarFileName, "fromRange");
		DebugLocation(265, 1);
		try
		{
			// Hql.g:266:2: ( fromClassOrOuterQueryPath | inClassDeclaration | inCollectionDeclaration | inCollectionElementsDeclaration )
			int alt34=4;
			try { DebugEnterDecision(34, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				int LA34_2 = input.LA(2);

				if ((LA34_2==EOF||LA34_2==AS||LA34_2==CLOSE||LA34_2==COMMA||LA34_2==DOT||LA34_2==FETCH||LA34_2==FULL||LA34_2==GROUP||LA34_2==HAVING||LA34_2==IDENT||LA34_2==INNER||LA34_2==JOIN||LA34_2==LEFT||LA34_2==ORDER||LA34_2==RIGHT||LA34_2==SKIP||LA34_2==TAKE||LA34_2==UNION||LA34_2==WHERE))
				{
					alt34 = 1;
				}
				else if ((LA34_2==IN))
				{
					int LA34_3 = input.LA(3);

					if ((LA34_3==ELEMENTS))
					{
						alt34 = 4;
					}
					else if ((LA34_3==CLASS||LA34_3==IDENT))
					{
						alt34 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 34, 5, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 34, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case IN:
				{
				alt34 = 3;
				}
				break;
			case ELEMENTS:
				{
				alt34 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 34, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(34); }
			switch (alt34)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:266:4: fromClassOrOuterQueryPath
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(266, 4);
				PushFollow(Follow._fromClassOrOuterQueryPath_in_fromRange1342);
				fromClassOrOuterQueryPath88=fromClassOrOuterQueryPath();
				PopFollow();

				adaptor.AddChild(root_0, fromClassOrOuterQueryPath88.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:267:4: inClassDeclaration
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(267, 4);
				PushFollow(Follow._inClassDeclaration_in_fromRange1347);
				inClassDeclaration89=inClassDeclaration();
				PopFollow();

				adaptor.AddChild(root_0, inClassDeclaration89.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:268:4: inCollectionDeclaration
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(268, 4);
				PushFollow(Follow._inCollectionDeclaration_in_fromRange1352);
				inCollectionDeclaration90=inCollectionDeclaration();
				PopFollow();

				adaptor.AddChild(root_0, inCollectionDeclaration90.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Hql.g:269:4: inCollectionElementsDeclaration
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(269, 4);
				PushFollow(Follow._inCollectionElementsDeclaration_in_fromRange1357);
				inCollectionElementsDeclaration91=inCollectionElementsDeclaration();
				PopFollow();

				adaptor.AddChild(root_0, inCollectionElementsDeclaration91.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fromRange", 22);
			LeaveRule("fromRange", 22);
			LeaveRule_fromRange();
		}
		DebugLocation(270, 1);
		} finally { DebugExitRule(GrammarFileName, "fromRange"); }
		return retval;

	}
	// $ANTLR end "fromRange"

	partial void EnterRule_fromClassOrOuterQueryPath();
	partial void LeaveRule_fromClassOrOuterQueryPath();
	// $ANTLR start "fromClassOrOuterQueryPath"
	// Hql.g:272:1: fromClassOrOuterQueryPath : path ( asAlias )? ( propertyFetch )? -> ^( RANGE path ( asAlias )? ( propertyFetch )? ) ;
	[GrammarRule("fromClassOrOuterQueryPath")]
	private AstParserRuleReturnScope<IASTNode, IToken> fromClassOrOuterQueryPath()
	{
		EnterRule_fromClassOrOuterQueryPath();
		EnterRule("fromClassOrOuterQueryPath", 23);
		TraceIn("fromClassOrOuterQueryPath", 23);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> path92 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> asAlias93 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> propertyFetch94 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
		RewriteRuleSubtreeStream stream_asAlias=new RewriteRuleSubtreeStream(adaptor,"rule asAlias");
		RewriteRuleSubtreeStream stream_propertyFetch=new RewriteRuleSubtreeStream(adaptor,"rule propertyFetch");
		try { DebugEnterRule(GrammarFileName, "fromClassOrOuterQueryPath");
		DebugLocation(272, 1);
		try
		{
			// Hql.g:273:2: ( path ( asAlias )? ( propertyFetch )? -> ^( RANGE path ( asAlias )? ( propertyFetch )? ) )
			DebugEnterAlt(1);
			// Hql.g:273:4: path ( asAlias )? ( propertyFetch )?
			{
			DebugLocation(273, 4);
			PushFollow(Follow._path_in_fromClassOrOuterQueryPath1369);
			path92=path();
			PopFollow();

			stream_path.Add(path92.Tree);
			DebugLocation(273, 9);
			 WeakKeywords(); 
			DebugLocation(273, 29);
			// Hql.g:273:29: ( asAlias )?
			int alt35=2;
			try { DebugEnterSubRule(35);
			try { DebugEnterDecision(35, false);
			int LA35_1 = input.LA(1);

			if ((LA35_1==AS||LA35_1==IDENT))
			{
				alt35 = 1;
			}
			} finally { DebugExitDecision(35); }
			switch (alt35)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:273:30: asAlias
				{
				DebugLocation(273, 30);
				PushFollow(Follow._asAlias_in_fromClassOrOuterQueryPath1374);
				asAlias93=asAlias();
				PopFollow();

				stream_asAlias.Add(asAlias93.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(35); }

			DebugLocation(273, 40);
			// Hql.g:273:40: ( propertyFetch )?
			int alt36=2;
			try { DebugEnterSubRule(36);
			try { DebugEnterDecision(36, false);
			int LA36_1 = input.LA(1);

			if ((LA36_1==FETCH))
			{
				alt36 = 1;
			}
			} finally { DebugExitDecision(36); }
			switch (alt36)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:273:41: propertyFetch
				{
				DebugLocation(273, 41);
				PushFollow(Follow._propertyFetch_in_fromClassOrOuterQueryPath1379);
				propertyFetch94=propertyFetch();
				PopFollow();

				stream_propertyFetch.Add(propertyFetch94.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(36); }



			{
			// AST REWRITE
			// elements: path, asAlias, propertyFetch
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 274:3: -> ^( RANGE path ( asAlias )? ( propertyFetch )? )
			{
				DebugLocation(274, 6);
				// Hql.g:274:6: ^( RANGE path ( asAlias )? ( propertyFetch )? )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(274, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(RANGE, "RANGE"), root_1);

				DebugLocation(274, 14);
				adaptor.AddChild(root_1, stream_path.NextTree());
				DebugLocation(274, 19);
				// Hql.g:274:19: ( asAlias )?
				if (stream_asAlias.HasNext)
				{
					DebugLocation(274, 19);
					adaptor.AddChild(root_1, stream_asAlias.NextTree());

				}
				stream_asAlias.Reset();
				DebugLocation(274, 28);
				// Hql.g:274:28: ( propertyFetch )?
				if (stream_propertyFetch.HasNext)
				{
					DebugLocation(274, 28);
					adaptor.AddChild(root_1, stream_propertyFetch.NextTree());

				}
				stream_propertyFetch.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fromClassOrOuterQueryPath", 23);
			LeaveRule("fromClassOrOuterQueryPath", 23);
			LeaveRule_fromClassOrOuterQueryPath();
		}
		DebugLocation(275, 1);
		} finally { DebugExitRule(GrammarFileName, "fromClassOrOuterQueryPath"); }
		return retval;

	}
	// $ANTLR end "fromClassOrOuterQueryPath"

	partial void EnterRule_inClassDeclaration();
	partial void LeaveRule_inClassDeclaration();
	// $ANTLR start "inClassDeclaration"
	// Hql.g:277:1: inClassDeclaration : alias IN ( CLASS )? path -> ^( RANGE path alias ) ;
	[GrammarRule("inClassDeclaration")]
	private AstParserRuleReturnScope<IASTNode, IToken> inClassDeclaration()
	{
		EnterRule_inClassDeclaration();
		EnterRule("inClassDeclaration", 24);
		TraceIn("inClassDeclaration", 24);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken IN96 = default(IToken);
		IToken CLASS97 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> alias95 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> path98 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode IN96_tree = default(IASTNode);
		IASTNode CLASS97_tree = default(IASTNode);
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleITokenStream stream_CLASS=new RewriteRuleITokenStream(adaptor,"token CLASS");
		RewriteRuleSubtreeStream stream_alias=new RewriteRuleSubtreeStream(adaptor,"rule alias");
		RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
		try { DebugEnterRule(GrammarFileName, "inClassDeclaration");
		DebugLocation(277, 1);
		try
		{
			// Hql.g:278:2: ( alias IN ( CLASS )? path -> ^( RANGE path alias ) )
			DebugEnterAlt(1);
			// Hql.g:278:4: alias IN ( CLASS )? path
			{
			DebugLocation(278, 4);
			PushFollow(Follow._alias_in_inClassDeclaration1409);
			alias95=alias();
			PopFollow();

			stream_alias.Add(alias95.Tree);
			DebugLocation(278, 10);
			IN96=(IToken)Match(input,IN,Follow._IN_in_inClassDeclaration1411);  
			stream_IN.Add(IN96);

			DebugLocation(278, 13);
			// Hql.g:278:13: ( CLASS )?
			int alt37=2;
			try { DebugEnterSubRule(37);
			try { DebugEnterDecision(37, false);
			int LA37_1 = input.LA(1);

			if ((LA37_1==CLASS))
			{
				alt37 = 1;
			}
			} finally { DebugExitDecision(37); }
			switch (alt37)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:278:13: CLASS
				{
				DebugLocation(278, 13);
				CLASS97=(IToken)Match(input,CLASS,Follow._CLASS_in_inClassDeclaration1413);  
				stream_CLASS.Add(CLASS97);


				}
				break;

			}
			} finally { DebugExitSubRule(37); }

			DebugLocation(278, 20);
			PushFollow(Follow._path_in_inClassDeclaration1416);
			path98=path();
			PopFollow();

			stream_path.Add(path98.Tree);


			{
			// AST REWRITE
			// elements: path, alias
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 279:3: -> ^( RANGE path alias )
			{
				DebugLocation(279, 6);
				// Hql.g:279:6: ^( RANGE path alias )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(279, 8);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(RANGE, "RANGE"), root_1);

				DebugLocation(279, 14);
				adaptor.AddChild(root_1, stream_path.NextTree());
				DebugLocation(279, 19);
				adaptor.AddChild(root_1, stream_alias.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("inClassDeclaration", 24);
			LeaveRule("inClassDeclaration", 24);
			LeaveRule_inClassDeclaration();
		}
		DebugLocation(280, 1);
		} finally { DebugExitRule(GrammarFileName, "inClassDeclaration"); }
		return retval;

	}
	// $ANTLR end "inClassDeclaration"

	partial void EnterRule_inCollectionDeclaration();
	partial void LeaveRule_inCollectionDeclaration();
	// $ANTLR start "inCollectionDeclaration"
	// Hql.g:282:1: inCollectionDeclaration : IN OPEN path CLOSE alias -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) ;
	[GrammarRule("inCollectionDeclaration")]
	private AstParserRuleReturnScope<IASTNode, IToken> inCollectionDeclaration()
	{
		EnterRule_inCollectionDeclaration();
		EnterRule("inCollectionDeclaration", 25);
		TraceIn("inCollectionDeclaration", 25);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken IN99 = default(IToken);
		IToken OPEN100 = default(IToken);
		IToken CLOSE102 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> path101 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> alias103 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode IN99_tree = default(IASTNode);
		IASTNode OPEN100_tree = default(IASTNode);
		IASTNode CLOSE102_tree = default(IASTNode);
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleITokenStream stream_OPEN=new RewriteRuleITokenStream(adaptor,"token OPEN");
		RewriteRuleITokenStream stream_CLOSE=new RewriteRuleITokenStream(adaptor,"token CLOSE");
		RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
		RewriteRuleSubtreeStream stream_alias=new RewriteRuleSubtreeStream(adaptor,"rule alias");
		try { DebugEnterRule(GrammarFileName, "inCollectionDeclaration");
		DebugLocation(282, 4);
		try
		{
			// Hql.g:283:5: ( IN OPEN path CLOSE alias -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) )
			DebugEnterAlt(1);
			// Hql.g:283:7: IN OPEN path CLOSE alias
			{
			DebugLocation(283, 7);
			IN99=(IToken)Match(input,IN,Follow._IN_in_inCollectionDeclaration1444);  
			stream_IN.Add(IN99);

			DebugLocation(283, 10);
			OPEN100=(IToken)Match(input,OPEN,Follow._OPEN_in_inCollectionDeclaration1446);  
			stream_OPEN.Add(OPEN100);

			DebugLocation(283, 15);
			PushFollow(Follow._path_in_inCollectionDeclaration1448);
			path101=path();
			PopFollow();

			stream_path.Add(path101.Tree);
			DebugLocation(283, 20);
			CLOSE102=(IToken)Match(input,CLOSE,Follow._CLOSE_in_inCollectionDeclaration1450);  
			stream_CLOSE.Add(CLOSE102);

			DebugLocation(283, 26);
			PushFollow(Follow._alias_in_inCollectionDeclaration1452);
			alias103=alias();
			PopFollow();

			stream_alias.Add(alias103.Tree);


			{
			// AST REWRITE
			// elements: path, alias
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 284:6: -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
			{
				DebugLocation(284, 9);
				// Hql.g:284:9: ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(284, 11);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(JOIN, "join"), root_1);

				DebugLocation(284, 24);
				adaptor.AddChild(root_1, (IASTNode)adaptor.Create(INNER, "inner"));
				DebugLocation(284, 39);
				adaptor.AddChild(root_1, stream_path.NextTree());
				DebugLocation(284, 44);
				adaptor.AddChild(root_1, stream_alias.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("inCollectionDeclaration", 25);
			LeaveRule("inCollectionDeclaration", 25);
			LeaveRule_inCollectionDeclaration();
		}
		DebugLocation(285, 4);
		} finally { DebugExitRule(GrammarFileName, "inCollectionDeclaration"); }
		return retval;

	}
	// $ANTLR end "inCollectionDeclaration"

	partial void EnterRule_inCollectionElementsDeclaration();
	partial void LeaveRule_inCollectionElementsDeclaration();
	// $ANTLR start "inCollectionElementsDeclaration"
	// Hql.g:287:1: inCollectionElementsDeclaration : ( alias IN ELEMENTS OPEN path CLOSE -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) | ELEMENTS OPEN path CLOSE AS alias -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) );
	[GrammarRule("inCollectionElementsDeclaration")]
	private AstParserRuleReturnScope<IASTNode, IToken> inCollectionElementsDeclaration()
	{
		EnterRule_inCollectionElementsDeclaration();
		EnterRule("inCollectionElementsDeclaration", 26);
		TraceIn("inCollectionElementsDeclaration", 26);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken IN105 = default(IToken);
		IToken ELEMENTS106 = default(IToken);
		IToken OPEN107 = default(IToken);
		IToken CLOSE109 = default(IToken);
		IToken ELEMENTS110 = default(IToken);
		IToken OPEN111 = default(IToken);
		IToken CLOSE113 = default(IToken);
		IToken AS114 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> alias104 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> path108 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> path112 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> alias115 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode IN105_tree = default(IASTNode);
		IASTNode ELEMENTS106_tree = default(IASTNode);
		IASTNode OPEN107_tree = default(IASTNode);
		IASTNode CLOSE109_tree = default(IASTNode);
		IASTNode ELEMENTS110_tree = default(IASTNode);
		IASTNode OPEN111_tree = default(IASTNode);
		IASTNode CLOSE113_tree = default(IASTNode);
		IASTNode AS114_tree = default(IASTNode);
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleITokenStream stream_ELEMENTS=new RewriteRuleITokenStream(adaptor,"token ELEMENTS");
		RewriteRuleITokenStream stream_OPEN=new RewriteRuleITokenStream(adaptor,"token OPEN");
		RewriteRuleITokenStream stream_CLOSE=new RewriteRuleITokenStream(adaptor,"token CLOSE");
		RewriteRuleITokenStream stream_AS=new RewriteRuleITokenStream(adaptor,"token AS");
		RewriteRuleSubtreeStream stream_alias=new RewriteRuleSubtreeStream(adaptor,"rule alias");
		RewriteRuleSubtreeStream stream_path=new RewriteRuleSubtreeStream(adaptor,"rule path");
		try { DebugEnterRule(GrammarFileName, "inCollectionElementsDeclaration");
		DebugLocation(287, 4);
		try
		{
			// Hql.g:288:2: ( alias IN ELEMENTS OPEN path CLOSE -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) | ELEMENTS OPEN path CLOSE AS alias -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias ) )
			int alt38=2;
			try { DebugEnterDecision(38, false);
			int LA38_1 = input.LA(1);

			if ((LA38_1==IDENT))
			{
				alt38 = 1;
			}
			else if ((LA38_1==ELEMENTS))
			{
				alt38 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 38, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:288:4: alias IN ELEMENTS OPEN path CLOSE
				{
				DebugLocation(288, 4);
				PushFollow(Follow._alias_in_inCollectionElementsDeclaration1486);
				alias104=alias();
				PopFollow();

				stream_alias.Add(alias104.Tree);
				DebugLocation(288, 10);
				IN105=(IToken)Match(input,IN,Follow._IN_in_inCollectionElementsDeclaration1488);  
				stream_IN.Add(IN105);

				DebugLocation(288, 13);
				ELEMENTS106=(IToken)Match(input,ELEMENTS,Follow._ELEMENTS_in_inCollectionElementsDeclaration1490);  
				stream_ELEMENTS.Add(ELEMENTS106);

				DebugLocation(288, 22);
				OPEN107=(IToken)Match(input,OPEN,Follow._OPEN_in_inCollectionElementsDeclaration1492);  
				stream_OPEN.Add(OPEN107);

				DebugLocation(288, 27);
				PushFollow(Follow._path_in_inCollectionElementsDeclaration1494);
				path108=path();
				PopFollow();

				stream_path.Add(path108.Tree);
				DebugLocation(288, 32);
				CLOSE109=(IToken)Match(input,CLOSE,Follow._CLOSE_in_inCollectionElementsDeclaration1496);  
				stream_CLOSE.Add(CLOSE109);



				{
				// AST REWRITE
				// elements: path, alias
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 289:3: -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
				{
					DebugLocation(289, 6);
					// Hql.g:289:6: ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(289, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(JOIN, "join"), root_1);

					DebugLocation(289, 21);
					adaptor.AddChild(root_1, (IASTNode)adaptor.Create(INNER, "inner"));
					DebugLocation(289, 36);
					adaptor.AddChild(root_1, stream_path.NextTree());
					DebugLocation(289, 41);
					adaptor.AddChild(root_1, stream_alias.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:290:4: ELEMENTS OPEN path CLOSE AS alias
				{
				DebugLocation(290, 4);
				ELEMENTS110=(IToken)Match(input,ELEMENTS,Follow._ELEMENTS_in_inCollectionElementsDeclaration1518);  
				stream_ELEMENTS.Add(ELEMENTS110);

				DebugLocation(290, 13);
				OPEN111=(IToken)Match(input,OPEN,Follow._OPEN_in_inCollectionElementsDeclaration1520);  
				stream_OPEN.Add(OPEN111);

				DebugLocation(290, 18);
				PushFollow(Follow._path_in_inCollectionElementsDeclaration1522);
				path112=path();
				PopFollow();

				stream_path.Add(path112.Tree);
				DebugLocation(290, 23);
				CLOSE113=(IToken)Match(input,CLOSE,Follow._CLOSE_in_inCollectionElementsDeclaration1524);  
				stream_CLOSE.Add(CLOSE113);

				DebugLocation(290, 29);
				AS114=(IToken)Match(input,AS,Follow._AS_in_inCollectionElementsDeclaration1526);  
				stream_AS.Add(AS114);

				DebugLocation(290, 32);
				PushFollow(Follow._alias_in_inCollectionElementsDeclaration1528);
				alias115=alias();
				PopFollow();

				stream_alias.Add(alias115.Tree);


				{
				// AST REWRITE
				// elements: path, alias
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 291:3: -> ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
				{
					DebugLocation(291, 6);
					// Hql.g:291:6: ^( JOIN[\"join\"] INNER[\"inner\"] path alias )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(291, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(JOIN, "join"), root_1);

					DebugLocation(291, 21);
					adaptor.AddChild(root_1, (IASTNode)adaptor.Create(INNER, "inner"));
					DebugLocation(291, 36);
					adaptor.AddChild(root_1, stream_path.NextTree());
					DebugLocation(291, 41);
					adaptor.AddChild(root_1, stream_alias.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("inCollectionElementsDeclaration", 26);
			LeaveRule("inCollectionElementsDeclaration", 26);
			LeaveRule_inCollectionElementsDeclaration();
		}
		DebugLocation(292, 4);
		} finally { DebugExitRule(GrammarFileName, "inCollectionElementsDeclaration"); }
		return retval;

	}
	// $ANTLR end "inCollectionElementsDeclaration"

	partial void EnterRule_asAlias();
	partial void LeaveRule_asAlias();
	// $ANTLR start "asAlias"
	// Hql.g:295:1: asAlias : ( AS !)? alias ;
	[GrammarRule("asAlias")]
	private AstParserRuleReturnScope<IASTNode, IToken> asAlias()
	{
		EnterRule_asAlias();
		EnterRule("asAlias", 27);
		TraceIn("asAlias", 27);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken AS116 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> alias117 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode AS116_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "asAlias");
		DebugLocation(295, 1);
		try
		{
			// Hql.g:296:2: ( ( AS !)? alias )
			DebugEnterAlt(1);
			// Hql.g:296:4: ( AS !)? alias
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(296, 4);
			// Hql.g:296:4: ( AS !)?
			int alt39=2;
			try { DebugEnterSubRule(39);
			try { DebugEnterDecision(39, false);
			int LA39_1 = input.LA(1);

			if ((LA39_1==AS))
			{
				alt39 = 1;
			}
			} finally { DebugExitDecision(39); }
			switch (alt39)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:296:5: AS !
				{
				DebugLocation(296, 7);
				AS116=(IToken)Match(input,AS,Follow._AS_in_asAlias1560); 

				}
				break;

			}
			} finally { DebugExitSubRule(39); }

			DebugLocation(296, 11);
			PushFollow(Follow._alias_in_asAlias1565);
			alias117=alias();
			PopFollow();

			adaptor.AddChild(root_0, alias117.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("asAlias", 27);
			LeaveRule("asAlias", 27);
			LeaveRule_asAlias();
		}
		DebugLocation(297, 1);
		} finally { DebugExitRule(GrammarFileName, "asAlias"); }
		return retval;

	}
	// $ANTLR end "asAlias"

	partial void EnterRule_alias();
	partial void LeaveRule_alias();
	// $ANTLR start "alias"
	// Hql.g:298:1: alias : i= identifier -> ^( ALIAS[$i.start] ) ;
	[GrammarRule("alias")]
	private AstParserRuleReturnScope<IASTNode, IToken> alias()
	{
		EnterRule_alias();
		EnterRule("alias", 28);
		TraceIn("alias", 28);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> i = default(AstParserRuleReturnScope<IASTNode, IToken>);

		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "alias");
		DebugLocation(298, 1);
		try
		{
			// Hql.g:299:2: (i= identifier -> ^( ALIAS[$i.start] ) )
			DebugEnterAlt(1);
			// Hql.g:299:4: i= identifier
			{
			DebugLocation(299, 5);
			PushFollow(Follow._identifier_in_alias1577);
			i=identifier();
			PopFollow();

			stream_identifier.Add(i.Tree);


			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 300:2: -> ^( ALIAS[$i.start] )
			{
				DebugLocation(300, 5);
				// Hql.g:300:5: ^( ALIAS[$i.start] )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(300, 7);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(ALIAS, (i!=null?((IToken)i.Start):default(IToken))), root_1);

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("alias", 28);
			LeaveRule("alias", 28);
			LeaveRule_alias();
		}
		DebugLocation(301, 1);
		} finally { DebugExitRule(GrammarFileName, "alias"); }
		return retval;

	}
	// $ANTLR end "alias"

	partial void EnterRule_propertyFetch();
	partial void LeaveRule_propertyFetch();
	// $ANTLR start "propertyFetch"
	// Hql.g:303:1: propertyFetch : FETCH ALL ! PROPERTIES !;
	[GrammarRule("propertyFetch")]
	private AstParserRuleReturnScope<IASTNode, IToken> propertyFetch()
	{
		EnterRule_propertyFetch();
		EnterRule("propertyFetch", 29);
		TraceIn("propertyFetch", 29);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken FETCH118 = default(IToken);
		IToken ALL119 = default(IToken);
		IToken PROPERTIES120 = default(IToken);

		IASTNode FETCH118_tree = default(IASTNode);
		IASTNode ALL119_tree = default(IASTNode);
		IASTNode PROPERTIES120_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "propertyFetch");
		DebugLocation(303, 1);
		try
		{
			// Hql.g:304:2: ( FETCH ALL ! PROPERTIES !)
			DebugEnterAlt(1);
			// Hql.g:304:4: FETCH ALL ! PROPERTIES !
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(304, 4);
			FETCH118=(IToken)Match(input,FETCH,Follow._FETCH_in_propertyFetch1596); 
			FETCH118_tree = (IASTNode)adaptor.Create(FETCH118);
			adaptor.AddChild(root_0, FETCH118_tree);
			DebugLocation(304, 13);
			ALL119=(IToken)Match(input,ALL,Follow._ALL_in_propertyFetch1598); 
			DebugLocation(304, 25);
			PROPERTIES120=(IToken)Match(input,PROPERTIES,Follow._PROPERTIES_in_propertyFetch1601); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyFetch", 29);
			LeaveRule("propertyFetch", 29);
			LeaveRule_propertyFetch();
		}
		DebugLocation(305, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyFetch"); }
		return retval;

	}
	// $ANTLR end "propertyFetch"

	partial void EnterRule_groupByClause();
	partial void LeaveRule_groupByClause();
	// $ANTLR start "groupByClause"
	// Hql.g:307:1: groupByClause : GROUP ^ 'by' ! expression ( COMMA ! expression )* ;
	[GrammarRule("groupByClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> groupByClause()
	{
		EnterRule_groupByClause();
		EnterRule("groupByClause", 30);
		TraceIn("groupByClause", 30);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken GROUP121 = default(IToken);
		IToken string_literal122 = default(IToken);
		IToken COMMA124 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> expression123 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression125 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode GROUP121_tree = default(IASTNode);
		IASTNode string_literal122_tree = default(IASTNode);
		IASTNode COMMA124_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "groupByClause");
		DebugLocation(307, 1);
		try
		{
			// Hql.g:308:2: ( GROUP ^ 'by' ! expression ( COMMA ! expression )* )
			DebugEnterAlt(1);
			// Hql.g:308:4: GROUP ^ 'by' ! expression ( COMMA ! expression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(308, 9);
			GROUP121=(IToken)Match(input,GROUP,Follow._GROUP_in_groupByClause1613); 
			GROUP121_tree = (IASTNode)adaptor.Create(GROUP121);
			root_0 = (IASTNode)adaptor.BecomeRoot(GROUP121_tree, root_0);
			DebugLocation(309, 7);
			string_literal122=(IToken)Match(input,LITERAL_by,Follow._LITERAL_by_in_groupByClause1619); 
			DebugLocation(309, 9);
			PushFollow(Follow._expression_in_groupByClause1622);
			expression123=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression123.Tree);
			DebugLocation(309, 20);
			// Hql.g:309:20: ( COMMA ! expression )*
			try { DebugEnterSubRule(40);
			while (true)
			{
				int alt40=2;
				try { DebugEnterDecision(40, false);
				int LA40_1 = input.LA(1);

				if ((LA40_1==COMMA))
				{
					alt40 = 1;
				}


				} finally { DebugExitDecision(40); }
				switch ( alt40 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:309:22: COMMA ! expression
					{
					DebugLocation(309, 27);
					COMMA124=(IToken)Match(input,COMMA,Follow._COMMA_in_groupByClause1626); 
					DebugLocation(309, 29);
					PushFollow(Follow._expression_in_groupByClause1629);
					expression125=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression125.Tree);

					}
					break;

				default:
					goto loop40;
				}
			}

			loop40:
				;

			} finally { DebugExitSubRule(40); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("groupByClause", 30);
			LeaveRule("groupByClause", 30);
			LeaveRule_groupByClause();
		}
		DebugLocation(310, 1);
		} finally { DebugExitRule(GrammarFileName, "groupByClause"); }
		return retval;

	}
	// $ANTLR end "groupByClause"

	partial void EnterRule_orderByClause();
	partial void LeaveRule_orderByClause();
	// $ANTLR start "orderByClause"
	// Hql.g:312:1: orderByClause : ORDER ^ 'by' ! orderElement ( COMMA ! orderElement )* ;
	[GrammarRule("orderByClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> orderByClause()
	{
		EnterRule_orderByClause();
		EnterRule("orderByClause", 31);
		TraceIn("orderByClause", 31);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken ORDER126 = default(IToken);
		IToken string_literal127 = default(IToken);
		IToken COMMA129 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> orderElement128 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> orderElement130 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode ORDER126_tree = default(IASTNode);
		IASTNode string_literal127_tree = default(IASTNode);
		IASTNode COMMA129_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "orderByClause");
		DebugLocation(312, 1);
		try
		{
			// Hql.g:313:2: ( ORDER ^ 'by' ! orderElement ( COMMA ! orderElement )* )
			DebugEnterAlt(1);
			// Hql.g:313:4: ORDER ^ 'by' ! orderElement ( COMMA ! orderElement )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(313, 9);
			ORDER126=(IToken)Match(input,ORDER,Follow._ORDER_in_orderByClause1643); 
			ORDER126_tree = (IASTNode)adaptor.Create(ORDER126);
			root_0 = (IASTNode)adaptor.BecomeRoot(ORDER126_tree, root_0);
			DebugLocation(313, 15);
			string_literal127=(IToken)Match(input,LITERAL_by,Follow._LITERAL_by_in_orderByClause1646); 
			DebugLocation(313, 17);
			PushFollow(Follow._orderElement_in_orderByClause1649);
			orderElement128=orderElement();
			PopFollow();

			adaptor.AddChild(root_0, orderElement128.Tree);
			DebugLocation(313, 30);
			// Hql.g:313:30: ( COMMA ! orderElement )*
			try { DebugEnterSubRule(41);
			while (true)
			{
				int alt41=2;
				try { DebugEnterDecision(41, false);
				int LA41_1 = input.LA(1);

				if ((LA41_1==COMMA))
				{
					alt41 = 1;
				}


				} finally { DebugExitDecision(41); }
				switch ( alt41 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:313:32: COMMA ! orderElement
					{
					DebugLocation(313, 37);
					COMMA129=(IToken)Match(input,COMMA,Follow._COMMA_in_orderByClause1653); 
					DebugLocation(313, 39);
					PushFollow(Follow._orderElement_in_orderByClause1656);
					orderElement130=orderElement();
					PopFollow();

					adaptor.AddChild(root_0, orderElement130.Tree);

					}
					break;

				default:
					goto loop41;
				}
			}

			loop41:
				;

			} finally { DebugExitSubRule(41); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("orderByClause", 31);
			LeaveRule("orderByClause", 31);
			LeaveRule_orderByClause();
		}
		DebugLocation(314, 1);
		} finally { DebugExitRule(GrammarFileName, "orderByClause"); }
		return retval;

	}
	// $ANTLR end "orderByClause"

	partial void EnterRule_skipClause();
	partial void LeaveRule_skipClause();
	// $ANTLR start "skipClause"
	// Hql.g:316:1: skipClause : SKIP ^ ( NUM_INT | parameter ) ;
	[GrammarRule("skipClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> skipClause()
	{
		EnterRule_skipClause();
		EnterRule("skipClause", 32);
		TraceIn("skipClause", 32);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken SKIP131 = default(IToken);
		IToken NUM_INT132 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> parameter133 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode SKIP131_tree = default(IASTNode);
		IASTNode NUM_INT132_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "skipClause");
		DebugLocation(316, 1);
		try
		{
			// Hql.g:317:2: ( SKIP ^ ( NUM_INT | parameter ) )
			DebugEnterAlt(1);
			// Hql.g:317:4: SKIP ^ ( NUM_INT | parameter )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(317, 8);
			SKIP131=(IToken)Match(input,SKIP,Follow._SKIP_in_skipClause1670); 
			SKIP131_tree = (IASTNode)adaptor.Create(SKIP131);
			root_0 = (IASTNode)adaptor.BecomeRoot(SKIP131_tree, root_0);
			DebugLocation(317, 10);
			// Hql.g:317:10: ( NUM_INT | parameter )
			int alt42=2;
			try { DebugEnterSubRule(42);
			try { DebugEnterDecision(42, false);
			int LA42_1 = input.LA(1);

			if ((LA42_1==NUM_INT))
			{
				alt42 = 1;
			}
			else if ((LA42_1==COLON||LA42_1==PARAM))
			{
				alt42 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 42, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(42); }
			switch (alt42)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:317:11: NUM_INT
				{
				DebugLocation(317, 11);
				NUM_INT132=(IToken)Match(input,NUM_INT,Follow._NUM_INT_in_skipClause1674); 
				NUM_INT132_tree = (IASTNode)adaptor.Create(NUM_INT132);
				adaptor.AddChild(root_0, NUM_INT132_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:317:21: parameter
				{
				DebugLocation(317, 21);
				PushFollow(Follow._parameter_in_skipClause1678);
				parameter133=parameter();
				PopFollow();

				adaptor.AddChild(root_0, parameter133.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(42); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("skipClause", 32);
			LeaveRule("skipClause", 32);
			LeaveRule_skipClause();
		}
		DebugLocation(318, 1);
		} finally { DebugExitRule(GrammarFileName, "skipClause"); }
		return retval;

	}
	// $ANTLR end "skipClause"

	partial void EnterRule_takeClause();
	partial void LeaveRule_takeClause();
	// $ANTLR start "takeClause"
	// Hql.g:320:1: takeClause : TAKE ^ ( NUM_INT | parameter ) ;
	[GrammarRule("takeClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> takeClause()
	{
		EnterRule_takeClause();
		EnterRule("takeClause", 33);
		TraceIn("takeClause", 33);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken TAKE134 = default(IToken);
		IToken NUM_INT135 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> parameter136 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode TAKE134_tree = default(IASTNode);
		IASTNode NUM_INT135_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "takeClause");
		DebugLocation(320, 1);
		try
		{
			// Hql.g:321:2: ( TAKE ^ ( NUM_INT | parameter ) )
			DebugEnterAlt(1);
			// Hql.g:321:4: TAKE ^ ( NUM_INT | parameter )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(321, 8);
			TAKE134=(IToken)Match(input,TAKE,Follow._TAKE_in_takeClause1690); 
			TAKE134_tree = (IASTNode)adaptor.Create(TAKE134);
			root_0 = (IASTNode)adaptor.BecomeRoot(TAKE134_tree, root_0);
			DebugLocation(321, 10);
			// Hql.g:321:10: ( NUM_INT | parameter )
			int alt43=2;
			try { DebugEnterSubRule(43);
			try { DebugEnterDecision(43, false);
			int LA43_1 = input.LA(1);

			if ((LA43_1==NUM_INT))
			{
				alt43 = 1;
			}
			else if ((LA43_1==COLON||LA43_1==PARAM))
			{
				alt43 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 43, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(43); }
			switch (alt43)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:321:11: NUM_INT
				{
				DebugLocation(321, 11);
				NUM_INT135=(IToken)Match(input,NUM_INT,Follow._NUM_INT_in_takeClause1694); 
				NUM_INT135_tree = (IASTNode)adaptor.Create(NUM_INT135);
				adaptor.AddChild(root_0, NUM_INT135_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:321:21: parameter
				{
				DebugLocation(321, 21);
				PushFollow(Follow._parameter_in_takeClause1698);
				parameter136=parameter();
				PopFollow();

				adaptor.AddChild(root_0, parameter136.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(43); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("takeClause", 33);
			LeaveRule("takeClause", 33);
			LeaveRule_takeClause();
		}
		DebugLocation(322, 1);
		} finally { DebugExitRule(GrammarFileName, "takeClause"); }
		return retval;

	}
	// $ANTLR end "takeClause"

	partial void EnterRule_parameter();
	partial void LeaveRule_parameter();
	// $ANTLR start "parameter"
	// Hql.g:324:1: parameter : ( COLON ^ identifier | PARAM ^ ( NUM_INT )? );
	[GrammarRule("parameter")]
	private AstParserRuleReturnScope<IASTNode, IToken> parameter()
	{
		EnterRule_parameter();
		EnterRule("parameter", 34);
		TraceIn("parameter", 34);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken COLON137 = default(IToken);
		IToken PARAM139 = default(IToken);
		IToken NUM_INT140 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> identifier138 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode COLON137_tree = default(IASTNode);
		IASTNode PARAM139_tree = default(IASTNode);
		IASTNode NUM_INT140_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "parameter");
		DebugLocation(324, 1);
		try
		{
			// Hql.g:325:2: ( COLON ^ identifier | PARAM ^ ( NUM_INT )? )
			int alt45=2;
			try { DebugEnterDecision(45, false);
			int LA45_1 = input.LA(1);

			if ((LA45_1==COLON))
			{
				alt45 = 1;
			}
			else if ((LA45_1==PARAM))
			{
				alt45 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 45, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(45); }
			switch (alt45)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:325:4: COLON ^ identifier
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(325, 9);
				COLON137=(IToken)Match(input,COLON,Follow._COLON_in_parameter1710); 
				COLON137_tree = (IASTNode)adaptor.Create(COLON137);
				root_0 = (IASTNode)adaptor.BecomeRoot(COLON137_tree, root_0);
				DebugLocation(325, 11);
				PushFollow(Follow._identifier_in_parameter1713);
				identifier138=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier138.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:326:4: PARAM ^ ( NUM_INT )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(326, 9);
				PARAM139=(IToken)Match(input,PARAM,Follow._PARAM_in_parameter1718); 
				PARAM139_tree = (IASTNode)adaptor.Create(PARAM139);
				root_0 = (IASTNode)adaptor.BecomeRoot(PARAM139_tree, root_0);
				DebugLocation(326, 11);
				// Hql.g:326:11: ( NUM_INT )?
				int alt44=2;
				try { DebugEnterSubRule(44);
				try { DebugEnterDecision(44, false);
				int LA44_1 = input.LA(1);

				if ((LA44_1==NUM_INT))
				{
					alt44 = 1;
				}
				} finally { DebugExitDecision(44); }
				switch (alt44)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:326:12: NUM_INT
					{
					DebugLocation(326, 12);
					NUM_INT140=(IToken)Match(input,NUM_INT,Follow._NUM_INT_in_parameter1722); 
					NUM_INT140_tree = (IASTNode)adaptor.Create(NUM_INT140);
					adaptor.AddChild(root_0, NUM_INT140_tree);

					}
					break;

				}
				} finally { DebugExitSubRule(44); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameter", 34);
			LeaveRule("parameter", 34);
			LeaveRule_parameter();
		}
		DebugLocation(327, 1);
		} finally { DebugExitRule(GrammarFileName, "parameter"); }
		return retval;

	}
	// $ANTLR end "parameter"

	partial void EnterRule_orderElement();
	partial void LeaveRule_orderElement();
	// $ANTLR start "orderElement"
	// Hql.g:329:1: orderElement : expression ( ascendingOrDescending )? ;
	[GrammarRule("orderElement")]
	private AstParserRuleReturnScope<IASTNode, IToken> orderElement()
	{
		EnterRule_orderElement();
		EnterRule("orderElement", 35);
		TraceIn("orderElement", 35);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> expression141 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> ascendingOrDescending142 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		try { DebugEnterRule(GrammarFileName, "orderElement");
		DebugLocation(329, 1);
		try
		{
			// Hql.g:330:2: ( expression ( ascendingOrDescending )? )
			DebugEnterAlt(1);
			// Hql.g:330:4: expression ( ascendingOrDescending )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(330, 4);
			PushFollow(Follow._expression_in_orderElement1735);
			expression141=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression141.Tree);
			DebugLocation(330, 15);
			// Hql.g:330:15: ( ascendingOrDescending )?
			int alt46=2;
			try { DebugEnterSubRule(46);
			try { DebugEnterDecision(46, false);
			int LA46_1 = input.LA(1);

			if ((LA46_1==ASCENDING||LA46_1==DESCENDING||(LA46_1>=133 && LA46_1<=134)))
			{
				alt46 = 1;
			}
			} finally { DebugExitDecision(46); }
			switch (alt46)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:330:17: ascendingOrDescending
				{
				DebugLocation(330, 17);
				PushFollow(Follow._ascendingOrDescending_in_orderElement1739);
				ascendingOrDescending142=ascendingOrDescending();
				PopFollow();

				adaptor.AddChild(root_0, ascendingOrDescending142.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(46); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("orderElement", 35);
			LeaveRule("orderElement", 35);
			LeaveRule_orderElement();
		}
		DebugLocation(331, 1);
		} finally { DebugExitRule(GrammarFileName, "orderElement"); }
		return retval;

	}
	// $ANTLR end "orderElement"

	partial void EnterRule_ascendingOrDescending();
	partial void LeaveRule_ascendingOrDescending();
	// $ANTLR start "ascendingOrDescending"
	// Hql.g:333:1: ascendingOrDescending : ( (a= 'asc' |a= 'ascending' ) -> ^( ASCENDING[$a.Text] ) | (d= 'desc' |d= 'descending' ) -> ^( DESCENDING[$d.Text] ) );
	[GrammarRule("ascendingOrDescending")]
	private AstParserRuleReturnScope<IASTNode, IToken> ascendingOrDescending()
	{
		EnterRule_ascendingOrDescending();
		EnterRule("ascendingOrDescending", 36);
		TraceIn("ascendingOrDescending", 36);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken a = default(IToken);
		IToken d = default(IToken);

		IASTNode a_tree = default(IASTNode);
		IASTNode d_tree = default(IASTNode);
		RewriteRuleITokenStream stream_ASCENDING=new RewriteRuleITokenStream(adaptor,"token ASCENDING");
		RewriteRuleITokenStream stream_133=new RewriteRuleITokenStream(adaptor,"token 133");
		RewriteRuleITokenStream stream_DESCENDING=new RewriteRuleITokenStream(adaptor,"token DESCENDING");
		RewriteRuleITokenStream stream_134=new RewriteRuleITokenStream(adaptor,"token 134");
		try { DebugEnterRule(GrammarFileName, "ascendingOrDescending");
		DebugLocation(333, 1);
		try
		{
			// Hql.g:334:2: ( (a= 'asc' |a= 'ascending' ) -> ^( ASCENDING[$a.Text] ) | (d= 'desc' |d= 'descending' ) -> ^( DESCENDING[$d.Text] ) )
			int alt49=2;
			try { DebugEnterDecision(49, false);
			int LA49_1 = input.LA(1);

			if ((LA49_1==ASCENDING||LA49_1==133))
			{
				alt49 = 1;
			}
			else if ((LA49_1==DESCENDING||LA49_1==134))
			{
				alt49 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 49, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:334:4: (a= 'asc' |a= 'ascending' )
				{
				DebugLocation(334, 4);
				// Hql.g:334:4: (a= 'asc' |a= 'ascending' )
				int alt47=2;
				try { DebugEnterSubRule(47);
				try { DebugEnterDecision(47, false);
				int LA47_1 = input.LA(1);

				if ((LA47_1==ASCENDING))
				{
					alt47 = 1;
				}
				else if ((LA47_1==133))
				{
					alt47 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 47, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(47); }
				switch (alt47)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:334:6: a= 'asc'
					{
					DebugLocation(334, 7);
					a=(IToken)Match(input,ASCENDING,Follow._ASCENDING_in_ascendingOrDescending1757);  
					stream_ASCENDING.Add(a);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:334:16: a= 'ascending'
					{
					DebugLocation(334, 17);
					a=(IToken)Match(input,133,Follow._133_in_ascendingOrDescending1763);  
					stream_133.Add(a);


					}
					break;

				}
				} finally { DebugExitSubRule(47); }



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 335:3: -> ^( ASCENDING[$a.Text] )
				{
					DebugLocation(335, 6);
					// Hql.g:335:6: ^( ASCENDING[$a.Text] )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(335, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(ASCENDING, a.Text), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:336:4: (d= 'desc' |d= 'descending' )
				{
				DebugLocation(336, 4);
				// Hql.g:336:4: (d= 'desc' |d= 'descending' )
				int alt48=2;
				try { DebugEnterSubRule(48);
				try { DebugEnterDecision(48, false);
				int LA48_1 = input.LA(1);

				if ((LA48_1==DESCENDING))
				{
					alt48 = 1;
				}
				else if ((LA48_1==134))
				{
					alt48 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 48, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(48); }
				switch (alt48)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:336:6: d= 'desc'
					{
					DebugLocation(336, 7);
					d=(IToken)Match(input,DESCENDING,Follow._DESCENDING_in_ascendingOrDescending1783);  
					stream_DESCENDING.Add(d);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:336:17: d= 'descending'
					{
					DebugLocation(336, 18);
					d=(IToken)Match(input,134,Follow._134_in_ascendingOrDescending1789);  
					stream_134.Add(d);


					}
					break;

				}
				} finally { DebugExitSubRule(48); }



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 337:3: -> ^( DESCENDING[$d.Text] )
				{
					DebugLocation(337, 6);
					// Hql.g:337:6: ^( DESCENDING[$d.Text] )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(337, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(DESCENDING, d.Text), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ascendingOrDescending", 36);
			LeaveRule("ascendingOrDescending", 36);
			LeaveRule_ascendingOrDescending();
		}
		DebugLocation(338, 1);
		} finally { DebugExitRule(GrammarFileName, "ascendingOrDescending"); }
		return retval;

	}
	// $ANTLR end "ascendingOrDescending"

	partial void EnterRule_havingClause();
	partial void LeaveRule_havingClause();
	// $ANTLR start "havingClause"
	// Hql.g:340:1: havingClause : HAVING ^ logicalExpression ;
	[GrammarRule("havingClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> havingClause()
	{
		EnterRule_havingClause();
		EnterRule("havingClause", 37);
		TraceIn("havingClause", 37);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken HAVING143 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> logicalExpression144 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode HAVING143_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "havingClause");
		DebugLocation(340, 1);
		try
		{
			// Hql.g:341:2: ( HAVING ^ logicalExpression )
			DebugEnterAlt(1);
			// Hql.g:341:4: HAVING ^ logicalExpression
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(341, 10);
			HAVING143=(IToken)Match(input,HAVING,Follow._HAVING_in_havingClause1810); 
			HAVING143_tree = (IASTNode)adaptor.Create(HAVING143);
			root_0 = (IASTNode)adaptor.BecomeRoot(HAVING143_tree, root_0);
			DebugLocation(341, 12);
			PushFollow(Follow._logicalExpression_in_havingClause1813);
			logicalExpression144=logicalExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalExpression144.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("havingClause", 37);
			LeaveRule("havingClause", 37);
			LeaveRule_havingClause();
		}
		DebugLocation(342, 1);
		} finally { DebugExitRule(GrammarFileName, "havingClause"); }
		return retval;

	}
	// $ANTLR end "havingClause"

	partial void EnterRule_whereClause();
	partial void LeaveRule_whereClause();
	// $ANTLR start "whereClause"
	// Hql.g:344:1: whereClause : WHERE ^ logicalExpression ;
	[GrammarRule("whereClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> whereClause()
	{
		EnterRule_whereClause();
		EnterRule("whereClause", 38);
		TraceIn("whereClause", 38);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken WHERE145 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> logicalExpression146 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode WHERE145_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "whereClause");
		DebugLocation(344, 1);
		try
		{
			// Hql.g:345:2: ( WHERE ^ logicalExpression )
			DebugEnterAlt(1);
			// Hql.g:345:4: WHERE ^ logicalExpression
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(345, 9);
			WHERE145=(IToken)Match(input,WHERE,Follow._WHERE_in_whereClause1824); 
			WHERE145_tree = (IASTNode)adaptor.Create(WHERE145);
			root_0 = (IASTNode)adaptor.BecomeRoot(WHERE145_tree, root_0);
			DebugLocation(345, 11);
			PushFollow(Follow._logicalExpression_in_whereClause1827);
			logicalExpression146=logicalExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalExpression146.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whereClause", 38);
			LeaveRule("whereClause", 38);
			LeaveRule_whereClause();
		}
		DebugLocation(346, 1);
		} finally { DebugExitRule(GrammarFileName, "whereClause"); }
		return retval;

	}
	// $ANTLR end "whereClause"

	partial void EnterRule_selectedPropertiesList();
	partial void LeaveRule_selectedPropertiesList();
	// $ANTLR start "selectedPropertiesList"
	// Hql.g:348:1: selectedPropertiesList : aliasedExpression ( COMMA ! aliasedExpression )* ;
	[GrammarRule("selectedPropertiesList")]
	private AstParserRuleReturnScope<IASTNode, IToken> selectedPropertiesList()
	{
		EnterRule_selectedPropertiesList();
		EnterRule("selectedPropertiesList", 39);
		TraceIn("selectedPropertiesList", 39);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken COMMA148 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> aliasedExpression147 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> aliasedExpression149 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode COMMA148_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "selectedPropertiesList");
		DebugLocation(348, 1);
		try
		{
			// Hql.g:349:2: ( aliasedExpression ( COMMA ! aliasedExpression )* )
			DebugEnterAlt(1);
			// Hql.g:349:4: aliasedExpression ( COMMA ! aliasedExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(349, 4);
			PushFollow(Follow._aliasedExpression_in_selectedPropertiesList1838);
			aliasedExpression147=aliasedExpression();
			PopFollow();

			adaptor.AddChild(root_0, aliasedExpression147.Tree);
			DebugLocation(349, 22);
			// Hql.g:349:22: ( COMMA ! aliasedExpression )*
			try { DebugEnterSubRule(50);
			while (true)
			{
				int alt50=2;
				try { DebugEnterDecision(50, false);
				int LA50_1 = input.LA(1);

				if ((LA50_1==COMMA))
				{
					alt50 = 1;
				}


				} finally { DebugExitDecision(50); }
				switch ( alt50 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:349:24: COMMA ! aliasedExpression
					{
					DebugLocation(349, 29);
					COMMA148=(IToken)Match(input,COMMA,Follow._COMMA_in_selectedPropertiesList1842); 
					DebugLocation(349, 31);
					PushFollow(Follow._aliasedExpression_in_selectedPropertiesList1845);
					aliasedExpression149=aliasedExpression();
					PopFollow();

					adaptor.AddChild(root_0, aliasedExpression149.Tree);

					}
					break;

				default:
					goto loop50;
				}
			}

			loop50:
				;

			} finally { DebugExitSubRule(50); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("selectedPropertiesList", 39);
			LeaveRule("selectedPropertiesList", 39);
			LeaveRule_selectedPropertiesList();
		}
		DebugLocation(350, 1);
		} finally { DebugExitRule(GrammarFileName, "selectedPropertiesList"); }
		return retval;

	}
	// $ANTLR end "selectedPropertiesList"

	partial void EnterRule_aliasedExpression();
	partial void LeaveRule_aliasedExpression();
	// $ANTLR start "aliasedExpression"
	// Hql.g:352:1: aliasedExpression : expression ( AS ^ identifier )? ;
	[GrammarRule("aliasedExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> aliasedExpression()
	{
		EnterRule_aliasedExpression();
		EnterRule("aliasedExpression", 40);
		TraceIn("aliasedExpression", 40);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken AS151 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> expression150 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> identifier152 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode AS151_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "aliasedExpression");
		DebugLocation(352, 1);
		try
		{
			// Hql.g:353:2: ( expression ( AS ^ identifier )? )
			DebugEnterAlt(1);
			// Hql.g:353:4: expression ( AS ^ identifier )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(353, 4);
			PushFollow(Follow._expression_in_aliasedExpression1860);
			expression150=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression150.Tree);
			DebugLocation(353, 15);
			// Hql.g:353:15: ( AS ^ identifier )?
			int alt51=2;
			try { DebugEnterSubRule(51);
			try { DebugEnterDecision(51, false);
			int LA51_1 = input.LA(1);

			if ((LA51_1==AS))
			{
				alt51 = 1;
			}
			} finally { DebugExitDecision(51); }
			switch (alt51)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:353:17: AS ^ identifier
				{
				DebugLocation(353, 19);
				AS151=(IToken)Match(input,AS,Follow._AS_in_aliasedExpression1864); 
				AS151_tree = (IASTNode)adaptor.Create(AS151);
				root_0 = (IASTNode)adaptor.BecomeRoot(AS151_tree, root_0);
				DebugLocation(353, 21);
				PushFollow(Follow._identifier_in_aliasedExpression1867);
				identifier152=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier152.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(51); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("aliasedExpression", 40);
			LeaveRule("aliasedExpression", 40);
			LeaveRule_aliasedExpression();
		}
		DebugLocation(354, 1);
		} finally { DebugExitRule(GrammarFileName, "aliasedExpression"); }
		return retval;

	}
	// $ANTLR end "aliasedExpression"

	partial void EnterRule_logicalExpression();
	partial void LeaveRule_logicalExpression();
	// $ANTLR start "logicalExpression"
	// Hql.g:381:1: logicalExpression : expression ;
	[GrammarRule("logicalExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> logicalExpression()
	{
		EnterRule_logicalExpression();
		EnterRule("logicalExpression", 41);
		TraceIn("logicalExpression", 41);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> expression153 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		try { DebugEnterRule(GrammarFileName, "logicalExpression");
		DebugLocation(381, 1);
		try
		{
			// Hql.g:382:2: ( expression )
			DebugEnterAlt(1);
			// Hql.g:382:4: expression
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(382, 4);
			PushFollow(Follow._expression_in_logicalExpression1906);
			expression153=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression153.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalExpression", 41);
			LeaveRule("logicalExpression", 41);
			LeaveRule_logicalExpression();
		}
		DebugLocation(383, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalExpression"); }
		return retval;

	}
	// $ANTLR end "logicalExpression"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// Hql.g:386:1: expression : logicalOrExpression ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<IASTNode, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 42);
		TraceIn("expression", 42);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> logicalOrExpression154 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(386, 1);
		try
		{
			// Hql.g:387:2: ( logicalOrExpression )
			DebugEnterAlt(1);
			// Hql.g:387:4: logicalOrExpression
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(387, 4);
			PushFollow(Follow._logicalOrExpression_in_expression1918);
			logicalOrExpression154=logicalOrExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalOrExpression154.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 42);
			LeaveRule("expression", 42);
			LeaveRule_expression();
		}
		DebugLocation(388, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_logicalOrExpression();
	partial void LeaveRule_logicalOrExpression();
	// $ANTLR start "logicalOrExpression"
	// Hql.g:391:1: logicalOrExpression : logicalAndExpression ( OR ^ logicalAndExpression )* ;
	[GrammarRule("logicalOrExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> logicalOrExpression()
	{
		EnterRule_logicalOrExpression();
		EnterRule("logicalOrExpression", 43);
		TraceIn("logicalOrExpression", 43);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken OR156 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> logicalAndExpression155 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> logicalAndExpression157 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode OR156_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "logicalOrExpression");
		DebugLocation(391, 1);
		try
		{
			// Hql.g:392:2: ( logicalAndExpression ( OR ^ logicalAndExpression )* )
			DebugEnterAlt(1);
			// Hql.g:392:4: logicalAndExpression ( OR ^ logicalAndExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(392, 4);
			PushFollow(Follow._logicalAndExpression_in_logicalOrExpression1930);
			logicalAndExpression155=logicalAndExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalAndExpression155.Tree);
			DebugLocation(392, 25);
			// Hql.g:392:25: ( OR ^ logicalAndExpression )*
			try { DebugEnterSubRule(52);
			while (true)
			{
				int alt52=2;
				try { DebugEnterDecision(52, false);
				int LA52_1 = input.LA(1);

				if ((LA52_1==OR))
				{
					alt52 = 1;
				}


				} finally { DebugExitDecision(52); }
				switch ( alt52 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:392:27: OR ^ logicalAndExpression
					{
					DebugLocation(392, 29);
					OR156=(IToken)Match(input,OR,Follow._OR_in_logicalOrExpression1934); 
					OR156_tree = (IASTNode)adaptor.Create(OR156);
					root_0 = (IASTNode)adaptor.BecomeRoot(OR156_tree, root_0);
					DebugLocation(392, 31);
					PushFollow(Follow._logicalAndExpression_in_logicalOrExpression1937);
					logicalAndExpression157=logicalAndExpression();
					PopFollow();

					adaptor.AddChild(root_0, logicalAndExpression157.Tree);

					}
					break;

				default:
					goto loop52;
				}
			}

			loop52:
				;

			} finally { DebugExitSubRule(52); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalOrExpression", 43);
			LeaveRule("logicalOrExpression", 43);
			LeaveRule_logicalOrExpression();
		}
		DebugLocation(393, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalOrExpression"); }
		return retval;

	}
	// $ANTLR end "logicalOrExpression"

	partial void EnterRule_logicalAndExpression();
	partial void LeaveRule_logicalAndExpression();
	// $ANTLR start "logicalAndExpression"
	// Hql.g:396:1: logicalAndExpression : negatedExpression ( AND ^ negatedExpression )* ;
	[GrammarRule("logicalAndExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> logicalAndExpression()
	{
		EnterRule_logicalAndExpression();
		EnterRule("logicalAndExpression", 44);
		TraceIn("logicalAndExpression", 44);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken AND159 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> negatedExpression158 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> negatedExpression160 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode AND159_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "logicalAndExpression");
		DebugLocation(396, 1);
		try
		{
			// Hql.g:397:2: ( negatedExpression ( AND ^ negatedExpression )* )
			DebugEnterAlt(1);
			// Hql.g:397:4: negatedExpression ( AND ^ negatedExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(397, 4);
			PushFollow(Follow._negatedExpression_in_logicalAndExpression1952);
			negatedExpression158=negatedExpression();
			PopFollow();

			adaptor.AddChild(root_0, negatedExpression158.Tree);
			DebugLocation(397, 22);
			// Hql.g:397:22: ( AND ^ negatedExpression )*
			try { DebugEnterSubRule(53);
			while (true)
			{
				int alt53=2;
				try { DebugEnterDecision(53, false);
				int LA53_1 = input.LA(1);

				if ((LA53_1==AND))
				{
					alt53 = 1;
				}


				} finally { DebugExitDecision(53); }
				switch ( alt53 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:397:24: AND ^ negatedExpression
					{
					DebugLocation(397, 27);
					AND159=(IToken)Match(input,AND,Follow._AND_in_logicalAndExpression1956); 
					AND159_tree = (IASTNode)adaptor.Create(AND159);
					root_0 = (IASTNode)adaptor.BecomeRoot(AND159_tree, root_0);
					DebugLocation(397, 29);
					PushFollow(Follow._negatedExpression_in_logicalAndExpression1959);
					negatedExpression160=negatedExpression();
					PopFollow();

					adaptor.AddChild(root_0, negatedExpression160.Tree);

					}
					break;

				default:
					goto loop53;
				}
			}

			loop53:
				;

			} finally { DebugExitSubRule(53); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalAndExpression", 44);
			LeaveRule("logicalAndExpression", 44);
			LeaveRule_logicalAndExpression();
		}
		DebugLocation(398, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalAndExpression"); }
		return retval;

	}
	// $ANTLR end "logicalAndExpression"

	partial void EnterRule_negatedExpression();
	partial void LeaveRule_negatedExpression();
	// $ANTLR start "negatedExpression"
	// Hql.g:402:1: negatedExpression : ( NOT x= negatedExpression -> ^() | equalityExpression );
	[GrammarRule("negatedExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> negatedExpression()
	{
		EnterRule_negatedExpression();
		EnterRule("negatedExpression", 45);
		TraceIn("negatedExpression", 45);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken NOT161 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> x = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> equalityExpression162 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode NOT161_tree = default(IASTNode);
		RewriteRuleITokenStream stream_NOT=new RewriteRuleITokenStream(adaptor,"token NOT");
		RewriteRuleSubtreeStream stream_negatedExpression=new RewriteRuleSubtreeStream(adaptor,"rule negatedExpression");
		 WeakKeywords(); 
		try { DebugEnterRule(GrammarFileName, "negatedExpression");
		DebugLocation(402, 1);
		try
		{
			// Hql.g:404:2: ( NOT x= negatedExpression -> ^() | equalityExpression )
			int alt54=2;
			try { DebugEnterDecision(54, false);
			int LA54_1 = input.LA(1);

			if ((LA54_1==NOT))
			{
				alt54 = 1;
			}
			else if ((LA54_1==ALL||LA54_1==ANY||LA54_1==AVG||LA54_1==BNOT||LA54_1==CASE||LA54_1==COLON||LA54_1==COUNT||LA54_1==ELEMENTS||LA54_1==EMPTY||LA54_1==EXISTS||LA54_1==FALSE||LA54_1==IDENT||LA54_1==INDICES||LA54_1==MAX||(LA54_1>=MIN && LA54_1<=MINUS)||(LA54_1>=NULL && LA54_1<=NUM_LONG)||LA54_1==OPEN||(LA54_1>=PARAM && LA54_1<=PLUS)||LA54_1==QUOTED_String||LA54_1==SOME||LA54_1==SUM||LA54_1==TRUE))
			{
				alt54 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 54, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(54); }
			switch (alt54)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:404:4: NOT x= negatedExpression
				{
				DebugLocation(404, 4);
				NOT161=(IToken)Match(input,NOT,Follow._NOT_in_negatedExpression1980);  
				stream_NOT.Add(NOT161);

				DebugLocation(404, 9);
				PushFollow(Follow._negatedExpression_in_negatedExpression1984);
				x=negatedExpression();
				PopFollow();

				stream_negatedExpression.Add(x.Tree);


				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 405:3: -> ^()
				{
					DebugLocation(405, 6);
					// Hql.g:405:6: ^()
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(405, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot(NegateNode((x!=null?((IASTNode)x.Tree):default(IASTNode))), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:406:4: equalityExpression
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(406, 4);
				PushFollow(Follow._equalityExpression_in_negatedExpression1997);
				equalityExpression162=equalityExpression();
				PopFollow();

				adaptor.AddChild(root_0, equalityExpression162.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("negatedExpression", 45);
			LeaveRule("negatedExpression", 45);
			LeaveRule_negatedExpression();
		}
		DebugLocation(407, 1);
		} finally { DebugExitRule(GrammarFileName, "negatedExpression"); }
		return retval;

	}
	// $ANTLR end "negatedExpression"

	partial void EnterRule_equalityExpression();
	partial void LeaveRule_equalityExpression();
	// $ANTLR start "equalityExpression"
	// Hql.g:412:1: equalityExpression : x= relationalExpression ( ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^) y= relationalExpression )* ;
	[GrammarRule("equalityExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 46);
		TraceIn("equalityExpression", 46);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken isx = default(IToken);
		IToken ne = default(IToken);
		IToken EQ163 = default(IToken);
		IToken NOT164 = default(IToken);
		IToken NE165 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> x = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> y = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode isx_tree = default(IASTNode);
		IASTNode ne_tree = default(IASTNode);
		IASTNode EQ163_tree = default(IASTNode);
		IASTNode NOT164_tree = default(IASTNode);
		IASTNode NE165_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(412, 1);
		try
		{
			// Hql.g:417:2: (x= relationalExpression ( ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^) y= relationalExpression )* )
			DebugEnterAlt(1);
			// Hql.g:417:4: x= relationalExpression ( ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^) y= relationalExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(417, 5);
			PushFollow(Follow._relationalExpression_in_equalityExpression2019);
			x=relationalExpression();
			PopFollow();

			adaptor.AddChild(root_0, x.Tree);
			DebugLocation(417, 27);
			// Hql.g:417:27: ( ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^) y= relationalExpression )*
			try { DebugEnterSubRule(57);
			while (true)
			{
				int alt57=2;
				try { DebugEnterDecision(57, false);
				int LA57_1 = input.LA(1);

				if ((LA57_1==EQ||LA57_1==IS||LA57_1==NE||LA57_1==SQL_NE))
				{
					alt57 = 1;
				}


				} finally { DebugExitDecision(57); }
				switch ( alt57 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:418:3: ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^) y= relationalExpression
					{
					DebugLocation(418, 3);
					// Hql.g:418:3: ( EQ ^|isx= IS ^ ( NOT !)? | NE ^|ne= SQL_NE ^)
					int alt56=4;
					try { DebugEnterSubRule(56);
					try { DebugEnterDecision(56, false);
					switch (input.LA(1))
					{
					case EQ:
						{
						alt56 = 1;
						}
						break;
					case IS:
						{
						alt56 = 2;
						}
						break;
					case NE:
						{
						alt56 = 3;
						}
						break;
					case SQL_NE:
						{
						alt56 = 4;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 56, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(56); }
					switch (alt56)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:418:5: EQ ^
						{
						DebugLocation(418, 7);
						EQ163=(IToken)Match(input,EQ,Follow._EQ_in_equalityExpression2027); 
						EQ163_tree = (IASTNode)adaptor.Create(EQ163);
						root_0 = (IASTNode)adaptor.BecomeRoot(EQ163_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Hql.g:419:5: isx= IS ^ ( NOT !)?
						{
						DebugLocation(419, 8);
						isx=(IToken)Match(input,IS,Follow._IS_in_equalityExpression2036); 
						isx_tree = (IASTNode)adaptor.Create(isx);
						root_0 = (IASTNode)adaptor.BecomeRoot(isx_tree, root_0);
						DebugLocation(419, 13);
						 isx.Type = EQ; 
						DebugLocation(419, 33);
						// Hql.g:419:33: ( NOT !)?
						int alt55=2;
						try { DebugEnterSubRule(55);
						try { DebugEnterDecision(55, false);
						int LA55_1 = input.LA(1);

						if ((LA55_1==NOT))
						{
							alt55 = 1;
						}
						} finally { DebugExitDecision(55); }
						switch (alt55)
						{
						case 1:
							DebugEnterAlt(1);
							// Hql.g:419:34: NOT !
							{
							DebugLocation(419, 37);
							NOT164=(IToken)Match(input,NOT,Follow._NOT_in_equalityExpression2042); 
							DebugLocation(419, 39);
							 isx.Type =NE; 

							}
							break;

						}
						} finally { DebugExitSubRule(55); }


						}
						break;
					case 3:
						DebugEnterAlt(3);
						// Hql.g:420:5: NE ^
						{
						DebugLocation(420, 7);
						NE165=(IToken)Match(input,NE,Follow._NE_in_equalityExpression2054); 
						NE165_tree = (IASTNode)adaptor.Create(NE165);
						root_0 = (IASTNode)adaptor.BecomeRoot(NE165_tree, root_0);

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// Hql.g:421:5: ne= SQL_NE ^
						{
						DebugLocation(421, 7);
						ne=(IToken)Match(input,SQL_NE,Follow._SQL_NE_in_equalityExpression2063); 
						ne_tree = (IASTNode)adaptor.Create(ne);
						root_0 = (IASTNode)adaptor.BecomeRoot(ne_tree, root_0);
						DebugLocation(421, 16);
						 ne.Type = NE; 

						}
						break;

					}
					} finally { DebugExitSubRule(56); }

					DebugLocation(422, 6);
					PushFollow(Follow._relationalExpression_in_equalityExpression2074);
					y=relationalExpression();
					PopFollow();

					adaptor.AddChild(root_0, y.Tree);

					}
					break;

				default:
					goto loop57;
				}
			}

			loop57:
				;

			} finally { DebugExitSubRule(57); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);


						// Post process the equality expression to clean up 'is null', etc.
						retval.Tree =  ProcessEqualityExpression(retval.Tree);
					
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpression", 46);
			LeaveRule("equalityExpression", 46);
			LeaveRule_equalityExpression();
		}
		DebugLocation(423, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return retval;

	}
	// $ANTLR end "equalityExpression"

	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();
	// $ANTLR start "relationalExpression"
	// Hql.g:429:1: relationalExpression : concatenation ( ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* ) | (n= NOT !)? ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) ) ) ;
	[GrammarRule("relationalExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 47);
		TraceIn("relationalExpression", 47);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken n = default(IToken);
		IToken i = default(IToken);
		IToken b = default(IToken);
		IToken l = default(IToken);
		IToken LT167 = default(IToken);
		IToken GT168 = default(IToken);
		IToken LE169 = default(IToken);
		IToken GE170 = default(IToken);
		IToken MEMBER176 = default(IToken);
		IToken OF177 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> p = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> concatenation166 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseNotExpression171 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> inList172 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> betweenList173 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> concatenation174 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> likeEscape175 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode n_tree = default(IASTNode);
		IASTNode i_tree = default(IASTNode);
		IASTNode b_tree = default(IASTNode);
		IASTNode l_tree = default(IASTNode);
		IASTNode LT167_tree = default(IASTNode);
		IASTNode GT168_tree = default(IASTNode);
		IASTNode LE169_tree = default(IASTNode);
		IASTNode GE170_tree = default(IASTNode);
		IASTNode MEMBER176_tree = default(IASTNode);
		IASTNode OF177_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(429, 1);
		try
		{
			// Hql.g:430:2: ( concatenation ( ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* ) | (n= NOT !)? ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) ) ) )
			DebugEnterAlt(1);
			// Hql.g:430:4: concatenation ( ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* ) | (n= NOT !)? ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) ) )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(430, 4);
			PushFollow(Follow._concatenation_in_relationalExpression2091);
			concatenation166=concatenation();
			PopFollow();

			adaptor.AddChild(root_0, concatenation166.Tree);
			DebugLocation(430, 18);
			// Hql.g:430:18: ( ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* ) | (n= NOT !)? ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) ) )
			int alt63=2;
			try { DebugEnterSubRule(63);
			try { DebugEnterDecision(63, false);
			int LA63_1 = input.LA(1);

			if ((LA63_1==EOF||LA63_1==AND||(LA63_1>=AS && LA63_1<=ASCENDING)||(LA63_1>=CLOSE && LA63_1<=CLOSE_BRACKET)||LA63_1==COMMA||LA63_1==DESCENDING||LA63_1==ELSE||(LA63_1>=END && LA63_1<=EQ)||(LA63_1>=FROM && LA63_1<=HAVING)||LA63_1==INNER||LA63_1==IS||(LA63_1>=JOIN && LA63_1<=LE)||LA63_1==LEFT||LA63_1==LT||LA63_1==NE||(LA63_1>=OR && LA63_1<=ORDER)||LA63_1==RIGHT||LA63_1==SKIP||LA63_1==SQL_NE||(LA63_1>=TAKE && LA63_1<=THEN)||LA63_1==UNION||(LA63_1>=WHEN && LA63_1<=WHERE)||(LA63_1>=133 && LA63_1<=134)))
			{
				alt63 = 1;
			}
			else if ((LA63_1==BETWEEN||LA63_1==IN||LA63_1==LIKE||LA63_1==MEMBER||LA63_1==NOT))
			{
				alt63 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 63, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(63); }
			switch (alt63)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:431:3: ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* )
				{
				DebugLocation(431, 3);
				// Hql.g:431:3: ( ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )* )
				DebugEnterAlt(1);
				// Hql.g:431:5: ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )*
				{
				DebugLocation(431, 5);
				// Hql.g:431:5: ( ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression )*
				try { DebugEnterSubRule(59);
				while (true)
				{
					int alt59=2;
					try { DebugEnterDecision(59, false);
					int LA59_1 = input.LA(1);

					if ((LA59_1==GE||LA59_1==GT||LA59_1==LE||LA59_1==LT))
					{
						alt59 = 1;
					}


					} finally { DebugExitDecision(59); }
					switch ( alt59 )
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:431:7: ( LT ^| GT ^| LE ^| GE ^) bitwiseNotExpression
						{
						DebugLocation(431, 7);
						// Hql.g:431:7: ( LT ^| GT ^| LE ^| GE ^)
						int alt58=4;
						try { DebugEnterSubRule(58);
						try { DebugEnterDecision(58, false);
						switch (input.LA(1))
						{
						case LT:
							{
							alt58 = 1;
							}
							break;
						case GT:
							{
							alt58 = 2;
							}
							break;
						case LE:
							{
							alt58 = 3;
							}
							break;
						case GE:
							{
							alt58 = 4;
							}
							break;
						default:
							{
								NoViableAltException nvae = new NoViableAltException("", 58, 0, input, 1);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}

						} finally { DebugExitDecision(58); }
						switch (alt58)
						{
						case 1:
							DebugEnterAlt(1);
							// Hql.g:431:9: LT ^
							{
							DebugLocation(431, 11);
							LT167=(IToken)Match(input,LT,Follow._LT_in_relationalExpression2103); 
							LT167_tree = (IASTNode)adaptor.Create(LT167);
							root_0 = (IASTNode)adaptor.BecomeRoot(LT167_tree, root_0);

							}
							break;
						case 2:
							DebugEnterAlt(2);
							// Hql.g:431:15: GT ^
							{
							DebugLocation(431, 17);
							GT168=(IToken)Match(input,GT,Follow._GT_in_relationalExpression2108); 
							GT168_tree = (IASTNode)adaptor.Create(GT168);
							root_0 = (IASTNode)adaptor.BecomeRoot(GT168_tree, root_0);

							}
							break;
						case 3:
							DebugEnterAlt(3);
							// Hql.g:431:21: LE ^
							{
							DebugLocation(431, 23);
							LE169=(IToken)Match(input,LE,Follow._LE_in_relationalExpression2113); 
							LE169_tree = (IASTNode)adaptor.Create(LE169);
							root_0 = (IASTNode)adaptor.BecomeRoot(LE169_tree, root_0);

							}
							break;
						case 4:
							DebugEnterAlt(4);
							// Hql.g:431:27: GE ^
							{
							DebugLocation(431, 29);
							GE170=(IToken)Match(input,GE,Follow._GE_in_relationalExpression2118); 
							GE170_tree = (IASTNode)adaptor.Create(GE170);
							root_0 = (IASTNode)adaptor.BecomeRoot(GE170_tree, root_0);

							}
							break;

						}
						} finally { DebugExitSubRule(58); }

						DebugLocation(431, 33);
						PushFollow(Follow._bitwiseNotExpression_in_relationalExpression2123);
						bitwiseNotExpression171=bitwiseNotExpression();
						PopFollow();

						adaptor.AddChild(root_0, bitwiseNotExpression171.Tree);

						}
						break;

					default:
						goto loop59;
					}
				}

				loop59:
					;

				} finally { DebugExitSubRule(59); }


				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:433:5: (n= NOT !)? ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) )
				{
				DebugLocation(433, 5);
				// Hql.g:433:5: (n= NOT !)?
				int alt60=2;
				try { DebugEnterSubRule(60);
				try { DebugEnterDecision(60, false);
				int LA60_1 = input.LA(1);

				if ((LA60_1==NOT))
				{
					alt60 = 1;
				}
				} finally { DebugExitDecision(60); }
				switch (alt60)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:433:6: n= NOT !
					{
					DebugLocation(433, 7);
					n=(IToken)Match(input,NOT,Follow._NOT_in_relationalExpression2140); 

					}
					break;

				}
				} finally { DebugExitSubRule(60); }

				DebugLocation(433, 15);
				// Hql.g:433:15: ( (i= IN ^ inList ) | (b= BETWEEN ^ betweenList ) | (l= LIKE ^ concatenation likeEscape ) | ( MEMBER ! ( OF !)? p= path !) )
				int alt62=4;
				try { DebugEnterSubRule(62);
				try { DebugEnterDecision(62, false);
				switch (input.LA(1))
				{
				case IN:
					{
					alt62 = 1;
					}
					break;
				case BETWEEN:
					{
					alt62 = 2;
					}
					break;
				case LIKE:
					{
					alt62 = 3;
					}
					break;
				case MEMBER:
					{
					alt62 = 4;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 62, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(62); }
				switch (alt62)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:436:4: (i= IN ^ inList )
					{
					DebugLocation(436, 4);
					// Hql.g:436:4: (i= IN ^ inList )
					DebugEnterAlt(1);
					// Hql.g:436:5: i= IN ^ inList
					{
					DebugLocation(436, 6);
					i=(IToken)Match(input,IN,Follow._IN_in_relationalExpression2161); 
					i_tree = (IASTNode)adaptor.Create(i);
					root_0 = (IASTNode)adaptor.BecomeRoot(i_tree, root_0);
					DebugLocation(436, 11);

										i.Type = (n == null) ? IN : NOT_IN;
										i.Text = (n == null) ? "in" : "not in";
									
					DebugLocation(440, 5);
					PushFollow(Follow._inList_in_relationalExpression2170);
					inList172=inList();
					PopFollow();

					adaptor.AddChild(root_0, inList172.Tree);

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:441:6: (b= BETWEEN ^ betweenList )
					{
					DebugLocation(441, 6);
					// Hql.g:441:6: (b= BETWEEN ^ betweenList )
					DebugEnterAlt(1);
					// Hql.g:441:7: b= BETWEEN ^ betweenList
					{
					DebugLocation(441, 8);
					b=(IToken)Match(input,BETWEEN,Follow._BETWEEN_in_relationalExpression2181); 
					b_tree = (IASTNode)adaptor.Create(b);
					root_0 = (IASTNode)adaptor.BecomeRoot(b_tree, root_0);
					DebugLocation(441, 18);

										b.Type = (n == null) ? BETWEEN : NOT_BETWEEN;
										b.Text = (n == null) ? "between" : "not between";
									
					DebugLocation(445, 5);
					PushFollow(Follow._betweenList_in_relationalExpression2190);
					betweenList173=betweenList();
					PopFollow();

					adaptor.AddChild(root_0, betweenList173.Tree);

					}


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Hql.g:446:6: (l= LIKE ^ concatenation likeEscape )
					{
					DebugLocation(446, 6);
					// Hql.g:446:6: (l= LIKE ^ concatenation likeEscape )
					DebugEnterAlt(1);
					// Hql.g:446:7: l= LIKE ^ concatenation likeEscape
					{
					DebugLocation(446, 8);
					l=(IToken)Match(input,LIKE,Follow._LIKE_in_relationalExpression2202); 
					l_tree = (IASTNode)adaptor.Create(l);
					root_0 = (IASTNode)adaptor.BecomeRoot(l_tree, root_0);
					DebugLocation(446, 15);

										l.Type = (n == null) ? LIKE : NOT_LIKE;
										l.Text = (n == null) ? "like" : "not like";
									
					DebugLocation(450, 5);
					PushFollow(Follow._concatenation_in_relationalExpression2211);
					concatenation174=concatenation();
					PopFollow();

					adaptor.AddChild(root_0, concatenation174.Tree);
					DebugLocation(450, 19);
					PushFollow(Follow._likeEscape_in_relationalExpression2213);
					likeEscape175=likeEscape();
					PopFollow();

					adaptor.AddChild(root_0, likeEscape175.Tree);

					}


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Hql.g:451:6: ( MEMBER ! ( OF !)? p= path !)
					{
					DebugLocation(451, 6);
					// Hql.g:451:6: ( MEMBER ! ( OF !)? p= path !)
					DebugEnterAlt(1);
					// Hql.g:451:7: MEMBER ! ( OF !)? p= path !
					{
					DebugLocation(451, 13);
					MEMBER176=(IToken)Match(input,MEMBER,Follow._MEMBER_in_relationalExpression2222); 
					DebugLocation(451, 15);
					// Hql.g:451:15: ( OF !)?
					int alt61=2;
					try { DebugEnterSubRule(61);
					try { DebugEnterDecision(61, false);
					int LA61_1 = input.LA(1);

					if ((LA61_1==OF))
					{
						alt61 = 1;
					}
					} finally { DebugExitDecision(61); }
					switch (alt61)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:451:16: OF !
						{
						DebugLocation(451, 18);
						OF177=(IToken)Match(input,OF,Follow._OF_in_relationalExpression2226); 

						}
						break;

					}
					} finally { DebugExitSubRule(61); }

					DebugLocation(451, 23);
					PushFollow(Follow._path_in_relationalExpression2233);
					p=path();
					PopFollow();

					DebugLocation(451, 30);

									root_0 = ProcessMemberOf(n,(p!=null?((IASTNode)p.Tree):default(IASTNode)), root_0);
								  

					}


					}
					break;

				}
				} finally { DebugExitSubRule(62); }


				}
				break;

			}
			} finally { DebugExitSubRule(63); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpression", 47);
			LeaveRule("relationalExpression", 47);
			LeaveRule_relationalExpression();
		}
		DebugLocation(456, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return retval;

	}
	// $ANTLR end "relationalExpression"

	partial void EnterRule_likeEscape();
	partial void LeaveRule_likeEscape();
	// $ANTLR start "likeEscape"
	// Hql.g:458:1: likeEscape : ( ESCAPE ^ concatenation )? ;
	[GrammarRule("likeEscape")]
	private AstParserRuleReturnScope<IASTNode, IToken> likeEscape()
	{
		EnterRule_likeEscape();
		EnterRule("likeEscape", 48);
		TraceIn("likeEscape", 48);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken ESCAPE178 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> concatenation179 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode ESCAPE178_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "likeEscape");
		DebugLocation(458, 1);
		try
		{
			// Hql.g:459:2: ( ( ESCAPE ^ concatenation )? )
			DebugEnterAlt(1);
			// Hql.g:459:4: ( ESCAPE ^ concatenation )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(459, 4);
			// Hql.g:459:4: ( ESCAPE ^ concatenation )?
			int alt64=2;
			try { DebugEnterSubRule(64);
			try { DebugEnterDecision(64, false);
			int LA64_1 = input.LA(1);

			if ((LA64_1==ESCAPE))
			{
				alt64 = 1;
			}
			} finally { DebugExitDecision(64); }
			switch (alt64)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:459:5: ESCAPE ^ concatenation
				{
				DebugLocation(459, 11);
				ESCAPE178=(IToken)Match(input,ESCAPE,Follow._ESCAPE_in_likeEscape2260); 
				ESCAPE178_tree = (IASTNode)adaptor.Create(ESCAPE178);
				root_0 = (IASTNode)adaptor.BecomeRoot(ESCAPE178_tree, root_0);
				DebugLocation(459, 13);
				PushFollow(Follow._concatenation_in_likeEscape2263);
				concatenation179=concatenation();
				PopFollow();

				adaptor.AddChild(root_0, concatenation179.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(64); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("likeEscape", 48);
			LeaveRule("likeEscape", 48);
			LeaveRule_likeEscape();
		}
		DebugLocation(460, 1);
		} finally { DebugExitRule(GrammarFileName, "likeEscape"); }
		return retval;

	}
	// $ANTLR end "likeEscape"

	partial void EnterRule_inList();
	partial void LeaveRule_inList();
	// $ANTLR start "inList"
	// Hql.g:462:1: inList : compoundExpr -> ^( IN_LIST[\"inList\"] compoundExpr ) ;
	[GrammarRule("inList")]
	private AstParserRuleReturnScope<IASTNode, IToken> inList()
	{
		EnterRule_inList();
		EnterRule("inList", 49);
		TraceIn("inList", 49);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> compoundExpr180 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		RewriteRuleSubtreeStream stream_compoundExpr=new RewriteRuleSubtreeStream(adaptor,"rule compoundExpr");
		try { DebugEnterRule(GrammarFileName, "inList");
		DebugLocation(462, 1);
		try
		{
			// Hql.g:463:2: ( compoundExpr -> ^( IN_LIST[\"inList\"] compoundExpr ) )
			DebugEnterAlt(1);
			// Hql.g:463:4: compoundExpr
			{
			DebugLocation(463, 4);
			PushFollow(Follow._compoundExpr_in_inList2276);
			compoundExpr180=compoundExpr();
			PopFollow();

			stream_compoundExpr.Add(compoundExpr180.Tree);


			{
			// AST REWRITE
			// elements: compoundExpr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 464:2: -> ^( IN_LIST[\"inList\"] compoundExpr )
			{
				DebugLocation(464, 5);
				// Hql.g:464:5: ^( IN_LIST[\"inList\"] compoundExpr )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(464, 7);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(IN_LIST, "inList"), root_1);

				DebugLocation(464, 25);
				adaptor.AddChild(root_1, stream_compoundExpr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("inList", 49);
			LeaveRule("inList", 49);
			LeaveRule_inList();
		}
		DebugLocation(465, 1);
		} finally { DebugExitRule(GrammarFileName, "inList"); }
		return retval;

	}
	// $ANTLR end "inList"

	partial void EnterRule_betweenList();
	partial void LeaveRule_betweenList();
	// $ANTLR start "betweenList"
	// Hql.g:467:1: betweenList : concatenation AND ! concatenation ;
	[GrammarRule("betweenList")]
	private AstParserRuleReturnScope<IASTNode, IToken> betweenList()
	{
		EnterRule_betweenList();
		EnterRule("betweenList", 50);
		TraceIn("betweenList", 50);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken AND182 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> concatenation181 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> concatenation183 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode AND182_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "betweenList");
		DebugLocation(467, 1);
		try
		{
			// Hql.g:468:2: ( concatenation AND ! concatenation )
			DebugEnterAlt(1);
			// Hql.g:468:4: concatenation AND ! concatenation
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(468, 4);
			PushFollow(Follow._concatenation_in_betweenList2297);
			concatenation181=concatenation();
			PopFollow();

			adaptor.AddChild(root_0, concatenation181.Tree);
			DebugLocation(468, 21);
			AND182=(IToken)Match(input,AND,Follow._AND_in_betweenList2299); 
			DebugLocation(468, 23);
			PushFollow(Follow._concatenation_in_betweenList2302);
			concatenation183=concatenation();
			PopFollow();

			adaptor.AddChild(root_0, concatenation183.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("betweenList", 50);
			LeaveRule("betweenList", 50);
			LeaveRule_betweenList();
		}
		DebugLocation(469, 1);
		} finally { DebugExitRule(GrammarFileName, "betweenList"); }
		return retval;

	}
	// $ANTLR end "betweenList"

	partial void EnterRule_concatenation();
	partial void LeaveRule_concatenation();
	// $ANTLR start "concatenation"
	// Hql.g:472:1: concatenation : a= bitwiseNotExpression (c= CONCAT ^ bitwiseNotExpression ( CONCAT ! bitwiseNotExpression )* )? ;
	[GrammarRule("concatenation")]
	private AstParserRuleReturnScope<IASTNode, IToken> concatenation()
	{
		EnterRule_concatenation();
		EnterRule("concatenation", 51);
		TraceIn("concatenation", 51);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken c = default(IToken);
		IToken CONCAT185 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> a = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseNotExpression184 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseNotExpression186 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode c_tree = default(IASTNode);
		IASTNode CONCAT185_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "concatenation");
		DebugLocation(472, 1);
		try
		{
			// Hql.g:483:2: (a= bitwiseNotExpression (c= CONCAT ^ bitwiseNotExpression ( CONCAT ! bitwiseNotExpression )* )? )
			DebugEnterAlt(1);
			// Hql.g:483:4: a= bitwiseNotExpression (c= CONCAT ^ bitwiseNotExpression ( CONCAT ! bitwiseNotExpression )* )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(483, 5);
			PushFollow(Follow._bitwiseNotExpression_in_concatenation2321);
			a=bitwiseNotExpression();
			PopFollow();

			adaptor.AddChild(root_0, a.Tree);
			DebugLocation(484, 2);
			// Hql.g:484:2: (c= CONCAT ^ bitwiseNotExpression ( CONCAT ! bitwiseNotExpression )* )?
			int alt66=2;
			try { DebugEnterSubRule(66);
			try { DebugEnterDecision(66, false);
			int LA66_1 = input.LA(1);

			if ((LA66_1==CONCAT))
			{
				alt66 = 1;
			}
			} finally { DebugExitDecision(66); }
			switch (alt66)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:484:4: c= CONCAT ^ bitwiseNotExpression ( CONCAT ! bitwiseNotExpression )*
				{
				DebugLocation(484, 5);
				c=(IToken)Match(input,CONCAT,Follow._CONCAT_in_concatenation2329); 
				c_tree = (IASTNode)adaptor.Create(c);
				root_0 = (IASTNode)adaptor.BecomeRoot(c_tree, root_0);
				DebugLocation(484, 14);
				 c.Type = EXPR_LIST; c.Text = "concatList"; 
				DebugLocation(485, 4);
				PushFollow(Follow._bitwiseNotExpression_in_concatenation2338);
				bitwiseNotExpression184=bitwiseNotExpression();
				PopFollow();

				adaptor.AddChild(root_0, bitwiseNotExpression184.Tree);
				DebugLocation(486, 4);
				// Hql.g:486:4: ( CONCAT ! bitwiseNotExpression )*
				try { DebugEnterSubRule(65);
				while (true)
				{
					int alt65=2;
					try { DebugEnterDecision(65, false);
					int LA65_1 = input.LA(1);

					if ((LA65_1==CONCAT))
					{
						alt65 = 1;
					}


					} finally { DebugExitDecision(65); }
					switch ( alt65 )
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:486:6: CONCAT ! bitwiseNotExpression
						{
						DebugLocation(486, 12);
						CONCAT185=(IToken)Match(input,CONCAT,Follow._CONCAT_in_concatenation2345); 
						DebugLocation(486, 14);
						PushFollow(Follow._bitwiseNotExpression_in_concatenation2348);
						bitwiseNotExpression186=bitwiseNotExpression();
						PopFollow();

						adaptor.AddChild(root_0, bitwiseNotExpression186.Tree);

						}
						break;

					default:
						goto loop65;
					}
				}

				loop65:
					;

				} finally { DebugExitSubRule(65); }


				}
				break;

			}
			} finally { DebugExitSubRule(66); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);


			   if (c != null)
			   {
			      IASTNode mc = (IASTNode) adaptor.Create(METHOD_CALL, "||");
			      IASTNode concat = (IASTNode) adaptor.Create(IDENT, "concat");
			      mc.AddChild(concat);
			      mc.AddChild((IASTNode) retval.Tree);
			      retval.Tree = mc;
			   }

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("concatenation", 51);
			LeaveRule("concatenation", 51);
			LeaveRule_concatenation();
		}
		DebugLocation(488, 1);
		} finally { DebugExitRule(GrammarFileName, "concatenation"); }
		return retval;

	}
	// $ANTLR end "concatenation"

	partial void EnterRule_bitwiseNotExpression();
	partial void LeaveRule_bitwiseNotExpression();
	// $ANTLR start "bitwiseNotExpression"
	// Hql.g:491:1: bitwiseNotExpression : ( ( BNOT ^ bitwiseOrExpression ) | bitwiseOrExpression );
	[GrammarRule("bitwiseNotExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> bitwiseNotExpression()
	{
		EnterRule_bitwiseNotExpression();
		EnterRule("bitwiseNotExpression", 52);
		TraceIn("bitwiseNotExpression", 52);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken BNOT187 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseOrExpression188 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseOrExpression189 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode BNOT187_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "bitwiseNotExpression");
		DebugLocation(491, 1);
		try
		{
			// Hql.g:492:2: ( ( BNOT ^ bitwiseOrExpression ) | bitwiseOrExpression )
			int alt67=2;
			try { DebugEnterDecision(67, false);
			int LA67_1 = input.LA(1);

			if ((LA67_1==BNOT))
			{
				alt67 = 1;
			}
			else if ((LA67_1==ALL||LA67_1==ANY||LA67_1==AVG||LA67_1==CASE||LA67_1==COLON||LA67_1==COUNT||LA67_1==ELEMENTS||LA67_1==EMPTY||LA67_1==EXISTS||LA67_1==FALSE||LA67_1==IDENT||LA67_1==INDICES||LA67_1==MAX||(LA67_1>=MIN && LA67_1<=MINUS)||(LA67_1>=NULL && LA67_1<=NUM_LONG)||LA67_1==OPEN||(LA67_1>=PARAM && LA67_1<=PLUS)||LA67_1==QUOTED_String||LA67_1==SOME||LA67_1==SUM||LA67_1==TRUE))
			{
				alt67 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 67, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(67); }
			switch (alt67)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:492:4: ( BNOT ^ bitwiseOrExpression )
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(492, 4);
				// Hql.g:492:4: ( BNOT ^ bitwiseOrExpression )
				DebugEnterAlt(1);
				// Hql.g:492:5: BNOT ^ bitwiseOrExpression
				{
				DebugLocation(492, 9);
				BNOT187=(IToken)Match(input,BNOT,Follow._BNOT_in_bitwiseNotExpression2372); 
				BNOT187_tree = (IASTNode)adaptor.Create(BNOT187);
				root_0 = (IASTNode)adaptor.BecomeRoot(BNOT187_tree, root_0);
				DebugLocation(492, 11);
				PushFollow(Follow._bitwiseOrExpression_in_bitwiseNotExpression2375);
				bitwiseOrExpression188=bitwiseOrExpression();
				PopFollow();

				adaptor.AddChild(root_0, bitwiseOrExpression188.Tree);

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:493:4: bitwiseOrExpression
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(493, 4);
				PushFollow(Follow._bitwiseOrExpression_in_bitwiseNotExpression2381);
				bitwiseOrExpression189=bitwiseOrExpression();
				PopFollow();

				adaptor.AddChild(root_0, bitwiseOrExpression189.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseNotExpression", 52);
			LeaveRule("bitwiseNotExpression", 52);
			LeaveRule_bitwiseNotExpression();
		}
		DebugLocation(494, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseNotExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseNotExpression"

	partial void EnterRule_bitwiseOrExpression();
	partial void LeaveRule_bitwiseOrExpression();
	// $ANTLR start "bitwiseOrExpression"
	// Hql.g:496:1: bitwiseOrExpression : bitwiseXOrExpression ( BOR ^ bitwiseXOrExpression )* ;
	[GrammarRule("bitwiseOrExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> bitwiseOrExpression()
	{
		EnterRule_bitwiseOrExpression();
		EnterRule("bitwiseOrExpression", 53);
		TraceIn("bitwiseOrExpression", 53);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken BOR191 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseXOrExpression190 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseXOrExpression192 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode BOR191_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "bitwiseOrExpression");
		DebugLocation(496, 1);
		try
		{
			// Hql.g:497:2: ( bitwiseXOrExpression ( BOR ^ bitwiseXOrExpression )* )
			DebugEnterAlt(1);
			// Hql.g:497:4: bitwiseXOrExpression ( BOR ^ bitwiseXOrExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(497, 4);
			PushFollow(Follow._bitwiseXOrExpression_in_bitwiseOrExpression2393);
			bitwiseXOrExpression190=bitwiseXOrExpression();
			PopFollow();

			adaptor.AddChild(root_0, bitwiseXOrExpression190.Tree);
			DebugLocation(497, 25);
			// Hql.g:497:25: ( BOR ^ bitwiseXOrExpression )*
			try { DebugEnterSubRule(68);
			while (true)
			{
				int alt68=2;
				try { DebugEnterDecision(68, false);
				int LA68_1 = input.LA(1);

				if ((LA68_1==BOR))
				{
					alt68 = 1;
				}


				} finally { DebugExitDecision(68); }
				switch ( alt68 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:497:26: BOR ^ bitwiseXOrExpression
					{
					DebugLocation(497, 29);
					BOR191=(IToken)Match(input,BOR,Follow._BOR_in_bitwiseOrExpression2396); 
					BOR191_tree = (IASTNode)adaptor.Create(BOR191);
					root_0 = (IASTNode)adaptor.BecomeRoot(BOR191_tree, root_0);
					DebugLocation(497, 31);
					PushFollow(Follow._bitwiseXOrExpression_in_bitwiseOrExpression2399);
					bitwiseXOrExpression192=bitwiseXOrExpression();
					PopFollow();

					adaptor.AddChild(root_0, bitwiseXOrExpression192.Tree);

					}
					break;

				default:
					goto loop68;
				}
			}

			loop68:
				;

			} finally { DebugExitSubRule(68); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseOrExpression", 53);
			LeaveRule("bitwiseOrExpression", 53);
			LeaveRule_bitwiseOrExpression();
		}
		DebugLocation(498, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseOrExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseOrExpression"

	partial void EnterRule_bitwiseXOrExpression();
	partial void LeaveRule_bitwiseXOrExpression();
	// $ANTLR start "bitwiseXOrExpression"
	// Hql.g:500:1: bitwiseXOrExpression : bitwiseAndExpression ( BXOR ^ bitwiseAndExpression )* ;
	[GrammarRule("bitwiseXOrExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> bitwiseXOrExpression()
	{
		EnterRule_bitwiseXOrExpression();
		EnterRule("bitwiseXOrExpression", 54);
		TraceIn("bitwiseXOrExpression", 54);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken BXOR194 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseAndExpression193 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> bitwiseAndExpression195 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode BXOR194_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "bitwiseXOrExpression");
		DebugLocation(500, 1);
		try
		{
			// Hql.g:501:2: ( bitwiseAndExpression ( BXOR ^ bitwiseAndExpression )* )
			DebugEnterAlt(1);
			// Hql.g:501:4: bitwiseAndExpression ( BXOR ^ bitwiseAndExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(501, 4);
			PushFollow(Follow._bitwiseAndExpression_in_bitwiseXOrExpression2413);
			bitwiseAndExpression193=bitwiseAndExpression();
			PopFollow();

			adaptor.AddChild(root_0, bitwiseAndExpression193.Tree);
			DebugLocation(501, 25);
			// Hql.g:501:25: ( BXOR ^ bitwiseAndExpression )*
			try { DebugEnterSubRule(69);
			while (true)
			{
				int alt69=2;
				try { DebugEnterDecision(69, false);
				int LA69_1 = input.LA(1);

				if ((LA69_1==BXOR))
				{
					alt69 = 1;
				}


				} finally { DebugExitDecision(69); }
				switch ( alt69 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:501:26: BXOR ^ bitwiseAndExpression
					{
					DebugLocation(501, 30);
					BXOR194=(IToken)Match(input,BXOR,Follow._BXOR_in_bitwiseXOrExpression2416); 
					BXOR194_tree = (IASTNode)adaptor.Create(BXOR194);
					root_0 = (IASTNode)adaptor.BecomeRoot(BXOR194_tree, root_0);
					DebugLocation(501, 32);
					PushFollow(Follow._bitwiseAndExpression_in_bitwiseXOrExpression2419);
					bitwiseAndExpression195=bitwiseAndExpression();
					PopFollow();

					adaptor.AddChild(root_0, bitwiseAndExpression195.Tree);

					}
					break;

				default:
					goto loop69;
				}
			}

			loop69:
				;

			} finally { DebugExitSubRule(69); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseXOrExpression", 54);
			LeaveRule("bitwiseXOrExpression", 54);
			LeaveRule_bitwiseXOrExpression();
		}
		DebugLocation(502, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXOrExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseXOrExpression"

	partial void EnterRule_bitwiseAndExpression();
	partial void LeaveRule_bitwiseAndExpression();
	// $ANTLR start "bitwiseAndExpression"
	// Hql.g:504:1: bitwiseAndExpression : additiveExpression ( BAND ^ additiveExpression )* ;
	[GrammarRule("bitwiseAndExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> bitwiseAndExpression()
	{
		EnterRule_bitwiseAndExpression();
		EnterRule("bitwiseAndExpression", 55);
		TraceIn("bitwiseAndExpression", 55);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken BAND197 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> additiveExpression196 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> additiveExpression198 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode BAND197_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "bitwiseAndExpression");
		DebugLocation(504, 1);
		try
		{
			// Hql.g:505:2: ( additiveExpression ( BAND ^ additiveExpression )* )
			DebugEnterAlt(1);
			// Hql.g:505:4: additiveExpression ( BAND ^ additiveExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(505, 4);
			PushFollow(Follow._additiveExpression_in_bitwiseAndExpression2433);
			additiveExpression196=additiveExpression();
			PopFollow();

			adaptor.AddChild(root_0, additiveExpression196.Tree);
			DebugLocation(505, 23);
			// Hql.g:505:23: ( BAND ^ additiveExpression )*
			try { DebugEnterSubRule(70);
			while (true)
			{
				int alt70=2;
				try { DebugEnterDecision(70, false);
				int LA70_1 = input.LA(1);

				if ((LA70_1==BAND))
				{
					alt70 = 1;
				}


				} finally { DebugExitDecision(70); }
				switch ( alt70 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:505:24: BAND ^ additiveExpression
					{
					DebugLocation(505, 28);
					BAND197=(IToken)Match(input,BAND,Follow._BAND_in_bitwiseAndExpression2436); 
					BAND197_tree = (IASTNode)adaptor.Create(BAND197);
					root_0 = (IASTNode)adaptor.BecomeRoot(BAND197_tree, root_0);
					DebugLocation(505, 30);
					PushFollow(Follow._additiveExpression_in_bitwiseAndExpression2439);
					additiveExpression198=additiveExpression();
					PopFollow();

					adaptor.AddChild(root_0, additiveExpression198.Tree);

					}
					break;

				default:
					goto loop70;
				}
			}

			loop70:
				;

			} finally { DebugExitSubRule(70); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseAndExpression", 55);
			LeaveRule("bitwiseAndExpression", 55);
			LeaveRule_bitwiseAndExpression();
		}
		DebugLocation(506, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseAndExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseAndExpression"

	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();
	// $ANTLR start "additiveExpression"
	// Hql.g:509:1: additiveExpression : multiplyExpression ( ( PLUS ^| MINUS ^) multiplyExpression )* ;
	[GrammarRule("additiveExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 56);
		TraceIn("additiveExpression", 56);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken PLUS200 = default(IToken);
		IToken MINUS201 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> multiplyExpression199 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> multiplyExpression202 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode PLUS200_tree = default(IASTNode);
		IASTNode MINUS201_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(509, 1);
		try
		{
			// Hql.g:510:2: ( multiplyExpression ( ( PLUS ^| MINUS ^) multiplyExpression )* )
			DebugEnterAlt(1);
			// Hql.g:510:4: multiplyExpression ( ( PLUS ^| MINUS ^) multiplyExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(510, 4);
			PushFollow(Follow._multiplyExpression_in_additiveExpression2453);
			multiplyExpression199=multiplyExpression();
			PopFollow();

			adaptor.AddChild(root_0, multiplyExpression199.Tree);
			DebugLocation(510, 23);
			// Hql.g:510:23: ( ( PLUS ^| MINUS ^) multiplyExpression )*
			try { DebugEnterSubRule(72);
			while (true)
			{
				int alt72=2;
				try { DebugEnterDecision(72, false);
				int LA72_1 = input.LA(1);

				if ((LA72_1==MINUS||LA72_1==PLUS))
				{
					alt72 = 1;
				}


				} finally { DebugExitDecision(72); }
				switch ( alt72 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:510:25: ( PLUS ^| MINUS ^) multiplyExpression
					{
					DebugLocation(510, 25);
					// Hql.g:510:25: ( PLUS ^| MINUS ^)
					int alt71=2;
					try { DebugEnterSubRule(71);
					try { DebugEnterDecision(71, false);
					int LA71_1 = input.LA(1);

					if ((LA71_1==PLUS))
					{
						alt71 = 1;
					}
					else if ((LA71_1==MINUS))
					{
						alt71 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 71, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(71); }
					switch (alt71)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:510:27: PLUS ^
						{
						DebugLocation(510, 31);
						PLUS200=(IToken)Match(input,PLUS,Follow._PLUS_in_additiveExpression2459); 
						PLUS200_tree = (IASTNode)adaptor.Create(PLUS200);
						root_0 = (IASTNode)adaptor.BecomeRoot(PLUS200_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Hql.g:510:35: MINUS ^
						{
						DebugLocation(510, 40);
						MINUS201=(IToken)Match(input,MINUS,Follow._MINUS_in_additiveExpression2464); 
						MINUS201_tree = (IASTNode)adaptor.Create(MINUS201);
						root_0 = (IASTNode)adaptor.BecomeRoot(MINUS201_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(71); }

					DebugLocation(510, 44);
					PushFollow(Follow._multiplyExpression_in_additiveExpression2469);
					multiplyExpression202=multiplyExpression();
					PopFollow();

					adaptor.AddChild(root_0, multiplyExpression202.Tree);

					}
					break;

				default:
					goto loop72;
				}
			}

			loop72:
				;

			} finally { DebugExitSubRule(72); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveExpression", 56);
			LeaveRule("additiveExpression", 56);
			LeaveRule_additiveExpression();
		}
		DebugLocation(511, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"

	partial void EnterRule_multiplyExpression();
	partial void LeaveRule_multiplyExpression();
	// $ANTLR start "multiplyExpression"
	// Hql.g:514:1: multiplyExpression : unaryExpression ( ( STAR ^| DIV ^) unaryExpression )* ;
	[GrammarRule("multiplyExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> multiplyExpression()
	{
		EnterRule_multiplyExpression();
		EnterRule("multiplyExpression", 57);
		TraceIn("multiplyExpression", 57);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken STAR204 = default(IToken);
		IToken DIV205 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> unaryExpression203 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> unaryExpression206 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode STAR204_tree = default(IASTNode);
		IASTNode DIV205_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "multiplyExpression");
		DebugLocation(514, 1);
		try
		{
			// Hql.g:515:2: ( unaryExpression ( ( STAR ^| DIV ^) unaryExpression )* )
			DebugEnterAlt(1);
			// Hql.g:515:4: unaryExpression ( ( STAR ^| DIV ^) unaryExpression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(515, 4);
			PushFollow(Follow._unaryExpression_in_multiplyExpression2484);
			unaryExpression203=unaryExpression();
			PopFollow();

			adaptor.AddChild(root_0, unaryExpression203.Tree);
			DebugLocation(515, 20);
			// Hql.g:515:20: ( ( STAR ^| DIV ^) unaryExpression )*
			try { DebugEnterSubRule(74);
			while (true)
			{
				int alt74=2;
				try { DebugEnterDecision(74, false);
				int LA74_1 = input.LA(1);

				if ((LA74_1==DIV||LA74_1==STAR))
				{
					alt74 = 1;
				}


				} finally { DebugExitDecision(74); }
				switch ( alt74 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:515:22: ( STAR ^| DIV ^) unaryExpression
					{
					DebugLocation(515, 22);
					// Hql.g:515:22: ( STAR ^| DIV ^)
					int alt73=2;
					try { DebugEnterSubRule(73);
					try { DebugEnterDecision(73, false);
					int LA73_1 = input.LA(1);

					if ((LA73_1==STAR))
					{
						alt73 = 1;
					}
					else if ((LA73_1==DIV))
					{
						alt73 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 73, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(73); }
					switch (alt73)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:515:24: STAR ^
						{
						DebugLocation(515, 28);
						STAR204=(IToken)Match(input,STAR,Follow._STAR_in_multiplyExpression2490); 
						STAR204_tree = (IASTNode)adaptor.Create(STAR204);
						root_0 = (IASTNode)adaptor.BecomeRoot(STAR204_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Hql.g:515:32: DIV ^
						{
						DebugLocation(515, 35);
						DIV205=(IToken)Match(input,DIV,Follow._DIV_in_multiplyExpression2495); 
						DIV205_tree = (IASTNode)adaptor.Create(DIV205);
						root_0 = (IASTNode)adaptor.BecomeRoot(DIV205_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(73); }

					DebugLocation(515, 39);
					PushFollow(Follow._unaryExpression_in_multiplyExpression2500);
					unaryExpression206=unaryExpression();
					PopFollow();

					adaptor.AddChild(root_0, unaryExpression206.Tree);

					}
					break;

				default:
					goto loop74;
				}
			}

			loop74:
				;

			} finally { DebugExitSubRule(74); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplyExpression", 57);
			LeaveRule("multiplyExpression", 57);
			LeaveRule_multiplyExpression();
		}
		DebugLocation(516, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplyExpression"); }
		return retval;

	}
	// $ANTLR end "multiplyExpression"

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();
	// $ANTLR start "unaryExpression"
	// Hql.g:519:1: unaryExpression : (m= MINUS mu= unaryExpression -> ^( UNARY_MINUS[$m] $mu) |p= PLUS pu= unaryExpression -> ^( UNARY_PLUS[$p] $pu) | caseExpression | quantifiedExpression | atom );
	[GrammarRule("unaryExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 58);
		TraceIn("unaryExpression", 58);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken m = default(IToken);
		IToken p = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> mu = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> pu = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> caseExpression207 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> quantifiedExpression208 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> atom209 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode m_tree = default(IASTNode);
		IASTNode p_tree = default(IASTNode);
		RewriteRuleITokenStream stream_MINUS=new RewriteRuleITokenStream(adaptor,"token MINUS");
		RewriteRuleITokenStream stream_PLUS=new RewriteRuleITokenStream(adaptor,"token PLUS");
		RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(519, 1);
		try
		{
			// Hql.g:520:2: (m= MINUS mu= unaryExpression -> ^( UNARY_MINUS[$m] $mu) |p= PLUS pu= unaryExpression -> ^( UNARY_PLUS[$p] $pu) | caseExpression | quantifiedExpression | atom )
			int alt75=5;
			try { DebugEnterDecision(75, false);
			switch (input.LA(1))
			{
			case MINUS:
				{
				alt75 = 1;
				}
				break;
			case PLUS:
				{
				alt75 = 2;
				}
				break;
			case CASE:
				{
				alt75 = 3;
				}
				break;
			case ALL:
			case ANY:
			case EXISTS:
			case SOME:
				{
				alt75 = 4;
				}
				break;
			case AVG:
			case COLON:
			case COUNT:
			case ELEMENTS:
			case EMPTY:
			case FALSE:
			case IDENT:
			case INDICES:
			case MAX:
			case MIN:
			case NULL:
			case NUM_DECIMAL:
			case NUM_DOUBLE:
			case NUM_FLOAT:
			case NUM_INT:
			case NUM_LONG:
			case OPEN:
			case PARAM:
			case QUOTED_String:
			case SUM:
			case TRUE:
				{
				alt75 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 75, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(75); }
			switch (alt75)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:520:4: m= MINUS mu= unaryExpression
				{
				DebugLocation(520, 5);
				m=(IToken)Match(input,MINUS,Follow._MINUS_in_unaryExpression2518);  
				stream_MINUS.Add(m);

				DebugLocation(520, 14);
				PushFollow(Follow._unaryExpression_in_unaryExpression2522);
				mu=unaryExpression();
				PopFollow();

				stream_unaryExpression.Add(mu.Tree);


				{
				// AST REWRITE
				// elements: mu
				// token labels: 
				// rule labels: mu, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_mu=new RewriteRuleSubtreeStream(adaptor,"rule mu",mu!=null?mu.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 520:31: -> ^( UNARY_MINUS[$m] $mu)
				{
					DebugLocation(520, 34);
					// Hql.g:520:34: ^( UNARY_MINUS[$m] $mu)
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(520, 36);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(UNARY_MINUS, m), root_1);

					DebugLocation(520, 53);
					adaptor.AddChild(root_1, stream_mu.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:521:4: p= PLUS pu= unaryExpression
				{
				DebugLocation(521, 5);
				p=(IToken)Match(input,PLUS,Follow._PLUS_in_unaryExpression2539);  
				stream_PLUS.Add(p);

				DebugLocation(521, 13);
				PushFollow(Follow._unaryExpression_in_unaryExpression2543);
				pu=unaryExpression();
				PopFollow();

				stream_unaryExpression.Add(pu.Tree);


				{
				// AST REWRITE
				// elements: pu
				// token labels: 
				// rule labels: pu, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_pu=new RewriteRuleSubtreeStream(adaptor,"rule pu",pu!=null?pu.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 521:30: -> ^( UNARY_PLUS[$p] $pu)
				{
					DebugLocation(521, 33);
					// Hql.g:521:33: ^( UNARY_PLUS[$p] $pu)
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(521, 35);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(UNARY_PLUS, p), root_1);

					DebugLocation(521, 51);
					adaptor.AddChild(root_1, stream_pu.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:522:4: caseExpression
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(522, 4);
				PushFollow(Follow._caseExpression_in_unaryExpression2558);
				caseExpression207=caseExpression();
				PopFollow();

				adaptor.AddChild(root_0, caseExpression207.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Hql.g:523:4: quantifiedExpression
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(523, 4);
				PushFollow(Follow._quantifiedExpression_in_unaryExpression2563);
				quantifiedExpression208=quantifiedExpression();
				PopFollow();

				adaptor.AddChild(root_0, quantifiedExpression208.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Hql.g:524:4: atom
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(524, 4);
				PushFollow(Follow._atom_in_unaryExpression2568);
				atom209=atom();
				PopFollow();

				adaptor.AddChild(root_0, atom209.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpression", 58);
			LeaveRule("unaryExpression", 58);
			LeaveRule_unaryExpression();
		}
		DebugLocation(525, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"

	partial void EnterRule_caseExpression();
	partial void LeaveRule_caseExpression();
	// $ANTLR start "caseExpression"
	// Hql.g:527:1: caseExpression : ( CASE ( whenClause )+ ( elseClause )? END -> ^( CASE ( whenClause )+ ( elseClause )? ) | CASE unaryExpression ( altWhenClause )+ ( elseClause )? END -> ^( CASE2 unaryExpression ( altWhenClause )+ ( elseClause )? ) );
	[GrammarRule("caseExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> caseExpression()
	{
		EnterRule_caseExpression();
		EnterRule("caseExpression", 59);
		TraceIn("caseExpression", 59);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken CASE210 = default(IToken);
		IToken END213 = default(IToken);
		IToken CASE214 = default(IToken);
		IToken END218 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> whenClause211 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> elseClause212 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> unaryExpression215 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> altWhenClause216 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> elseClause217 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode CASE210_tree = default(IASTNode);
		IASTNode END213_tree = default(IASTNode);
		IASTNode CASE214_tree = default(IASTNode);
		IASTNode END218_tree = default(IASTNode);
		RewriteRuleITokenStream stream_CASE=new RewriteRuleITokenStream(adaptor,"token CASE");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_whenClause=new RewriteRuleSubtreeStream(adaptor,"rule whenClause");
		RewriteRuleSubtreeStream stream_elseClause=new RewriteRuleSubtreeStream(adaptor,"rule elseClause");
		RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
		RewriteRuleSubtreeStream stream_altWhenClause=new RewriteRuleSubtreeStream(adaptor,"rule altWhenClause");
		try { DebugEnterRule(GrammarFileName, "caseExpression");
		DebugLocation(527, 1);
		try
		{
			// Hql.g:528:2: ( CASE ( whenClause )+ ( elseClause )? END -> ^( CASE ( whenClause )+ ( elseClause )? ) | CASE unaryExpression ( altWhenClause )+ ( elseClause )? END -> ^( CASE2 unaryExpression ( altWhenClause )+ ( elseClause )? ) )
			int alt80=2;
			try { DebugEnterDecision(80, false);
			int LA80_1 = input.LA(1);

			if ((LA80_1==CASE))
			{
				int LA80_2 = input.LA(2);

				if ((LA80_2==WHEN))
				{
					alt80 = 1;
				}
				else if ((LA80_2==ALL||LA80_2==ANY||LA80_2==AVG||LA80_2==CASE||LA80_2==COLON||LA80_2==COUNT||LA80_2==ELEMENTS||LA80_2==EMPTY||LA80_2==EXISTS||LA80_2==FALSE||LA80_2==IDENT||LA80_2==INDICES||LA80_2==MAX||(LA80_2>=MIN && LA80_2<=MINUS)||(LA80_2>=NULL && LA80_2<=NUM_LONG)||LA80_2==OPEN||(LA80_2>=PARAM && LA80_2<=PLUS)||LA80_2==QUOTED_String||LA80_2==SOME||LA80_2==SUM||LA80_2==TRUE))
				{
					alt80 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 80, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 80, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(80); }
			switch (alt80)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:528:4: CASE ( whenClause )+ ( elseClause )? END
				{
				DebugLocation(528, 4);
				CASE210=(IToken)Match(input,CASE,Follow._CASE_in_caseExpression2580);  
				stream_CASE.Add(CASE210);

				DebugLocation(528, 9);
				// Hql.g:528:9: ( whenClause )+
				int cnt76=0;
				try { DebugEnterSubRule(76);
				while (true)
				{
					int alt76=2;
					try { DebugEnterDecision(76, false);
					int LA76_1 = input.LA(1);

					if ((LA76_1==WHEN))
					{
						alt76 = 1;
					}


					} finally { DebugExitDecision(76); }
					switch (alt76)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:528:10: whenClause
						{
						DebugLocation(528, 10);
						PushFollow(Follow._whenClause_in_caseExpression2583);
						whenClause211=whenClause();
						PopFollow();

						stream_whenClause.Add(whenClause211.Tree);

						}
						break;

					default:
						if (cnt76 >= 1)
							goto loop76;

						EarlyExitException eee76 = new EarlyExitException( 76, input );
						DebugRecognitionException(eee76);
						throw eee76;
					}
					cnt76++;
				}
				loop76:
					;

				} finally { DebugExitSubRule(76); }

				DebugLocation(528, 23);
				// Hql.g:528:23: ( elseClause )?
				int alt77=2;
				try { DebugEnterSubRule(77);
				try { DebugEnterDecision(77, false);
				int LA77_1 = input.LA(1);

				if ((LA77_1==ELSE))
				{
					alt77 = 1;
				}
				} finally { DebugExitDecision(77); }
				switch (alt77)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:528:24: elseClause
					{
					DebugLocation(528, 24);
					PushFollow(Follow._elseClause_in_caseExpression2588);
					elseClause212=elseClause();
					PopFollow();

					stream_elseClause.Add(elseClause212.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(77); }

				DebugLocation(528, 37);
				END213=(IToken)Match(input,END,Follow._END_in_caseExpression2592);  
				stream_END.Add(END213);



				{
				// AST REWRITE
				// elements: CASE, whenClause, elseClause
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 529:3: -> ^( CASE ( whenClause )+ ( elseClause )? )
				{
					DebugLocation(529, 6);
					// Hql.g:529:6: ^( CASE ( whenClause )+ ( elseClause )? )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(529, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot(stream_CASE.NextNode(), root_1);

					DebugLocation(529, 13);
					if (!(stream_whenClause.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_whenClause.HasNext )
					{
						DebugLocation(529, 13);
						adaptor.AddChild(root_1, stream_whenClause.NextTree());

					}
					stream_whenClause.Reset();
					DebugLocation(529, 25);
					// Hql.g:529:25: ( elseClause )?
					if (stream_elseClause.HasNext)
					{
						DebugLocation(529, 25);
						adaptor.AddChild(root_1, stream_elseClause.NextTree());

					}
					stream_elseClause.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:530:4: CASE unaryExpression ( altWhenClause )+ ( elseClause )? END
				{
				DebugLocation(530, 4);
				CASE214=(IToken)Match(input,CASE,Follow._CASE_in_caseExpression2612);  
				stream_CASE.Add(CASE214);

				DebugLocation(530, 9);
				PushFollow(Follow._unaryExpression_in_caseExpression2614);
				unaryExpression215=unaryExpression();
				PopFollow();

				stream_unaryExpression.Add(unaryExpression215.Tree);
				DebugLocation(530, 25);
				// Hql.g:530:25: ( altWhenClause )+
				int cnt78=0;
				try { DebugEnterSubRule(78);
				while (true)
				{
					int alt78=2;
					try { DebugEnterDecision(78, false);
					int LA78_1 = input.LA(1);

					if ((LA78_1==WHEN))
					{
						alt78 = 1;
					}


					} finally { DebugExitDecision(78); }
					switch (alt78)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:530:26: altWhenClause
						{
						DebugLocation(530, 26);
						PushFollow(Follow._altWhenClause_in_caseExpression2617);
						altWhenClause216=altWhenClause();
						PopFollow();

						stream_altWhenClause.Add(altWhenClause216.Tree);

						}
						break;

					default:
						if (cnt78 >= 1)
							goto loop78;

						EarlyExitException eee78 = new EarlyExitException( 78, input );
						DebugRecognitionException(eee78);
						throw eee78;
					}
					cnt78++;
				}
				loop78:
					;

				} finally { DebugExitSubRule(78); }

				DebugLocation(530, 42);
				// Hql.g:530:42: ( elseClause )?
				int alt79=2;
				try { DebugEnterSubRule(79);
				try { DebugEnterDecision(79, false);
				int LA79_1 = input.LA(1);

				if ((LA79_1==ELSE))
				{
					alt79 = 1;
				}
				} finally { DebugExitDecision(79); }
				switch (alt79)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:530:43: elseClause
					{
					DebugLocation(530, 43);
					PushFollow(Follow._elseClause_in_caseExpression2622);
					elseClause217=elseClause();
					PopFollow();

					stream_elseClause.Add(elseClause217.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(79); }

				DebugLocation(530, 56);
				END218=(IToken)Match(input,END,Follow._END_in_caseExpression2626);  
				stream_END.Add(END218);



				{
				// AST REWRITE
				// elements: unaryExpression, altWhenClause, elseClause
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 531:3: -> ^( CASE2 unaryExpression ( altWhenClause )+ ( elseClause )? )
				{
					DebugLocation(531, 6);
					// Hql.g:531:6: ^( CASE2 unaryExpression ( altWhenClause )+ ( elseClause )? )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(531, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(CASE2, "CASE2"), root_1);

					DebugLocation(531, 14);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());
					DebugLocation(531, 30);
					if (!(stream_altWhenClause.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_altWhenClause.HasNext )
					{
						DebugLocation(531, 30);
						adaptor.AddChild(root_1, stream_altWhenClause.NextTree());

					}
					stream_altWhenClause.Reset();
					DebugLocation(531, 45);
					// Hql.g:531:45: ( elseClause )?
					if (stream_elseClause.HasNext)
					{
						DebugLocation(531, 45);
						adaptor.AddChild(root_1, stream_elseClause.NextTree());

					}
					stream_elseClause.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("caseExpression", 59);
			LeaveRule("caseExpression", 59);
			LeaveRule_caseExpression();
		}
		DebugLocation(532, 1);
		} finally { DebugExitRule(GrammarFileName, "caseExpression"); }
		return retval;

	}
	// $ANTLR end "caseExpression"

	partial void EnterRule_whenClause();
	partial void LeaveRule_whenClause();
	// $ANTLR start "whenClause"
	// Hql.g:534:1: whenClause : ( WHEN ^ logicalExpression THEN ! expression ) ;
	[GrammarRule("whenClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> whenClause()
	{
		EnterRule_whenClause();
		EnterRule("whenClause", 60);
		TraceIn("whenClause", 60);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken WHEN219 = default(IToken);
		IToken THEN221 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> logicalExpression220 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression222 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode WHEN219_tree = default(IASTNode);
		IASTNode THEN221_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "whenClause");
		DebugLocation(534, 1);
		try
		{
			// Hql.g:535:2: ( ( WHEN ^ logicalExpression THEN ! expression ) )
			DebugEnterAlt(1);
			// Hql.g:535:4: ( WHEN ^ logicalExpression THEN ! expression )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(535, 4);
			// Hql.g:535:4: ( WHEN ^ logicalExpression THEN ! expression )
			DebugEnterAlt(1);
			// Hql.g:535:5: WHEN ^ logicalExpression THEN ! expression
			{
			DebugLocation(535, 9);
			WHEN219=(IToken)Match(input,WHEN,Follow._WHEN_in_whenClause2655); 
			WHEN219_tree = (IASTNode)adaptor.Create(WHEN219);
			root_0 = (IASTNode)adaptor.BecomeRoot(WHEN219_tree, root_0);
			DebugLocation(535, 11);
			PushFollow(Follow._logicalExpression_in_whenClause2658);
			logicalExpression220=logicalExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalExpression220.Tree);
			DebugLocation(535, 33);
			THEN221=(IToken)Match(input,THEN,Follow._THEN_in_whenClause2660); 
			DebugLocation(535, 35);
			PushFollow(Follow._expression_in_whenClause2663);
			expression222=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression222.Tree);

			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whenClause", 60);
			LeaveRule("whenClause", 60);
			LeaveRule_whenClause();
		}
		DebugLocation(536, 1);
		} finally { DebugExitRule(GrammarFileName, "whenClause"); }
		return retval;

	}
	// $ANTLR end "whenClause"

	partial void EnterRule_altWhenClause();
	partial void LeaveRule_altWhenClause();
	// $ANTLR start "altWhenClause"
	// Hql.g:538:1: altWhenClause : ( WHEN ^ unaryExpression THEN ! expression ) ;
	[GrammarRule("altWhenClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> altWhenClause()
	{
		EnterRule_altWhenClause();
		EnterRule("altWhenClause", 61);
		TraceIn("altWhenClause", 61);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken WHEN223 = default(IToken);
		IToken THEN225 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> unaryExpression224 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression226 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode WHEN223_tree = default(IASTNode);
		IASTNode THEN225_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "altWhenClause");
		DebugLocation(538, 1);
		try
		{
			// Hql.g:539:2: ( ( WHEN ^ unaryExpression THEN ! expression ) )
			DebugEnterAlt(1);
			// Hql.g:539:4: ( WHEN ^ unaryExpression THEN ! expression )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(539, 4);
			// Hql.g:539:4: ( WHEN ^ unaryExpression THEN ! expression )
			DebugEnterAlt(1);
			// Hql.g:539:5: WHEN ^ unaryExpression THEN ! expression
			{
			DebugLocation(539, 9);
			WHEN223=(IToken)Match(input,WHEN,Follow._WHEN_in_altWhenClause2677); 
			WHEN223_tree = (IASTNode)adaptor.Create(WHEN223);
			root_0 = (IASTNode)adaptor.BecomeRoot(WHEN223_tree, root_0);
			DebugLocation(539, 11);
			PushFollow(Follow._unaryExpression_in_altWhenClause2680);
			unaryExpression224=unaryExpression();
			PopFollow();

			adaptor.AddChild(root_0, unaryExpression224.Tree);
			DebugLocation(539, 31);
			THEN225=(IToken)Match(input,THEN,Follow._THEN_in_altWhenClause2682); 
			DebugLocation(539, 33);
			PushFollow(Follow._expression_in_altWhenClause2685);
			expression226=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression226.Tree);

			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("altWhenClause", 61);
			LeaveRule("altWhenClause", 61);
			LeaveRule_altWhenClause();
		}
		DebugLocation(540, 1);
		} finally { DebugExitRule(GrammarFileName, "altWhenClause"); }
		return retval;

	}
	// $ANTLR end "altWhenClause"

	partial void EnterRule_elseClause();
	partial void LeaveRule_elseClause();
	// $ANTLR start "elseClause"
	// Hql.g:542:1: elseClause : ( ELSE ^ expression ) ;
	[GrammarRule("elseClause")]
	private AstParserRuleReturnScope<IASTNode, IToken> elseClause()
	{
		EnterRule_elseClause();
		EnterRule("elseClause", 62);
		TraceIn("elseClause", 62);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken ELSE227 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> expression228 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode ELSE227_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "elseClause");
		DebugLocation(542, 1);
		try
		{
			// Hql.g:543:2: ( ( ELSE ^ expression ) )
			DebugEnterAlt(1);
			// Hql.g:543:4: ( ELSE ^ expression )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(543, 4);
			// Hql.g:543:4: ( ELSE ^ expression )
			DebugEnterAlt(1);
			// Hql.g:543:5: ELSE ^ expression
			{
			DebugLocation(543, 9);
			ELSE227=(IToken)Match(input,ELSE,Follow._ELSE_in_elseClause2699); 
			ELSE227_tree = (IASTNode)adaptor.Create(ELSE227);
			root_0 = (IASTNode)adaptor.BecomeRoot(ELSE227_tree, root_0);
			DebugLocation(543, 11);
			PushFollow(Follow._expression_in_elseClause2702);
			expression228=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression228.Tree);

			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("elseClause", 62);
			LeaveRule("elseClause", 62);
			LeaveRule_elseClause();
		}
		DebugLocation(544, 1);
		} finally { DebugExitRule(GrammarFileName, "elseClause"); }
		return retval;

	}
	// $ANTLR end "elseClause"

	partial void EnterRule_quantifiedExpression();
	partial void LeaveRule_quantifiedExpression();
	// $ANTLR start "quantifiedExpression"
	// Hql.g:546:1: quantifiedExpression : ( SOME ^| EXISTS ^| ALL ^| ANY ^) ( identifier | collectionExpr | ( OPEN ! ( subQuery ) CLOSE !) ) ;
	[GrammarRule("quantifiedExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> quantifiedExpression()
	{
		EnterRule_quantifiedExpression();
		EnterRule("quantifiedExpression", 63);
		TraceIn("quantifiedExpression", 63);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken SOME229 = default(IToken);
		IToken EXISTS230 = default(IToken);
		IToken ALL231 = default(IToken);
		IToken ANY232 = default(IToken);
		IToken OPEN235 = default(IToken);
		IToken CLOSE237 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> identifier233 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> collectionExpr234 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> subQuery236 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode SOME229_tree = default(IASTNode);
		IASTNode EXISTS230_tree = default(IASTNode);
		IASTNode ALL231_tree = default(IASTNode);
		IASTNode ANY232_tree = default(IASTNode);
		IASTNode OPEN235_tree = default(IASTNode);
		IASTNode CLOSE237_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "quantifiedExpression");
		DebugLocation(546, 1);
		try
		{
			// Hql.g:547:2: ( ( SOME ^| EXISTS ^| ALL ^| ANY ^) ( identifier | collectionExpr | ( OPEN ! ( subQuery ) CLOSE !) ) )
			DebugEnterAlt(1);
			// Hql.g:547:4: ( SOME ^| EXISTS ^| ALL ^| ANY ^) ( identifier | collectionExpr | ( OPEN ! ( subQuery ) CLOSE !) )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(547, 4);
			// Hql.g:547:4: ( SOME ^| EXISTS ^| ALL ^| ANY ^)
			int alt81=4;
			try { DebugEnterSubRule(81);
			try { DebugEnterDecision(81, false);
			switch (input.LA(1))
			{
			case SOME:
				{
				alt81 = 1;
				}
				break;
			case EXISTS:
				{
				alt81 = 2;
				}
				break;
			case ALL:
				{
				alt81 = 3;
				}
				break;
			case ANY:
				{
				alt81 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 81, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(81); }
			switch (alt81)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:547:6: SOME ^
				{
				DebugLocation(547, 10);
				SOME229=(IToken)Match(input,SOME,Follow._SOME_in_quantifiedExpression2717); 
				SOME229_tree = (IASTNode)adaptor.Create(SOME229);
				root_0 = (IASTNode)adaptor.BecomeRoot(SOME229_tree, root_0);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:547:14: EXISTS ^
				{
				DebugLocation(547, 20);
				EXISTS230=(IToken)Match(input,EXISTS,Follow._EXISTS_in_quantifiedExpression2722); 
				EXISTS230_tree = (IASTNode)adaptor.Create(EXISTS230);
				root_0 = (IASTNode)adaptor.BecomeRoot(EXISTS230_tree, root_0);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:547:24: ALL ^
				{
				DebugLocation(547, 27);
				ALL231=(IToken)Match(input,ALL,Follow._ALL_in_quantifiedExpression2727); 
				ALL231_tree = (IASTNode)adaptor.Create(ALL231);
				root_0 = (IASTNode)adaptor.BecomeRoot(ALL231_tree, root_0);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Hql.g:547:31: ANY ^
				{
				DebugLocation(547, 34);
				ANY232=(IToken)Match(input,ANY,Follow._ANY_in_quantifiedExpression2732); 
				ANY232_tree = (IASTNode)adaptor.Create(ANY232);
				root_0 = (IASTNode)adaptor.BecomeRoot(ANY232_tree, root_0);

				}
				break;

			}
			} finally { DebugExitSubRule(81); }

			DebugLocation(548, 2);
			// Hql.g:548:2: ( identifier | collectionExpr | ( OPEN ! ( subQuery ) CLOSE !) )
			int alt82=3;
			try { DebugEnterSubRule(82);
			try { DebugEnterDecision(82, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				alt82 = 1;
				}
				break;
			case ELEMENTS:
			case INDICES:
				{
				alt82 = 2;
				}
				break;
			case OPEN:
				{
				alt82 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 82, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(82); }
			switch (alt82)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:548:4: identifier
				{
				DebugLocation(548, 4);
				PushFollow(Follow._identifier_in_quantifiedExpression2741);
				identifier233=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier233.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:548:17: collectionExpr
				{
				DebugLocation(548, 17);
				PushFollow(Follow._collectionExpr_in_quantifiedExpression2745);
				collectionExpr234=collectionExpr();
				PopFollow();

				adaptor.AddChild(root_0, collectionExpr234.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:548:34: ( OPEN ! ( subQuery ) CLOSE !)
				{
				DebugLocation(548, 34);
				// Hql.g:548:34: ( OPEN ! ( subQuery ) CLOSE !)
				DebugEnterAlt(1);
				// Hql.g:548:35: OPEN ! ( subQuery ) CLOSE !
				{
				DebugLocation(548, 39);
				OPEN235=(IToken)Match(input,OPEN,Follow._OPEN_in_quantifiedExpression2750); 
				DebugLocation(548, 41);
				// Hql.g:548:41: ( subQuery )
				DebugEnterAlt(1);
				// Hql.g:548:43: subQuery
				{
				DebugLocation(548, 43);
				PushFollow(Follow._subQuery_in_quantifiedExpression2755);
				subQuery236=subQuery();
				PopFollow();

				adaptor.AddChild(root_0, subQuery236.Tree);

				}

				DebugLocation(548, 59);
				CLOSE237=(IToken)Match(input,CLOSE,Follow._CLOSE_in_quantifiedExpression2759); 

				}


				}
				break;

			}
			} finally { DebugExitSubRule(82); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("quantifiedExpression", 63);
			LeaveRule("quantifiedExpression", 63);
			LeaveRule_quantifiedExpression();
		}
		DebugLocation(549, 1);
		} finally { DebugExitRule(GrammarFileName, "quantifiedExpression"); }
		return retval;

	}
	// $ANTLR end "quantifiedExpression"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();
	// $ANTLR start "atom"
	// Hql.g:554:1: atom : primaryExpression ( DOT ^ identifier ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )? |lb= OPEN_BRACKET ^ expression CLOSE_BRACKET !)* ;
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<IASTNode, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 64);
		TraceIn("atom", 64);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken op = default(IToken);
		IToken lb = default(IToken);
		IToken DOT239 = default(IToken);
		IToken CLOSE242 = default(IToken);
		IToken CLOSE_BRACKET244 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> primaryExpression238 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> identifier240 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> exprList241 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression243 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode op_tree = default(IASTNode);
		IASTNode lb_tree = default(IASTNode);
		IASTNode DOT239_tree = default(IASTNode);
		IASTNode CLOSE242_tree = default(IASTNode);
		IASTNode CLOSE_BRACKET244_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(554, 1);
		try
		{
			// Hql.g:555:3: ( primaryExpression ( DOT ^ identifier ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )? |lb= OPEN_BRACKET ^ expression CLOSE_BRACKET !)* )
			DebugEnterAlt(1);
			// Hql.g:555:5: primaryExpression ( DOT ^ identifier ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )? |lb= OPEN_BRACKET ^ expression CLOSE_BRACKET !)*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(555, 5);
			PushFollow(Follow._primaryExpression_in_atom2778);
			primaryExpression238=primaryExpression();
			PopFollow();

			adaptor.AddChild(root_0, primaryExpression238.Tree);
			DebugLocation(556, 3);
			// Hql.g:556:3: ( DOT ^ identifier ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )? |lb= OPEN_BRACKET ^ expression CLOSE_BRACKET !)*
			try { DebugEnterSubRule(84);
			while (true)
			{
				int alt84=3;
				try { DebugEnterDecision(84, false);
				int LA84_1 = input.LA(1);

				if ((LA84_1==DOT))
				{
					alt84 = 1;
				}
				else if ((LA84_1==OPEN_BRACKET))
				{
					alt84 = 2;
				}


				} finally { DebugExitDecision(84); }
				switch ( alt84 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:557:4: DOT ^ identifier ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )?
					{
					DebugLocation(557, 7);
					DOT239=(IToken)Match(input,DOT,Follow._DOT_in_atom2787); 
					DOT239_tree = (IASTNode)adaptor.Create(DOT239);
					root_0 = (IASTNode)adaptor.BecomeRoot(DOT239_tree, root_0);
					DebugLocation(557, 9);
					PushFollow(Follow._identifier_in_atom2790);
					identifier240=identifier();
					PopFollow();

					adaptor.AddChild(root_0, identifier240.Tree);
					DebugLocation(558, 5);
					// Hql.g:558:5: ( options {greedy=true; } : (op= OPEN ^ exprList CLOSE !) )?
					int alt83=2;
					try { DebugEnterSubRule(83);
					try { DebugEnterDecision(83, false);
					int LA83_1 = input.LA(1);

					if ((LA83_1==OPEN))
					{
						alt83 = 1;
					}
					} finally { DebugExitDecision(83); }
					switch (alt83)
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:559:6: (op= OPEN ^ exprList CLOSE !)
						{
						DebugLocation(559, 6);
						// Hql.g:559:6: (op= OPEN ^ exprList CLOSE !)
						DebugEnterAlt(1);
						// Hql.g:559:8: op= OPEN ^ exprList CLOSE !
						{
						DebugLocation(559, 10);
						op=(IToken)Match(input,OPEN,Follow._OPEN_in_atom2818); 
						op_tree = (IASTNode)adaptor.Create(op);
						root_0 = (IASTNode)adaptor.BecomeRoot(op_tree, root_0);
						DebugLocation(559, 17);
						op.Type = METHOD_CALL; 
						DebugLocation(559, 44);
						PushFollow(Follow._exprList_in_atom2823);
						exprList241=exprList();
						PopFollow();

						adaptor.AddChild(root_0, exprList241.Tree);
						DebugLocation(559, 58);
						CLOSE242=(IToken)Match(input,CLOSE,Follow._CLOSE_in_atom2825); 

						}


						}
						break;

					}
					} finally { DebugExitSubRule(83); }


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:560:5: lb= OPEN_BRACKET ^ expression CLOSE_BRACKET !
					{
					DebugLocation(560, 7);
					lb=(IToken)Match(input,OPEN_BRACKET,Follow._OPEN_BRACKET_in_atom2839); 
					lb_tree = (IASTNode)adaptor.Create(lb);
					root_0 = (IASTNode)adaptor.BecomeRoot(lb_tree, root_0);
					DebugLocation(560, 22);
					lb.Type = INDEX_OP; 
					DebugLocation(560, 46);
					PushFollow(Follow._expression_in_atom2844);
					expression243=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression243.Tree);
					DebugLocation(560, 70);
					CLOSE_BRACKET244=(IToken)Match(input,CLOSE_BRACKET,Follow._CLOSE_BRACKET_in_atom2846); 

					}
					break;

				default:
					goto loop84;
				}
			}

			loop84:
				;

			} finally { DebugExitSubRule(84); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 64);
			LeaveRule("atom", 64);
			LeaveRule_atom();
		}
		DebugLocation(562, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_primaryExpression();
	partial void LeaveRule_primaryExpression();
	// $ANTLR start "primaryExpression"
	// Hql.g:565:1: primaryExpression : ( identPrimary ( options {greedy=true; } : DOT ^ 'class' )? | constant | COLON ^ identifier | OPEN ! ( expressionOrVector | subQuery ) CLOSE !| PARAM ^ ( NUM_INT )? );
	[GrammarRule("primaryExpression")]
	private AstParserRuleReturnScope<IASTNode, IToken> primaryExpression()
	{
		EnterRule_primaryExpression();
		EnterRule("primaryExpression", 65);
		TraceIn("primaryExpression", 65);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken DOT246 = default(IToken);
		IToken string_literal247 = default(IToken);
		IToken COLON249 = default(IToken);
		IToken OPEN251 = default(IToken);
		IToken CLOSE254 = default(IToken);
		IToken PARAM255 = default(IToken);
		IToken NUM_INT256 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> identPrimary245 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> constant248 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> identifier250 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expressionOrVector252 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> subQuery253 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode DOT246_tree = default(IASTNode);
		IASTNode string_literal247_tree = default(IASTNode);
		IASTNode COLON249_tree = default(IASTNode);
		IASTNode OPEN251_tree = default(IASTNode);
		IASTNode CLOSE254_tree = default(IASTNode);
		IASTNode PARAM255_tree = default(IASTNode);
		IASTNode NUM_INT256_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "primaryExpression");
		DebugLocation(565, 1);
		try
		{
			// Hql.g:566:2: ( identPrimary ( options {greedy=true; } : DOT ^ 'class' )? | constant | COLON ^ identifier | OPEN ! ( expressionOrVector | subQuery ) CLOSE !| PARAM ^ ( NUM_INT )? )
			int alt88=5;
			try { DebugEnterDecision(88, false);
			switch (input.LA(1))
			{
			case AVG:
			case COUNT:
			case ELEMENTS:
			case IDENT:
			case INDICES:
			case MAX:
			case MIN:
			case SUM:
				{
				alt88 = 1;
				}
				break;
			case EMPTY:
			case FALSE:
			case NULL:
			case NUM_DECIMAL:
			case NUM_DOUBLE:
			case NUM_FLOAT:
			case NUM_INT:
			case NUM_LONG:
			case QUOTED_String:
			case TRUE:
				{
				alt88 = 2;
				}
				break;
			case COLON:
				{
				alt88 = 3;
				}
				break;
			case OPEN:
				{
				alt88 = 4;
				}
				break;
			case PARAM:
				{
				alt88 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 88, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(88); }
			switch (alt88)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:566:6: identPrimary ( options {greedy=true; } : DOT ^ 'class' )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(566, 6);
				PushFollow(Follow._identPrimary_in_primaryExpression2866);
				identPrimary245=identPrimary();
				PopFollow();

				adaptor.AddChild(root_0, identPrimary245.Tree);
				DebugLocation(566, 19);
				// Hql.g:566:19: ( options {greedy=true; } : DOT ^ 'class' )?
				int alt85=2;
				try { DebugEnterSubRule(85);
				try { DebugEnterDecision(85, false);
				int LA85_1 = input.LA(1);

				if ((LA85_1==DOT))
				{
					int LA85_2 = input.LA(2);

					if ((LA85_2==CLASS))
					{
						alt85 = 1;
					}
				}
				} finally { DebugExitDecision(85); }
				switch (alt85)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:566:46: DOT ^ 'class'
					{
					DebugLocation(566, 49);
					DOT246=(IToken)Match(input,DOT,Follow._DOT_in_primaryExpression2879); 
					DOT246_tree = (IASTNode)adaptor.Create(DOT246);
					root_0 = (IASTNode)adaptor.BecomeRoot(DOT246_tree, root_0);
					DebugLocation(566, 51);
					string_literal247=(IToken)Match(input,CLASS,Follow._CLASS_in_primaryExpression2882); 
					string_literal247_tree = (IASTNode)adaptor.Create(string_literal247);
					adaptor.AddChild(root_0, string_literal247_tree);

					}
					break;

				}
				} finally { DebugExitSubRule(85); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:567:6: constant
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(567, 6);
				PushFollow(Follow._constant_in_primaryExpression2892);
				constant248=constant();
				PopFollow();

				adaptor.AddChild(root_0, constant248.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:568:6: COLON ^ identifier
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(568, 11);
				COLON249=(IToken)Match(input,COLON,Follow._COLON_in_primaryExpression2899); 
				COLON249_tree = (IASTNode)adaptor.Create(COLON249);
				root_0 = (IASTNode)adaptor.BecomeRoot(COLON249_tree, root_0);
				DebugLocation(568, 13);
				PushFollow(Follow._identifier_in_primaryExpression2902);
				identifier250=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier250.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Hql.g:570:6: OPEN ! ( expressionOrVector | subQuery ) CLOSE !
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(570, 10);
				OPEN251=(IToken)Match(input,OPEN,Follow._OPEN_in_primaryExpression2911); 
				DebugLocation(570, 12);
				// Hql.g:570:12: ( expressionOrVector | subQuery )
				int alt86=2;
				try { DebugEnterSubRule(86);
				try { DebugEnterDecision(86, false);
				int LA86_1 = input.LA(1);

				if ((LA86_1==ALL||LA86_1==ANY||LA86_1==AVG||LA86_1==BNOT||LA86_1==CASE||LA86_1==COLON||LA86_1==COUNT||LA86_1==ELEMENTS||LA86_1==EMPTY||LA86_1==EXISTS||LA86_1==FALSE||LA86_1==IDENT||LA86_1==INDICES||LA86_1==MAX||(LA86_1>=MIN && LA86_1<=MINUS)||LA86_1==NOT||(LA86_1>=NULL && LA86_1<=NUM_LONG)||LA86_1==OPEN||(LA86_1>=PARAM && LA86_1<=PLUS)||LA86_1==QUOTED_String||LA86_1==SOME||LA86_1==SUM||LA86_1==TRUE))
				{
					alt86 = 1;
				}
				else if ((LA86_1==EOF||LA86_1==CLOSE||LA86_1==FROM||LA86_1==GROUP||LA86_1==HAVING||LA86_1==ORDER||LA86_1==SELECT||LA86_1==SKIP||LA86_1==TAKE||LA86_1==UNION||LA86_1==WHERE))
				{
					alt86 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 86, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(86); }
				switch (alt86)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:570:13: expressionOrVector
					{
					DebugLocation(570, 13);
					PushFollow(Follow._expressionOrVector_in_primaryExpression2915);
					expressionOrVector252=expressionOrVector();
					PopFollow();

					adaptor.AddChild(root_0, expressionOrVector252.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:570:34: subQuery
					{
					DebugLocation(570, 34);
					PushFollow(Follow._subQuery_in_primaryExpression2919);
					subQuery253=subQuery();
					PopFollow();

					adaptor.AddChild(root_0, subQuery253.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(86); }

				DebugLocation(570, 49);
				CLOSE254=(IToken)Match(input,CLOSE,Follow._CLOSE_in_primaryExpression2922); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Hql.g:571:6: PARAM ^ ( NUM_INT )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(571, 11);
				PARAM255=(IToken)Match(input,PARAM,Follow._PARAM_in_primaryExpression2930); 
				PARAM255_tree = (IASTNode)adaptor.Create(PARAM255);
				root_0 = (IASTNode)adaptor.BecomeRoot(PARAM255_tree, root_0);
				DebugLocation(571, 13);
				// Hql.g:571:13: ( NUM_INT )?
				int alt87=2;
				try { DebugEnterSubRule(87);
				try { DebugEnterDecision(87, false);
				int LA87_1 = input.LA(1);

				if ((LA87_1==NUM_INT))
				{
					alt87 = 1;
				}
				} finally { DebugExitDecision(87); }
				switch (alt87)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:571:14: NUM_INT
					{
					DebugLocation(571, 14);
					NUM_INT256=(IToken)Match(input,NUM_INT,Follow._NUM_INT_in_primaryExpression2934); 
					NUM_INT256_tree = (IASTNode)adaptor.Create(NUM_INT256);
					adaptor.AddChild(root_0, NUM_INT256_tree);

					}
					break;

				}
				} finally { DebugExitSubRule(87); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExpression", 65);
			LeaveRule("primaryExpression", 65);
			LeaveRule_primaryExpression();
		}
		DebugLocation(572, 1);
		} finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
		return retval;

	}
	// $ANTLR end "primaryExpression"

	partial void EnterRule_expressionOrVector();
	partial void LeaveRule_expressionOrVector();
	// $ANTLR start "expressionOrVector"
	// Hql.g:576:1: expressionOrVector : e= expression (v= vectorExpr )? -> {v != null}? ^( VECTOR_EXPR[\"{vector}\"] $e $v) -> $e;
	[GrammarRule("expressionOrVector")]
	private AstParserRuleReturnScope<IASTNode, IToken> expressionOrVector()
	{
		EnterRule_expressionOrVector();
		EnterRule("expressionOrVector", 66);
		TraceIn("expressionOrVector", 66);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> e = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> v = default(AstParserRuleReturnScope<IASTNode, IToken>);

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_vectorExpr=new RewriteRuleSubtreeStream(adaptor,"rule vectorExpr");
		try { DebugEnterRule(GrammarFileName, "expressionOrVector");
		DebugLocation(576, 1);
		try
		{
			// Hql.g:577:2: (e= expression (v= vectorExpr )? -> {v != null}? ^( VECTOR_EXPR[\"{vector}\"] $e $v) -> $e)
			DebugEnterAlt(1);
			// Hql.g:577:4: e= expression (v= vectorExpr )?
			{
			DebugLocation(577, 5);
			PushFollow(Follow._expression_in_expressionOrVector2952);
			e=expression();
			PopFollow();

			stream_expression.Add(e.Tree);
			DebugLocation(577, 17);
			// Hql.g:577:17: (v= vectorExpr )?
			int alt89=2;
			try { DebugEnterSubRule(89);
			try { DebugEnterDecision(89, false);
			int LA89_1 = input.LA(1);

			if ((LA89_1==COMMA))
			{
				alt89 = 1;
			}
			} finally { DebugExitDecision(89); }
			switch (alt89)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:577:19: v= vectorExpr
				{
				DebugLocation(577, 20);
				PushFollow(Follow._vectorExpr_in_expressionOrVector2958);
				v=vectorExpr();
				PopFollow();

				stream_vectorExpr.Add(v.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(89); }



			{
			// AST REWRITE
			// elements: e, v, e
			// token labels: 
			// rule labels: e, v, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.Tree:null);
			RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 578:2: -> {v != null}? ^( VECTOR_EXPR[\"{vector}\"] $e $v)
			if (v != null)
			{
				DebugLocation(578, 18);
				// Hql.g:578:18: ^( VECTOR_EXPR[\"{vector}\"] $e $v)
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(578, 20);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(VECTOR_EXPR, "{vector}"), root_1);

				DebugLocation(578, 45);
				adaptor.AddChild(root_1, stream_e.NextTree());
				DebugLocation(578, 48);
				adaptor.AddChild(root_1, stream_v.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}
			else // 579:2: -> $e
			{
				DebugLocation(579, 6);
				adaptor.AddChild(root_0, stream_e.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressionOrVector", 66);
			LeaveRule("expressionOrVector", 66);
			LeaveRule_expressionOrVector();
		}
		DebugLocation(580, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionOrVector"); }
		return retval;

	}
	// $ANTLR end "expressionOrVector"

	partial void EnterRule_vectorExpr();
	partial void LeaveRule_vectorExpr();
	// $ANTLR start "vectorExpr"
	// Hql.g:582:1: vectorExpr : COMMA ! expression ( COMMA ! expression )* ;
	[GrammarRule("vectorExpr")]
	private AstParserRuleReturnScope<IASTNode, IToken> vectorExpr()
	{
		EnterRule_vectorExpr();
		EnterRule("vectorExpr", 67);
		TraceIn("vectorExpr", 67);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken COMMA257 = default(IToken);
		IToken COMMA259 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> expression258 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression260 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode COMMA257_tree = default(IASTNode);
		IASTNode COMMA259_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "vectorExpr");
		DebugLocation(582, 1);
		try
		{
			// Hql.g:583:2: ( COMMA ! expression ( COMMA ! expression )* )
			DebugEnterAlt(1);
			// Hql.g:583:4: COMMA ! expression ( COMMA ! expression )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(583, 9);
			COMMA257=(IToken)Match(input,COMMA,Follow._COMMA_in_vectorExpr2995); 
			DebugLocation(583, 11);
			PushFollow(Follow._expression_in_vectorExpr2998);
			expression258=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression258.Tree);
			DebugLocation(583, 22);
			// Hql.g:583:22: ( COMMA ! expression )*
			try { DebugEnterSubRule(90);
			while (true)
			{
				int alt90=2;
				try { DebugEnterDecision(90, false);
				int LA90_1 = input.LA(1);

				if ((LA90_1==COMMA))
				{
					alt90 = 1;
				}


				} finally { DebugExitDecision(90); }
				switch ( alt90 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:583:23: COMMA ! expression
					{
					DebugLocation(583, 28);
					COMMA259=(IToken)Match(input,COMMA,Follow._COMMA_in_vectorExpr3001); 
					DebugLocation(583, 30);
					PushFollow(Follow._expression_in_vectorExpr3004);
					expression260=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression260.Tree);

					}
					break;

				default:
					goto loop90;
				}
			}

			loop90:
				;

			} finally { DebugExitSubRule(90); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("vectorExpr", 67);
			LeaveRule("vectorExpr", 67);
			LeaveRule_vectorExpr();
		}
		DebugLocation(584, 1);
		} finally { DebugExitRule(GrammarFileName, "vectorExpr"); }
		return retval;

	}
	// $ANTLR end "vectorExpr"

	partial void EnterRule_identPrimary();
	partial void LeaveRule_identPrimary();
	// $ANTLR start "identPrimary"
	// Hql.g:589:1: identPrimary : ( identifier ( options {greedy=true; } : DOT ^ ( identifier |o= OBJECT ) )* ( (op= OPEN ^ exprList CLOSE !) )? | aggregate );
	[GrammarRule("identPrimary")]
	private AstParserRuleReturnScope<IASTNode, IToken> identPrimary()
	{
		EnterRule_identPrimary();
		EnterRule("identPrimary", 68);
		TraceIn("identPrimary", 68);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken o = default(IToken);
		IToken op = default(IToken);
		IToken DOT262 = default(IToken);
		IToken CLOSE265 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> identifier261 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> identifier263 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> exprList264 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> aggregate266 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode o_tree = default(IASTNode);
		IASTNode op_tree = default(IASTNode);
		IASTNode DOT262_tree = default(IASTNode);
		IASTNode CLOSE265_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "identPrimary");
		DebugLocation(589, 1);
		try
		{
			// Hql.g:590:2: ( identifier ( options {greedy=true; } : DOT ^ ( identifier |o= OBJECT ) )* ( (op= OPEN ^ exprList CLOSE !) )? | aggregate )
			int alt94=2;
			try { DebugEnterDecision(94, false);
			int LA94_1 = input.LA(1);

			if ((LA94_1==IDENT))
			{
				alt94 = 1;
			}
			else if ((LA94_1==AVG||LA94_1==COUNT||LA94_1==ELEMENTS||LA94_1==INDICES||LA94_1==MAX||LA94_1==MIN||LA94_1==SUM))
			{
				alt94 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 94, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(94); }
			switch (alt94)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:590:4: identifier ( options {greedy=true; } : DOT ^ ( identifier |o= OBJECT ) )* ( (op= OPEN ^ exprList CLOSE !) )?
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(590, 4);
				PushFollow(Follow._identifier_in_identPrimary3020);
				identifier261=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier261.Tree);
				DebugLocation(590, 15);
				 HandleDotIdent(); 
				DebugLocation(591, 4);
				// Hql.g:591:4: ( options {greedy=true; } : DOT ^ ( identifier |o= OBJECT ) )*
				try { DebugEnterSubRule(92);
				while (true)
				{
					int alt92=2;
					try { DebugEnterDecision(92, false);
					int LA92_1 = input.LA(1);

					if ((LA92_1==DOT))
					{
						int LA92_2 = input.LA(2);

						if ((LA92_2==IDENT||LA92_2==OBJECT))
						{
							alt92 = 1;
						}


					}


					} finally { DebugExitDecision(92); }
					switch ( alt92 )
					{
					case 1:
						DebugEnterAlt(1);
						// Hql.g:591:31: DOT ^ ( identifier |o= OBJECT )
						{
						DebugLocation(591, 34);
						DOT262=(IToken)Match(input,DOT,Follow._DOT_in_identPrimary3038); 
						DOT262_tree = (IASTNode)adaptor.Create(DOT262);
						root_0 = (IASTNode)adaptor.BecomeRoot(DOT262_tree, root_0);
						DebugLocation(591, 36);
						// Hql.g:591:36: ( identifier |o= OBJECT )
						int alt91=2;
						try { DebugEnterSubRule(91);
						try { DebugEnterDecision(91, false);
						int LA91_1 = input.LA(1);

						if ((LA91_1==IDENT))
						{
							alt91 = 1;
						}
						else if ((LA91_1==OBJECT))
						{
							alt91 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 91, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						} finally { DebugExitDecision(91); }
						switch (alt91)
						{
						case 1:
							DebugEnterAlt(1);
							// Hql.g:591:38: identifier
							{
							DebugLocation(591, 38);
							PushFollow(Follow._identifier_in_identPrimary3043);
							identifier263=identifier();
							PopFollow();

							adaptor.AddChild(root_0, identifier263.Tree);

							}
							break;
						case 2:
							DebugEnterAlt(2);
							// Hql.g:591:51: o= OBJECT
							{
							DebugLocation(591, 52);
							o=(IToken)Match(input,OBJECT,Follow._OBJECT_in_identPrimary3049); 
							o_tree = (IASTNode)adaptor.Create(o);
							adaptor.AddChild(root_0, o_tree);
							DebugLocation(591, 60);
							 o.Type = IDENT; 

							}
							break;

						}
						} finally { DebugExitSubRule(91); }


						}
						break;

					default:
						goto loop92;
					}
				}

				loop92:
					;

				} finally { DebugExitSubRule(92); }

				DebugLocation(592, 4);
				// Hql.g:592:4: ( (op= OPEN ^ exprList CLOSE !) )?
				int alt93=2;
				try { DebugEnterSubRule(93);
				try { DebugEnterDecision(93, false);
				int LA93_1 = input.LA(1);

				if ((LA93_1==OPEN))
				{
					alt93 = 1;
				}
				} finally { DebugExitDecision(93); }
				switch (alt93)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:592:6: (op= OPEN ^ exprList CLOSE !)
					{
					DebugLocation(592, 6);
					// Hql.g:592:6: (op= OPEN ^ exprList CLOSE !)
					DebugEnterAlt(1);
					// Hql.g:592:8: op= OPEN ^ exprList CLOSE !
					{
					DebugLocation(592, 10);
					op=(IToken)Match(input,OPEN,Follow._OPEN_in_identPrimary3067); 
					op_tree = (IASTNode)adaptor.Create(op);
					root_0 = (IASTNode)adaptor.BecomeRoot(op_tree, root_0);
					DebugLocation(592, 17);
					 op.Type = METHOD_CALL;
					DebugLocation(592, 44);
					PushFollow(Follow._exprList_in_identPrimary3072);
					exprList264=exprList();
					PopFollow();

					adaptor.AddChild(root_0, exprList264.Tree);
					DebugLocation(592, 58);
					CLOSE265=(IToken)Match(input,CLOSE,Follow._CLOSE_in_identPrimary3074); 

					}


					}
					break;

				}
				} finally { DebugExitSubRule(93); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:595:4: aggregate
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(595, 4);
				PushFollow(Follow._aggregate_in_identPrimary3090);
				aggregate266=aggregate();
				PopFollow();

				adaptor.AddChild(root_0, aggregate266.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identPrimary", 68);
			LeaveRule("identPrimary", 68);
			LeaveRule_identPrimary();
		}
		DebugLocation(596, 1);
		} finally { DebugExitRule(GrammarFileName, "identPrimary"); }
		return retval;

	}
	// $ANTLR end "identPrimary"

	partial void EnterRule_aggregate();
	partial void LeaveRule_aggregate();
	// $ANTLR start "aggregate"
	// Hql.g:603:1: aggregate : ( (op= SUM |op= AVG |op= MAX |op= MIN ) OPEN additiveExpression CLOSE -> ^( AGGREGATE[$op] additiveExpression ) | COUNT OPEN (s= STAR |p= aggregateDistinctAll ) CLOSE -> {s == null}? ^( COUNT $p) -> ^( COUNT ^( ROW_STAR[\"*\"] ) ) | collectionExpr );
	[GrammarRule("aggregate")]
	private AstParserRuleReturnScope<IASTNode, IToken> aggregate()
	{
		EnterRule_aggregate();
		EnterRule("aggregate", 69);
		TraceIn("aggregate", 69);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken op = default(IToken);
		IToken s = default(IToken);
		IToken OPEN267 = default(IToken);
		IToken CLOSE269 = default(IToken);
		IToken COUNT270 = default(IToken);
		IToken OPEN271 = default(IToken);
		IToken CLOSE272 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> p = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> additiveExpression268 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> collectionExpr273 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode op_tree = default(IASTNode);
		IASTNode s_tree = default(IASTNode);
		IASTNode OPEN267_tree = default(IASTNode);
		IASTNode CLOSE269_tree = default(IASTNode);
		IASTNode COUNT270_tree = default(IASTNode);
		IASTNode OPEN271_tree = default(IASTNode);
		IASTNode CLOSE272_tree = default(IASTNode);
		RewriteRuleITokenStream stream_SUM=new RewriteRuleITokenStream(adaptor,"token SUM");
		RewriteRuleITokenStream stream_AVG=new RewriteRuleITokenStream(adaptor,"token AVG");
		RewriteRuleITokenStream stream_MAX=new RewriteRuleITokenStream(adaptor,"token MAX");
		RewriteRuleITokenStream stream_MIN=new RewriteRuleITokenStream(adaptor,"token MIN");
		RewriteRuleITokenStream stream_OPEN=new RewriteRuleITokenStream(adaptor,"token OPEN");
		RewriteRuleITokenStream stream_CLOSE=new RewriteRuleITokenStream(adaptor,"token CLOSE");
		RewriteRuleITokenStream stream_COUNT=new RewriteRuleITokenStream(adaptor,"token COUNT");
		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
		RewriteRuleSubtreeStream stream_additiveExpression=new RewriteRuleSubtreeStream(adaptor,"rule additiveExpression");
		RewriteRuleSubtreeStream stream_aggregateDistinctAll=new RewriteRuleSubtreeStream(adaptor,"rule aggregateDistinctAll");
		try { DebugEnterRule(GrammarFileName, "aggregate");
		DebugLocation(603, 1);
		try
		{
			// Hql.g:604:2: ( (op= SUM |op= AVG |op= MAX |op= MIN ) OPEN additiveExpression CLOSE -> ^( AGGREGATE[$op] additiveExpression ) | COUNT OPEN (s= STAR |p= aggregateDistinctAll ) CLOSE -> {s == null}? ^( COUNT $p) -> ^( COUNT ^( ROW_STAR[\"*\"] ) ) | collectionExpr )
			int alt97=3;
			try { DebugEnterDecision(97, false);
			switch (input.LA(1))
			{
			case AVG:
			case MAX:
			case MIN:
			case SUM:
				{
				alt97 = 1;
				}
				break;
			case COUNT:
				{
				alt97 = 2;
				}
				break;
			case ELEMENTS:
			case INDICES:
				{
				alt97 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 97, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(97); }
			switch (alt97)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:604:4: (op= SUM |op= AVG |op= MAX |op= MIN ) OPEN additiveExpression CLOSE
				{
				DebugLocation(604, 4);
				// Hql.g:604:4: (op= SUM |op= AVG |op= MAX |op= MIN )
				int alt95=4;
				try { DebugEnterSubRule(95);
				try { DebugEnterDecision(95, false);
				switch (input.LA(1))
				{
				case SUM:
					{
					alt95 = 1;
					}
					break;
				case AVG:
					{
					alt95 = 2;
					}
					break;
				case MAX:
					{
					alt95 = 3;
					}
					break;
				case MIN:
					{
					alt95 = 4;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 95, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(95); }
				switch (alt95)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:604:6: op= SUM
					{
					DebugLocation(604, 8);
					op=(IToken)Match(input,SUM,Follow._SUM_in_aggregate3111);  
					stream_SUM.Add(op);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:604:15: op= AVG
					{
					DebugLocation(604, 17);
					op=(IToken)Match(input,AVG,Follow._AVG_in_aggregate3117);  
					stream_AVG.Add(op);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Hql.g:604:24: op= MAX
					{
					DebugLocation(604, 26);
					op=(IToken)Match(input,MAX,Follow._MAX_in_aggregate3123);  
					stream_MAX.Add(op);


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Hql.g:604:33: op= MIN
					{
					DebugLocation(604, 35);
					op=(IToken)Match(input,MIN,Follow._MIN_in_aggregate3129);  
					stream_MIN.Add(op);


					}
					break;

				}
				} finally { DebugExitSubRule(95); }

				DebugLocation(604, 42);
				OPEN267=(IToken)Match(input,OPEN,Follow._OPEN_in_aggregate3133);  
				stream_OPEN.Add(OPEN267);

				DebugLocation(604, 47);
				PushFollow(Follow._additiveExpression_in_aggregate3135);
				additiveExpression268=additiveExpression();
				PopFollow();

				stream_additiveExpression.Add(additiveExpression268.Tree);
				DebugLocation(604, 66);
				CLOSE269=(IToken)Match(input,CLOSE,Follow._CLOSE_in_aggregate3137);  
				stream_CLOSE.Add(CLOSE269);



				{
				// AST REWRITE
				// elements: additiveExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 605:3: -> ^( AGGREGATE[$op] additiveExpression )
				{
					DebugLocation(605, 6);
					// Hql.g:605:6: ^( AGGREGATE[$op] additiveExpression )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(605, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(AGGREGATE, op), root_1);

					DebugLocation(605, 23);
					adaptor.AddChild(root_1, stream_additiveExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:607:5: COUNT OPEN (s= STAR |p= aggregateDistinctAll ) CLOSE
				{
				DebugLocation(607, 5);
				COUNT270=(IToken)Match(input,COUNT,Follow._COUNT_in_aggregate3156);  
				stream_COUNT.Add(COUNT270);

				DebugLocation(607, 11);
				OPEN271=(IToken)Match(input,OPEN,Follow._OPEN_in_aggregate3158);  
				stream_OPEN.Add(OPEN271);

				DebugLocation(607, 16);
				// Hql.g:607:16: (s= STAR |p= aggregateDistinctAll )
				int alt96=2;
				try { DebugEnterSubRule(96);
				try { DebugEnterDecision(96, false);
				int LA96_1 = input.LA(1);

				if ((LA96_1==STAR))
				{
					alt96 = 1;
				}
				else if ((LA96_1==ALL||LA96_1==DISTINCT||LA96_1==ELEMENTS||LA96_1==IDENT||LA96_1==INDICES))
				{
					alt96 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 96, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(96); }
				switch (alt96)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:607:18: s= STAR
					{
					DebugLocation(607, 19);
					s=(IToken)Match(input,STAR,Follow._STAR_in_aggregate3164);  
					stream_STAR.Add(s);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:607:27: p= aggregateDistinctAll
					{
					DebugLocation(607, 28);
					PushFollow(Follow._aggregateDistinctAll_in_aggregate3170);
					p=aggregateDistinctAll();
					PopFollow();

					stream_aggregateDistinctAll.Add(p.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(96); }

				DebugLocation(607, 52);
				CLOSE272=(IToken)Match(input,CLOSE,Follow._CLOSE_in_aggregate3174);  
				stream_CLOSE.Add(CLOSE272);



				{
				// AST REWRITE
				// elements: COUNT, p, COUNT
				// token labels: 
				// rule labels: p, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (IASTNode)adaptor.Nil();
				// 608:3: -> {s == null}? ^( COUNT $p)
				if (s == null)
				{
					DebugLocation(608, 19);
					// Hql.g:608:19: ^( COUNT $p)
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(608, 21);
					root_1 = (IASTNode)adaptor.BecomeRoot(stream_COUNT.NextNode(), root_1);

					DebugLocation(608, 28);
					adaptor.AddChild(root_1, stream_p.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 609:3: -> ^( COUNT ^( ROW_STAR[\"*\"] ) )
				{
					DebugLocation(609, 6);
					// Hql.g:609:6: ^( COUNT ^( ROW_STAR[\"*\"] ) )
					{
					IASTNode root_1 = (IASTNode)adaptor.Nil();
					DebugLocation(609, 8);
					root_1 = (IASTNode)adaptor.BecomeRoot(stream_COUNT.NextNode(), root_1);

					DebugLocation(609, 14);
					// Hql.g:609:14: ^( ROW_STAR[\"*\"] )
					{
					IASTNode root_2 = (IASTNode)adaptor.Nil();
					DebugLocation(609, 16);
					root_2 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(ROW_STAR, "*"), root_2);

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:610:5: collectionExpr
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(610, 5);
				PushFollow(Follow._collectionExpr_in_aggregate3206);
				collectionExpr273=collectionExpr();
				PopFollow();

				adaptor.AddChild(root_0, collectionExpr273.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("aggregate", 69);
			LeaveRule("aggregate", 69);
			LeaveRule_aggregate();
		}
		DebugLocation(611, 1);
		} finally { DebugExitRule(GrammarFileName, "aggregate"); }
		return retval;

	}
	// $ANTLR end "aggregate"

	partial void EnterRule_aggregateDistinctAll();
	partial void LeaveRule_aggregateDistinctAll();
	// $ANTLR start "aggregateDistinctAll"
	// Hql.g:613:1: aggregateDistinctAll : ( ( DISTINCT | ALL )? ( path | collectionExpr ) ) ;
	[GrammarRule("aggregateDistinctAll")]
	private AstParserRuleReturnScope<IASTNode, IToken> aggregateDistinctAll()
	{
		EnterRule_aggregateDistinctAll();
		EnterRule("aggregateDistinctAll", 70);
		TraceIn("aggregateDistinctAll", 70);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken set274 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> path275 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> collectionExpr276 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode set274_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "aggregateDistinctAll");
		DebugLocation(613, 1);
		try
		{
			// Hql.g:614:2: ( ( ( DISTINCT | ALL )? ( path | collectionExpr ) ) )
			DebugEnterAlt(1);
			// Hql.g:614:4: ( ( DISTINCT | ALL )? ( path | collectionExpr ) )
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(614, 4);
			// Hql.g:614:4: ( ( DISTINCT | ALL )? ( path | collectionExpr ) )
			DebugEnterAlt(1);
			// Hql.g:614:6: ( DISTINCT | ALL )? ( path | collectionExpr )
			{
			DebugLocation(614, 6);
			// Hql.g:614:6: ( DISTINCT | ALL )?
			int alt98=2;
			try { DebugEnterSubRule(98);
			try { DebugEnterDecision(98, false);
			int LA98_1 = input.LA(1);

			if ((LA98_1==ALL||LA98_1==DISTINCT))
			{
				alt98 = 1;
			}
			} finally { DebugExitDecision(98); }
			switch (alt98)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:
				{
				DebugLocation(614, 6);

				set274=(IToken)input.LT(1);
				if (input.LA(1)==ALL||input.LA(1)==DISTINCT)
				{
					input.Consume();
					adaptor.AddChild(root_0, (IASTNode)adaptor.Create(set274));
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(98); }

			DebugLocation(614, 26);
			// Hql.g:614:26: ( path | collectionExpr )
			int alt99=2;
			try { DebugEnterSubRule(99);
			try { DebugEnterDecision(99, false);
			int LA99_1 = input.LA(1);

			if ((LA99_1==IDENT))
			{
				alt99 = 1;
			}
			else if ((LA99_1==ELEMENTS||LA99_1==INDICES))
			{
				alt99 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 99, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(99); }
			switch (alt99)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:614:28: path
				{
				DebugLocation(614, 28);
				PushFollow(Follow._path_in_aggregateDistinctAll3232);
				path275=path();
				PopFollow();

				adaptor.AddChild(root_0, path275.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:614:35: collectionExpr
				{
				DebugLocation(614, 35);
				PushFollow(Follow._collectionExpr_in_aggregateDistinctAll3236);
				collectionExpr276=collectionExpr();
				PopFollow();

				adaptor.AddChild(root_0, collectionExpr276.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(99); }


			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("aggregateDistinctAll", 70);
			LeaveRule("aggregateDistinctAll", 70);
			LeaveRule_aggregateDistinctAll();
		}
		DebugLocation(615, 1);
		} finally { DebugExitRule(GrammarFileName, "aggregateDistinctAll"); }
		return retval;

	}
	// $ANTLR end "aggregateDistinctAll"

	partial void EnterRule_collectionExpr();
	partial void LeaveRule_collectionExpr();
	// $ANTLR start "collectionExpr"
	// Hql.g:619:1: collectionExpr : ( ELEMENTS ^| INDICES ^) OPEN ! path CLOSE !;
	[GrammarRule("collectionExpr")]
	private AstParserRuleReturnScope<IASTNode, IToken> collectionExpr()
	{
		EnterRule_collectionExpr();
		EnterRule("collectionExpr", 71);
		TraceIn("collectionExpr", 71);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken ELEMENTS277 = default(IToken);
		IToken INDICES278 = default(IToken);
		IToken OPEN279 = default(IToken);
		IToken CLOSE281 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> path280 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode ELEMENTS277_tree = default(IASTNode);
		IASTNode INDICES278_tree = default(IASTNode);
		IASTNode OPEN279_tree = default(IASTNode);
		IASTNode CLOSE281_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "collectionExpr");
		DebugLocation(619, 1);
		try
		{
			// Hql.g:620:2: ( ( ELEMENTS ^| INDICES ^) OPEN ! path CLOSE !)
			DebugEnterAlt(1);
			// Hql.g:620:4: ( ELEMENTS ^| INDICES ^) OPEN ! path CLOSE !
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(620, 4);
			// Hql.g:620:4: ( ELEMENTS ^| INDICES ^)
			int alt100=2;
			try { DebugEnterSubRule(100);
			try { DebugEnterDecision(100, false);
			int LA100_1 = input.LA(1);

			if ((LA100_1==ELEMENTS))
			{
				alt100 = 1;
			}
			else if ((LA100_1==INDICES))
			{
				alt100 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 100, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(100); }
			switch (alt100)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:620:5: ELEMENTS ^
				{
				DebugLocation(620, 13);
				ELEMENTS277=(IToken)Match(input,ELEMENTS,Follow._ELEMENTS_in_collectionExpr3255); 
				ELEMENTS277_tree = (IASTNode)adaptor.Create(ELEMENTS277);
				root_0 = (IASTNode)adaptor.BecomeRoot(ELEMENTS277_tree, root_0);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:620:17: INDICES ^
				{
				DebugLocation(620, 24);
				INDICES278=(IToken)Match(input,INDICES,Follow._INDICES_in_collectionExpr3260); 
				INDICES278_tree = (IASTNode)adaptor.Create(INDICES278);
				root_0 = (IASTNode)adaptor.BecomeRoot(INDICES278_tree, root_0);

				}
				break;

			}
			} finally { DebugExitSubRule(100); }

			DebugLocation(620, 31);
			OPEN279=(IToken)Match(input,OPEN,Follow._OPEN_in_collectionExpr3264); 
			DebugLocation(620, 33);
			PushFollow(Follow._path_in_collectionExpr3267);
			path280=path();
			PopFollow();

			adaptor.AddChild(root_0, path280.Tree);
			DebugLocation(620, 43);
			CLOSE281=(IToken)Match(input,CLOSE,Follow._CLOSE_in_collectionExpr3269); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("collectionExpr", 71);
			LeaveRule("collectionExpr", 71);
			LeaveRule_collectionExpr();
		}
		DebugLocation(621, 1);
		} finally { DebugExitRule(GrammarFileName, "collectionExpr"); }
		return retval;

	}
	// $ANTLR end "collectionExpr"

	partial void EnterRule_compoundExpr();
	partial void LeaveRule_compoundExpr();
	// $ANTLR start "compoundExpr"
	// Hql.g:623:1: compoundExpr : ( collectionExpr | path | ( OPEN ! ( subQuery | ( expression ( COMMA ! expression )* ) ) CLOSE !) );
	[GrammarRule("compoundExpr")]
	private AstParserRuleReturnScope<IASTNode, IToken> compoundExpr()
	{
		EnterRule_compoundExpr();
		EnterRule("compoundExpr", 72);
		TraceIn("compoundExpr", 72);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken OPEN284 = default(IToken);
		IToken COMMA287 = default(IToken);
		IToken CLOSE289 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> collectionExpr282 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> path283 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> subQuery285 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression286 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression288 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode OPEN284_tree = default(IASTNode);
		IASTNode COMMA287_tree = default(IASTNode);
		IASTNode CLOSE289_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "compoundExpr");
		DebugLocation(623, 1);
		try
		{
			// Hql.g:624:2: ( collectionExpr | path | ( OPEN ! ( subQuery | ( expression ( COMMA ! expression )* ) ) CLOSE !) )
			int alt103=3;
			try { DebugEnterDecision(103, false);
			switch (input.LA(1))
			{
			case ELEMENTS:
			case INDICES:
				{
				alt103 = 1;
				}
				break;
			case IDENT:
				{
				alt103 = 2;
				}
				break;
			case OPEN:
				{
				alt103 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 103, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(103); }
			switch (alt103)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:624:4: collectionExpr
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(624, 4);
				PushFollow(Follow._collectionExpr_in_compoundExpr3324);
				collectionExpr282=collectionExpr();
				PopFollow();

				adaptor.AddChild(root_0, collectionExpr282.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:625:4: path
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(625, 4);
				PushFollow(Follow._path_in_compoundExpr3329);
				path283=path();
				PopFollow();

				adaptor.AddChild(root_0, path283.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:626:4: ( OPEN ! ( subQuery | ( expression ( COMMA ! expression )* ) ) CLOSE !)
				{
				root_0 = (IASTNode)adaptor.Nil();

				DebugLocation(626, 4);
				// Hql.g:626:4: ( OPEN ! ( subQuery | ( expression ( COMMA ! expression )* ) ) CLOSE !)
				DebugEnterAlt(1);
				// Hql.g:626:5: OPEN ! ( subQuery | ( expression ( COMMA ! expression )* ) ) CLOSE !
				{
				DebugLocation(626, 9);
				OPEN284=(IToken)Match(input,OPEN,Follow._OPEN_in_compoundExpr3335); 
				DebugLocation(626, 11);
				// Hql.g:626:11: ( subQuery | ( expression ( COMMA ! expression )* ) )
				int alt102=2;
				try { DebugEnterSubRule(102);
				try { DebugEnterDecision(102, false);
				int LA102_1 = input.LA(1);

				if ((LA102_1==EOF||LA102_1==CLOSE||LA102_1==FROM||LA102_1==GROUP||LA102_1==HAVING||LA102_1==ORDER||LA102_1==SELECT||LA102_1==SKIP||LA102_1==TAKE||LA102_1==UNION||LA102_1==WHERE))
				{
					alt102 = 1;
				}
				else if ((LA102_1==ALL||LA102_1==ANY||LA102_1==AVG||LA102_1==BNOT||LA102_1==CASE||LA102_1==COLON||LA102_1==COUNT||LA102_1==ELEMENTS||LA102_1==EMPTY||LA102_1==EXISTS||LA102_1==FALSE||LA102_1==IDENT||LA102_1==INDICES||LA102_1==MAX||(LA102_1>=MIN && LA102_1<=MINUS)||LA102_1==NOT||(LA102_1>=NULL && LA102_1<=NUM_LONG)||LA102_1==OPEN||(LA102_1>=PARAM && LA102_1<=PLUS)||LA102_1==QUOTED_String||LA102_1==SOME||LA102_1==SUM||LA102_1==TRUE))
				{
					alt102 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 102, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(102); }
				switch (alt102)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:626:13: subQuery
					{
					DebugLocation(626, 13);
					PushFollow(Follow._subQuery_in_compoundExpr3340);
					subQuery285=subQuery();
					PopFollow();

					adaptor.AddChild(root_0, subQuery285.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:626:24: ( expression ( COMMA ! expression )* )
					{
					DebugLocation(626, 24);
					// Hql.g:626:24: ( expression ( COMMA ! expression )* )
					DebugEnterAlt(1);
					// Hql.g:626:25: expression ( COMMA ! expression )*
					{
					DebugLocation(626, 25);
					PushFollow(Follow._expression_in_compoundExpr3345);
					expression286=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression286.Tree);
					DebugLocation(626, 36);
					// Hql.g:626:36: ( COMMA ! expression )*
					try { DebugEnterSubRule(101);
					while (true)
					{
						int alt101=2;
						try { DebugEnterDecision(101, false);
						int LA101_1 = input.LA(1);

						if ((LA101_1==COMMA))
						{
							alt101 = 1;
						}


						} finally { DebugExitDecision(101); }
						switch ( alt101 )
						{
						case 1:
							DebugEnterAlt(1);
							// Hql.g:626:37: COMMA ! expression
							{
							DebugLocation(626, 42);
							COMMA287=(IToken)Match(input,COMMA,Follow._COMMA_in_compoundExpr3348); 
							DebugLocation(626, 44);
							PushFollow(Follow._expression_in_compoundExpr3351);
							expression288=expression();
							PopFollow();

							adaptor.AddChild(root_0, expression288.Tree);

							}
							break;

						default:
							goto loop101;
						}
					}

					loop101:
						;

					} finally { DebugExitSubRule(101); }


					}


					}
					break;

				}
				} finally { DebugExitSubRule(102); }

				DebugLocation(626, 65);
				CLOSE289=(IToken)Match(input,CLOSE,Follow._CLOSE_in_compoundExpr3358); 

				}


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("compoundExpr", 72);
			LeaveRule("compoundExpr", 72);
			LeaveRule_compoundExpr();
		}
		DebugLocation(627, 1);
		} finally { DebugExitRule(GrammarFileName, "compoundExpr"); }
		return retval;

	}
	// $ANTLR end "compoundExpr"

	partial void EnterRule_exprList();
	partial void LeaveRule_exprList();
	// $ANTLR start "exprList"
	// Hql.g:629:1: exprList : ( TRAILING | LEADING | BOTH )? ( expression ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )? |f2= FROM expression )? ;
	[GrammarRule("exprList")]
	private AstParserRuleReturnScope<IASTNode, IToken> exprList()
	{
		EnterRule_exprList();
		EnterRule("exprList", 73);
		TraceIn("exprList", 73);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken f = default(IToken);
		IToken f2 = default(IToken);
		IToken TRAILING290 = default(IToken);
		IToken LEADING291 = default(IToken);
		IToken BOTH292 = default(IToken);
		IToken COMMA294 = default(IToken);
		IToken AS297 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> expression293 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression295 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression296 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> identifier298 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> expression299 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode f_tree = default(IASTNode);
		IASTNode f2_tree = default(IASTNode);
		IASTNode TRAILING290_tree = default(IASTNode);
		IASTNode LEADING291_tree = default(IASTNode);
		IASTNode BOTH292_tree = default(IASTNode);
		IASTNode COMMA294_tree = default(IASTNode);
		IASTNode AS297_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "exprList");
		DebugLocation(629, 1);
		try
		{
			// Hql.g:635:2: ( ( TRAILING | LEADING | BOTH )? ( expression ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )? |f2= FROM expression )? )
			DebugEnterAlt(1);
			// Hql.g:635:4: ( TRAILING | LEADING | BOTH )? ( expression ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )? |f2= FROM expression )?
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(635, 4);
			// Hql.g:635:4: ( TRAILING | LEADING | BOTH )?
			int alt104=4;
			try { DebugEnterSubRule(104);
			try { DebugEnterDecision(104, false);
			switch (input.LA(1))
			{
			case TRAILING:
				{
				alt104 = 1;
				}
				break;
			case LEADING:
				{
				alt104 = 2;
				}
				break;
			case BOTH:
				{
				alt104 = 3;
				}
				break;
			}

			} finally { DebugExitDecision(104); }
			switch (alt104)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:635:5: TRAILING
				{
				DebugLocation(635, 5);
				TRAILING290=(IToken)Match(input,TRAILING,Follow._TRAILING_in_exprList3377); 
				TRAILING290_tree = (IASTNode)adaptor.Create(TRAILING290);
				adaptor.AddChild(root_0, TRAILING290_tree);
				DebugLocation(635, 14);
				TRAILING290.Type = IDENT;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:636:10: LEADING
				{
				DebugLocation(636, 10);
				LEADING291=(IToken)Match(input,LEADING,Follow._LEADING_in_exprList3390); 
				LEADING291_tree = (IASTNode)adaptor.Create(LEADING291);
				adaptor.AddChild(root_0, LEADING291_tree);
				DebugLocation(636, 18);
				LEADING291.Type = IDENT;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Hql.g:637:10: BOTH
				{
				DebugLocation(637, 10);
				BOTH292=(IToken)Match(input,BOTH,Follow._BOTH_in_exprList3403); 
				BOTH292_tree = (IASTNode)adaptor.Create(BOTH292);
				adaptor.AddChild(root_0, BOTH292_tree);
				DebugLocation(637, 15);
				BOTH292.Type = IDENT;

				}
				break;

			}
			} finally { DebugExitSubRule(104); }

			DebugLocation(639, 4);
			// Hql.g:639:4: ( expression ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )? |f2= FROM expression )?
			int alt107=3;
			try { DebugEnterSubRule(107);
			try { DebugEnterDecision(107, false);
			int LA107_1 = input.LA(1);

			if ((LA107_1==ALL||LA107_1==ANY||LA107_1==AVG||LA107_1==BNOT||LA107_1==CASE||LA107_1==COLON||LA107_1==COUNT||LA107_1==ELEMENTS||LA107_1==EMPTY||LA107_1==EXISTS||LA107_1==FALSE||LA107_1==IDENT||LA107_1==INDICES||LA107_1==MAX||(LA107_1>=MIN && LA107_1<=MINUS)||LA107_1==NOT||(LA107_1>=NULL && LA107_1<=NUM_LONG)||LA107_1==OPEN||(LA107_1>=PARAM && LA107_1<=PLUS)||LA107_1==QUOTED_String||LA107_1==SOME||LA107_1==SUM||LA107_1==TRUE))
			{
				alt107 = 1;
			}
			else if ((LA107_1==FROM))
			{
				alt107 = 2;
			}
			} finally { DebugExitDecision(107); }
			switch (alt107)
			{
			case 1:
				DebugEnterAlt(1);
				// Hql.g:640:5: expression ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )?
				{
				DebugLocation(640, 5);
				PushFollow(Follow._expression_in_exprList3427);
				expression293=expression();
				PopFollow();

				adaptor.AddChild(root_0, expression293.Tree);
				DebugLocation(640, 16);
				// Hql.g:640:16: ( ( COMMA ! expression )+ |f= FROM expression | AS ! identifier )?
				int alt106=4;
				try { DebugEnterSubRule(106);
				try { DebugEnterDecision(106, false);
				switch (input.LA(1))
				{
				case COMMA:
					{
					alt106 = 1;
					}
					break;
				case FROM:
					{
					alt106 = 2;
					}
					break;
				case AS:
					{
					alt106 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(106); }
				switch (alt106)
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:640:18: ( COMMA ! expression )+
					{
					DebugLocation(640, 18);
					// Hql.g:640:18: ( COMMA ! expression )+
					int cnt105=0;
					try { DebugEnterSubRule(105);
					while (true)
					{
						int alt105=2;
						try { DebugEnterDecision(105, false);
						int LA105_1 = input.LA(1);

						if ((LA105_1==COMMA))
						{
							alt105 = 1;
						}


						} finally { DebugExitDecision(105); }
						switch (alt105)
						{
						case 1:
							DebugEnterAlt(1);
							// Hql.g:640:19: COMMA ! expression
							{
							DebugLocation(640, 24);
							COMMA294=(IToken)Match(input,COMMA,Follow._COMMA_in_exprList3432); 
							DebugLocation(640, 26);
							PushFollow(Follow._expression_in_exprList3435);
							expression295=expression();
							PopFollow();

							adaptor.AddChild(root_0, expression295.Tree);

							}
							break;

						default:
							if (cnt105 >= 1)
								goto loop105;

							EarlyExitException eee105 = new EarlyExitException( 105, input );
							DebugRecognitionException(eee105);
							throw eee105;
						}
						cnt105++;
					}
					loop105:
						;

					} finally { DebugExitSubRule(105); }


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Hql.g:641:9: f= FROM expression
					{
					DebugLocation(641, 10);
					f=(IToken)Match(input,FROM,Follow._FROM_in_exprList3450); 
					f_tree = (IASTNode)adaptor.Create(f);
					adaptor.AddChild(root_0, f_tree);
					DebugLocation(641, 16);
					PushFollow(Follow._expression_in_exprList3452);
					expression296=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression296.Tree);
					DebugLocation(641, 27);
					f.Type = IDENT;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Hql.g:642:9: AS ! identifier
					{
					DebugLocation(642, 11);
					AS297=(IToken)Match(input,AS,Follow._AS_in_exprList3464); 
					DebugLocation(642, 13);
					PushFollow(Follow._identifier_in_exprList3467);
					identifier298=identifier();
					PopFollow();

					adaptor.AddChild(root_0, identifier298.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(106); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Hql.g:643:7: f2= FROM expression
				{
				DebugLocation(643, 9);
				f2=(IToken)Match(input,FROM,Follow._FROM_in_exprList3481); 
				f2_tree = (IASTNode)adaptor.Create(f2);
				adaptor.AddChild(root_0, f2_tree);
				DebugLocation(643, 15);
				PushFollow(Follow._expression_in_exprList3483);
				expression299=expression();
				PopFollow();

				adaptor.AddChild(root_0, expression299.Tree);
				DebugLocation(643, 26);
				f2.Type = IDENT;

				}
				break;

			}
			} finally { DebugExitSubRule(107); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);


			   IASTNode root = (IASTNode) adaptor.Create(EXPR_LIST, "exprList");
			   root.AddChild((IASTNode)retval.Tree);
			   retval.Tree = root;

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exprList", 73);
			LeaveRule("exprList", 73);
			LeaveRule_exprList();
		}
		DebugLocation(645, 1);
		} finally { DebugExitRule(GrammarFileName, "exprList"); }
		return retval;

	}
	// $ANTLR end "exprList"

	partial void EnterRule_subQuery();
	partial void LeaveRule_subQuery();
	// $ANTLR start "subQuery"
	// Hql.g:647:1: subQuery : innerSubQuery ( UNION ^ innerSubQuery )* ;
	[GrammarRule("subQuery")]
	private AstParserRuleReturnScope<IASTNode, IToken> subQuery()
	{
		EnterRule_subQuery();
		EnterRule("subQuery", 74);
		TraceIn("subQuery", 74);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken UNION301 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> innerSubQuery300 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> innerSubQuery302 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode UNION301_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "subQuery");
		DebugLocation(647, 1);
		try
		{
			// Hql.g:648:2: ( innerSubQuery ( UNION ^ innerSubQuery )* )
			DebugEnterAlt(1);
			// Hql.g:648:4: innerSubQuery ( UNION ^ innerSubQuery )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(648, 4);
			PushFollow(Follow._innerSubQuery_in_subQuery3503);
			innerSubQuery300=innerSubQuery();
			PopFollow();

			adaptor.AddChild(root_0, innerSubQuery300.Tree);
			DebugLocation(648, 18);
			// Hql.g:648:18: ( UNION ^ innerSubQuery )*
			try { DebugEnterSubRule(108);
			while (true)
			{
				int alt108=2;
				try { DebugEnterDecision(108, false);
				int LA108_1 = input.LA(1);

				if ((LA108_1==UNION))
				{
					alt108 = 1;
				}


				} finally { DebugExitDecision(108); }
				switch ( alt108 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:648:19: UNION ^ innerSubQuery
					{
					DebugLocation(648, 24);
					UNION301=(IToken)Match(input,UNION,Follow._UNION_in_subQuery3506); 
					UNION301_tree = (IASTNode)adaptor.Create(UNION301);
					root_0 = (IASTNode)adaptor.BecomeRoot(UNION301_tree, root_0);
					DebugLocation(648, 26);
					PushFollow(Follow._innerSubQuery_in_subQuery3509);
					innerSubQuery302=innerSubQuery();
					PopFollow();

					adaptor.AddChild(root_0, innerSubQuery302.Tree);

					}
					break;

				default:
					goto loop108;
				}
			}

			loop108:
				;

			} finally { DebugExitSubRule(108); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("subQuery", 74);
			LeaveRule("subQuery", 74);
			LeaveRule_subQuery();
		}
		DebugLocation(649, 1);
		} finally { DebugExitRule(GrammarFileName, "subQuery"); }
		return retval;

	}
	// $ANTLR end "subQuery"

	partial void EnterRule_innerSubQuery();
	partial void LeaveRule_innerSubQuery();
	// $ANTLR start "innerSubQuery"
	// Hql.g:651:1: innerSubQuery : queryRule -> ^( QUERY[\"query\"] queryRule ) ;
	[GrammarRule("innerSubQuery")]
	private AstParserRuleReturnScope<IASTNode, IToken> innerSubQuery()
	{
		EnterRule_innerSubQuery();
		EnterRule("innerSubQuery", 75);
		TraceIn("innerSubQuery", 75);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		AstParserRuleReturnScope<IASTNode, IToken> queryRule303 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		RewriteRuleSubtreeStream stream_queryRule=new RewriteRuleSubtreeStream(adaptor,"rule queryRule");
		try { DebugEnterRule(GrammarFileName, "innerSubQuery");
		DebugLocation(651, 1);
		try
		{
			// Hql.g:652:2: ( queryRule -> ^( QUERY[\"query\"] queryRule ) )
			DebugEnterAlt(1);
			// Hql.g:652:4: queryRule
			{
			DebugLocation(652, 4);
			PushFollow(Follow._queryRule_in_innerSubQuery3523);
			queryRule303=queryRule();
			PopFollow();

			stream_queryRule.Add(queryRule303.Tree);


			{
			// AST REWRITE
			// elements: queryRule
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (IASTNode)adaptor.Nil();
			// 653:2: -> ^( QUERY[\"query\"] queryRule )
			{
				DebugLocation(653, 5);
				// Hql.g:653:5: ^( QUERY[\"query\"] queryRule )
				{
				IASTNode root_1 = (IASTNode)adaptor.Nil();
				DebugLocation(653, 7);
				root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(QUERY, "query"), root_1);

				DebugLocation(653, 22);
				adaptor.AddChild(root_1, stream_queryRule.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("innerSubQuery", 75);
			LeaveRule("innerSubQuery", 75);
			LeaveRule_innerSubQuery();
		}
		DebugLocation(654, 1);
		} finally { DebugExitRule(GrammarFileName, "innerSubQuery"); }
		return retval;

	}
	// $ANTLR end "innerSubQuery"

	partial void EnterRule_constant();
	partial void LeaveRule_constant();
	// $ANTLR start "constant"
	// Hql.g:656:1: constant : ( NUM_INT | NUM_FLOAT | NUM_LONG | NUM_DOUBLE | NUM_DECIMAL | QUOTED_String | NULL | TRUE | FALSE | EMPTY );
	[GrammarRule("constant")]
	private AstParserRuleReturnScope<IASTNode, IToken> constant()
	{
		EnterRule_constant();
		EnterRule("constant", 76);
		TraceIn("constant", 76);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken set304 = default(IToken);

		IASTNode set304_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(656, 1);
		try
		{
			// Hql.g:657:2: ( NUM_INT | NUM_FLOAT | NUM_LONG | NUM_DOUBLE | NUM_DECIMAL | QUOTED_String | NULL | TRUE | FALSE | EMPTY )
			DebugEnterAlt(1);
			// Hql.g:
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(657, 2);

			set304=(IToken)input.LT(1);
			if (input.LA(1)==EMPTY||input.LA(1)==FALSE||(input.LA(1)>=NULL && input.LA(1)<=NUM_LONG)||input.LA(1)==QUOTED_String||input.LA(1)==TRUE)
			{
				input.Consume();
				adaptor.AddChild(root_0, (IASTNode)adaptor.Create(set304));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constant", 76);
			LeaveRule("constant", 76);
			LeaveRule_constant();
		}
		DebugLocation(667, 1);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"

	partial void EnterRule_path();
	partial void LeaveRule_path();
	// $ANTLR start "path"
	// Hql.g:675:1: path : identifier ( DOT ^ identifier )* ;
	[GrammarRule("path")]
	private AstParserRuleReturnScope<IASTNode, IToken> path()
	{
		EnterRule_path();
		EnterRule("path", 77);
		TraceIn("path", 77);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken DOT306 = default(IToken);
		AstParserRuleReturnScope<IASTNode, IToken> identifier305 = default(AstParserRuleReturnScope<IASTNode, IToken>);
		AstParserRuleReturnScope<IASTNode, IToken> identifier307 = default(AstParserRuleReturnScope<IASTNode, IToken>);

		IASTNode DOT306_tree = default(IASTNode);

		// TODO - need to clean up DotIdent - suspect that DotIdent2 supersedes the other one, but need to do the analysis
		//HandleDotIdent2();

		try { DebugEnterRule(GrammarFileName, "path");
		DebugLocation(675, 1);
		try
		{
			// Hql.g:680:2: ( identifier ( DOT ^ identifier )* )
			DebugEnterAlt(1);
			// Hql.g:680:4: identifier ( DOT ^ identifier )*
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(680, 4);
			PushFollow(Follow._identifier_in_path3611);
			identifier305=identifier();
			PopFollow();

			adaptor.AddChild(root_0, identifier305.Tree);
			DebugLocation(680, 15);
			// Hql.g:680:15: ( DOT ^ identifier )*
			try { DebugEnterSubRule(109);
			while (true)
			{
				int alt109=2;
				try { DebugEnterDecision(109, false);
				int LA109_1 = input.LA(1);

				if ((LA109_1==DOT))
				{
					alt109 = 1;
				}


				} finally { DebugExitDecision(109); }
				switch ( alt109 )
				{
				case 1:
					DebugEnterAlt(1);
					// Hql.g:680:17: DOT ^ identifier
					{
					DebugLocation(680, 20);
					DOT306=(IToken)Match(input,DOT,Follow._DOT_in_path3615); 
					DOT306_tree = (IASTNode)adaptor.Create(DOT306);
					root_0 = (IASTNode)adaptor.BecomeRoot(DOT306_tree, root_0);
					DebugLocation(680, 22);
					 WeakKeywords(); 
					DebugLocation(680, 42);
					PushFollow(Follow._identifier_in_path3620);
					identifier307=identifier();
					PopFollow();

					adaptor.AddChild(root_0, identifier307.Tree);

					}
					break;

				default:
					goto loop109;
				}
			}

			loop109:
				;

			} finally { DebugExitSubRule(109); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (IASTNode)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("path", 77);
			LeaveRule("path", 77);
			LeaveRule_path();
		}
		DebugLocation(681, 1);
		} finally { DebugExitRule(GrammarFileName, "path"); }
		return retval;

	}
	// $ANTLR end "path"

	partial void EnterRule_identifier();
	partial void LeaveRule_identifier();
	// $ANTLR start "identifier"
	// Hql.g:685:1: identifier : IDENT ;
	[GrammarRule("identifier")]
	private AstParserRuleReturnScope<IASTNode, IToken> identifier()
	{
		EnterRule_identifier();
		EnterRule("identifier", 78);
		TraceIn("identifier", 78);
		AstParserRuleReturnScope<IASTNode, IToken> retval = new AstParserRuleReturnScope<IASTNode, IToken>();
		retval.Start = (IToken)input.LT(1);

		IASTNode root_0 = default(IASTNode);

		IToken IDENT308 = default(IToken);

		IASTNode IDENT308_tree = default(IASTNode);
		try { DebugEnterRule(GrammarFileName, "identifier");
		DebugLocation(685, 1);
		try
		{
			// Hql.g:686:2: ( IDENT )
			DebugEnterAlt(1);
			// Hql.g:686:4: IDENT
			{
			root_0 = (IASTNode)adaptor.Nil();

			DebugLocation(686, 4);
			IDENT308=(IToken)Match(input,IDENT,Follow._IDENT_in_identifier3636); 
			IDENT308_tree = (IASTNode)adaptor.Create(IDENT308);
			adaptor.AddChild(root_0, IDENT308_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException ex)
		{

					retval.Tree = HandleIdentifierError(input.LT(1),ex);
				
		}

		finally
		{
			TraceOut("identifier", 78);
			LeaveRule("identifier", 78);
			LeaveRule_identifier();
		}
		DebugLocation(687, 1);
		} finally { DebugExitRule(GrammarFileName, "identifier"); }
		return retval;

	}
	// $ANTLR end "identifier"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _updateStatement_in_statement620 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _deleteStatement_in_statement624 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _insertStatement_in_statement628 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _selectStatement_in_statement637 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_statement642 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _UPDATE_in_updateStatement654 = new BitSet(new ulong[]{0x81000000000000UL,0x8000000000000000UL});
		public static readonly BitSet _VERSIONED_in_updateStatement658 = new BitSet(new ulong[]{0x81000000000000UL});
		public static readonly BitSet _optionalFromTokenFromClause_in_updateStatement664 = new BitSet(new ulong[]{0x0UL,0x1000000000000UL});
		public static readonly BitSet _setClause_in_updateStatement668 = new BitSet(new ulong[]{0x2UL,0x0UL,0x4UL});
		public static readonly BitSet _whereClause_in_updateStatement673 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SET_in_setClause687 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _assignment_in_setClause690 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_setClause693 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _assignment_in_setClause696 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _stateField_in_assignment710 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _EQ_in_assignment712 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _newValue_in_assignment715 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _path_in_stateField728 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concatenation_in_newValue741 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DELETE_in_deleteStatement752 = new BitSet(new ulong[]{0x81000000000000UL});
		public static readonly BitSet _optionalFromTokenFromClause_in_deleteStatement758 = new BitSet(new ulong[]{0x2UL,0x0UL,0x4UL});
		public static readonly BitSet _whereClause_in_deleteStatement764 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _optionalFromTokenFromClause2_in_optionalFromTokenFromClause779 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_optionalFromTokenFromClause781 = new BitSet(new ulong[]{0x80000000000202UL});
		public static readonly BitSet _asAlias_in_optionalFromTokenFromClause784 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FROM_in_optionalFromTokenFromClause2815 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _queryRule_in_selectStatement830 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INSERT_in_insertStatement859 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _intoClause_in_insertStatement862 = new BitSet(new ulong[]{0x29000000000000UL,0x42400800000000UL,0x4UL});
		public static readonly BitSet _selectStatement_in_insertStatement864 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTO_in_intoClause875 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_intoClause878 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _insertablePropertySpec_in_intoClause882 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_in_insertablePropertySpec893 = new BitSet(new ulong[]{0x1080101410800800UL,0x22004411F809000UL});
		public static readonly BitSet _primaryExpression_in_insertablePropertySpec895 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _COMMA_in_insertablePropertySpec899 = new BitSet(new ulong[]{0x1080101410800800UL,0x22004411F809000UL});
		public static readonly BitSet _primaryExpression_in_insertablePropertySpec901 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _CLOSE_in_insertablePropertySpec906 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selectFrom_in_queryRule944 = new BitSet(new ulong[]{0x28000000000002UL,0x42000800000000UL,0x4UL});
		public static readonly BitSet _whereClause_in_queryRule949 = new BitSet(new ulong[]{0x28000000000002UL,0x42000800000000UL});
		public static readonly BitSet _groupByClause_in_queryRule956 = new BitSet(new ulong[]{0x20000000000002UL,0x42000800000000UL});
		public static readonly BitSet _havingClause_in_queryRule963 = new BitSet(new ulong[]{0x2UL,0x42000800000000UL});
		public static readonly BitSet _orderByClause_in_queryRule970 = new BitSet(new ulong[]{0x2UL,0x42000000000000UL});
		public static readonly BitSet _skipClause_in_queryRule977 = new BitSet(new ulong[]{0x2UL,0x40000000000000UL});
		public static readonly BitSet _takeClause_in_queryRule984 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selectClause_in_selectFrom1002 = new BitSet(new ulong[]{0x1000000000002UL});
		public static readonly BitSet _fromClause_in_selectFrom1009 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SELECT_in_selectClause1058 = new BitSet(new ulong[]{0x1080121490844940UL,0x22404C13F8D9000UL});
		public static readonly BitSet _DISTINCT_in_selectClause1070 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C13F8D9000UL});
		public static readonly BitSet _selectedPropertiesList_in_selectClause1076 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _newExpression_in_selectClause1080 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selectObject_in_selectClause1084 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_newExpression1098 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_newExpression1100 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_newExpression1105 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _selectedPropertiesList_in_newExpression1107 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_newExpression1109 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OBJECT_in_selectObject1135 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_selectObject1138 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_selectObject1141 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_selectObject1143 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FROM_in_fromClause1161 = new BitSet(new ulong[]{0x480000400000000UL});
		public static readonly BitSet _fromRange_in_fromClause1166 = new BitSet(new ulong[]{0x2002000001000002UL,0x100000000120UL});
		public static readonly BitSet _fromJoin_in_fromClause1170 = new BitSet(new ulong[]{0x2002000001000002UL,0x100000000120UL});
		public static readonly BitSet _COMMA_in_fromClause1174 = new BitSet(new ulong[]{0x480000400000000UL});
		public static readonly BitSet _fromRange_in_fromClause1179 = new BitSet(new ulong[]{0x2002000001000002UL,0x100000000120UL});
		public static readonly BitSet _set_in_fromJoin1197 = new BitSet(new ulong[]{0x0UL,0x2000000020UL});
		public static readonly BitSet _OUTER_in_fromJoin1208 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _FULL_in_fromJoin1216 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _INNER_in_fromJoin1220 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _JOIN_in_fromJoin1225 = new BitSet(new ulong[]{0x80200000000000UL});
		public static readonly BitSet _FETCH_in_fromJoin1229 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_fromJoin1233 = new BitSet(new ulong[]{0x80200000000202UL,0x0UL,0x8UL});
		public static readonly BitSet _asAlias_in_fromJoin1236 = new BitSet(new ulong[]{0x200000000002UL,0x0UL,0x8UL});
		public static readonly BitSet _propertyFetch_in_fromJoin1241 = new BitSet(new ulong[]{0x2UL,0x0UL,0x8UL});
		public static readonly BitSet _withClause_in_fromJoin1246 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_fromJoin1257 = new BitSet(new ulong[]{0x0UL,0x2000000020UL});
		public static readonly BitSet _OUTER_in_fromJoin1268 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _FULL_in_fromJoin1276 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _INNER_in_fromJoin1280 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _JOIN_in_fromJoin1285 = new BitSet(new ulong[]{0x200400000000UL});
		public static readonly BitSet _FETCH_in_fromJoin1289 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _ELEMENTS_in_fromJoin1293 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_fromJoin1296 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_fromJoin1299 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_fromJoin1301 = new BitSet(new ulong[]{0x80200000000202UL,0x0UL,0x8UL});
		public static readonly BitSet _asAlias_in_fromJoin1305 = new BitSet(new ulong[]{0x200000000002UL,0x0UL,0x8UL});
		public static readonly BitSet _propertyFetch_in_fromJoin1310 = new BitSet(new ulong[]{0x2UL,0x0UL,0x8UL});
		public static readonly BitSet _withClause_in_fromJoin1315 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WITH_in_withClause1328 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _logicalExpression_in_withClause1331 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _fromClassOrOuterQueryPath_in_fromRange1342 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inClassDeclaration_in_fromRange1347 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inCollectionDeclaration_in_fromRange1352 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inCollectionElementsDeclaration_in_fromRange1357 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _path_in_fromClassOrOuterQueryPath1369 = new BitSet(new ulong[]{0x80200000000202UL});
		public static readonly BitSet _asAlias_in_fromClassOrOuterQueryPath1374 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _propertyFetch_in_fromClassOrOuterQueryPath1379 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _alias_in_inClassDeclaration1409 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _IN_in_inClassDeclaration1411 = new BitSet(new ulong[]{0x80000000100000UL});
		public static readonly BitSet _CLASS_in_inClassDeclaration1413 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_inClassDeclaration1416 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IN_in_inCollectionDeclaration1444 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_inCollectionDeclaration1446 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_inCollectionDeclaration1448 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_inCollectionDeclaration1450 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _alias_in_inCollectionDeclaration1452 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _alias_in_inCollectionElementsDeclaration1486 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _IN_in_inCollectionElementsDeclaration1488 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _ELEMENTS_in_inCollectionElementsDeclaration1490 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_inCollectionElementsDeclaration1492 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_inCollectionElementsDeclaration1494 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_inCollectionElementsDeclaration1496 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELEMENTS_in_inCollectionElementsDeclaration1518 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_inCollectionElementsDeclaration1520 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_inCollectionElementsDeclaration1522 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_inCollectionElementsDeclaration1524 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _AS_in_inCollectionElementsDeclaration1526 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _alias_in_inCollectionElementsDeclaration1528 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _AS_in_asAlias1560 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _alias_in_asAlias1565 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_alias1577 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FETCH_in_propertyFetch1596 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _ALL_in_propertyFetch1598 = new BitSet(new ulong[]{0x0UL,0x10000000000UL});
		public static readonly BitSet _PROPERTIES_in_propertyFetch1601 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GROUP_in_groupByClause1613 = new BitSet(new ulong[]{0x0UL,0x400UL});
		public static readonly BitSet _LITERAL_by_in_groupByClause1619 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_groupByClause1622 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_groupByClause1626 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_groupByClause1629 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _ORDER_in_orderByClause1643 = new BitSet(new ulong[]{0x0UL,0x400UL});
		public static readonly BitSet _LITERAL_by_in_orderByClause1646 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _orderElement_in_orderByClause1649 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_orderByClause1653 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _orderElement_in_orderByClause1656 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _SKIP_in_skipClause1670 = new BitSet(new ulong[]{0x800000UL,0x4008000000UL});
		public static readonly BitSet _NUM_INT_in_skipClause1674 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parameter_in_skipClause1678 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TAKE_in_takeClause1690 = new BitSet(new ulong[]{0x800000UL,0x4008000000UL});
		public static readonly BitSet _NUM_INT_in_takeClause1694 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parameter_in_takeClause1698 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COLON_in_parameter1710 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_parameter1713 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PARAM_in_parameter1718 = new BitSet(new ulong[]{0x2UL,0x8000000UL});
		public static readonly BitSet _NUM_INT_in_parameter1722 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_orderElement1735 = new BitSet(new ulong[]{0x40000402UL,0x0UL,0x60UL});
		public static readonly BitSet _ascendingOrDescending_in_orderElement1739 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ASCENDING_in_ascendingOrDescending1757 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _133_in_ascendingOrDescending1763 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DESCENDING_in_ascendingOrDescending1783 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _134_in_ascendingOrDescending1789 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _HAVING_in_havingClause1810 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _logicalExpression_in_havingClause1813 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHERE_in_whereClause1824 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _logicalExpression_in_whereClause1827 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _aliasedExpression_in_selectedPropertiesList1838 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_selectedPropertiesList1842 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _aliasedExpression_in_selectedPropertiesList1845 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _expression_in_aliasedExpression1860 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _AS_in_aliasedExpression1864 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_aliasedExpression1867 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_logicalExpression1906 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalOrExpression_in_expression1918 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalAndExpression_in_logicalOrExpression1930 = new BitSet(new ulong[]{0x2UL,0x400000000UL});
		public static readonly BitSet _OR_in_logicalOrExpression1934 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _logicalAndExpression_in_logicalOrExpression1937 = new BitSet(new ulong[]{0x2UL,0x400000000UL});
		public static readonly BitSet _negatedExpression_in_logicalAndExpression1952 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _AND_in_logicalAndExpression1956 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _negatedExpression_in_logicalAndExpression1959 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _NOT_in_negatedExpression1980 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _negatedExpression_in_negatedExpression1984 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _equalityExpression_in_negatedExpression1997 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression2019 = new BitSet(new ulong[]{0x4000000002UL,0x8000000020002UL});
		public static readonly BitSet _EQ_in_equalityExpression2027 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _IS_in_equalityExpression2036 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _NOT_in_equalityExpression2042 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _NE_in_equalityExpression2054 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _SQL_NE_in_equalityExpression2063 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression2074 = new BitSet(new ulong[]{0x4000000002UL,0x8000000020002UL});
		public static readonly BitSet _concatenation_in_relationalExpression2091 = new BitSet(new ulong[]{0x414000000002002UL,0x82A40UL});
		public static readonly BitSet _LT_in_relationalExpression2103 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _GT_in_relationalExpression2108 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _LE_in_relationalExpression2113 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _GE_in_relationalExpression2118 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseNotExpression_in_relationalExpression2123 = new BitSet(new ulong[]{0x14000000000002UL,0x840UL});
		public static readonly BitSet _NOT_in_relationalExpression2140 = new BitSet(new ulong[]{0x400000000002000UL,0x2200UL});
		public static readonly BitSet _IN_in_relationalExpression2161 = new BitSet(new ulong[]{0x1080000400000000UL,0x100000000UL});
		public static readonly BitSet _inList_in_relationalExpression2170 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BETWEEN_in_relationalExpression2181 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _betweenList_in_relationalExpression2190 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LIKE_in_relationalExpression2202 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _concatenation_in_relationalExpression2211 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _likeEscape_in_relationalExpression2213 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MEMBER_in_relationalExpression2222 = new BitSet(new ulong[]{0x80000000000000UL,0x40000000UL});
		public static readonly BitSet _OF_in_relationalExpression2226 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_relationalExpression2233 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ESCAPE_in_likeEscape2260 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _concatenation_in_likeEscape2263 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _compoundExpr_in_inList2276 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _concatenation_in_betweenList2297 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _AND_in_betweenList2299 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _concatenation_in_betweenList2302 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseNotExpression_in_concatenation2321 = new BitSet(new ulong[]{0x2000002UL});
		public static readonly BitSet _CONCAT_in_concatenation2329 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseNotExpression_in_concatenation2338 = new BitSet(new ulong[]{0x2000002UL});
		public static readonly BitSet _CONCAT_in_concatenation2345 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseNotExpression_in_concatenation2348 = new BitSet(new ulong[]{0x2000002UL});
		public static readonly BitSet _BNOT_in_bitwiseNotExpression2372 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseOrExpression_in_bitwiseNotExpression2375 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseOrExpression_in_bitwiseNotExpression2381 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseXOrExpression_in_bitwiseOrExpression2393 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _BOR_in_bitwiseOrExpression2396 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseXOrExpression_in_bitwiseOrExpression2399 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _bitwiseAndExpression_in_bitwiseXOrExpression2413 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _BXOR_in_bitwiseXOrExpression2416 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _bitwiseAndExpression_in_bitwiseXOrExpression2419 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _additiveExpression_in_bitwiseAndExpression2433 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _BAND_in_bitwiseAndExpression2436 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _additiveExpression_in_bitwiseAndExpression2439 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _multiplyExpression_in_additiveExpression2453 = new BitSet(new ulong[]{0x2UL,0x8000010000UL});
		public static readonly BitSet _PLUS_in_additiveExpression2459 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _MINUS_in_additiveExpression2464 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _multiplyExpression_in_additiveExpression2469 = new BitSet(new ulong[]{0x2UL,0x8000010000UL});
		public static readonly BitSet _unaryExpression_in_multiplyExpression2484 = new BitSet(new ulong[]{0x100000002UL,0x10000000000000UL});
		public static readonly BitSet _STAR_in_multiplyExpression2490 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _DIV_in_multiplyExpression2495 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _unaryExpression_in_multiplyExpression2500 = new BitSet(new ulong[]{0x100000002UL,0x10000000000000UL});
		public static readonly BitSet _MINUS_in_unaryExpression2518 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression2522 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PLUS_in_unaryExpression2539 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression2543 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _caseExpression_in_unaryExpression2558 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _quantifiedExpression_in_unaryExpression2563 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_unaryExpression2568 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CASE_in_caseExpression2580 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _whenClause_in_caseExpression2583 = new BitSet(new ulong[]{0x2800000000UL,0x0UL,0x2UL});
		public static readonly BitSet _elseClause_in_caseExpression2588 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _END_in_caseExpression2592 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CASE_in_caseExpression2612 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _unaryExpression_in_caseExpression2614 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _altWhenClause_in_caseExpression2617 = new BitSet(new ulong[]{0x2800000000UL,0x0UL,0x2UL});
		public static readonly BitSet _elseClause_in_caseExpression2622 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _END_in_caseExpression2626 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHEN_in_whenClause2655 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _logicalExpression_in_whenClause2658 = new BitSet(new ulong[]{0x0UL,0x80000000000000UL});
		public static readonly BitSet _THEN_in_whenClause2660 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_whenClause2663 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHEN_in_altWhenClause2677 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _unaryExpression_in_altWhenClause2680 = new BitSet(new ulong[]{0x0UL,0x80000000000000UL});
		public static readonly BitSet _THEN_in_altWhenClause2682 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_altWhenClause2685 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELSE_in_elseClause2699 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_elseClause2702 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SOME_in_quantifiedExpression2717 = new BitSet(new ulong[]{0x1080000400000000UL,0x100000000UL});
		public static readonly BitSet _EXISTS_in_quantifiedExpression2722 = new BitSet(new ulong[]{0x1080000400000000UL,0x100000000UL});
		public static readonly BitSet _ALL_in_quantifiedExpression2727 = new BitSet(new ulong[]{0x1080000400000000UL,0x100000000UL});
		public static readonly BitSet _ANY_in_quantifiedExpression2732 = new BitSet(new ulong[]{0x1080000400000000UL,0x100000000UL});
		public static readonly BitSet _identifier_in_quantifiedExpression2741 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionExpr_in_quantifiedExpression2745 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_in_quantifiedExpression2750 = new BitSet(new ulong[]{0x29000000000000UL,0x42400800000000UL,0x4UL});
		public static readonly BitSet _subQuery_in_quantifiedExpression2755 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_quantifiedExpression2759 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExpression_in_atom2778 = new BitSet(new ulong[]{0x200000002UL,0x200000000UL});
		public static readonly BitSet _DOT_in_atom2787 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_atom2790 = new BitSet(new ulong[]{0x200000002UL,0x300000000UL});
		public static readonly BitSet _OPEN_in_atom2818 = new BitSet(new ulong[]{0x1081121410A54940UL,0x32404C11F899080UL});
		public static readonly BitSet _exprList_in_atom2823 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_atom2825 = new BitSet(new ulong[]{0x200000002UL,0x200000000UL});
		public static readonly BitSet _OPEN_BRACKET_in_atom2839 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_atom2844 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _CLOSE_BRACKET_in_atom2846 = new BitSet(new ulong[]{0x200000002UL,0x200000000UL});
		public static readonly BitSet _identPrimary_in_primaryExpression2866 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _DOT_in_primaryExpression2879 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _CLASS_in_primaryExpression2882 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_primaryExpression2892 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COLON_in_primaryExpression2899 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_primaryExpression2902 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_in_primaryExpression2911 = new BitSet(new ulong[]{0x10A9121410844940UL,0x26644C91F899000UL,0x4UL});
		public static readonly BitSet _expressionOrVector_in_primaryExpression2915 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _subQuery_in_primaryExpression2919 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_primaryExpression2922 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PARAM_in_primaryExpression2930 = new BitSet(new ulong[]{0x2UL,0x8000000UL});
		public static readonly BitSet _NUM_INT_in_primaryExpression2934 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_expressionOrVector2952 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _vectorExpr_in_expressionOrVector2958 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMA_in_vectorExpr2995 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_vectorExpr2998 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_vectorExpr3001 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_vectorExpr3004 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _identifier_in_identPrimary3020 = new BitSet(new ulong[]{0x200000002UL,0x100000000UL});
		public static readonly BitSet _DOT_in_identPrimary3038 = new BitSet(new ulong[]{0x80000000000000UL,0x20000000UL});
		public static readonly BitSet _identifier_in_identPrimary3043 = new BitSet(new ulong[]{0x200000002UL,0x100000000UL});
		public static readonly BitSet _OBJECT_in_identPrimary3049 = new BitSet(new ulong[]{0x200000002UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_identPrimary3067 = new BitSet(new ulong[]{0x1081121410A54940UL,0x32404C11F899080UL});
		public static readonly BitSet _exprList_in_identPrimary3072 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_identPrimary3074 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _aggregate_in_identPrimary3090 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SUM_in_aggregate3111 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _AVG_in_aggregate3117 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _MAX_in_aggregate3123 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _MIN_in_aggregate3129 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_aggregate3133 = new BitSet(new ulong[]{0x1080121410840940UL,0x22404C11F819000UL});
		public static readonly BitSet _additiveExpression_in_aggregate3135 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_aggregate3137 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COUNT_in_aggregate3156 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_aggregate3158 = new BitSet(new ulong[]{0x1080000480000040UL,0x10000000000000UL});
		public static readonly BitSet _STAR_in_aggregate3164 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _aggregateDistinctAll_in_aggregate3170 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_aggregate3174 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionExpr_in_aggregate3206 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _path_in_aggregateDistinctAll3232 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionExpr_in_aggregateDistinctAll3236 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELEMENTS_in_collectionExpr3255 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _INDICES_in_collectionExpr3260 = new BitSet(new ulong[]{0x0UL,0x100000000UL});
		public static readonly BitSet _OPEN_in_collectionExpr3264 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _path_in_collectionExpr3267 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _CLOSE_in_collectionExpr3269 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionExpr_in_compoundExpr3324 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _path_in_compoundExpr3329 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_in_compoundExpr3335 = new BitSet(new ulong[]{0x10A9121410844940UL,0x26644C91F899000UL,0x4UL});
		public static readonly BitSet _subQuery_in_compoundExpr3340 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _expression_in_compoundExpr3345 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _COMMA_in_compoundExpr3348 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_compoundExpr3351 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _CLOSE_in_compoundExpr3358 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRAILING_in_exprList3377 = new BitSet(new ulong[]{0x1081121410844942UL,0x22404C11F899000UL});
		public static readonly BitSet _LEADING_in_exprList3390 = new BitSet(new ulong[]{0x1081121410844942UL,0x22404C11F899000UL});
		public static readonly BitSet _BOTH_in_exprList3403 = new BitSet(new ulong[]{0x1081121410844942UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_exprList3427 = new BitSet(new ulong[]{0x1000001000202UL});
		public static readonly BitSet _COMMA_in_exprList3432 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_exprList3435 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _FROM_in_exprList3450 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_exprList3452 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _AS_in_exprList3464 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_exprList3467 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FROM_in_exprList3481 = new BitSet(new ulong[]{0x1080121410844940UL,0x22404C11F899000UL});
		public static readonly BitSet _expression_in_exprList3483 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _innerSubQuery_in_subQuery3503 = new BitSet(new ulong[]{0x2UL,0x1000000000000000UL});
		public static readonly BitSet _UNION_in_subQuery3506 = new BitSet(new ulong[]{0x29000000000000UL,0x42400800000000UL,0x4UL});
		public static readonly BitSet _innerSubQuery_in_subQuery3509 = new BitSet(new ulong[]{0x2UL,0x1000000000000000UL});
		public static readonly BitSet _queryRule_in_innerSubQuery3523 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_path3611 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _DOT_in_path3615 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _identifier_in_path3620 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _IDENT_in_identifier3636 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  NHibernate.Hql.Ast.ANTLR 
