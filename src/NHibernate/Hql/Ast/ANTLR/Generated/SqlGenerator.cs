//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 SqlGenerator.g 2015-05-03 23:15:29

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using NHibernate.Hql.Ast.ANTLR.Tree;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  NHibernate.Hql.Ast.ANTLR 
{
/**
 * SQL Generator Tree Parser, providing SQL rendering of SQL ASTs produced by the previous phase, HqlSqlWalker.  All
 * syntax decoration such as extra spaces, lack of spaces, extra parens, etc. should be added by this class.
 * <br>
 * This grammar processes the HQL/SQL AST and produces an SQL string.  The intent is to move dialect-specific
 * code into a sub-class that will override some of the methods, just like the other two grammars in this system.
 * @author Joshua Davis (joshua@hibernate.org)
 */
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
[System.CLSCompliant(false)]
public partial class SqlGenerator : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AGGREGATE", "ALIAS", "ALL", "AND", "ANY", "AS", "ASCENDING", "AVG", "BAND", "BETWEEN", "BNOT", "BOR", "BOTH", "BXOR", "CASE", "CASE2", "CLASS", "CLOSE", "CLOSE_BRACKET", "COLON", "COMMA", "CONCAT", "CONSTANT", "CONSTRUCTOR", "COUNT", "DELETE", "DESCENDING", "DISTINCT", "DIV", "DOT", "ELEMENTS", "ELSE", "EMPTY", "END", "EQ", "ESCAPE", "ESCqs", "EXISTS", "EXPONENT", "EXPR_LIST", "FALSE", "FETCH", "FILTER_ENTITY", "FLOAT_SUFFIX", "FROM", "FULL", "GE", "GROUP", "GT", "HAVING", "HEX_DIGIT", "IDENT", "ID_LETTER", "ID_START_LETTER", "IN", "INDEX_OP", "INDICES", "INNER", "INSERT", "INTO", "IN_LIST", "IS", "IS_NOT_NULL", "IS_NULL", "JAVA_CONSTANT", "JOIN", "LE", "LEADING", "LEFT", "LIKE", "LITERAL_by", "LT", "MAX", "MEMBER", "METHOD_CALL", "MIN", "MINUS", "NE", "NEW", "NOT", "NOT_BETWEEN", "NOT_IN", "NOT_LIKE", "NULL", "NUM_DECIMAL", "NUM_DOUBLE", "NUM_FLOAT", "NUM_INT", "NUM_LONG", "OBJECT", "OF", "ON", "OPEN", "OPEN_BRACKET", "OR", "ORDER", "ORDER_ELEMENT", "OUTER", "PARAM", "PLUS", "PROPERTIES", "QUERY", "QUOTED_String", "RANGE", "RIGHT", "ROW_STAR", "SELECT", "SELECT_FROM", "SET", "SKIP", "SOME", "SQL_NE", "STAR", "SUM", "TAKE", "THEN", "TRAILING", "TRUE", "UNARY_MINUS", "UNARY_PLUS", "UNION", "UPDATE", "VECTOR_EXPR", "VERSIONED", "WEIRD_IDENT", "WHEN", "WHERE", "WITH", "WS", "'ascending'", "'descending'", "ALIAS_REF", "BOGUS", "FILTERS", "FROM_FRAGMENT", "IMPLIED_FROM", "JOIN_FRAGMENT", "LEFT_OUTER", "METHOD_NAME", "NAMED_PARAM", "PROPERTY_REF", "RESULT_VARIABLE_REF", "RIGHT_OUTER", "SELECT_CLAUSE", "SELECT_COLUMNS", "SELECT_EXPR", "SQL_TOKEN", "THETA_JOINS"
	};
	public const int EOF=-1;
	public const int AGGREGATE=4;
	public const int ALIAS=5;
	public const int ALL=6;
	public const int AND=7;
	public const int ANY=8;
	public const int AS=9;
	public const int ASCENDING=10;
	public const int AVG=11;
	public const int BAND=12;
	public const int BETWEEN=13;
	public const int BNOT=14;
	public const int BOR=15;
	public const int BOTH=16;
	public const int BXOR=17;
	public const int CASE=18;
	public const int CASE2=19;
	public const int CLASS=20;
	public const int CLOSE=21;
	public const int CLOSE_BRACKET=22;
	public const int COLON=23;
	public const int COMMA=24;
	public const int CONCAT=25;
	public const int CONSTANT=26;
	public const int CONSTRUCTOR=27;
	public const int COUNT=28;
	public const int DELETE=29;
	public const int DESCENDING=30;
	public const int DISTINCT=31;
	public const int DIV=32;
	public const int DOT=33;
	public const int ELEMENTS=34;
	public const int ELSE=35;
	public const int EMPTY=36;
	public const int END=37;
	public const int EQ=38;
	public const int ESCAPE=39;
	public const int ESCqs=40;
	public const int EXISTS=41;
	public const int EXPONENT=42;
	public const int EXPR_LIST=43;
	public const int FALSE=44;
	public const int FETCH=45;
	public const int FILTER_ENTITY=46;
	public const int FLOAT_SUFFIX=47;
	public const int FROM=48;
	public const int FULL=49;
	public const int GE=50;
	public const int GROUP=51;
	public const int GT=52;
	public const int HAVING=53;
	public const int HEX_DIGIT=54;
	public const int IDENT=55;
	public const int ID_LETTER=56;
	public const int ID_START_LETTER=57;
	public const int IN=58;
	public const int INDEX_OP=59;
	public const int INDICES=60;
	public const int INNER=61;
	public const int INSERT=62;
	public const int INTO=63;
	public const int IN_LIST=64;
	public const int IS=65;
	public const int IS_NOT_NULL=66;
	public const int IS_NULL=67;
	public const int JAVA_CONSTANT=68;
	public const int JOIN=69;
	public const int LE=70;
	public const int LEADING=71;
	public const int LEFT=72;
	public const int LIKE=73;
	public const int LITERAL_by=74;
	public const int LT=75;
	public const int MAX=76;
	public const int MEMBER=77;
	public const int METHOD_CALL=78;
	public const int MIN=79;
	public const int MINUS=80;
	public const int NE=81;
	public const int NEW=82;
	public const int NOT=83;
	public const int NOT_BETWEEN=84;
	public const int NOT_IN=85;
	public const int NOT_LIKE=86;
	public const int NULL=87;
	public const int NUM_DECIMAL=88;
	public const int NUM_DOUBLE=89;
	public const int NUM_FLOAT=90;
	public const int NUM_INT=91;
	public const int NUM_LONG=92;
	public const int OBJECT=93;
	public const int OF=94;
	public const int ON=95;
	public const int OPEN=96;
	public const int OPEN_BRACKET=97;
	public const int OR=98;
	public const int ORDER=99;
	public const int ORDER_ELEMENT=100;
	public const int OUTER=101;
	public const int PARAM=102;
	public const int PLUS=103;
	public const int PROPERTIES=104;
	public const int QUERY=105;
	public const int QUOTED_String=106;
	public const int RANGE=107;
	public const int RIGHT=108;
	public const int ROW_STAR=109;
	public const int SELECT=110;
	public const int SELECT_FROM=111;
	public const int SET=112;
	public const int SKIP=113;
	public const int SOME=114;
	public const int SQL_NE=115;
	public const int STAR=116;
	public const int SUM=117;
	public const int TAKE=118;
	public const int THEN=119;
	public const int TRAILING=120;
	public const int TRUE=121;
	public const int UNARY_MINUS=122;
	public const int UNARY_PLUS=123;
	public const int UNION=124;
	public const int UPDATE=125;
	public const int VECTOR_EXPR=126;
	public const int VERSIONED=127;
	public const int WEIRD_IDENT=128;
	public const int WHEN=129;
	public const int WHERE=130;
	public const int WITH=131;
	public const int WS=132;
	public const int T__133=133;
	public const int T__134=134;
	public const int ALIAS_REF=135;
	public const int BOGUS=136;
	public const int FILTERS=137;
	public const int FROM_FRAGMENT=138;
	public const int IMPLIED_FROM=139;
	public const int JOIN_FRAGMENT=140;
	public const int LEFT_OUTER=141;
	public const int METHOD_NAME=142;
	public const int NAMED_PARAM=143;
	public const int PROPERTY_REF=144;
	public const int RESULT_VARIABLE_REF=145;
	public const int RIGHT_OUTER=146;
	public const int SELECT_CLAUSE=147;
	public const int SELECT_COLUMNS=148;
	public const int SELECT_EXPR=149;
	public const int SQL_TOKEN=150;
	public const int THETA_JOINS=151;

	public SqlGenerator(ITreeNodeStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public SqlGenerator(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return SqlGenerator.tokenNames; } }
	public override string GrammarFileName { get { return "SqlGenerator.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_statement();
	partial void LeaveRule_statement();
	// $ANTLR start "statement"
	// SqlGenerator.g:27:8: public statement : ( selectStatement | updateStatement | deleteStatement | insertStatement );
	[GrammarRule("statement")]
	public void statement()
	{
		EnterRule_statement();
		EnterRule("statement", 1);
		TraceIn("statement", 1);
		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(27, 1);
		try
		{
			// SqlGenerator.g:28:2: ( selectStatement | updateStatement | deleteStatement | insertStatement )
			int alt1=4;
			try { DebugEnterDecision(1, false);
			switch (input.LA(1))
			{
			case SELECT:
				{
				alt1 = 1;
				}
				break;
			case UPDATE:
				{
				alt1 = 2;
				}
				break;
			case DELETE:
				{
				alt1 = 3;
				}
				break;
			case INSERT:
				{
				alt1 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:28:4: selectStatement
				{
				DebugLocation(28, 4);
				PushFollow(Follow._selectStatement_in_statement59);
				selectStatement();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:29:4: updateStatement
				{
				DebugLocation(29, 4);
				PushFollow(Follow._updateStatement_in_statement64);
				updateStatement();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// SqlGenerator.g:30:4: deleteStatement
				{
				DebugLocation(30, 4);
				PushFollow(Follow._deleteStatement_in_statement69);
				deleteStatement();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// SqlGenerator.g:31:4: insertStatement
				{
				DebugLocation(31, 4);
				PushFollow(Follow._insertStatement_in_statement74);
				insertStatement();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("statement", 1);
			LeaveRule("statement", 1);
			LeaveRule_statement();
		}
		DebugLocation(32, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return;

	}
	// $ANTLR end "statement"

	partial void EnterRule_selectStatement();
	partial void LeaveRule_selectStatement();
	// $ANTLR start "selectStatement"
	// SqlGenerator.g:34:1: selectStatement : ^( SELECT selectClause from ( ^( WHERE whereExpr ) )? ( ^( GROUP groupExprs ) )? ( ^( HAVING booleanExpr[false] ) )? ( ^( ORDER orderExprs ) )? ( ^( SKIP si= limitValue ) )? ( ^( TAKE ti= limitValue ) )? ) ;
	[GrammarRule("selectStatement")]
	private void selectStatement()
	{
		EnterRule_selectStatement();
		EnterRule("selectStatement", 2);
		TraceIn("selectStatement", 2);
		TreeRuleReturnScope<IASTNode> si = default(TreeRuleReturnScope<IASTNode>);
		TreeRuleReturnScope<IASTNode> ti = default(TreeRuleReturnScope<IASTNode>);

		try { DebugEnterRule(GrammarFileName, "selectStatement");
		DebugLocation(34, 1);
		try
		{
			// SqlGenerator.g:35:2: ( ^( SELECT selectClause from ( ^( WHERE whereExpr ) )? ( ^( GROUP groupExprs ) )? ( ^( HAVING booleanExpr[false] ) )? ( ^( ORDER orderExprs ) )? ( ^( SKIP si= limitValue ) )? ( ^( TAKE ti= limitValue ) )? ) )
			DebugEnterAlt(1);
			// SqlGenerator.g:35:4: ^( SELECT selectClause from ( ^( WHERE whereExpr ) )? ( ^( GROUP groupExprs ) )? ( ^( HAVING booleanExpr[false] ) )? ( ^( ORDER orderExprs ) )? ( ^( SKIP si= limitValue ) )? ( ^( TAKE ti= limitValue ) )? )
			{
			DebugLocation(35, 4);
			DebugLocation(35, 6);
			Match(input,SELECT,Follow._SELECT_in_selectStatement86); if (state.failed) return;

			DebugLocation(35, 13);
			if (state.backtracking == 0)
			{
				 StartQuery(); Out("select "); 
			}

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(36, 3);
			PushFollow(Follow._selectClause_in_selectStatement92);
			selectClause();
			PopFollow();
			if (state.failed) return;
			DebugLocation(37, 3);
			PushFollow(Follow._from_in_selectStatement96);
			from();
			PopFollow();
			if (state.failed) return;
			DebugLocation(38, 3);
			// SqlGenerator.g:38:3: ( ^( WHERE whereExpr ) )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if ((LA2_1==WHERE))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:38:5: ^( WHERE whereExpr )
				{
				DebugLocation(38, 5);
				DebugLocation(38, 7);
				Match(input,WHERE,Follow._WHERE_in_selectStatement103); if (state.failed) return;

				DebugLocation(38, 13);
				if (state.backtracking == 0)
				{
					 Out(" where "); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(38, 33);
				PushFollow(Follow._whereExpr_in_selectStatement107);
				whereExpr();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(39, 3);
			// SqlGenerator.g:39:3: ( ^( GROUP groupExprs ) )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1==GROUP))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:39:5: ^( GROUP groupExprs )
				{
				DebugLocation(39, 5);
				DebugLocation(39, 7);
				Match(input,GROUP,Follow._GROUP_in_selectStatement119); if (state.failed) return;

				DebugLocation(39, 13);
				if (state.backtracking == 0)
				{
					 Out(" group by "); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(39, 36);
				PushFollow(Follow._groupExprs_in_selectStatement123);
				groupExprs();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(40, 3);
			// SqlGenerator.g:40:3: ( ^( HAVING booleanExpr[false] ) )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1==HAVING))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:40:5: ^( HAVING booleanExpr[false] )
				{
				DebugLocation(40, 5);
				DebugLocation(40, 7);
				Match(input,HAVING,Follow._HAVING_in_selectStatement135); if (state.failed) return;

				DebugLocation(40, 14);
				if (state.backtracking == 0)
				{
					 Out(" having "); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(40, 35);
				PushFollow(Follow._booleanExpr_in_selectStatement139);
				booleanExpr(false);
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(41, 3);
			// SqlGenerator.g:41:3: ( ^( ORDER orderExprs ) )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if ((LA5_1==ORDER))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:41:5: ^( ORDER orderExprs )
				{
				DebugLocation(41, 5);
				DebugLocation(41, 7);
				Match(input,ORDER,Follow._ORDER_in_selectStatement151); if (state.failed) return;

				DebugLocation(41, 13);
				if (state.backtracking == 0)
				{
					 Out(" order by "); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(41, 36);
				PushFollow(Follow._orderExprs_in_selectStatement155);
				orderExprs();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(42, 3);
			// SqlGenerator.g:42:3: ( ^( SKIP si= limitValue ) )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1==SKIP))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:42:5: ^( SKIP si= limitValue )
				{
				DebugLocation(42, 5);
				DebugLocation(42, 7);
				Match(input,SKIP,Follow._SKIP_in_selectStatement167); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(42, 14);
				PushFollow(Follow._limitValue_in_selectStatement171);
				si=limitValue();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(42, 27);
				if (state.backtracking == 0)
				{
					 Skip((si!=null?((IASTNode)si.Start):default(IASTNode))); 
				}

				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(43, 3);
			// SqlGenerator.g:43:3: ( ^( TAKE ti= limitValue ) )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1==TAKE))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:43:5: ^( TAKE ti= limitValue )
				{
				DebugLocation(43, 5);
				DebugLocation(43, 7);
				Match(input,TAKE,Follow._TAKE_in_selectStatement183); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(43, 14);
				PushFollow(Follow._limitValue_in_selectStatement187);
				ti=limitValue();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(43, 27);
				if (state.backtracking == 0)
				{
					 Take((ti!=null?((IASTNode)ti.Start):default(IASTNode))); 
				}

				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(44, 3);
			if (state.backtracking == 0)
			{
				 EndQuery(); 
			}

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("selectStatement", 2);
			LeaveRule("selectStatement", 2);
			LeaveRule_selectStatement();
		}
		DebugLocation(46, 1);
		} finally { DebugExitRule(GrammarFileName, "selectStatement"); }
		return;

	}
	// $ANTLR end "selectStatement"

	partial void EnterRule_updateStatement();
	partial void LeaveRule_updateStatement();
	// $ANTLR start "updateStatement"
	// SqlGenerator.g:51:1: updateStatement : ^( UPDATE ^( FROM fromTable ) setClause ( whereClause )? ) ;
	[GrammarRule("updateStatement")]
	private void updateStatement()
	{
		EnterRule_updateStatement();
		EnterRule("updateStatement", 3);
		TraceIn("updateStatement", 3);
		try { DebugEnterRule(GrammarFileName, "updateStatement");
		DebugLocation(51, 1);
		try
		{
			// SqlGenerator.g:52:2: ( ^( UPDATE ^( FROM fromTable ) setClause ( whereClause )? ) )
			DebugEnterAlt(1);
			// SqlGenerator.g:52:4: ^( UPDATE ^( FROM fromTable ) setClause ( whereClause )? )
			{
			DebugLocation(52, 4);
			DebugLocation(52, 6);
			Match(input,UPDATE,Follow._UPDATE_in_updateStatement214); if (state.failed) return;

			DebugLocation(52, 13);
			if (state.backtracking == 0)
			{
				 Out("update "); 
			}

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(53, 3);
			DebugLocation(53, 6);
			Match(input,FROM,Follow._FROM_in_updateStatement222); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(53, 11);
			PushFollow(Follow._fromTable_in_updateStatement224);
			fromTable();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			DebugLocation(54, 3);
			PushFollow(Follow._setClause_in_updateStatement230);
			setClause();
			PopFollow();
			if (state.failed) return;
			DebugLocation(55, 3);
			// SqlGenerator.g:55:3: ( whereClause )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==WHERE))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:55:4: whereClause
				{
				DebugLocation(55, 4);
				PushFollow(Follow._whereClause_in_updateStatement235);
				whereClause();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(8); }


			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("updateStatement", 3);
			LeaveRule("updateStatement", 3);
			LeaveRule_updateStatement();
		}
		DebugLocation(57, 1);
		} finally { DebugExitRule(GrammarFileName, "updateStatement"); }
		return;

	}
	// $ANTLR end "updateStatement"

	partial void EnterRule_deleteStatement();
	partial void LeaveRule_deleteStatement();
	// $ANTLR start "deleteStatement"
	// SqlGenerator.g:59:1: deleteStatement : ^( DELETE from ( whereClause )? ) ;
	[GrammarRule("deleteStatement")]
	private void deleteStatement()
	{
		EnterRule_deleteStatement();
		EnterRule("deleteStatement", 4);
		TraceIn("deleteStatement", 4);
		try { DebugEnterRule(GrammarFileName, "deleteStatement");
		DebugLocation(59, 1);
		try
		{
			// SqlGenerator.g:61:2: ( ^( DELETE from ( whereClause )? ) )
			DebugEnterAlt(1);
			// SqlGenerator.g:61:4: ^( DELETE from ( whereClause )? )
			{
			DebugLocation(61, 4);
			DebugLocation(61, 6);
			Match(input,DELETE,Follow._DELETE_in_deleteStatement254); if (state.failed) return;

			DebugLocation(61, 13);
			if (state.backtracking == 0)
			{
				 Out("delete"); 
			}

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(62, 3);
			PushFollow(Follow._from_in_deleteStatement260);
			from();
			PopFollow();
			if (state.failed) return;
			DebugLocation(63, 3);
			// SqlGenerator.g:63:3: ( whereClause )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if ((LA9_1==WHERE))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:63:4: whereClause
				{
				DebugLocation(63, 4);
				PushFollow(Follow._whereClause_in_deleteStatement265);
				whereClause();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(9); }


			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("deleteStatement", 4);
			LeaveRule("deleteStatement", 4);
			LeaveRule_deleteStatement();
		}
		DebugLocation(65, 1);
		} finally { DebugExitRule(GrammarFileName, "deleteStatement"); }
		return;

	}
	// $ANTLR end "deleteStatement"

	partial void EnterRule_insertStatement();
	partial void LeaveRule_insertStatement();
	// $ANTLR start "insertStatement"
	// SqlGenerator.g:67:1: insertStatement : ^( INSERT ^(i= INTO ( . )* ) selectStatement ) ;
	[GrammarRule("insertStatement")]
	private void insertStatement()
	{
		EnterRule_insertStatement();
		EnterRule("insertStatement", 5);
		TraceIn("insertStatement", 5);
		IASTNode i = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "insertStatement");
		DebugLocation(67, 1);
		try
		{
			// SqlGenerator.g:68:2: ( ^( INSERT ^(i= INTO ( . )* ) selectStatement ) )
			DebugEnterAlt(1);
			// SqlGenerator.g:68:4: ^( INSERT ^(i= INTO ( . )* ) selectStatement )
			{
			DebugLocation(68, 4);
			DebugLocation(68, 6);
			Match(input,INSERT,Follow._INSERT_in_insertStatement282); if (state.failed) return;

			DebugLocation(68, 13);
			if (state.backtracking == 0)
			{
				 Out( "insert " ); 
			}

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(69, 3);
			DebugLocation(69, 6);
			i=(IASTNode)Match(input,INTO,Follow._INTO_in_insertStatement291); if (state.failed) return;

			DebugLocation(69, 12);
			if (state.backtracking == 0)
			{
				 Out( i ); Out( " " ); 
			}

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(69, 38);
				// SqlGenerator.g:69:38: ( . )*
				try { DebugEnterSubRule(10);
				while (true)
				{
					int alt10=2;
					try { DebugEnterDecision(10, false);
					int LA10_1 = input.LA(1);

					if (((LA10_1>=AGGREGATE && LA10_1<=THETA_JOINS)))
					{
						alt10 = 1;
					}
					else if ((LA10_1==UP))
					{
						alt10 = 2;
					}


					} finally { DebugExitDecision(10); }
					switch ( alt10 )
					{
					case 1:
						DebugEnterAlt(1);
						// SqlGenerator.g:69:38: .
						{
						DebugLocation(69, 38);
						MatchAny(input); if (state.failed) return;

						}
						break;

					default:
						goto loop10;
					}
				}

				loop10:
					;

				} finally { DebugExitSubRule(10); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}

			DebugLocation(70, 3);
			PushFollow(Follow._selectStatement_in_insertStatement301);
			selectStatement();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("insertStatement", 5);
			LeaveRule("insertStatement", 5);
			LeaveRule_insertStatement();
		}
		DebugLocation(72, 1);
		} finally { DebugExitRule(GrammarFileName, "insertStatement"); }
		return;

	}
	// $ANTLR end "insertStatement"

	partial void EnterRule_setClause();
	partial void LeaveRule_setClause();
	// $ANTLR start "setClause"
	// SqlGenerator.g:74:1: setClause : ^( SET comparisonExpr[false] ( comparisonExpr[false] )* ) ;
	[GrammarRule("setClause")]
	private void setClause()
	{
		EnterRule_setClause();
		EnterRule("setClause", 6);
		TraceIn("setClause", 6);
		try { DebugEnterRule(GrammarFileName, "setClause");
		DebugLocation(74, 1);
		try
		{
			// SqlGenerator.g:77:2: ( ^( SET comparisonExpr[false] ( comparisonExpr[false] )* ) )
			DebugEnterAlt(1);
			// SqlGenerator.g:77:4: ^( SET comparisonExpr[false] ( comparisonExpr[false] )* )
			{
			DebugLocation(77, 4);
			DebugLocation(77, 7);
			Match(input,SET,Follow._SET_in_setClause321); if (state.failed) return;

			DebugLocation(77, 11);
			if (state.backtracking == 0)
			{
				 Out(" set "); 
			}

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(77, 29);
			PushFollow(Follow._comparisonExpr_in_setClause325);
			comparisonExpr(false);
			PopFollow();
			if (state.failed) return;
			DebugLocation(77, 51);
			// SqlGenerator.g:77:51: ( comparisonExpr[false] )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if ((LA11_1==BETWEEN||LA11_1==EQ||LA11_1==EXISTS||LA11_1==GE||LA11_1==GT||LA11_1==IN||(LA11_1>=IS_NOT_NULL && LA11_1<=IS_NULL)||LA11_1==LE||LA11_1==LIKE||LA11_1==LT||LA11_1==NE||(LA11_1>=NOT_BETWEEN && LA11_1<=NOT_LIKE)))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// SqlGenerator.g:77:53: comparisonExpr[false]
					{
					DebugLocation(77, 53);
					if (state.backtracking == 0)
					{
						 Out(", "); 
					}
					DebugLocation(77, 68);
					PushFollow(Follow._comparisonExpr_in_setClause332);
					comparisonExpr(false);
					PopFollow();
					if (state.failed) return;

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }


			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("setClause", 6);
			LeaveRule("setClause", 6);
			LeaveRule_setClause();
		}
		DebugLocation(78, 1);
		} finally { DebugExitRule(GrammarFileName, "setClause"); }
		return;

	}
	// $ANTLR end "setClause"

	partial void EnterRule_whereClause();
	partial void LeaveRule_whereClause();
	// $ANTLR start "whereClause"
	// SqlGenerator.g:80:8: public whereClause : ^( WHERE whereClauseExpr ) ;
	[GrammarRule("whereClause")]
	public void whereClause()
	{
		EnterRule_whereClause();
		EnterRule("whereClause", 7);
		TraceIn("whereClause", 7);
		try { DebugEnterRule(GrammarFileName, "whereClause");
		DebugLocation(80, 1);
		try
		{
			// SqlGenerator.g:81:2: ( ^( WHERE whereClauseExpr ) )
			DebugEnterAlt(1);
			// SqlGenerator.g:81:4: ^( WHERE whereClauseExpr )
			{
			DebugLocation(81, 4);
			DebugLocation(81, 6);
			Match(input,WHERE,Follow._WHERE_in_whereClause352); if (state.failed) return;

			DebugLocation(81, 12);
			if (state.backtracking == 0)
			{
				 Out(" where "); 
			}

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(81, 32);
			PushFollow(Follow._whereClauseExpr_in_whereClause356);
			whereClauseExpr();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("whereClause", 7);
			LeaveRule("whereClause", 7);
			LeaveRule_whereClause();
		}
		DebugLocation(82, 1);
		} finally { DebugExitRule(GrammarFileName, "whereClause"); }
		return;

	}
	// $ANTLR end "whereClause"

	partial void EnterRule_whereClauseExpr();
	partial void LeaveRule_whereClauseExpr();
	// $ANTLR start "whereClauseExpr"
	// SqlGenerator.g:84:1: whereClauseExpr : ( ( SQL_TOKEN )=> conditionList | booleanExpr[ false ] );
	[GrammarRule("whereClauseExpr")]
	private void whereClauseExpr()
	{
		EnterRule_whereClauseExpr();
		EnterRule("whereClauseExpr", 8);
		TraceIn("whereClauseExpr", 8);
		try { DebugEnterRule(GrammarFileName, "whereClauseExpr");
		DebugLocation(84, 1);
		try
		{
			// SqlGenerator.g:85:2: ( ( SQL_TOKEN )=> conditionList | booleanExpr[ false ] )
			int alt12=2;
			try { DebugEnterDecision(12, false);
			int LA12_1 = input.LA(1);

			if ((LA12_1==SQL_TOKEN))
			{
				int LA12_2 = input.LA(2);

				if ((LA12_2==DOWN) && (EvaluatePredicate(synpred1_SqlGenerator_fragment)))
				{
					alt12 = 1;
				}
				else if ((LA12_2==UP))
				{
					alt12 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 12, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA12_1==AND||LA12_1==BETWEEN||LA12_1==EQ||LA12_1==EXISTS||LA12_1==GE||LA12_1==GT||LA12_1==IN||(LA12_1>=IS_NOT_NULL && LA12_1<=IS_NULL)||LA12_1==LE||LA12_1==LIKE||LA12_1==LT||LA12_1==METHOD_CALL||LA12_1==NE||(LA12_1>=NOT && LA12_1<=NOT_LIKE)||LA12_1==OR))
			{
				alt12 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:85:4: ( SQL_TOKEN )=> conditionList
				{
				DebugLocation(85, 19);
				PushFollow(Follow._conditionList_in_whereClauseExpr375);
				conditionList();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:86:4: booleanExpr[ false ]
				{
				DebugLocation(86, 4);
				PushFollow(Follow._booleanExpr_in_whereClauseExpr380);
				booleanExpr(false);
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("whereClauseExpr", 8);
			LeaveRule("whereClauseExpr", 8);
			LeaveRule_whereClauseExpr();
		}
		DebugLocation(87, 1);
		} finally { DebugExitRule(GrammarFileName, "whereClauseExpr"); }
		return;

	}
	// $ANTLR end "whereClauseExpr"

	partial void EnterRule_orderExprs();
	partial void LeaveRule_orderExprs();
	// $ANTLR start "orderExprs"
	// SqlGenerator.g:89:1: orderExprs : ( expr ) (dir= orderDirection )? ( orderExprs )? ;
	[GrammarRule("orderExprs")]
	private void orderExprs()
	{
		EnterRule_orderExprs();
		EnterRule("orderExprs", 9);
		TraceIn("orderExprs", 9);
		TreeRuleReturnScope<IASTNode> dir = default(TreeRuleReturnScope<IASTNode>);

		try { DebugEnterRule(GrammarFileName, "orderExprs");
		DebugLocation(89, 1);
		try
		{
			// SqlGenerator.g:91:2: ( ( expr ) (dir= orderDirection )? ( orderExprs )? )
			DebugEnterAlt(1);
			// SqlGenerator.g:91:4: ( expr ) (dir= orderDirection )? ( orderExprs )?
			{
			DebugLocation(91, 4);
			// SqlGenerator.g:91:4: ( expr )
			DebugEnterAlt(1);
			// SqlGenerator.g:91:6: expr
			{
			DebugLocation(91, 6);
			PushFollow(Follow._expr_in_orderExprs396);
			expr();
			PopFollow();
			if (state.failed) return;

			}

			DebugLocation(91, 13);
			// SqlGenerator.g:91:13: (dir= orderDirection )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_1 = input.LA(1);

			if ((LA13_1==ASCENDING||LA13_1==DESCENDING))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:91:14: dir= orderDirection
				{
				DebugLocation(91, 17);
				PushFollow(Follow._orderDirection_in_orderExprs403);
				dir=orderDirection();
				PopFollow();
				if (state.failed) return;
				DebugLocation(91, 33);
				if (state.backtracking == 0)
				{
					 Out(" "); Out((dir!=null?((IASTNode)dir.Start):default(IASTNode))); 
				}

				}
				break;

			}
			} finally { DebugExitSubRule(13); }

			DebugLocation(91, 66);
			// SqlGenerator.g:91:66: ( orderExprs )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_1 = input.LA(1);

			if ((LA14_1==AGGREGATE||LA14_1==ALL||LA14_1==ANY||LA14_1==BAND||(LA14_1>=BNOT && LA14_1<=BOR)||(LA14_1>=BXOR && LA14_1<=CASE2)||LA14_1==CONSTANT||LA14_1==COUNT||(LA14_1>=DIV && LA14_1<=DOT)||LA14_1==FALSE||LA14_1==IDENT||LA14_1==INDEX_OP||LA14_1==JAVA_CONSTANT||LA14_1==METHOD_CALL||LA14_1==MINUS||(LA14_1>=NULL && LA14_1<=NUM_LONG)||(LA14_1>=PARAM && LA14_1<=PLUS)||LA14_1==QUOTED_String||LA14_1==SELECT||LA14_1==SOME||LA14_1==STAR||(LA14_1>=TRUE && LA14_1<=UNARY_MINUS)||LA14_1==UNION||LA14_1==VECTOR_EXPR||LA14_1==ALIAS_REF||LA14_1==NAMED_PARAM||LA14_1==RESULT_VARIABLE_REF||LA14_1==SQL_TOKEN))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:91:68: orderExprs
				{
				DebugLocation(91, 68);
				if (state.backtracking == 0)
				{
					Out(", "); 
				}
				DebugLocation(91, 82);
				PushFollow(Follow._orderExprs_in_orderExprs413);
				orderExprs();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(14); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("orderExprs", 9);
			LeaveRule("orderExprs", 9);
			LeaveRule_orderExprs();
		}
		DebugLocation(92, 1);
		} finally { DebugExitRule(GrammarFileName, "orderExprs"); }
		return;

	}
	// $ANTLR end "orderExprs"

	partial void EnterRule_groupExprs();
	partial void LeaveRule_groupExprs();
	// $ANTLR start "groupExprs"
	// SqlGenerator.g:94:1: groupExprs : expr ( groupExprs )? ;
	[GrammarRule("groupExprs")]
	private void groupExprs()
	{
		EnterRule_groupExprs();
		EnterRule("groupExprs", 10);
		TraceIn("groupExprs", 10);
		try { DebugEnterRule(GrammarFileName, "groupExprs");
		DebugLocation(94, 1);
		try
		{
			// SqlGenerator.g:96:2: ( expr ( groupExprs )? )
			DebugEnterAlt(1);
			// SqlGenerator.g:96:4: expr ( groupExprs )?
			{
			DebugLocation(96, 4);
			PushFollow(Follow._expr_in_groupExprs428);
			expr();
			PopFollow();
			if (state.failed) return;
			DebugLocation(96, 9);
			// SqlGenerator.g:96:9: ( groupExprs )?
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_1 = input.LA(1);

			if ((LA15_1==AGGREGATE||LA15_1==ALL||LA15_1==ANY||LA15_1==BAND||(LA15_1>=BNOT && LA15_1<=BOR)||(LA15_1>=BXOR && LA15_1<=CASE2)||LA15_1==CONSTANT||LA15_1==COUNT||(LA15_1>=DIV && LA15_1<=DOT)||LA15_1==FALSE||LA15_1==IDENT||LA15_1==INDEX_OP||LA15_1==JAVA_CONSTANT||LA15_1==METHOD_CALL||LA15_1==MINUS||(LA15_1>=NULL && LA15_1<=NUM_LONG)||(LA15_1>=PARAM && LA15_1<=PLUS)||LA15_1==QUOTED_String||LA15_1==SELECT||LA15_1==SOME||LA15_1==STAR||(LA15_1>=TRUE && LA15_1<=UNARY_MINUS)||LA15_1==UNION||LA15_1==VECTOR_EXPR||LA15_1==ALIAS_REF||LA15_1==NAMED_PARAM||LA15_1==RESULT_VARIABLE_REF||LA15_1==SQL_TOKEN))
			{
				alt15 = 1;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:96:11: groupExprs
				{
				DebugLocation(96, 11);
				if (state.backtracking == 0)
				{
					Out(" , "); 
				}
				DebugLocation(96, 26);
				PushFollow(Follow._groupExprs_in_groupExprs434);
				groupExprs();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(15); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("groupExprs", 10);
			LeaveRule("groupExprs", 10);
			LeaveRule_groupExprs();
		}
		DebugLocation(97, 1);
		} finally { DebugExitRule(GrammarFileName, "groupExprs"); }
		return;

	}
	// $ANTLR end "groupExprs"

	partial void EnterRule_orderDirection();
	partial void LeaveRule_orderDirection();
	// $ANTLR start "orderDirection"
	// SqlGenerator.g:99:1: orderDirection : ( ASCENDING | DESCENDING );
	[GrammarRule("orderDirection")]
	private TreeRuleReturnScope<IASTNode> orderDirection()
	{
		EnterRule_orderDirection();
		EnterRule("orderDirection", 11);
		TraceIn("orderDirection", 11);
		TreeRuleReturnScope<IASTNode> retval = new TreeRuleReturnScope<IASTNode>();
		retval.Start = (IASTNode)input.LT(1);

		try { DebugEnterRule(GrammarFileName, "orderDirection");
		DebugLocation(99, 1);
		try
		{
			// SqlGenerator.g:100:2: ( ASCENDING | DESCENDING )
			DebugEnterAlt(1);
			// SqlGenerator.g:
			{
			DebugLocation(100, 2);
			if (input.LA(1)==ASCENDING||input.LA(1)==DESCENDING)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("orderDirection", 11);
			LeaveRule("orderDirection", 11);
			LeaveRule_orderDirection();
		}
		DebugLocation(102, 1);
		} finally { DebugExitRule(GrammarFileName, "orderDirection"); }
		return retval;

	}
	// $ANTLR end "orderDirection"

	partial void EnterRule_whereExpr();
	partial void LeaveRule_whereExpr();
	// $ANTLR start "whereExpr"
	// SqlGenerator.g:104:8: public whereExpr : ( filters ( thetaJoins )? ( booleanExpr[ true ] )? | thetaJoins ( booleanExpr[ true ] )? | booleanExpr[false] );
	[GrammarRule("whereExpr")]
	public void whereExpr()
	{
		EnterRule_whereExpr();
		EnterRule("whereExpr", 12);
		TraceIn("whereExpr", 12);
		try { DebugEnterRule(GrammarFileName, "whereExpr");
		DebugLocation(104, 1);
		try
		{
			// SqlGenerator.g:108:2: ( filters ( thetaJoins )? ( booleanExpr[ true ] )? | thetaJoins ( booleanExpr[ true ] )? | booleanExpr[false] )
			int alt19=3;
			try { DebugEnterDecision(19, false);
			switch (input.LA(1))
			{
			case FILTERS:
				{
				alt19 = 1;
				}
				break;
			case THETA_JOINS:
				{
				alt19 = 2;
				}
				break;
			case AND:
			case BETWEEN:
			case EQ:
			case EXISTS:
			case GE:
			case GT:
			case IN:
			case IS_NOT_NULL:
			case IS_NULL:
			case LE:
			case LIKE:
			case LT:
			case METHOD_CALL:
			case NE:
			case NOT:
			case NOT_BETWEEN:
			case NOT_IN:
			case NOT_LIKE:
			case OR:
			case SQL_TOKEN:
				{
				alt19 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 19, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:108:4: filters ( thetaJoins )? ( booleanExpr[ true ] )?
				{
				DebugLocation(108, 4);
				PushFollow(Follow._filters_in_whereExpr471);
				filters();
				PopFollow();
				if (state.failed) return;
				DebugLocation(109, 3);
				// SqlGenerator.g:109:3: ( thetaJoins )?
				int alt16=2;
				try { DebugEnterSubRule(16);
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if ((LA16_1==THETA_JOINS))
				{
					alt16 = 1;
				}
				} finally { DebugExitDecision(16); }
				switch (alt16)
				{
				case 1:
					DebugEnterAlt(1);
					// SqlGenerator.g:109:5: thetaJoins
					{
					DebugLocation(109, 5);
					if (state.backtracking == 0)
					{
						 Out(" and "); 
					}
					DebugLocation(109, 23);
					PushFollow(Follow._thetaJoins_in_whereExpr479);
					thetaJoins();
					PopFollow();
					if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(16); }

				DebugLocation(110, 3);
				// SqlGenerator.g:110:3: ( booleanExpr[ true ] )?
				int alt17=2;
				try { DebugEnterSubRule(17);
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if ((LA17_1==AND||LA17_1==BETWEEN||LA17_1==EQ||LA17_1==EXISTS||LA17_1==GE||LA17_1==GT||LA17_1==IN||(LA17_1>=IS_NOT_NULL && LA17_1<=IS_NULL)||LA17_1==LE||LA17_1==LIKE||LA17_1==LT||LA17_1==METHOD_CALL||LA17_1==NE||(LA17_1>=NOT && LA17_1<=NOT_LIKE)||LA17_1==OR||LA17_1==SQL_TOKEN))
				{
					alt17 = 1;
				}
				} finally { DebugExitDecision(17); }
				switch (alt17)
				{
				case 1:
					DebugEnterAlt(1);
					// SqlGenerator.g:110:5: booleanExpr[ true ]
					{
					DebugLocation(110, 5);
					if (state.backtracking == 0)
					{
						 Out(" and "); 
					}
					DebugLocation(110, 23);
					PushFollow(Follow._booleanExpr_in_whereExpr490);
					booleanExpr(true);
					PopFollow();
					if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(17); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:111:4: thetaJoins ( booleanExpr[ true ] )?
				{
				DebugLocation(111, 4);
				PushFollow(Follow._thetaJoins_in_whereExpr500);
				thetaJoins();
				PopFollow();
				if (state.failed) return;
				DebugLocation(112, 3);
				// SqlGenerator.g:112:3: ( booleanExpr[ true ] )?
				int alt18=2;
				try { DebugEnterSubRule(18);
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1==AND||LA18_1==BETWEEN||LA18_1==EQ||LA18_1==EXISTS||LA18_1==GE||LA18_1==GT||LA18_1==IN||(LA18_1>=IS_NOT_NULL && LA18_1<=IS_NULL)||LA18_1==LE||LA18_1==LIKE||LA18_1==LT||LA18_1==METHOD_CALL||LA18_1==NE||(LA18_1>=NOT && LA18_1<=NOT_LIKE)||LA18_1==OR||LA18_1==SQL_TOKEN))
				{
					alt18 = 1;
				}
				} finally { DebugExitDecision(18); }
				switch (alt18)
				{
				case 1:
					DebugEnterAlt(1);
					// SqlGenerator.g:112:5: booleanExpr[ true ]
					{
					DebugLocation(112, 5);
					if (state.backtracking == 0)
					{
						 Out(" and "); 
					}
					DebugLocation(112, 23);
					PushFollow(Follow._booleanExpr_in_whereExpr508);
					booleanExpr(true);
					PopFollow();
					if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(18); }


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// SqlGenerator.g:113:4: booleanExpr[false]
				{
				DebugLocation(113, 4);
				PushFollow(Follow._booleanExpr_in_whereExpr519);
				booleanExpr(false);
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("whereExpr", 12);
			LeaveRule("whereExpr", 12);
			LeaveRule_whereExpr();
		}
		DebugLocation(114, 1);
		} finally { DebugExitRule(GrammarFileName, "whereExpr"); }
		return;

	}
	// $ANTLR end "whereExpr"

	partial void EnterRule_filters();
	partial void LeaveRule_filters();
	// $ANTLR start "filters"
	// SqlGenerator.g:116:1: filters : ^( FILTERS conditionList ) ;
	[GrammarRule("filters")]
	private void filters()
	{
		EnterRule_filters();
		EnterRule("filters", 13);
		TraceIn("filters", 13);
		try { DebugEnterRule(GrammarFileName, "filters");
		DebugLocation(116, 1);
		try
		{
			// SqlGenerator.g:117:2: ( ^( FILTERS conditionList ) )
			DebugEnterAlt(1);
			// SqlGenerator.g:117:4: ^( FILTERS conditionList )
			{
			DebugLocation(117, 4);
			DebugLocation(117, 6);
			Match(input,FILTERS,Follow._FILTERS_in_filters532); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(117, 14);
			PushFollow(Follow._conditionList_in_filters534);
			conditionList();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("filters", 13);
			LeaveRule("filters", 13);
			LeaveRule_filters();
		}
		DebugLocation(118, 1);
		} finally { DebugExitRule(GrammarFileName, "filters"); }
		return;

	}
	// $ANTLR end "filters"

	partial void EnterRule_thetaJoins();
	partial void LeaveRule_thetaJoins();
	// $ANTLR start "thetaJoins"
	// SqlGenerator.g:120:1: thetaJoins : ^( THETA_JOINS conditionList ) ;
	[GrammarRule("thetaJoins")]
	private void thetaJoins()
	{
		EnterRule_thetaJoins();
		EnterRule("thetaJoins", 14);
		TraceIn("thetaJoins", 14);
		try { DebugEnterRule(GrammarFileName, "thetaJoins");
		DebugLocation(120, 1);
		try
		{
			// SqlGenerator.g:121:2: ( ^( THETA_JOINS conditionList ) )
			DebugEnterAlt(1);
			// SqlGenerator.g:121:4: ^( THETA_JOINS conditionList )
			{
			DebugLocation(121, 4);
			DebugLocation(121, 6);
			Match(input,THETA_JOINS,Follow._THETA_JOINS_in_thetaJoins548); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(121, 18);
			PushFollow(Follow._conditionList_in_thetaJoins550);
			conditionList();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("thetaJoins", 14);
			LeaveRule("thetaJoins", 14);
			LeaveRule_thetaJoins();
		}
		DebugLocation(122, 1);
		} finally { DebugExitRule(GrammarFileName, "thetaJoins"); }
		return;

	}
	// $ANTLR end "thetaJoins"

	partial void EnterRule_conditionList();
	partial void LeaveRule_conditionList();
	// $ANTLR start "conditionList"
	// SqlGenerator.g:124:1: conditionList : sqlToken ( conditionList )? ;
	[GrammarRule("conditionList")]
	private void conditionList()
	{
		EnterRule_conditionList();
		EnterRule("conditionList", 15);
		TraceIn("conditionList", 15);
		try { DebugEnterRule(GrammarFileName, "conditionList");
		DebugLocation(124, 1);
		try
		{
			// SqlGenerator.g:125:2: ( sqlToken ( conditionList )? )
			DebugEnterAlt(1);
			// SqlGenerator.g:125:4: sqlToken ( conditionList )?
			{
			DebugLocation(125, 4);
			PushFollow(Follow._sqlToken_in_conditionList563);
			sqlToken();
			PopFollow();
			if (state.failed) return;
			DebugLocation(125, 13);
			// SqlGenerator.g:125:13: ( conditionList )?
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_1 = input.LA(1);

			if ((LA20_1==SQL_TOKEN))
			{
				alt20 = 1;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:125:15: conditionList
				{
				DebugLocation(125, 15);
				if (state.backtracking == 0)
				{
					 Out(" and "); 
				}
				DebugLocation(125, 33);
				PushFollow(Follow._conditionList_in_conditionList569);
				conditionList();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(20); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("conditionList", 15);
			LeaveRule("conditionList", 15);
			LeaveRule_conditionList();
		}
		DebugLocation(126, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionList"); }
		return;

	}
	// $ANTLR end "conditionList"

	partial void EnterRule_selectClause();
	partial void LeaveRule_selectClause();
	// $ANTLR start "selectClause"
	// SqlGenerator.g:128:1: selectClause : ^( SELECT_CLAUSE ( distinctOrAll )? ( selectColumn )+ ) ;
	[GrammarRule("selectClause")]
	private void selectClause()
	{
		EnterRule_selectClause();
		EnterRule("selectClause", 16);
		TraceIn("selectClause", 16);
		try { DebugEnterRule(GrammarFileName, "selectClause");
		DebugLocation(128, 1);
		try
		{
			// SqlGenerator.g:129:2: ( ^( SELECT_CLAUSE ( distinctOrAll )? ( selectColumn )+ ) )
			DebugEnterAlt(1);
			// SqlGenerator.g:129:4: ^( SELECT_CLAUSE ( distinctOrAll )? ( selectColumn )+ )
			{
			DebugLocation(129, 4);
			DebugLocation(129, 6);
			Match(input,SELECT_CLAUSE,Follow._SELECT_CLAUSE_in_selectClause584); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(129, 20);
			// SqlGenerator.g:129:20: ( distinctOrAll )?
			int alt21=2;
			try { DebugEnterSubRule(21);
			try { DebugEnterDecision(21, false);
			int LA21_1 = input.LA(1);

			if ((LA21_1==ALL||LA21_1==DISTINCT))
			{
				alt21 = 1;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:129:21: distinctOrAll
				{
				DebugLocation(129, 21);
				PushFollow(Follow._distinctOrAll_in_selectClause587);
				distinctOrAll();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(21); }

			DebugLocation(129, 37);
			// SqlGenerator.g:129:37: ( selectColumn )+
			int cnt22=0;
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_1 = input.LA(1);

				if ((LA22_1==AGGREGATE||LA22_1==BAND||(LA22_1>=BNOT && LA22_1<=BOR)||(LA22_1>=BXOR && LA22_1<=CASE2)||(LA22_1>=CONSTANT && LA22_1<=COUNT)||(LA22_1>=DIV && LA22_1<=DOT)||LA22_1==FALSE||LA22_1==IDENT||LA22_1==JAVA_CONSTANT||LA22_1==METHOD_CALL||LA22_1==MINUS||(LA22_1>=NUM_DECIMAL && LA22_1<=NUM_LONG)||(LA22_1>=PARAM && LA22_1<=PLUS)||LA22_1==QUOTED_String||LA22_1==SELECT||LA22_1==STAR||(LA22_1>=TRUE && LA22_1<=UNARY_MINUS)||LA22_1==ALIAS_REF||LA22_1==NAMED_PARAM||(LA22_1>=SELECT_EXPR && LA22_1<=SQL_TOKEN)))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch (alt22)
				{
				case 1:
					DebugEnterAlt(1);
					// SqlGenerator.g:129:39: selectColumn
					{
					DebugLocation(129, 39);
					PushFollow(Follow._selectColumn_in_selectClause593);
					selectColumn();
					PopFollow();
					if (state.failed) return;

					}
					break;

				default:
					if (cnt22 >= 1)
						goto loop22;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee22 = new EarlyExitException( 22, input );
					DebugRecognitionException(eee22);
					throw eee22;
				}
				cnt22++;
			}
			loop22:
				;

			} finally { DebugExitSubRule(22); }


			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("selectClause", 16);
			LeaveRule("selectClause", 16);
			LeaveRule_selectClause();
		}
		DebugLocation(130, 1);
		} finally { DebugExitRule(GrammarFileName, "selectClause"); }
		return;

	}
	// $ANTLR end "selectClause"

	partial void EnterRule_selectColumn();
	partial void LeaveRule_selectColumn();
	// $ANTLR start "selectColumn"
	// SqlGenerator.g:132:1: selectColumn : p= selectExpr (sc= SELECT_COLUMNS )? ;
	[GrammarRule("selectColumn")]
	private void selectColumn()
	{
		EnterRule_selectColumn();
		EnterRule("selectColumn", 17);
		TraceIn("selectColumn", 17);
		IASTNode sc = default(IASTNode);
		TreeRuleReturnScope<IASTNode> p = default(TreeRuleReturnScope<IASTNode>);

		try { DebugEnterRule(GrammarFileName, "selectColumn");
		DebugLocation(132, 1);
		try
		{
			// SqlGenerator.g:133:2: (p= selectExpr (sc= SELECT_COLUMNS )? )
			DebugEnterAlt(1);
			// SqlGenerator.g:133:4: p= selectExpr (sc= SELECT_COLUMNS )?
			{
			DebugLocation(133, 5);
			PushFollow(Follow._selectExpr_in_selectColumn611);
			p=selectExpr();
			PopFollow();
			if (state.failed) return;
			DebugLocation(133, 17);
			// SqlGenerator.g:133:17: (sc= SELECT_COLUMNS )?
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_1 = input.LA(1);

			if ((LA23_1==SELECT_COLUMNS))
			{
				alt23 = 1;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:133:18: sc= SELECT_COLUMNS
				{
				DebugLocation(133, 20);
				sc=(IASTNode)Match(input,SELECT_COLUMNS,Follow._SELECT_COLUMNS_in_selectColumn616); if (state.failed) return;
				DebugLocation(133, 36);
				if (state.backtracking == 0)
				{
					 Out(sc); 
				}

				}
				break;

			}
			} finally { DebugExitSubRule(23); }

			DebugLocation(133, 53);
			if (state.backtracking == 0)
			{
				 Separator( (sc != null) ? sc : (p!=null?((IASTNode)p.Start):default(IASTNode)) ,", "); 
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("selectColumn", 17);
			LeaveRule("selectColumn", 17);
			LeaveRule_selectColumn();
		}
		DebugLocation(134, 1);
		} finally { DebugExitRule(GrammarFileName, "selectColumn"); }
		return;

	}
	// $ANTLR end "selectColumn"

	partial void EnterRule_selectExpr();
	partial void LeaveRule_selectExpr();
	// $ANTLR start "selectExpr"
	// SqlGenerator.g:136:1: selectExpr : (e= selectAtom | count | ^( CONSTRUCTOR ( DOT | IDENT ) ( selectColumn )+ ) | methodCall | aggregate |c= constant | arithmeticExpr | parameter | selectStatement );
	[GrammarRule("selectExpr")]
	private TreeRuleReturnScope<IASTNode> selectExpr()
	{
		EnterRule_selectExpr();
		EnterRule("selectExpr", 18);
		TraceIn("selectExpr", 18);
		TreeRuleReturnScope<IASTNode> retval = new TreeRuleReturnScope<IASTNode>();
		retval.Start = (IASTNode)input.LT(1);

		TreeRuleReturnScope<IASTNode> e = default(TreeRuleReturnScope<IASTNode>);
		TreeRuleReturnScope<IASTNode> c = default(TreeRuleReturnScope<IASTNode>);

		try { DebugEnterRule(GrammarFileName, "selectExpr");
		DebugLocation(136, 1);
		try
		{
			// SqlGenerator.g:137:2: (e= selectAtom | count | ^( CONSTRUCTOR ( DOT | IDENT ) ( selectColumn )+ ) | methodCall | aggregate |c= constant | arithmeticExpr | parameter | selectStatement )
			int alt25=9;
			try { DebugEnterDecision(25, false);
			switch (input.LA(1))
			{
			case DOT:
			case ALIAS_REF:
			case SELECT_EXPR:
			case SQL_TOKEN:
				{
				alt25 = 1;
				}
				break;
			case COUNT:
				{
				alt25 = 2;
				}
				break;
			case CONSTRUCTOR:
				{
				alt25 = 3;
				}
				break;
			case METHOD_CALL:
				{
				alt25 = 4;
				}
				break;
			case AGGREGATE:
				{
				alt25 = 5;
				}
				break;
			case CONSTANT:
			case FALSE:
			case IDENT:
			case JAVA_CONSTANT:
			case NUM_DECIMAL:
			case NUM_DOUBLE:
			case NUM_FLOAT:
			case NUM_INT:
			case NUM_LONG:
			case QUOTED_String:
			case TRUE:
				{
				alt25 = 6;
				}
				break;
			case BAND:
			case BNOT:
			case BOR:
			case BXOR:
			case CASE:
			case CASE2:
			case DIV:
			case MINUS:
			case PLUS:
			case STAR:
			case UNARY_MINUS:
				{
				alt25 = 7;
				}
				break;
			case PARAM:
			case NAMED_PARAM:
				{
				alt25 = 8;
				}
				break;
			case SELECT:
				{
				alt25 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 25, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:137:4: e= selectAtom
				{
				DebugLocation(137, 5);
				PushFollow(Follow._selectAtom_in_selectExpr636);
				e=selectAtom();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(137, 17);
				if (state.backtracking == 0)
				{
					 Out((e!=null?((IASTNode)e.Start):default(IASTNode))); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:138:4: count
				{
				DebugLocation(138, 4);
				PushFollow(Follow._count_in_selectExpr643);
				count();
				PopFollow();
				if (state.failed) return retval;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// SqlGenerator.g:139:4: ^( CONSTRUCTOR ( DOT | IDENT ) ( selectColumn )+ )
				{
				DebugLocation(139, 4);
				DebugLocation(139, 6);
				Match(input,CONSTRUCTOR,Follow._CONSTRUCTOR_in_selectExpr649); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(139, 18);
				if (input.LA(1)==DOT||input.LA(1)==IDENT)
				{
					input.Consume();
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(139, 32);
				// SqlGenerator.g:139:32: ( selectColumn )+
				int cnt24=0;
				try { DebugEnterSubRule(24);
				while (true)
				{
					int alt24=2;
					try { DebugEnterDecision(24, false);
					int LA24_1 = input.LA(1);

					if ((LA24_1==AGGREGATE||LA24_1==BAND||(LA24_1>=BNOT && LA24_1<=BOR)||(LA24_1>=BXOR && LA24_1<=CASE2)||(LA24_1>=CONSTANT && LA24_1<=COUNT)||(LA24_1>=DIV && LA24_1<=DOT)||LA24_1==FALSE||LA24_1==IDENT||LA24_1==JAVA_CONSTANT||LA24_1==METHOD_CALL||LA24_1==MINUS||(LA24_1>=NUM_DECIMAL && LA24_1<=NUM_LONG)||(LA24_1>=PARAM && LA24_1<=PLUS)||LA24_1==QUOTED_String||LA24_1==SELECT||LA24_1==STAR||(LA24_1>=TRUE && LA24_1<=UNARY_MINUS)||LA24_1==ALIAS_REF||LA24_1==NAMED_PARAM||(LA24_1>=SELECT_EXPR && LA24_1<=SQL_TOKEN)))
					{
						alt24 = 1;
					}


					} finally { DebugExitDecision(24); }
					switch (alt24)
					{
					case 1:
						DebugEnterAlt(1);
						// SqlGenerator.g:139:34: selectColumn
						{
						DebugLocation(139, 34);
						PushFollow(Follow._selectColumn_in_selectExpr661);
						selectColumn();
						PopFollow();
						if (state.failed) return retval;

						}
						break;

					default:
						if (cnt24 >= 1)
							goto loop24;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee24 = new EarlyExitException( 24, input );
						DebugRecognitionException(eee24);
						throw eee24;
					}
					cnt24++;
				}
				loop24:
					;

				} finally { DebugExitSubRule(24); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// SqlGenerator.g:140:4: methodCall
				{
				DebugLocation(140, 4);
				PushFollow(Follow._methodCall_in_selectExpr671);
				methodCall();
				PopFollow();
				if (state.failed) return retval;

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// SqlGenerator.g:141:4: aggregate
				{
				DebugLocation(141, 4);
				PushFollow(Follow._aggregate_in_selectExpr676);
				aggregate();
				PopFollow();
				if (state.failed) return retval;

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// SqlGenerator.g:142:4: c= constant
				{
				DebugLocation(142, 5);
				PushFollow(Follow._constant_in_selectExpr683);
				c=constant();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(142, 15);
				if (state.backtracking == 0)
				{
					 Out((c!=null?((IASTNode)c.Start):default(IASTNode))); 
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// SqlGenerator.g:143:4: arithmeticExpr
				{
				DebugLocation(143, 4);
				PushFollow(Follow._arithmeticExpr_in_selectExpr690);
				arithmeticExpr();
				PopFollow();
				if (state.failed) return retval;

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// SqlGenerator.g:144:4: parameter
				{
				DebugLocation(144, 4);
				PushFollow(Follow._parameter_in_selectExpr695);
				parameter();
				PopFollow();
				if (state.failed) return retval;

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// SqlGenerator.g:147:4: selectStatement
				{
				DebugLocation(147, 4);
				if (state.backtracking == 0)
				{
					 Out("("); 
				}
				DebugLocation(147, 18);
				PushFollow(Follow._selectStatement_in_selectExpr704);
				selectStatement();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(147, 34);
				if (state.backtracking == 0)
				{
					 Out(")"); 
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("selectExpr", 18);
			LeaveRule("selectExpr", 18);
			LeaveRule_selectExpr();
		}
		DebugLocation(148, 1);
		} finally { DebugExitRule(GrammarFileName, "selectExpr"); }
		return retval;

	}
	// $ANTLR end "selectExpr"

	partial void EnterRule_count();
	partial void LeaveRule_count();
	// $ANTLR start "count"
	// SqlGenerator.g:150:1: count : ^( COUNT ( distinctOrAll )? countExpr ) ;
	[GrammarRule("count")]
	private void count()
	{
		EnterRule_count();
		EnterRule("count", 19);
		TraceIn("count", 19);
		try { DebugEnterRule(GrammarFileName, "count");
		DebugLocation(150, 1);
		try
		{
			// SqlGenerator.g:151:2: ( ^( COUNT ( distinctOrAll )? countExpr ) )
			DebugEnterAlt(1);
			// SqlGenerator.g:151:4: ^( COUNT ( distinctOrAll )? countExpr )
			{
			DebugLocation(151, 4);
			DebugLocation(151, 6);
			Match(input,COUNT,Follow._COUNT_in_count718); if (state.failed) return;

			DebugLocation(151, 12);
			if (state.backtracking == 0)
			{
				 Out("count("); 
			}

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(151, 32);
			// SqlGenerator.g:151:32: ( distinctOrAll )?
			int alt26=2;
			try { DebugEnterSubRule(26);
			try { DebugEnterDecision(26, false);
			int LA26_1 = input.LA(1);

			if ((LA26_1==ALL||LA26_1==DISTINCT))
			{
				alt26 = 1;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:151:34: distinctOrAll
				{
				DebugLocation(151, 34);
				PushFollow(Follow._distinctOrAll_in_count725);
				distinctOrAll();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(26); }

			DebugLocation(151, 52);
			PushFollow(Follow._countExpr_in_count731);
			countExpr();
			PopFollow();
			if (state.failed) return;
			DebugLocation(151, 62);
			if (state.backtracking == 0)
			{
				 Out(")"); 
			}

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("count", 19);
			LeaveRule("count", 19);
			LeaveRule_count();
		}
		DebugLocation(152, 1);
		} finally { DebugExitRule(GrammarFileName, "count"); }
		return;

	}
	// $ANTLR end "count"

	partial void EnterRule_distinctOrAll();
	partial void LeaveRule_distinctOrAll();
	// $ANTLR start "distinctOrAll"
	// SqlGenerator.g:154:1: distinctOrAll : ( DISTINCT | ^( ALL ( . )* ) );
	[GrammarRule("distinctOrAll")]
	private void distinctOrAll()
	{
		EnterRule_distinctOrAll();
		EnterRule("distinctOrAll", 20);
		TraceIn("distinctOrAll", 20);
		try { DebugEnterRule(GrammarFileName, "distinctOrAll");
		DebugLocation(154, 1);
		try
		{
			// SqlGenerator.g:155:2: ( DISTINCT | ^( ALL ( . )* ) )
			int alt28=2;
			try { DebugEnterDecision(28, false);
			int LA28_1 = input.LA(1);

			if ((LA28_1==DISTINCT))
			{
				alt28 = 1;
			}
			else if ((LA28_1==ALL))
			{
				alt28 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 28, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:155:4: DISTINCT
				{
				DebugLocation(155, 4);
				Match(input,DISTINCT,Follow._DISTINCT_in_distinctOrAll746); if (state.failed) return;
				DebugLocation(155, 13);
				if (state.backtracking == 0)
				{
					 Out("distinct "); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:156:4: ^( ALL ( . )* )
				{
				DebugLocation(156, 4);
				DebugLocation(156, 6);
				Match(input,ALL,Follow._ALL_in_distinctOrAll754); if (state.failed) return;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(156, 10);
					// SqlGenerator.g:156:10: ( . )*
					try { DebugEnterSubRule(27);
					while (true)
					{
						int alt27=2;
						try { DebugEnterDecision(27, false);
						int LA27_1 = input.LA(1);

						if (((LA27_1>=AGGREGATE && LA27_1<=THETA_JOINS)))
						{
							alt27 = 1;
						}
						else if ((LA27_1==UP))
						{
							alt27 = 2;
						}


						} finally { DebugExitDecision(27); }
						switch ( alt27 )
						{
						case 1:
							DebugEnterAlt(1);
							// SqlGenerator.g:156:10: .
							{
							DebugLocation(156, 10);
							MatchAny(input); if (state.failed) return;

							}
							break;

						default:
							goto loop27;
						}
					}

					loop27:
						;

					} finally { DebugExitSubRule(27); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}

				DebugLocation(156, 14);
				if (state.backtracking == 0)
				{
					 Out("all "); 
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("distinctOrAll", 20);
			LeaveRule("distinctOrAll", 20);
			LeaveRule_distinctOrAll();
		}
		DebugLocation(157, 1);
		} finally { DebugExitRule(GrammarFileName, "distinctOrAll"); }
		return;

	}
	// $ANTLR end "distinctOrAll"

	partial void EnterRule_countExpr();
	partial void LeaveRule_countExpr();
	// $ANTLR start "countExpr"
	// SqlGenerator.g:159:1: countExpr : ( ROW_STAR | simpleExpr );
	[GrammarRule("countExpr")]
	private void countExpr()
	{
		EnterRule_countExpr();
		EnterRule("countExpr", 21);
		TraceIn("countExpr", 21);
		try { DebugEnterRule(GrammarFileName, "countExpr");
		DebugLocation(159, 1);
		try
		{
			// SqlGenerator.g:161:2: ( ROW_STAR | simpleExpr )
			int alt29=2;
			try { DebugEnterDecision(29, false);
			int LA29_1 = input.LA(1);

			if ((LA29_1==ROW_STAR))
			{
				alt29 = 1;
			}
			else if ((LA29_1==AGGREGATE||LA29_1==BAND||(LA29_1>=BNOT && LA29_1<=BOR)||(LA29_1>=BXOR && LA29_1<=CASE2)||LA29_1==CONSTANT||LA29_1==COUNT||(LA29_1>=DIV && LA29_1<=DOT)||LA29_1==FALSE||LA29_1==IDENT||LA29_1==INDEX_OP||LA29_1==JAVA_CONSTANT||LA29_1==METHOD_CALL||LA29_1==MINUS||(LA29_1>=NULL && LA29_1<=NUM_LONG)||(LA29_1>=PARAM && LA29_1<=PLUS)||LA29_1==QUOTED_String||LA29_1==STAR||(LA29_1>=TRUE && LA29_1<=UNARY_MINUS)||LA29_1==ALIAS_REF||LA29_1==NAMED_PARAM||LA29_1==RESULT_VARIABLE_REF||LA29_1==SQL_TOKEN))
			{
				alt29 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 29, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:161:4: ROW_STAR
				{
				DebugLocation(161, 4);
				Match(input,ROW_STAR,Follow._ROW_STAR_in_countExpr773); if (state.failed) return;
				DebugLocation(161, 13);
				if (state.backtracking == 0)
				{
					 Out("*"); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:162:4: simpleExpr
				{
				DebugLocation(162, 4);
				PushFollow(Follow._simpleExpr_in_countExpr780);
				simpleExpr();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("countExpr", 21);
			LeaveRule("countExpr", 21);
			LeaveRule_countExpr();
		}
		DebugLocation(163, 1);
		} finally { DebugExitRule(GrammarFileName, "countExpr"); }
		return;

	}
	// $ANTLR end "countExpr"

	partial void EnterRule_selectAtom();
	partial void LeaveRule_selectAtom();
	// $ANTLR start "selectAtom"
	// SqlGenerator.g:165:1: selectAtom : ( ^( DOT ( . )* ) | ^( SQL_TOKEN ( . )* ) | ^( ALIAS_REF ( . )* ) | ^( SELECT_EXPR ( . )* ) );
	[GrammarRule("selectAtom")]
	private TreeRuleReturnScope<IASTNode> selectAtom()
	{
		EnterRule_selectAtom();
		EnterRule("selectAtom", 22);
		TraceIn("selectAtom", 22);
		TreeRuleReturnScope<IASTNode> retval = new TreeRuleReturnScope<IASTNode>();
		retval.Start = (IASTNode)input.LT(1);

		try { DebugEnterRule(GrammarFileName, "selectAtom");
		DebugLocation(165, 1);
		try
		{
			// SqlGenerator.g:166:2: ( ^( DOT ( . )* ) | ^( SQL_TOKEN ( . )* ) | ^( ALIAS_REF ( . )* ) | ^( SELECT_EXPR ( . )* ) )
			int alt34=4;
			try { DebugEnterDecision(34, false);
			switch (input.LA(1))
			{
			case DOT:
				{
				alt34 = 1;
				}
				break;
			case SQL_TOKEN:
				{
				alt34 = 2;
				}
				break;
			case ALIAS_REF:
				{
				alt34 = 3;
				}
				break;
			case SELECT_EXPR:
				{
				alt34 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 34, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(34); }
			switch (alt34)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:166:4: ^( DOT ( . )* )
				{
				DebugLocation(166, 4);
				DebugLocation(166, 6);
				Match(input,DOT,Follow._DOT_in_selectAtom792); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(166, 10);
					// SqlGenerator.g:166:10: ( . )*
					try { DebugEnterSubRule(30);
					while (true)
					{
						int alt30=2;
						try { DebugEnterDecision(30, false);
						int LA30_1 = input.LA(1);

						if (((LA30_1>=AGGREGATE && LA30_1<=THETA_JOINS)))
						{
							alt30 = 1;
						}
						else if ((LA30_1==UP))
						{
							alt30 = 2;
						}


						} finally { DebugExitDecision(30); }
						switch ( alt30 )
						{
						case 1:
							DebugEnterAlt(1);
							// SqlGenerator.g:166:10: .
							{
							DebugLocation(166, 10);
							MatchAny(input); if (state.failed) return retval;

							}
							break;

						default:
							goto loop30;
						}
					}

					loop30:
						;

					} finally { DebugExitSubRule(30); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:167:4: ^( SQL_TOKEN ( . )* )
				{
				DebugLocation(167, 4);
				DebugLocation(167, 6);
				Match(input,SQL_TOKEN,Follow._SQL_TOKEN_in_selectAtom802); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(167, 16);
					// SqlGenerator.g:167:16: ( . )*
					try { DebugEnterSubRule(31);
					while (true)
					{
						int alt31=2;
						try { DebugEnterDecision(31, false);
						int LA31_1 = input.LA(1);

						if (((LA31_1>=AGGREGATE && LA31_1<=THETA_JOINS)))
						{
							alt31 = 1;
						}
						else if ((LA31_1==UP))
						{
							alt31 = 2;
						}


						} finally { DebugExitDecision(31); }
						switch ( alt31 )
						{
						case 1:
							DebugEnterAlt(1);
							// SqlGenerator.g:167:16: .
							{
							DebugLocation(167, 16);
							MatchAny(input); if (state.failed) return retval;

							}
							break;

						default:
							goto loop31;
						}
					}

					loop31:
						;

					} finally { DebugExitSubRule(31); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// SqlGenerator.g:168:4: ^( ALIAS_REF ( . )* )
				{
				DebugLocation(168, 4);
				DebugLocation(168, 6);
				Match(input,ALIAS_REF,Follow._ALIAS_REF_in_selectAtom812); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(168, 16);
					// SqlGenerator.g:168:16: ( . )*
					try { DebugEnterSubRule(32);
					while (true)
					{
						int alt32=2;
						try { DebugEnterDecision(32, false);
						int LA32_1 = input.LA(1);

						if (((LA32_1>=AGGREGATE && LA32_1<=THETA_JOINS)))
						{
							alt32 = 1;
						}
						else if ((LA32_1==UP))
						{
							alt32 = 2;
						}


						} finally { DebugExitDecision(32); }
						switch ( alt32 )
						{
						case 1:
							DebugEnterAlt(1);
							// SqlGenerator.g:168:16: .
							{
							DebugLocation(168, 16);
							MatchAny(input); if (state.failed) return retval;

							}
							break;

						default:
							goto loop32;
						}
					}

					loop32:
						;

					} finally { DebugExitSubRule(32); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// SqlGenerator.g:169:4: ^( SELECT_EXPR ( . )* )
				{
				DebugLocation(169, 4);
				DebugLocation(169, 6);
				Match(input,SELECT_EXPR,Follow._SELECT_EXPR_in_selectAtom822); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(169, 18);
					// SqlGenerator.g:169:18: ( . )*
					try { DebugEnterSubRule(33);
					while (true)
					{
						int alt33=2;
						try { DebugEnterDecision(33, false);
						int LA33_1 = input.LA(1);

						if (((LA33_1>=AGGREGATE && LA33_1<=THETA_JOINS)))
						{
							alt33 = 1;
						}
						else if ((LA33_1==UP))
						{
							alt33 = 2;
						}


						} finally { DebugExitDecision(33); }
						switch ( alt33 )
						{
						case 1:
							DebugEnterAlt(1);
							// SqlGenerator.g:169:18: .
							{
							DebugLocation(169, 18);
							MatchAny(input); if (state.failed) return retval;

							}
							break;

						default:
							goto loop33;
						}
					}

					loop33:
						;

					} finally { DebugExitSubRule(33); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("selectAtom", 22);
			LeaveRule("selectAtom", 22);
			LeaveRule_selectAtom();
		}
		DebugLocation(170, 1);
		} finally { DebugExitRule(GrammarFileName, "selectAtom"); }
		return retval;

	}
	// $ANTLR end "selectAtom"

	partial void EnterRule_from();
	partial void LeaveRule_from();
	// $ANTLR start "from"
	// SqlGenerator.g:177:1: from : ^(f= FROM ( fromTable )* ) ;
	[GrammarRule("from")]
	private void from()
	{
		EnterRule_from();
		EnterRule("from", 23);
		TraceIn("from", 23);
		IASTNode f = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "from");
		DebugLocation(177, 1);
		try
		{
			// SqlGenerator.g:178:2: ( ^(f= FROM ( fromTable )* ) )
			DebugEnterAlt(1);
			// SqlGenerator.g:178:4: ^(f= FROM ( fromTable )* )
			{
			DebugLocation(178, 4);
			DebugLocation(178, 7);
			f=(IASTNode)Match(input,FROM,Follow._FROM_in_from845); if (state.failed) return;

			DebugLocation(178, 13);
			if (state.backtracking == 0)
			{
				 Out(" from "); 
			}

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(179, 3);
				// SqlGenerator.g:179:3: ( fromTable )*
				try { DebugEnterSubRule(35);
				while (true)
				{
					int alt35=2;
					try { DebugEnterDecision(35, false);
					int LA35_1 = input.LA(1);

					if ((LA35_1==FROM_FRAGMENT||LA35_1==JOIN_FRAGMENT))
					{
						alt35 = 1;
					}


					} finally { DebugExitDecision(35); }
					switch ( alt35 )
					{
					case 1:
						DebugEnterAlt(1);
						// SqlGenerator.g:179:4: fromTable
						{
						DebugLocation(179, 4);
						PushFollow(Follow._fromTable_in_from852);
						fromTable();
						PopFollow();
						if (state.failed) return;

						}
						break;

					default:
						goto loop35;
					}
				}

				loop35:
					;

				} finally { DebugExitSubRule(35); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("from", 23);
			LeaveRule("from", 23);
			LeaveRule_from();
		}
		DebugLocation(180, 1);
		} finally { DebugExitRule(GrammarFileName, "from"); }
		return;

	}
	// $ANTLR end "from"

	partial void EnterRule_fromTable();
	partial void LeaveRule_fromTable();
	// $ANTLR start "fromTable"
	// SqlGenerator.g:182:1: fromTable : ( ^(a= FROM_FRAGMENT ( tableJoin[ a ] )* ) | ^(a= JOIN_FRAGMENT ( tableJoin[ a ] )* ) );
	[GrammarRule("fromTable")]
	private void fromTable()
	{
		EnterRule_fromTable();
		EnterRule("fromTable", 24);
		TraceIn("fromTable", 24);
		IASTNode a = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "fromTable");
		DebugLocation(182, 1);
		try
		{
			// SqlGenerator.g:187:2: ( ^(a= FROM_FRAGMENT ( tableJoin[ a ] )* ) | ^(a= JOIN_FRAGMENT ( tableJoin[ a ] )* ) )
			int alt38=2;
			try { DebugEnterDecision(38, false);
			int LA38_1 = input.LA(1);

			if ((LA38_1==FROM_FRAGMENT))
			{
				alt38 = 1;
			}
			else if ((LA38_1==JOIN_FRAGMENT))
			{
				alt38 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 38, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:187:4: ^(a= FROM_FRAGMENT ( tableJoin[ a ] )* )
				{
				DebugLocation(187, 4);
				DebugLocation(187, 8);
				a=(IASTNode)Match(input,FROM_FRAGMENT,Follow._FROM_FRAGMENT_in_fromTable878); if (state.failed) return;

				DebugLocation(187, 24);
				if (state.backtracking == 0)
				{
					 Out(a); 
				}

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(187, 36);
					// SqlGenerator.g:187:36: ( tableJoin[ a ] )*
					try { DebugEnterSubRule(36);
					while (true)
					{
						int alt36=2;
						try { DebugEnterDecision(36, false);
						int LA36_1 = input.LA(1);

						if ((LA36_1==FROM_FRAGMENT||LA36_1==JOIN_FRAGMENT))
						{
							alt36 = 1;
						}


						} finally { DebugExitDecision(36); }
						switch ( alt36 )
						{
						case 1:
							DebugEnterAlt(1);
							// SqlGenerator.g:187:37: tableJoin[ a ]
							{
							DebugLocation(187, 37);
							PushFollow(Follow._tableJoin_in_fromTable884);
							tableJoin(a);
							PopFollow();
							if (state.failed) return;

							}
							break;

						default:
							goto loop36;
						}
					}

					loop36:
						;

					} finally { DebugExitSubRule(36); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:188:4: ^(a= JOIN_FRAGMENT ( tableJoin[ a ] )* )
				{
				DebugLocation(188, 4);
				DebugLocation(188, 8);
				a=(IASTNode)Match(input,JOIN_FRAGMENT,Follow._JOIN_FRAGMENT_in_fromTable899); if (state.failed) return;

				DebugLocation(188, 24);
				if (state.backtracking == 0)
				{
					 Out(a); 
				}

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(188, 36);
					// SqlGenerator.g:188:36: ( tableJoin[ a ] )*
					try { DebugEnterSubRule(37);
					while (true)
					{
						int alt37=2;
						try { DebugEnterDecision(37, false);
						int LA37_1 = input.LA(1);

						if ((LA37_1==FROM_FRAGMENT||LA37_1==JOIN_FRAGMENT))
						{
							alt37 = 1;
						}


						} finally { DebugExitDecision(37); }
						switch ( alt37 )
						{
						case 1:
							DebugEnterAlt(1);
							// SqlGenerator.g:188:37: tableJoin[ a ]
							{
							DebugLocation(188, 37);
							PushFollow(Follow._tableJoin_in_fromTable905);
							tableJoin(a);
							PopFollow();
							if (state.failed) return;

							}
							break;

						default:
							goto loop37;
						}
					}

					loop37:
						;

					} finally { DebugExitSubRule(37); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;

			}
			if (state.backtracking == 0)
			{

				   FromFragmentSeparator(a);

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("fromTable", 24);
			LeaveRule("fromTable", 24);
			LeaveRule_fromTable();
		}
		DebugLocation(189, 1);
		} finally { DebugExitRule(GrammarFileName, "fromTable"); }
		return;

	}
	// $ANTLR end "fromTable"

	partial void EnterRule_tableJoin();
	partial void LeaveRule_tableJoin();
	// $ANTLR start "tableJoin"
	// SqlGenerator.g:191:1: tableJoin[ IASTNode parent ] : ( ^(c= JOIN_FRAGMENT ( tableJoin[ c ] )* ) | ^(d= FROM_FRAGMENT ( tableJoin[ d ] )* ) );
	[GrammarRule("tableJoin")]
	private void tableJoin(IASTNode parent)
	{
		EnterRule_tableJoin();
		EnterRule("tableJoin", 25);
		TraceIn("tableJoin", 25);
		IASTNode c = default(IASTNode);
		IASTNode d = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "tableJoin");
		DebugLocation(191, 1);
		try
		{
			// SqlGenerator.g:192:2: ( ^(c= JOIN_FRAGMENT ( tableJoin[ c ] )* ) | ^(d= FROM_FRAGMENT ( tableJoin[ d ] )* ) )
			int alt41=2;
			try { DebugEnterDecision(41, false);
			int LA41_1 = input.LA(1);

			if ((LA41_1==JOIN_FRAGMENT))
			{
				alt41 = 1;
			}
			else if ((LA41_1==FROM_FRAGMENT))
			{
				alt41 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 41, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(41); }
			switch (alt41)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:192:4: ^(c= JOIN_FRAGMENT ( tableJoin[ c ] )* )
				{
				DebugLocation(192, 4);
				DebugLocation(192, 8);
				c=(IASTNode)Match(input,JOIN_FRAGMENT,Follow._JOIN_FRAGMENT_in_tableJoin928); if (state.failed) return;

				DebugLocation(192, 23);
				if (state.backtracking == 0)
				{
					 Out(" "); Out(c); 
				}

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(192, 46);
					// SqlGenerator.g:192:46: ( tableJoin[ c ] )*
					try { DebugEnterSubRule(39);
					while (true)
					{
						int alt39=2;
						try { DebugEnterDecision(39, false);
						int LA39_1 = input.LA(1);

						if ((LA39_1==FROM_FRAGMENT||LA39_1==JOIN_FRAGMENT))
						{
							alt39 = 1;
						}


						} finally { DebugExitDecision(39); }
						switch ( alt39 )
						{
						case 1:
							DebugEnterAlt(1);
							// SqlGenerator.g:192:47: tableJoin[ c ]
							{
							DebugLocation(192, 47);
							PushFollow(Follow._tableJoin_in_tableJoin933);
							tableJoin(c);
							PopFollow();
							if (state.failed) return;

							}
							break;

						default:
							goto loop39;
						}
					}

					loop39:
						;

					} finally { DebugExitSubRule(39); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:193:4: ^(d= FROM_FRAGMENT ( tableJoin[ d ] )* )
				{
				DebugLocation(193, 4);
				DebugLocation(193, 8);
				d=(IASTNode)Match(input,FROM_FRAGMENT,Follow._FROM_FRAGMENT_in_tableJoin949); if (state.failed) return;

				DebugLocation(193, 23);
				if (state.backtracking == 0)
				{
					 NestedFromFragment(d,parent); 
				}

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(193, 58);
					// SqlGenerator.g:193:58: ( tableJoin[ d ] )*
					try { DebugEnterSubRule(40);
					while (true)
					{
						int alt40=2;
						try { DebugEnterDecision(40, false);
						int LA40_1 = input.LA(1);

						if ((LA40_1==FROM_FRAGMENT||LA40_1==JOIN_FRAGMENT))
						{
							alt40 = 1;
						}


						} finally { DebugExitDecision(40); }
						switch ( alt40 )
						{
						case 1:
							DebugEnterAlt(1);
							// SqlGenerator.g:193:59: tableJoin[ d ]
							{
							DebugLocation(193, 59);
							PushFollow(Follow._tableJoin_in_tableJoin954);
							tableJoin(d);
							PopFollow();
							if (state.failed) return;

							}
							break;

						default:
							goto loop40;
						}
					}

					loop40:
						;

					} finally { DebugExitSubRule(40); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("tableJoin", 25);
			LeaveRule("tableJoin", 25);
			LeaveRule_tableJoin();
		}
		DebugLocation(194, 1);
		} finally { DebugExitRule(GrammarFileName, "tableJoin"); }
		return;

	}
	// $ANTLR end "tableJoin"

	partial void EnterRule_booleanOp();
	partial void LeaveRule_booleanOp();
	// $ANTLR start "booleanOp"
	// SqlGenerator.g:196:1: booleanOp[ bool parens ] : ( ^( AND booleanExpr[true] booleanExpr[true] ) | ^( OR booleanExpr[false] booleanExpr[false] ) | ^( NOT booleanExpr[false] ) );
	[GrammarRule("booleanOp")]
	private void booleanOp(bool parens)
	{
		EnterRule_booleanOp();
		EnterRule("booleanOp", 26);
		TraceIn("booleanOp", 26);
		try { DebugEnterRule(GrammarFileName, "booleanOp");
		DebugLocation(196, 1);
		try
		{
			// SqlGenerator.g:197:2: ( ^( AND booleanExpr[true] booleanExpr[true] ) | ^( OR booleanExpr[false] booleanExpr[false] ) | ^( NOT booleanExpr[false] ) )
			int alt42=3;
			try { DebugEnterDecision(42, false);
			switch (input.LA(1))
			{
			case AND:
				{
				alt42 = 1;
				}
				break;
			case OR:
				{
				alt42 = 2;
				}
				break;
			case NOT:
				{
				alt42 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 42, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(42); }
			switch (alt42)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:197:4: ^( AND booleanExpr[true] booleanExpr[true] )
				{
				DebugLocation(197, 4);
				DebugLocation(197, 6);
				Match(input,AND,Follow._AND_in_booleanOp974); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(197, 10);
				PushFollow(Follow._booleanExpr_in_booleanOp976);
				booleanExpr(true);
				PopFollow();
				if (state.failed) return;
				DebugLocation(197, 28);
				if (state.backtracking == 0)
				{
					 Out(" and "); 
				}
				DebugLocation(197, 46);
				PushFollow(Follow._booleanExpr_in_booleanOp981);
				booleanExpr(true);
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:198:4: ^( OR booleanExpr[false] booleanExpr[false] )
				{
				DebugLocation(198, 4);
				DebugLocation(198, 6);
				Match(input,OR,Follow._OR_in_booleanOp989); if (state.failed) return;

				DebugLocation(198, 9);
				if (state.backtracking == 0)
				{
					 if (parens) Out("("); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(198, 35);
				PushFollow(Follow._booleanExpr_in_booleanOp993);
				booleanExpr(false);
				PopFollow();
				if (state.failed) return;
				DebugLocation(198, 54);
				if (state.backtracking == 0)
				{
					 Out(" or "); 
				}
				DebugLocation(198, 71);
				PushFollow(Follow._booleanExpr_in_booleanOp998);
				booleanExpr(false);
				PopFollow();
				if (state.failed) return;
				DebugLocation(198, 90);
				if (state.backtracking == 0)
				{
					 if (parens) Out(")"); 
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// SqlGenerator.g:199:4: ^( NOT booleanExpr[false] )
				{
				DebugLocation(199, 4);
				DebugLocation(199, 6);
				Match(input,NOT,Follow._NOT_in_booleanOp1008); if (state.failed) return;

				DebugLocation(199, 10);
				if (state.backtracking == 0)
				{
					 Out(" not ("); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(199, 29);
				PushFollow(Follow._booleanExpr_in_booleanOp1012);
				booleanExpr(false);
				PopFollow();
				if (state.failed) return;
				DebugLocation(199, 48);
				if (state.backtracking == 0)
				{
					 Out(")"); 
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("booleanOp", 26);
			LeaveRule("booleanOp", 26);
			LeaveRule_booleanOp();
		}
		DebugLocation(200, 1);
		} finally { DebugExitRule(GrammarFileName, "booleanOp"); }
		return;

	}
	// $ANTLR end "booleanOp"

	partial void EnterRule_booleanExpr();
	partial void LeaveRule_booleanExpr();
	// $ANTLR start "booleanExpr"
	// SqlGenerator.g:202:1: booleanExpr[ bool parens ] : ( booleanOp[ parens ] | comparisonExpr[ parens ] | methodCall |st= SQL_TOKEN );
	[GrammarRule("booleanExpr")]
	private void booleanExpr(bool parens)
	{
		EnterRule_booleanExpr();
		EnterRule("booleanExpr", 27);
		TraceIn("booleanExpr", 27);
		IASTNode st = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "booleanExpr");
		DebugLocation(202, 1);
		try
		{
			// SqlGenerator.g:203:2: ( booleanOp[ parens ] | comparisonExpr[ parens ] | methodCall |st= SQL_TOKEN )
			int alt43=4;
			try { DebugEnterDecision(43, false);
			switch (input.LA(1))
			{
			case AND:
			case NOT:
			case OR:
				{
				alt43 = 1;
				}
				break;
			case BETWEEN:
			case EQ:
			case EXISTS:
			case GE:
			case GT:
			case IN:
			case IS_NOT_NULL:
			case IS_NULL:
			case LE:
			case LIKE:
			case LT:
			case NE:
			case NOT_BETWEEN:
			case NOT_IN:
			case NOT_LIKE:
				{
				alt43 = 2;
				}
				break;
			case METHOD_CALL:
				{
				alt43 = 3;
				}
				break;
			case SQL_TOKEN:
				{
				alt43 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 43, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(43); }
			switch (alt43)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:203:4: booleanOp[ parens ]
				{
				DebugLocation(203, 4);
				PushFollow(Follow._booleanOp_in_booleanExpr1029);
				booleanOp(parens);
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:204:4: comparisonExpr[ parens ]
				{
				DebugLocation(204, 4);
				PushFollow(Follow._comparisonExpr_in_booleanExpr1036);
				comparisonExpr(parens);
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// SqlGenerator.g:205:4: methodCall
				{
				DebugLocation(205, 4);
				PushFollow(Follow._methodCall_in_booleanExpr1043);
				methodCall();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// SqlGenerator.g:206:4: st= SQL_TOKEN
				{
				DebugLocation(206, 6);
				st=(IASTNode)Match(input,SQL_TOKEN,Follow._SQL_TOKEN_in_booleanExpr1050); if (state.failed) return;
				DebugLocation(206, 17);
				if (state.backtracking == 0)
				{
					 Out(st); 
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("booleanExpr", 27);
			LeaveRule("booleanExpr", 27);
			LeaveRule_booleanExpr();
		}
		DebugLocation(207, 1);
		} finally { DebugExitRule(GrammarFileName, "booleanExpr"); }
		return;

	}
	// $ANTLR end "booleanExpr"

	partial void EnterRule_comparisonExpr();
	partial void LeaveRule_comparisonExpr();
	// $ANTLR start "comparisonExpr"
	// SqlGenerator.g:209:8: public comparisonExpr[ bool parens ] : ( binaryComparisonExpression | exoticComparisonExpression );
	[GrammarRule("comparisonExpr")]
	public void comparisonExpr(bool parens)
	{
		EnterRule_comparisonExpr();
		EnterRule("comparisonExpr", 28);
		TraceIn("comparisonExpr", 28);
		try { DebugEnterRule(GrammarFileName, "comparisonExpr");
		DebugLocation(209, 1);
		try
		{
			// SqlGenerator.g:210:2: ( binaryComparisonExpression | exoticComparisonExpression )
			int alt44=2;
			try { DebugEnterDecision(44, false);
			int LA44_1 = input.LA(1);

			if ((LA44_1==EQ||LA44_1==GE||LA44_1==GT||LA44_1==LE||LA44_1==LT||LA44_1==NE))
			{
				alt44 = 1;
			}
			else if ((LA44_1==BETWEEN||LA44_1==EXISTS||LA44_1==IN||(LA44_1>=IS_NOT_NULL && LA44_1<=IS_NULL)||LA44_1==LIKE||(LA44_1>=NOT_BETWEEN && LA44_1<=NOT_LIKE)))
			{
				alt44 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 44, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(44); }
			switch (alt44)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:210:4: binaryComparisonExpression
				{
				DebugLocation(210, 4);
				PushFollow(Follow._binaryComparisonExpression_in_comparisonExpr1068);
				binaryComparisonExpression();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:211:4: exoticComparisonExpression
				{
				DebugLocation(211, 4);
				if (state.backtracking == 0)
				{
					 if (parens) Out("("); 
				}
				DebugLocation(211, 30);
				PushFollow(Follow._exoticComparisonExpression_in_comparisonExpr1075);
				exoticComparisonExpression();
				PopFollow();
				if (state.failed) return;
				DebugLocation(211, 57);
				if (state.backtracking == 0)
				{
					 if (parens) Out(")"); 
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("comparisonExpr", 28);
			LeaveRule("comparisonExpr", 28);
			LeaveRule_comparisonExpr();
		}
		DebugLocation(212, 1);
		} finally { DebugExitRule(GrammarFileName, "comparisonExpr"); }
		return;

	}
	// $ANTLR end "comparisonExpr"

	partial void EnterRule_binaryComparisonExpression();
	partial void LeaveRule_binaryComparisonExpression();
	// $ANTLR start "binaryComparisonExpression"
	// SqlGenerator.g:214:1: binaryComparisonExpression : ( ^( EQ expr expr ) | ^( NE expr expr ) | ^( GT expr expr ) | ^( GE expr expr ) | ^( LT expr expr ) | ^( LE expr expr ) );
	[GrammarRule("binaryComparisonExpression")]
	private void binaryComparisonExpression()
	{
		EnterRule_binaryComparisonExpression();
		EnterRule("binaryComparisonExpression", 29);
		TraceIn("binaryComparisonExpression", 29);
		try { DebugEnterRule(GrammarFileName, "binaryComparisonExpression");
		DebugLocation(214, 1);
		try
		{
			// SqlGenerator.g:215:2: ( ^( EQ expr expr ) | ^( NE expr expr ) | ^( GT expr expr ) | ^( GE expr expr ) | ^( LT expr expr ) | ^( LE expr expr ) )
			int alt45=6;
			try { DebugEnterDecision(45, false);
			switch (input.LA(1))
			{
			case EQ:
				{
				alt45 = 1;
				}
				break;
			case NE:
				{
				alt45 = 2;
				}
				break;
			case GT:
				{
				alt45 = 3;
				}
				break;
			case GE:
				{
				alt45 = 4;
				}
				break;
			case LT:
				{
				alt45 = 5;
				}
				break;
			case LE:
				{
				alt45 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 45, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(45); }
			switch (alt45)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:215:4: ^( EQ expr expr )
				{
				DebugLocation(215, 4);
				DebugLocation(215, 6);
				Match(input,EQ,Follow._EQ_in_binaryComparisonExpression1090); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(215, 9);
				PushFollow(Follow._expr_in_binaryComparisonExpression1092);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(215, 14);
				if (state.backtracking == 0)
				{
					 Out("="); 
				}
				DebugLocation(215, 28);
				PushFollow(Follow._expr_in_binaryComparisonExpression1096);
				expr();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:216:4: ^( NE expr expr )
				{
				DebugLocation(216, 4);
				DebugLocation(216, 6);
				Match(input,NE,Follow._NE_in_binaryComparisonExpression1103); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(216, 9);
				PushFollow(Follow._expr_in_binaryComparisonExpression1105);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(216, 14);
				if (state.backtracking == 0)
				{
					 Out("<>"); 
				}
				DebugLocation(216, 29);
				PushFollow(Follow._expr_in_binaryComparisonExpression1109);
				expr();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// SqlGenerator.g:217:4: ^( GT expr expr )
				{
				DebugLocation(217, 4);
				DebugLocation(217, 6);
				Match(input,GT,Follow._GT_in_binaryComparisonExpression1116); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(217, 9);
				PushFollow(Follow._expr_in_binaryComparisonExpression1118);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(217, 14);
				if (state.backtracking == 0)
				{
					 Out(">"); 
				}
				DebugLocation(217, 28);
				PushFollow(Follow._expr_in_binaryComparisonExpression1122);
				expr();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// SqlGenerator.g:218:4: ^( GE expr expr )
				{
				DebugLocation(218, 4);
				DebugLocation(218, 6);
				Match(input,GE,Follow._GE_in_binaryComparisonExpression1129); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(218, 9);
				PushFollow(Follow._expr_in_binaryComparisonExpression1131);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(218, 14);
				if (state.backtracking == 0)
				{
					 Out(">="); 
				}
				DebugLocation(218, 29);
				PushFollow(Follow._expr_in_binaryComparisonExpression1135);
				expr();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// SqlGenerator.g:219:4: ^( LT expr expr )
				{
				DebugLocation(219, 4);
				DebugLocation(219, 6);
				Match(input,LT,Follow._LT_in_binaryComparisonExpression1142); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(219, 9);
				PushFollow(Follow._expr_in_binaryComparisonExpression1144);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(219, 14);
				if (state.backtracking == 0)
				{
					 Out("<"); 
				}
				DebugLocation(219, 28);
				PushFollow(Follow._expr_in_binaryComparisonExpression1148);
				expr();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// SqlGenerator.g:220:4: ^( LE expr expr )
				{
				DebugLocation(220, 4);
				DebugLocation(220, 6);
				Match(input,LE,Follow._LE_in_binaryComparisonExpression1155); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(220, 9);
				PushFollow(Follow._expr_in_binaryComparisonExpression1157);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(220, 14);
				if (state.backtracking == 0)
				{
					 Out("<="); 
				}
				DebugLocation(220, 29);
				PushFollow(Follow._expr_in_binaryComparisonExpression1161);
				expr();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("binaryComparisonExpression", 29);
			LeaveRule("binaryComparisonExpression", 29);
			LeaveRule_binaryComparisonExpression();
		}
		DebugLocation(221, 1);
		} finally { DebugExitRule(GrammarFileName, "binaryComparisonExpression"); }
		return;

	}
	// $ANTLR end "binaryComparisonExpression"

	partial void EnterRule_exoticComparisonExpression();
	partial void LeaveRule_exoticComparisonExpression();
	// $ANTLR start "exoticComparisonExpression"
	// SqlGenerator.g:223:1: exoticComparisonExpression : ( ^( LIKE expr expr likeEscape ) | ^( NOT_LIKE expr expr likeEscape ) | ^( BETWEEN expr expr expr ) | ^( NOT_BETWEEN expr expr expr ) | ^( IN expr inList ) | ^( NOT_IN expr inList ) | ^( EXISTS quantified ) | ^( IS_NULL expr ) | ^( IS_NOT_NULL expr ) );
	[GrammarRule("exoticComparisonExpression")]
	private void exoticComparisonExpression()
	{
		EnterRule_exoticComparisonExpression();
		EnterRule("exoticComparisonExpression", 30);
		TraceIn("exoticComparisonExpression", 30);
		try { DebugEnterRule(GrammarFileName, "exoticComparisonExpression");
		DebugLocation(223, 1);
		try
		{
			// SqlGenerator.g:224:2: ( ^( LIKE expr expr likeEscape ) | ^( NOT_LIKE expr expr likeEscape ) | ^( BETWEEN expr expr expr ) | ^( NOT_BETWEEN expr expr expr ) | ^( IN expr inList ) | ^( NOT_IN expr inList ) | ^( EXISTS quantified ) | ^( IS_NULL expr ) | ^( IS_NOT_NULL expr ) )
			int alt46=9;
			try { DebugEnterDecision(46, false);
			switch (input.LA(1))
			{
			case LIKE:
				{
				alt46 = 1;
				}
				break;
			case NOT_LIKE:
				{
				alt46 = 2;
				}
				break;
			case BETWEEN:
				{
				alt46 = 3;
				}
				break;
			case NOT_BETWEEN:
				{
				alt46 = 4;
				}
				break;
			case IN:
				{
				alt46 = 5;
				}
				break;
			case NOT_IN:
				{
				alt46 = 6;
				}
				break;
			case EXISTS:
				{
				alt46 = 7;
				}
				break;
			case IS_NULL:
				{
				alt46 = 8;
				}
				break;
			case IS_NOT_NULL:
				{
				alt46 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 46, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(46); }
			switch (alt46)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:224:4: ^( LIKE expr expr likeEscape )
				{
				DebugLocation(224, 4);
				DebugLocation(224, 6);
				Match(input,LIKE,Follow._LIKE_in_exoticComparisonExpression1175); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(224, 11);
				PushFollow(Follow._expr_in_exoticComparisonExpression1177);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(224, 16);
				if (state.backtracking == 0)
				{
					 Out(" like "); 
				}
				DebugLocation(224, 35);
				PushFollow(Follow._expr_in_exoticComparisonExpression1181);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(224, 40);
				PushFollow(Follow._likeEscape_in_exoticComparisonExpression1183);
				likeEscape();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:225:4: ^( NOT_LIKE expr expr likeEscape )
				{
				DebugLocation(225, 4);
				DebugLocation(225, 6);
				Match(input,NOT_LIKE,Follow._NOT_LIKE_in_exoticComparisonExpression1191); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(225, 15);
				PushFollow(Follow._expr_in_exoticComparisonExpression1193);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(225, 20);
				if (state.backtracking == 0)
				{
					 Out(" not like "); 
				}
				DebugLocation(225, 43);
				PushFollow(Follow._expr_in_exoticComparisonExpression1197);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(225, 48);
				PushFollow(Follow._likeEscape_in_exoticComparisonExpression1199);
				likeEscape();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// SqlGenerator.g:226:4: ^( BETWEEN expr expr expr )
				{
				DebugLocation(226, 4);
				DebugLocation(226, 6);
				Match(input,BETWEEN,Follow._BETWEEN_in_exoticComparisonExpression1206); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(226, 14);
				PushFollow(Follow._expr_in_exoticComparisonExpression1208);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(226, 19);
				if (state.backtracking == 0)
				{
					 Out(" between "); 
				}
				DebugLocation(226, 41);
				PushFollow(Follow._expr_in_exoticComparisonExpression1212);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(226, 46);
				if (state.backtracking == 0)
				{
					 Out(" and "); 
				}
				DebugLocation(226, 64);
				PushFollow(Follow._expr_in_exoticComparisonExpression1216);
				expr();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// SqlGenerator.g:227:4: ^( NOT_BETWEEN expr expr expr )
				{
				DebugLocation(227, 4);
				DebugLocation(227, 6);
				Match(input,NOT_BETWEEN,Follow._NOT_BETWEEN_in_exoticComparisonExpression1223); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(227, 18);
				PushFollow(Follow._expr_in_exoticComparisonExpression1225);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(227, 23);
				if (state.backtracking == 0)
				{
					 Out(" not between "); 
				}
				DebugLocation(227, 49);
				PushFollow(Follow._expr_in_exoticComparisonExpression1229);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(227, 54);
				if (state.backtracking == 0)
				{
					 Out(" and "); 
				}
				DebugLocation(227, 72);
				PushFollow(Follow._expr_in_exoticComparisonExpression1233);
				expr();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// SqlGenerator.g:228:4: ^( IN expr inList )
				{
				DebugLocation(228, 4);
				DebugLocation(228, 6);
				Match(input,IN,Follow._IN_in_exoticComparisonExpression1240); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(228, 9);
				PushFollow(Follow._expr_in_exoticComparisonExpression1242);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(228, 14);
				if (state.backtracking == 0)
				{
					 Out(" in"); 
				}
				DebugLocation(228, 30);
				PushFollow(Follow._inList_in_exoticComparisonExpression1246);
				inList();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// SqlGenerator.g:229:4: ^( NOT_IN expr inList )
				{
				DebugLocation(229, 4);
				DebugLocation(229, 6);
				Match(input,NOT_IN,Follow._NOT_IN_in_exoticComparisonExpression1254); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(229, 13);
				PushFollow(Follow._expr_in_exoticComparisonExpression1256);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(229, 18);
				if (state.backtracking == 0)
				{
					 Out(" not in "); 
				}
				DebugLocation(229, 39);
				PushFollow(Follow._inList_in_exoticComparisonExpression1260);
				inList();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 7:
				DebugEnterAlt(7);
				// SqlGenerator.g:230:4: ^( EXISTS quantified )
				{
				DebugLocation(230, 4);
				DebugLocation(230, 6);
				Match(input,EXISTS,Follow._EXISTS_in_exoticComparisonExpression1268); if (state.failed) return;

				DebugLocation(230, 13);
				if (state.backtracking == 0)
				{
					 OptionalSpace(); Out("exists "); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(230, 50);
				PushFollow(Follow._quantified_in_exoticComparisonExpression1272);
				quantified();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 8:
				DebugEnterAlt(8);
				// SqlGenerator.g:231:4: ^( IS_NULL expr )
				{
				DebugLocation(231, 4);
				DebugLocation(231, 6);
				Match(input,IS_NULL,Follow._IS_NULL_in_exoticComparisonExpression1280); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(231, 14);
				PushFollow(Follow._expr_in_exoticComparisonExpression1282);
				expr();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(231, 20);
				if (state.backtracking == 0)
				{
					 Out(" is null"); 
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// SqlGenerator.g:232:4: ^( IS_NOT_NULL expr )
				{
				DebugLocation(232, 4);
				DebugLocation(232, 6);
				Match(input,IS_NOT_NULL,Follow._IS_NOT_NULL_in_exoticComparisonExpression1291); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(232, 18);
				PushFollow(Follow._expr_in_exoticComparisonExpression1293);
				expr();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(232, 24);
				if (state.backtracking == 0)
				{
					 Out(" is not null"); 
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exoticComparisonExpression", 30);
			LeaveRule("exoticComparisonExpression", 30);
			LeaveRule_exoticComparisonExpression();
		}
		DebugLocation(233, 1);
		} finally { DebugExitRule(GrammarFileName, "exoticComparisonExpression"); }
		return;

	}
	// $ANTLR end "exoticComparisonExpression"

	partial void EnterRule_likeEscape();
	partial void LeaveRule_likeEscape();
	// $ANTLR start "likeEscape"
	// SqlGenerator.g:235:1: likeEscape : ( ^( ESCAPE expr ) )? ;
	[GrammarRule("likeEscape")]
	private void likeEscape()
	{
		EnterRule_likeEscape();
		EnterRule("likeEscape", 31);
		TraceIn("likeEscape", 31);
		try { DebugEnterRule(GrammarFileName, "likeEscape");
		DebugLocation(235, 1);
		try
		{
			// SqlGenerator.g:236:2: ( ( ^( ESCAPE expr ) )? )
			DebugEnterAlt(1);
			// SqlGenerator.g:236:4: ( ^( ESCAPE expr ) )?
			{
			DebugLocation(236, 4);
			// SqlGenerator.g:236:4: ( ^( ESCAPE expr ) )?
			int alt47=2;
			try { DebugEnterSubRule(47);
			try { DebugEnterDecision(47, false);
			int LA47_1 = input.LA(1);

			if ((LA47_1==ESCAPE))
			{
				alt47 = 1;
			}
			} finally { DebugExitDecision(47); }
			switch (alt47)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:236:6: ^( ESCAPE expr )
				{
				DebugLocation(236, 6);
				DebugLocation(236, 8);
				Match(input,ESCAPE,Follow._ESCAPE_in_likeEscape1310); if (state.failed) return;

				DebugLocation(236, 15);
				if (state.backtracking == 0)
				{
					 Out(" escape "); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(236, 36);
				PushFollow(Follow._expr_in_likeEscape1314);
				expr();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
			} finally { DebugExitSubRule(47); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("likeEscape", 31);
			LeaveRule("likeEscape", 31);
			LeaveRule_likeEscape();
		}
		DebugLocation(237, 1);
		} finally { DebugExitRule(GrammarFileName, "likeEscape"); }
		return;

	}
	// $ANTLR end "likeEscape"

	partial void EnterRule_inList();
	partial void LeaveRule_inList();
	// $ANTLR start "inList"
	// SqlGenerator.g:239:1: inList : ^( IN_LIST ( parenSelect | simpleExprList ) ) ;
	[GrammarRule("inList")]
	private void inList()
	{
		EnterRule_inList();
		EnterRule("inList", 32);
		TraceIn("inList", 32);
		try { DebugEnterRule(GrammarFileName, "inList");
		DebugLocation(239, 1);
		try
		{
			// SqlGenerator.g:240:2: ( ^( IN_LIST ( parenSelect | simpleExprList ) ) )
			DebugEnterAlt(1);
			// SqlGenerator.g:240:4: ^( IN_LIST ( parenSelect | simpleExprList ) )
			{
			DebugLocation(240, 4);
			DebugLocation(240, 6);
			Match(input,IN_LIST,Follow._IN_LIST_in_inList1330); if (state.failed) return;

			DebugLocation(240, 14);
			if (state.backtracking == 0)
			{
				 Out(" "); 
			}

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(240, 28);
				// SqlGenerator.g:240:28: ( parenSelect | simpleExprList )
				int alt48=2;
				try { DebugEnterSubRule(48);
				try { DebugEnterDecision(48, false);
				int LA48_1 = input.LA(1);

				if ((LA48_1==SELECT||LA48_1==UNION))
				{
					alt48 = 1;
				}
				else if (((LA48_1>=UP && LA48_1<=AGGREGATE)||LA48_1==BAND||(LA48_1>=BNOT && LA48_1<=BOR)||(LA48_1>=BXOR && LA48_1<=CASE2)||LA48_1==CONSTANT||LA48_1==COUNT||(LA48_1>=DIV && LA48_1<=DOT)||LA48_1==FALSE||LA48_1==IDENT||LA48_1==INDEX_OP||LA48_1==JAVA_CONSTANT||LA48_1==METHOD_CALL||LA48_1==MINUS||(LA48_1>=NULL && LA48_1<=NUM_LONG)||(LA48_1>=PARAM && LA48_1<=PLUS)||LA48_1==QUOTED_String||LA48_1==STAR||(LA48_1>=TRUE && LA48_1<=UNARY_MINUS)||LA48_1==ALIAS_REF||LA48_1==NAMED_PARAM||LA48_1==RESULT_VARIABLE_REF||LA48_1==SQL_TOKEN))
				{
					alt48 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 48, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(48); }
				switch (alt48)
				{
				case 1:
					DebugEnterAlt(1);
					// SqlGenerator.g:240:30: parenSelect
					{
					DebugLocation(240, 30);
					PushFollow(Follow._parenSelect_in_inList1336);
					parenSelect();
					PopFollow();
					if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// SqlGenerator.g:240:44: simpleExprList
					{
					DebugLocation(240, 44);
					PushFollow(Follow._simpleExprList_in_inList1340);
					simpleExprList();
					PopFollow();
					if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(48); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("inList", 32);
			LeaveRule("inList", 32);
			LeaveRule_inList();
		}
		DebugLocation(241, 1);
		} finally { DebugExitRule(GrammarFileName, "inList"); }
		return;

	}
	// $ANTLR end "inList"

	partial void EnterRule_simpleExprList();
	partial void LeaveRule_simpleExprList();
	// $ANTLR start "simpleExprList"
	// SqlGenerator.g:243:1: simpleExprList : (e= simpleExpr )* ;
	[GrammarRule("simpleExprList")]
	private void simpleExprList()
	{
		EnterRule_simpleExprList();
		EnterRule("simpleExprList", 33);
		TraceIn("simpleExprList", 33);
		TreeRuleReturnScope<IASTNode> e = default(TreeRuleReturnScope<IASTNode>);

		try { DebugEnterRule(GrammarFileName, "simpleExprList");
		DebugLocation(243, 1);
		try
		{
			// SqlGenerator.g:244:2: ( (e= simpleExpr )* )
			DebugEnterAlt(1);
			// SqlGenerator.g:244:4: (e= simpleExpr )*
			{
			DebugLocation(244, 4);
			if (state.backtracking == 0)
			{
				 Out("("); 
			}
			DebugLocation(244, 18);
			// SqlGenerator.g:244:18: (e= simpleExpr )*
			try { DebugEnterSubRule(49);
			while (true)
			{
				int alt49=2;
				try { DebugEnterDecision(49, false);
				int LA49_1 = input.LA(1);

				if ((LA49_1==AGGREGATE||LA49_1==BAND||(LA49_1>=BNOT && LA49_1<=BOR)||(LA49_1>=BXOR && LA49_1<=CASE2)||LA49_1==CONSTANT||LA49_1==COUNT||(LA49_1>=DIV && LA49_1<=DOT)||LA49_1==FALSE||LA49_1==IDENT||LA49_1==INDEX_OP||LA49_1==JAVA_CONSTANT||LA49_1==METHOD_CALL||LA49_1==MINUS||(LA49_1>=NULL && LA49_1<=NUM_LONG)||(LA49_1>=PARAM && LA49_1<=PLUS)||LA49_1==QUOTED_String||LA49_1==STAR||(LA49_1>=TRUE && LA49_1<=UNARY_MINUS)||LA49_1==ALIAS_REF||LA49_1==NAMED_PARAM||LA49_1==RESULT_VARIABLE_REF||LA49_1==SQL_TOKEN))
				{
					alt49 = 1;
				}


				} finally { DebugExitDecision(49); }
				switch ( alt49 )
				{
				case 1:
					DebugEnterAlt(1);
					// SqlGenerator.g:244:19: e= simpleExpr
					{
					DebugLocation(244, 20);
					PushFollow(Follow._simpleExpr_in_simpleExprList1361);
					e=simpleExpr();
					PopFollow();
					if (state.failed) return;
					DebugLocation(244, 32);
					if (state.backtracking == 0)
					{
						 Separator((e!=null?((IASTNode)e.Start):default(IASTNode))," , "); 
					}

					}
					break;

				default:
					goto loop49;
				}
			}

			loop49:
				;

			} finally { DebugExitSubRule(49); }

			DebugLocation(244, 66);
			if (state.backtracking == 0)
			{
				 Out(")"); 
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("simpleExprList", 33);
			LeaveRule("simpleExprList", 33);
			LeaveRule_simpleExprList();
		}
		DebugLocation(245, 1);
		} finally { DebugExitRule(GrammarFileName, "simpleExprList"); }
		return;

	}
	// $ANTLR end "simpleExprList"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();
	// $ANTLR start "expr"
	// SqlGenerator.g:248:1: expr : ( simpleExpr | ^( VECTOR_EXPR (e= expr )* ) | parenSelect | ^( ANY quantified ) | ^( ALL quantified ) | ^( SOME quantified ) );
	[GrammarRule("expr")]
	private TreeRuleReturnScope<IASTNode> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 34);
		TraceIn("expr", 34);
		TreeRuleReturnScope<IASTNode> retval = new TreeRuleReturnScope<IASTNode>();
		retval.Start = (IASTNode)input.LT(1);

		TreeRuleReturnScope<IASTNode> e = default(TreeRuleReturnScope<IASTNode>);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(248, 1);
		try
		{
			// SqlGenerator.g:249:2: ( simpleExpr | ^( VECTOR_EXPR (e= expr )* ) | parenSelect | ^( ANY quantified ) | ^( ALL quantified ) | ^( SOME quantified ) )
			int alt51=6;
			try { DebugEnterDecision(51, false);
			switch (input.LA(1))
			{
			case AGGREGATE:
			case BAND:
			case BNOT:
			case BOR:
			case BXOR:
			case CASE:
			case CASE2:
			case CONSTANT:
			case COUNT:
			case DIV:
			case DOT:
			case FALSE:
			case IDENT:
			case INDEX_OP:
			case JAVA_CONSTANT:
			case METHOD_CALL:
			case MINUS:
			case NULL:
			case NUM_DECIMAL:
			case NUM_DOUBLE:
			case NUM_FLOAT:
			case NUM_INT:
			case NUM_LONG:
			case PARAM:
			case PLUS:
			case QUOTED_String:
			case STAR:
			case TRUE:
			case UNARY_MINUS:
			case ALIAS_REF:
			case NAMED_PARAM:
			case RESULT_VARIABLE_REF:
			case SQL_TOKEN:
				{
				alt51 = 1;
				}
				break;
			case VECTOR_EXPR:
				{
				alt51 = 2;
				}
				break;
			case SELECT:
			case UNION:
				{
				alt51 = 3;
				}
				break;
			case ANY:
				{
				alt51 = 4;
				}
				break;
			case ALL:
				{
				alt51 = 5;
				}
				break;
			case SOME:
				{
				alt51 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 51, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(51); }
			switch (alt51)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:249:4: simpleExpr
				{
				DebugLocation(249, 4);
				PushFollow(Follow._simpleExpr_in_expr1380);
				simpleExpr();
				PopFollow();
				if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:250:4: ^( VECTOR_EXPR (e= expr )* )
				{
				DebugLocation(250, 4);
				DebugLocation(250, 7);
				Match(input,VECTOR_EXPR,Follow._VECTOR_EXPR_in_expr1387); if (state.failed) return retval;

				DebugLocation(250, 19);
				if (state.backtracking == 0)
				{
					 Out("("); 
				}

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(250, 33);
					// SqlGenerator.g:250:33: (e= expr )*
					try { DebugEnterSubRule(50);
					while (true)
					{
						int alt50=2;
						try { DebugEnterDecision(50, false);
						int LA50_1 = input.LA(1);

						if ((LA50_1==AGGREGATE||LA50_1==ALL||LA50_1==ANY||LA50_1==BAND||(LA50_1>=BNOT && LA50_1<=BOR)||(LA50_1>=BXOR && LA50_1<=CASE2)||LA50_1==CONSTANT||LA50_1==COUNT||(LA50_1>=DIV && LA50_1<=DOT)||LA50_1==FALSE||LA50_1==IDENT||LA50_1==INDEX_OP||LA50_1==JAVA_CONSTANT||LA50_1==METHOD_CALL||LA50_1==MINUS||(LA50_1>=NULL && LA50_1<=NUM_LONG)||(LA50_1>=PARAM && LA50_1<=PLUS)||LA50_1==QUOTED_String||LA50_1==SELECT||LA50_1==SOME||LA50_1==STAR||(LA50_1>=TRUE && LA50_1<=UNARY_MINUS)||LA50_1==UNION||LA50_1==VECTOR_EXPR||LA50_1==ALIAS_REF||LA50_1==NAMED_PARAM||LA50_1==RESULT_VARIABLE_REF||LA50_1==SQL_TOKEN))
						{
							alt50 = 1;
						}


						} finally { DebugExitDecision(50); }
						switch ( alt50 )
						{
						case 1:
							DebugEnterAlt(1);
							// SqlGenerator.g:250:34: e= expr
							{
							DebugLocation(250, 35);
							PushFollow(Follow._expr_in_expr1394);
							e=expr();
							PopFollow();
							if (state.failed) return retval;
							DebugLocation(250, 41);
							if (state.backtracking == 0)
							{
								 Separator((e!=null?((IASTNode)e.Start):default(IASTNode))," , "); 
							}

							}
							break;

						default:
							goto loop50;
						}
					}

					loop50:
						;

					} finally { DebugExitSubRule(50); }

					DebugLocation(250, 76);
					if (state.backtracking == 0)
					{
						 Out(")"); 
					}

					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// SqlGenerator.g:251:4: parenSelect
				{
				DebugLocation(251, 4);
				PushFollow(Follow._parenSelect_in_expr1409);
				parenSelect();
				PopFollow();
				if (state.failed) return retval;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// SqlGenerator.g:252:4: ^( ANY quantified )
				{
				DebugLocation(252, 4);
				DebugLocation(252, 6);
				Match(input,ANY,Follow._ANY_in_expr1415); if (state.failed) return retval;

				DebugLocation(252, 10);
				if (state.backtracking == 0)
				{
					 Out("any "); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(252, 27);
				PushFollow(Follow._quantified_in_expr1419);
				quantified();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// SqlGenerator.g:253:4: ^( ALL quantified )
				{
				DebugLocation(253, 4);
				DebugLocation(253, 6);
				Match(input,ALL,Follow._ALL_in_expr1427); if (state.failed) return retval;

				DebugLocation(253, 10);
				if (state.backtracking == 0)
				{
					 Out("all "); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(253, 27);
				PushFollow(Follow._quantified_in_expr1431);
				quantified();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// SqlGenerator.g:254:4: ^( SOME quantified )
				{
				DebugLocation(254, 4);
				DebugLocation(254, 6);
				Match(input,SOME,Follow._SOME_in_expr1439); if (state.failed) return retval;

				DebugLocation(254, 11);
				if (state.backtracking == 0)
				{
					 Out("some "); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(254, 29);
				PushFollow(Follow._quantified_in_expr1443);
				quantified();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expr", 34);
			LeaveRule("expr", 34);
			LeaveRule_expr();
		}
		DebugLocation(255, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_quantified();
	partial void LeaveRule_quantified();
	// $ANTLR start "quantified"
	// SqlGenerator.g:257:1: quantified : ( sqlToken | selectStatement ) ;
	[GrammarRule("quantified")]
	private void quantified()
	{
		EnterRule_quantified();
		EnterRule("quantified", 35);
		TraceIn("quantified", 35);
		try { DebugEnterRule(GrammarFileName, "quantified");
		DebugLocation(257, 1);
		try
		{
			// SqlGenerator.g:258:2: ( ( sqlToken | selectStatement ) )
			DebugEnterAlt(1);
			// SqlGenerator.g:258:4: ( sqlToken | selectStatement )
			{
			DebugLocation(258, 4);
			if (state.backtracking == 0)
			{
				 Out("("); 
			}
			DebugLocation(258, 18);
			// SqlGenerator.g:258:18: ( sqlToken | selectStatement )
			int alt52=2;
			try { DebugEnterSubRule(52);
			try { DebugEnterDecision(52, false);
			int LA52_1 = input.LA(1);

			if ((LA52_1==SQL_TOKEN))
			{
				alt52 = 1;
			}
			else if ((LA52_1==SELECT))
			{
				alt52 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 52, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(52); }
			switch (alt52)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:258:20: sqlToken
				{
				DebugLocation(258, 20);
				PushFollow(Follow._sqlToken_in_quantified1461);
				sqlToken();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:258:31: selectStatement
				{
				DebugLocation(258, 31);
				PushFollow(Follow._selectStatement_in_quantified1465);
				selectStatement();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(52); }

			DebugLocation(258, 49);
			if (state.backtracking == 0)
			{
				 Out(")"); 
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("quantified", 35);
			LeaveRule("quantified", 35);
			LeaveRule_quantified();
		}
		DebugLocation(259, 1);
		} finally { DebugExitRule(GrammarFileName, "quantified"); }
		return;

	}
	// $ANTLR end "quantified"

	partial void EnterRule_parenSelect();
	partial void LeaveRule_parenSelect();
	// $ANTLR start "parenSelect"
	// SqlGenerator.g:261:1: parenSelect : ( selectStatement | ^( UNION selectStatement parenSelect ) );
	[GrammarRule("parenSelect")]
	private void parenSelect()
	{
		EnterRule_parenSelect();
		EnterRule("parenSelect", 36);
		TraceIn("parenSelect", 36);
		try { DebugEnterRule(GrammarFileName, "parenSelect");
		DebugLocation(261, 1);
		try
		{
			// SqlGenerator.g:262:2: ( selectStatement | ^( UNION selectStatement parenSelect ) )
			int alt53=2;
			try { DebugEnterDecision(53, false);
			int LA53_1 = input.LA(1);

			if ((LA53_1==SELECT))
			{
				alt53 = 1;
			}
			else if ((LA53_1==UNION))
			{
				alt53 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 53, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(53); }
			switch (alt53)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:262:4: selectStatement
				{
				DebugLocation(262, 4);
				if (state.backtracking == 0)
				{
					 Out("("); 
				}
				DebugLocation(262, 18);
				PushFollow(Follow._selectStatement_in_parenSelect1484);
				selectStatement();
				PopFollow();
				if (state.failed) return;
				DebugLocation(262, 34);
				if (state.backtracking == 0)
				{
					 Out(")"); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:263:4: ^( UNION selectStatement parenSelect )
				{
				DebugLocation(263, 4);
				DebugLocation(263, 6);
				Match(input,UNION,Follow._UNION_in_parenSelect1493); if (state.failed) return;

				DebugLocation(263, 12);
				if (state.backtracking == 0)
				{
					 Out("("); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(263, 26);
				PushFollow(Follow._selectStatement_in_parenSelect1497);
				selectStatement();
				PopFollow();
				if (state.failed) return;
				DebugLocation(263, 42);
				if (state.backtracking == 0)
				{
					 Out(") union "); 
				}
				DebugLocation(263, 63);
				PushFollow(Follow._parenSelect_in_parenSelect1501);
				parenSelect();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("parenSelect", 36);
			LeaveRule("parenSelect", 36);
			LeaveRule_parenSelect();
		}
		DebugLocation(264, 1);
		} finally { DebugExitRule(GrammarFileName, "parenSelect"); }
		return;

	}
	// $ANTLR end "parenSelect"

	partial void EnterRule_simpleExpr();
	partial void LeaveRule_simpleExpr();
	// $ANTLR start "simpleExpr"
	// SqlGenerator.g:267:8: public simpleExpr : (c= constant | NULL | addrExpr | sqlToken | aggregate | methodCall | count | parameter | arithmeticExpr );
	[GrammarRule("simpleExpr")]
	public TreeRuleReturnScope<IASTNode> simpleExpr()
	{
		EnterRule_simpleExpr();
		EnterRule("simpleExpr", 37);
		TraceIn("simpleExpr", 37);
		TreeRuleReturnScope<IASTNode> retval = new TreeRuleReturnScope<IASTNode>();
		retval.Start = (IASTNode)input.LT(1);

		TreeRuleReturnScope<IASTNode> c = default(TreeRuleReturnScope<IASTNode>);

		try { DebugEnterRule(GrammarFileName, "simpleExpr");
		DebugLocation(267, 1);
		try
		{
			// SqlGenerator.g:268:2: (c= constant | NULL | addrExpr | sqlToken | aggregate | methodCall | count | parameter | arithmeticExpr )
			int alt54=9;
			try { DebugEnterDecision(54, false);
			switch (input.LA(1))
			{
			case CONSTANT:
			case FALSE:
			case IDENT:
			case JAVA_CONSTANT:
			case NUM_DECIMAL:
			case NUM_DOUBLE:
			case NUM_FLOAT:
			case NUM_INT:
			case NUM_LONG:
			case QUOTED_String:
			case TRUE:
				{
				alt54 = 1;
				}
				break;
			case NULL:
				{
				alt54 = 2;
				}
				break;
			case DOT:
			case INDEX_OP:
			case ALIAS_REF:
			case RESULT_VARIABLE_REF:
				{
				alt54 = 3;
				}
				break;
			case SQL_TOKEN:
				{
				alt54 = 4;
				}
				break;
			case AGGREGATE:
				{
				alt54 = 5;
				}
				break;
			case METHOD_CALL:
				{
				alt54 = 6;
				}
				break;
			case COUNT:
				{
				alt54 = 7;
				}
				break;
			case PARAM:
			case NAMED_PARAM:
				{
				alt54 = 8;
				}
				break;
			case BAND:
			case BNOT:
			case BOR:
			case BXOR:
			case CASE:
			case CASE2:
			case DIV:
			case MINUS:
			case PLUS:
			case STAR:
			case UNARY_MINUS:
				{
				alt54 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 54, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(54); }
			switch (alt54)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:268:4: c= constant
				{
				DebugLocation(268, 5);
				PushFollow(Follow._constant_in_simpleExpr1520);
				c=constant();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(268, 15);
				if (state.backtracking == 0)
				{
					 Out((c!=null?((IASTNode)c.Start):default(IASTNode))); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:269:4: NULL
				{
				DebugLocation(269, 4);
				Match(input,NULL,Follow._NULL_in_simpleExpr1527); if (state.failed) return retval;
				DebugLocation(269, 9);
				if (state.backtracking == 0)
				{
					 Out("null"); 
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// SqlGenerator.g:270:4: addrExpr
				{
				DebugLocation(270, 4);
				PushFollow(Follow._addrExpr_in_simpleExpr1534);
				addrExpr();
				PopFollow();
				if (state.failed) return retval;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// SqlGenerator.g:271:4: sqlToken
				{
				DebugLocation(271, 4);
				PushFollow(Follow._sqlToken_in_simpleExpr1539);
				sqlToken();
				PopFollow();
				if (state.failed) return retval;

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// SqlGenerator.g:272:4: aggregate
				{
				DebugLocation(272, 4);
				PushFollow(Follow._aggregate_in_simpleExpr1544);
				aggregate();
				PopFollow();
				if (state.failed) return retval;

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// SqlGenerator.g:273:4: methodCall
				{
				DebugLocation(273, 4);
				PushFollow(Follow._methodCall_in_simpleExpr1549);
				methodCall();
				PopFollow();
				if (state.failed) return retval;

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// SqlGenerator.g:274:4: count
				{
				DebugLocation(274, 4);
				PushFollow(Follow._count_in_simpleExpr1554);
				count();
				PopFollow();
				if (state.failed) return retval;

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// SqlGenerator.g:275:4: parameter
				{
				DebugLocation(275, 4);
				PushFollow(Follow._parameter_in_simpleExpr1559);
				parameter();
				PopFollow();
				if (state.failed) return retval;

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// SqlGenerator.g:276:4: arithmeticExpr
				{
				DebugLocation(276, 4);
				PushFollow(Follow._arithmeticExpr_in_simpleExpr1564);
				arithmeticExpr();
				PopFollow();
				if (state.failed) return retval;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("simpleExpr", 37);
			LeaveRule("simpleExpr", 37);
			LeaveRule_simpleExpr();
		}
		DebugLocation(277, 1);
		} finally { DebugExitRule(GrammarFileName, "simpleExpr"); }
		return retval;

	}
	// $ANTLR end "simpleExpr"

	partial void EnterRule_constant();
	partial void LeaveRule_constant();
	// $ANTLR start "constant"
	// SqlGenerator.g:279:1: constant : ( NUM_DOUBLE | NUM_DECIMAL | NUM_FLOAT | NUM_INT | NUM_LONG | QUOTED_String | CONSTANT | JAVA_CONSTANT | TRUE | FALSE | IDENT );
	[GrammarRule("constant")]
	private TreeRuleReturnScope<IASTNode> constant()
	{
		EnterRule_constant();
		EnterRule("constant", 38);
		TraceIn("constant", 38);
		TreeRuleReturnScope<IASTNode> retval = new TreeRuleReturnScope<IASTNode>();
		retval.Start = (IASTNode)input.LT(1);

		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(279, 1);
		try
		{
			// SqlGenerator.g:280:2: ( NUM_DOUBLE | NUM_DECIMAL | NUM_FLOAT | NUM_INT | NUM_LONG | QUOTED_String | CONSTANT | JAVA_CONSTANT | TRUE | FALSE | IDENT )
			DebugEnterAlt(1);
			// SqlGenerator.g:
			{
			DebugLocation(280, 2);
			if (input.LA(1)==CONSTANT||input.LA(1)==FALSE||input.LA(1)==IDENT||input.LA(1)==JAVA_CONSTANT||(input.LA(1)>=NUM_DECIMAL && input.LA(1)<=NUM_LONG)||input.LA(1)==QUOTED_String||input.LA(1)==TRUE)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("constant", 38);
			LeaveRule("constant", 38);
			LeaveRule_constant();
		}
		DebugLocation(291, 1);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"

	partial void EnterRule_arithmeticExpr();
	partial void LeaveRule_arithmeticExpr();
	// $ANTLR start "arithmeticExpr"
	// SqlGenerator.g:293:1: arithmeticExpr : ( additiveExpr | bitwiseExpr | multiplicativeExpr | ^( UNARY_MINUS nestedExprAfterMinusDiv ) | caseExpr );
	[GrammarRule("arithmeticExpr")]
	private void arithmeticExpr()
	{
		EnterRule_arithmeticExpr();
		EnterRule("arithmeticExpr", 39);
		TraceIn("arithmeticExpr", 39);
		try { DebugEnterRule(GrammarFileName, "arithmeticExpr");
		DebugLocation(293, 1);
		try
		{
			// SqlGenerator.g:294:2: ( additiveExpr | bitwiseExpr | multiplicativeExpr | ^( UNARY_MINUS nestedExprAfterMinusDiv ) | caseExpr )
			int alt55=5;
			try { DebugEnterDecision(55, false);
			switch (input.LA(1))
			{
			case MINUS:
			case PLUS:
				{
				alt55 = 1;
				}
				break;
			case BAND:
			case BNOT:
			case BOR:
			case BXOR:
				{
				alt55 = 2;
				}
				break;
			case DIV:
			case STAR:
				{
				alt55 = 3;
				}
				break;
			case UNARY_MINUS:
				{
				alt55 = 4;
				}
				break;
			case CASE:
			case CASE2:
				{
				alt55 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 55, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(55); }
			switch (alt55)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:294:4: additiveExpr
				{
				DebugLocation(294, 4);
				PushFollow(Follow._additiveExpr_in_arithmeticExpr1638);
				additiveExpr();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:295:4: bitwiseExpr
				{
				DebugLocation(295, 4);
				PushFollow(Follow._bitwiseExpr_in_arithmeticExpr1643);
				bitwiseExpr();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// SqlGenerator.g:296:4: multiplicativeExpr
				{
				DebugLocation(296, 4);
				PushFollow(Follow._multiplicativeExpr_in_arithmeticExpr1648);
				multiplicativeExpr();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// SqlGenerator.g:298:4: ^( UNARY_MINUS nestedExprAfterMinusDiv )
				{
				DebugLocation(298, 4);
				DebugLocation(298, 6);
				Match(input,UNARY_MINUS,Follow._UNARY_MINUS_in_arithmeticExpr1655); if (state.failed) return;

				DebugLocation(298, 18);
				if (state.backtracking == 0)
				{
					 Out("-"); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(298, 32);
				PushFollow(Follow._nestedExprAfterMinusDiv_in_arithmeticExpr1659);
				nestedExprAfterMinusDiv();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// SqlGenerator.g:299:4: caseExpr
				{
				DebugLocation(299, 4);
				PushFollow(Follow._caseExpr_in_arithmeticExpr1665);
				caseExpr();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("arithmeticExpr", 39);
			LeaveRule("arithmeticExpr", 39);
			LeaveRule_arithmeticExpr();
		}
		DebugLocation(300, 1);
		} finally { DebugExitRule(GrammarFileName, "arithmeticExpr"); }
		return;

	}
	// $ANTLR end "arithmeticExpr"

	partial void EnterRule_additiveExpr();
	partial void LeaveRule_additiveExpr();
	// $ANTLR start "additiveExpr"
	// SqlGenerator.g:302:1: additiveExpr : ( ^( PLUS expr expr ) | ^( MINUS expr nestedExprAfterMinusDiv ) );
	[GrammarRule("additiveExpr")]
	private void additiveExpr()
	{
		EnterRule_additiveExpr();
		EnterRule("additiveExpr", 40);
		TraceIn("additiveExpr", 40);
		try { DebugEnterRule(GrammarFileName, "additiveExpr");
		DebugLocation(302, 1);
		try
		{
			// SqlGenerator.g:303:2: ( ^( PLUS expr expr ) | ^( MINUS expr nestedExprAfterMinusDiv ) )
			int alt56=2;
			try { DebugEnterDecision(56, false);
			int LA56_1 = input.LA(1);

			if ((LA56_1==PLUS))
			{
				alt56 = 1;
			}
			else if ((LA56_1==MINUS))
			{
				alt56 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 56, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(56); }
			switch (alt56)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:303:4: ^( PLUS expr expr )
				{
				DebugLocation(303, 4);
				DebugLocation(303, 6);
				Match(input,PLUS,Follow._PLUS_in_additiveExpr1677); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(303, 11);
				PushFollow(Follow._expr_in_additiveExpr1679);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(303, 16);
				if (state.backtracking == 0)
				{
					 Out("+"); 
				}
				DebugLocation(303, 30);
				PushFollow(Follow._expr_in_additiveExpr1683);
				expr();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:304:4: ^( MINUS expr nestedExprAfterMinusDiv )
				{
				DebugLocation(304, 4);
				DebugLocation(304, 6);
				Match(input,MINUS,Follow._MINUS_in_additiveExpr1690); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(304, 12);
				PushFollow(Follow._expr_in_additiveExpr1692);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(304, 17);
				if (state.backtracking == 0)
				{
					 Out("-"); 
				}
				DebugLocation(304, 31);
				PushFollow(Follow._nestedExprAfterMinusDiv_in_additiveExpr1696);
				nestedExprAfterMinusDiv();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("additiveExpr", 40);
			LeaveRule("additiveExpr", 40);
			LeaveRule_additiveExpr();
		}
		DebugLocation(305, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpr"); }
		return;

	}
	// $ANTLR end "additiveExpr"

	partial void EnterRule_bitwiseExpr();
	partial void LeaveRule_bitwiseExpr();
	// $ANTLR start "bitwiseExpr"
	// SqlGenerator.g:307:1: bitwiseExpr : ( ^( BAND expr nestedExpr ) | ^( BOR expr nestedExpr ) | ^( BXOR expr nestedExpr ) | ^( BNOT nestedExpr ) );
	[GrammarRule("bitwiseExpr")]
	private void bitwiseExpr()
	{
		EnterRule_bitwiseExpr();
		EnterRule("bitwiseExpr", 41);
		TraceIn("bitwiseExpr", 41);
		try { DebugEnterRule(GrammarFileName, "bitwiseExpr");
		DebugLocation(307, 1);
		try
		{
			// SqlGenerator.g:308:2: ( ^( BAND expr nestedExpr ) | ^( BOR expr nestedExpr ) | ^( BXOR expr nestedExpr ) | ^( BNOT nestedExpr ) )
			int alt57=4;
			try { DebugEnterDecision(57, false);
			switch (input.LA(1))
			{
			case BAND:
				{
				alt57 = 1;
				}
				break;
			case BOR:
				{
				alt57 = 2;
				}
				break;
			case BXOR:
				{
				alt57 = 3;
				}
				break;
			case BNOT:
				{
				alt57 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 57, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(57); }
			switch (alt57)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:308:4: ^( BAND expr nestedExpr )
				{
				DebugLocation(308, 4);
				DebugLocation(308, 6);
				Match(input,BAND,Follow._BAND_in_bitwiseExpr1709); if (state.failed) return;

				DebugLocation(308, 11);
				if (state.backtracking == 0)
				{
					 BeginBitwiseOp("band"); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(308, 39);
				PushFollow(Follow._expr_in_bitwiseExpr1713);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(308, 44);
				PushFollow(Follow._nestedExpr_in_bitwiseExpr1715);
				nestedExpr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(308, 55);
				if (state.backtracking == 0)
				{
					 EndBitwiseOp("band"); 
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:309:4: ^( BOR expr nestedExpr )
				{
				DebugLocation(309, 4);
				DebugLocation(309, 6);
				Match(input,BOR,Follow._BOR_in_bitwiseExpr1724); if (state.failed) return;

				DebugLocation(309, 10);
				if (state.backtracking == 0)
				{
					 BeginBitwiseOp("bor"); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(309, 37);
				PushFollow(Follow._expr_in_bitwiseExpr1728);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(309, 42);
				PushFollow(Follow._nestedExpr_in_bitwiseExpr1730);
				nestedExpr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(309, 53);
				if (state.backtracking == 0)
				{
					 EndBitwiseOp("bor"); 
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// SqlGenerator.g:310:4: ^( BXOR expr nestedExpr )
				{
				DebugLocation(310, 4);
				DebugLocation(310, 6);
				Match(input,BXOR,Follow._BXOR_in_bitwiseExpr1739); if (state.failed) return;

				DebugLocation(310, 11);
				if (state.backtracking == 0)
				{
					 BeginBitwiseOp("bxor"); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(310, 39);
				PushFollow(Follow._expr_in_bitwiseExpr1743);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(310, 44);
				PushFollow(Follow._nestedExpr_in_bitwiseExpr1745);
				nestedExpr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(310, 55);
				if (state.backtracking == 0)
				{
					 EndBitwiseOp("bxor"); 
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// SqlGenerator.g:311:4: ^( BNOT nestedExpr )
				{
				DebugLocation(311, 4);
				DebugLocation(311, 6);
				Match(input,BNOT,Follow._BNOT_in_bitwiseExpr1754); if (state.failed) return;

				DebugLocation(311, 11);
				if (state.backtracking == 0)
				{
					 BeginBitwiseOp("bnot"); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(311, 39);
				PushFollow(Follow._nestedExpr_in_bitwiseExpr1758);
				nestedExpr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(311, 50);
				if (state.backtracking == 0)
				{
					 EndBitwiseOp("bnot"); 
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("bitwiseExpr", 41);
			LeaveRule("bitwiseExpr", 41);
			LeaveRule_bitwiseExpr();
		}
		DebugLocation(312, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseExpr"); }
		return;

	}
	// $ANTLR end "bitwiseExpr"

	partial void EnterRule_multiplicativeExpr();
	partial void LeaveRule_multiplicativeExpr();
	// $ANTLR start "multiplicativeExpr"
	// SqlGenerator.g:314:1: multiplicativeExpr : ( ^( STAR nestedExpr nestedExpr ) | ^( DIV nestedExpr nestedExprAfterMinusDiv ) );
	[GrammarRule("multiplicativeExpr")]
	private void multiplicativeExpr()
	{
		EnterRule_multiplicativeExpr();
		EnterRule("multiplicativeExpr", 42);
		TraceIn("multiplicativeExpr", 42);
		try { DebugEnterRule(GrammarFileName, "multiplicativeExpr");
		DebugLocation(314, 1);
		try
		{
			// SqlGenerator.g:315:2: ( ^( STAR nestedExpr nestedExpr ) | ^( DIV nestedExpr nestedExprAfterMinusDiv ) )
			int alt58=2;
			try { DebugEnterDecision(58, false);
			int LA58_1 = input.LA(1);

			if ((LA58_1==STAR))
			{
				alt58 = 1;
			}
			else if ((LA58_1==DIV))
			{
				alt58 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 58, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(58); }
			switch (alt58)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:315:4: ^( STAR nestedExpr nestedExpr )
				{
				DebugLocation(315, 4);
				DebugLocation(315, 6);
				Match(input,STAR,Follow._STAR_in_multiplicativeExpr1773); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(315, 11);
				PushFollow(Follow._nestedExpr_in_multiplicativeExpr1775);
				nestedExpr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(315, 22);
				if (state.backtracking == 0)
				{
					 Out("*"); 
				}
				DebugLocation(315, 36);
				PushFollow(Follow._nestedExpr_in_multiplicativeExpr1779);
				nestedExpr();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:316:4: ^( DIV nestedExpr nestedExprAfterMinusDiv )
				{
				DebugLocation(316, 4);
				DebugLocation(316, 6);
				Match(input,DIV,Follow._DIV_in_multiplicativeExpr1786); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(316, 10);
				PushFollow(Follow._nestedExpr_in_multiplicativeExpr1788);
				nestedExpr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(316, 21);
				if (state.backtracking == 0)
				{
					 Out("/"); 
				}
				DebugLocation(316, 35);
				PushFollow(Follow._nestedExprAfterMinusDiv_in_multiplicativeExpr1792);
				nestedExprAfterMinusDiv();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("multiplicativeExpr", 42);
			LeaveRule("multiplicativeExpr", 42);
			LeaveRule_multiplicativeExpr();
		}
		DebugLocation(317, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpr"); }
		return;

	}
	// $ANTLR end "multiplicativeExpr"

	partial void EnterRule_nestedExpr();
	partial void LeaveRule_nestedExpr();
	// $ANTLR start "nestedExpr"
	// SqlGenerator.g:319:1: nestedExpr : ( ( additiveExpr )=> additiveExpr | ( bitwiseExpr )=> bitwiseExpr | expr );
	[GrammarRule("nestedExpr")]
	private void nestedExpr()
	{
		EnterRule_nestedExpr();
		EnterRule("nestedExpr", 43);
		TraceIn("nestedExpr", 43);
		try { DebugEnterRule(GrammarFileName, "nestedExpr");
		DebugLocation(319, 1);
		try
		{
			// SqlGenerator.g:321:2: ( ( additiveExpr )=> additiveExpr | ( bitwiseExpr )=> bitwiseExpr | expr )
			int alt59=3;
			try { DebugEnterDecision(59, false);
			switch (input.LA(1))
			{
			case PLUS:
				{
				int LA59_2 = input.LA(2);

				if ((EvaluatePredicate(synpred2_SqlGenerator_fragment)))
				{
					alt59 = 1;
				}
				else if ((true))
				{
					alt59 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 59, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case MINUS:
				{
				int LA59_2 = input.LA(2);

				if ((EvaluatePredicate(synpred2_SqlGenerator_fragment)))
				{
					alt59 = 1;
				}
				else if ((true))
				{
					alt59 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 59, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case BAND:
				{
				int LA59_2 = input.LA(2);

				if ((EvaluatePredicate(synpred3_SqlGenerator_fragment)))
				{
					alt59 = 2;
				}
				else if ((true))
				{
					alt59 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 59, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case BOR:
				{
				int LA59_2 = input.LA(2);

				if ((EvaluatePredicate(synpred3_SqlGenerator_fragment)))
				{
					alt59 = 2;
				}
				else if ((true))
				{
					alt59 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 59, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case BXOR:
				{
				int LA59_2 = input.LA(2);

				if ((EvaluatePredicate(synpred3_SqlGenerator_fragment)))
				{
					alt59 = 2;
				}
				else if ((true))
				{
					alt59 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 59, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case BNOT:
				{
				int LA59_2 = input.LA(2);

				if ((EvaluatePredicate(synpred3_SqlGenerator_fragment)))
				{
					alt59 = 2;
				}
				else if ((true))
				{
					alt59 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 59, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case AGGREGATE:
			case ALL:
			case ANY:
			case CASE:
			case CASE2:
			case CONSTANT:
			case COUNT:
			case DIV:
			case DOT:
			case FALSE:
			case IDENT:
			case INDEX_OP:
			case JAVA_CONSTANT:
			case METHOD_CALL:
			case NULL:
			case NUM_DECIMAL:
			case NUM_DOUBLE:
			case NUM_FLOAT:
			case NUM_INT:
			case NUM_LONG:
			case PARAM:
			case QUOTED_String:
			case SELECT:
			case SOME:
			case STAR:
			case TRUE:
			case UNARY_MINUS:
			case UNION:
			case VECTOR_EXPR:
			case ALIAS_REF:
			case NAMED_PARAM:
			case RESULT_VARIABLE_REF:
			case SQL_TOKEN:
				{
				alt59 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 59, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(59); }
			switch (alt59)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:321:4: ( additiveExpr )=> additiveExpr
				{
				DebugLocation(321, 22);
				if (state.backtracking == 0)
				{
					 Out("("); 
				}
				DebugLocation(321, 36);
				PushFollow(Follow._additiveExpr_in_nestedExpr1814);
				additiveExpr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(321, 49);
				if (state.backtracking == 0)
				{
					 Out(")"); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:322:4: ( bitwiseExpr )=> bitwiseExpr
				{
				DebugLocation(322, 21);
				if (state.backtracking == 0)
				{
					 Out("("); 
				}
				DebugLocation(322, 35);
				PushFollow(Follow._bitwiseExpr_in_nestedExpr1829);
				bitwiseExpr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(322, 47);
				if (state.backtracking == 0)
				{
					 Out(")"); 
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// SqlGenerator.g:323:4: expr
				{
				DebugLocation(323, 4);
				PushFollow(Follow._expr_in_nestedExpr1836);
				expr();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("nestedExpr", 43);
			LeaveRule("nestedExpr", 43);
			LeaveRule_nestedExpr();
		}
		DebugLocation(324, 1);
		} finally { DebugExitRule(GrammarFileName, "nestedExpr"); }
		return;

	}
	// $ANTLR end "nestedExpr"

	partial void EnterRule_nestedExprAfterMinusDiv();
	partial void LeaveRule_nestedExprAfterMinusDiv();
	// $ANTLR start "nestedExprAfterMinusDiv"
	// SqlGenerator.g:326:1: nestedExprAfterMinusDiv : ( ( arithmeticExpr )=> arithmeticExpr | expr );
	[GrammarRule("nestedExprAfterMinusDiv")]
	private void nestedExprAfterMinusDiv()
	{
		EnterRule_nestedExprAfterMinusDiv();
		EnterRule("nestedExprAfterMinusDiv", 44);
		TraceIn("nestedExprAfterMinusDiv", 44);
		try { DebugEnterRule(GrammarFileName, "nestedExprAfterMinusDiv");
		DebugLocation(326, 1);
		try
		{
			// SqlGenerator.g:328:2: ( ( arithmeticExpr )=> arithmeticExpr | expr )
			int alt60=2;
			try { DebugEnterDecision(60, false);
			switch (input.LA(1))
			{
			case PLUS:
				{
				int LA60_2 = input.LA(2);

				if ((EvaluatePredicate(synpred4_SqlGenerator_fragment)))
				{
					alt60 = 1;
				}
				else if ((true))
				{
					alt60 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 60, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case MINUS:
				{
				int LA60_2 = input.LA(2);

				if ((EvaluatePredicate(synpred4_SqlGenerator_fragment)))
				{
					alt60 = 1;
				}
				else if ((true))
				{
					alt60 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 60, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case BAND:
				{
				int LA60_2 = input.LA(2);

				if ((EvaluatePredicate(synpred4_SqlGenerator_fragment)))
				{
					alt60 = 1;
				}
				else if ((true))
				{
					alt60 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 60, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case BOR:
				{
				int LA60_2 = input.LA(2);

				if ((EvaluatePredicate(synpred4_SqlGenerator_fragment)))
				{
					alt60 = 1;
				}
				else if ((true))
				{
					alt60 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 60, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case BXOR:
				{
				int LA60_2 = input.LA(2);

				if ((EvaluatePredicate(synpred4_SqlGenerator_fragment)))
				{
					alt60 = 1;
				}
				else if ((true))
				{
					alt60 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 60, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case BNOT:
				{
				int LA60_2 = input.LA(2);

				if ((EvaluatePredicate(synpred4_SqlGenerator_fragment)))
				{
					alt60 = 1;
				}
				else if ((true))
				{
					alt60 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 60, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case STAR:
				{
				int LA60_2 = input.LA(2);

				if ((EvaluatePredicate(synpred4_SqlGenerator_fragment)))
				{
					alt60 = 1;
				}
				else if ((true))
				{
					alt60 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 60, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case DIV:
				{
				int LA60_2 = input.LA(2);

				if ((EvaluatePredicate(synpred4_SqlGenerator_fragment)))
				{
					alt60 = 1;
				}
				else if ((true))
				{
					alt60 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 60, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case UNARY_MINUS:
				{
				int LA60_2 = input.LA(2);

				if ((EvaluatePredicate(synpred4_SqlGenerator_fragment)))
				{
					alt60 = 1;
				}
				else if ((true))
				{
					alt60 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 60, 9, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case CASE:
				{
				int LA60_2 = input.LA(2);

				if ((EvaluatePredicate(synpred4_SqlGenerator_fragment)))
				{
					alt60 = 1;
				}
				else if ((true))
				{
					alt60 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 60, 10, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case CASE2:
				{
				int LA60_2 = input.LA(2);

				if ((EvaluatePredicate(synpred4_SqlGenerator_fragment)))
				{
					alt60 = 1;
				}
				else if ((true))
				{
					alt60 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 60, 11, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case AGGREGATE:
			case ALL:
			case ANY:
			case CONSTANT:
			case COUNT:
			case DOT:
			case FALSE:
			case IDENT:
			case INDEX_OP:
			case JAVA_CONSTANT:
			case METHOD_CALL:
			case NULL:
			case NUM_DECIMAL:
			case NUM_DOUBLE:
			case NUM_FLOAT:
			case NUM_INT:
			case NUM_LONG:
			case PARAM:
			case QUOTED_String:
			case SELECT:
			case SOME:
			case TRUE:
			case UNION:
			case VECTOR_EXPR:
			case ALIAS_REF:
			case NAMED_PARAM:
			case RESULT_VARIABLE_REF:
			case SQL_TOKEN:
				{
				alt60 = 2;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 60, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(60); }
			switch (alt60)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:328:4: ( arithmeticExpr )=> arithmeticExpr
				{
				DebugLocation(328, 24);
				if (state.backtracking == 0)
				{
					 Out("("); 
				}
				DebugLocation(328, 38);
				PushFollow(Follow._arithmeticExpr_in_nestedExprAfterMinusDiv1858);
				arithmeticExpr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(328, 53);
				if (state.backtracking == 0)
				{
					 Out(")"); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:329:4: expr
				{
				DebugLocation(329, 4);
				PushFollow(Follow._expr_in_nestedExprAfterMinusDiv1865);
				expr();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("nestedExprAfterMinusDiv", 44);
			LeaveRule("nestedExprAfterMinusDiv", 44);
			LeaveRule_nestedExprAfterMinusDiv();
		}
		DebugLocation(330, 1);
		} finally { DebugExitRule(GrammarFileName, "nestedExprAfterMinusDiv"); }
		return;

	}
	// $ANTLR end "nestedExprAfterMinusDiv"

	partial void EnterRule_caseExpr();
	partial void LeaveRule_caseExpr();
	// $ANTLR start "caseExpr"
	// SqlGenerator.g:332:1: caseExpr : ( ^( CASE ( ^( WHEN booleanExpr[false] expr ) )+ ( ^( ELSE expr ) )? ) | ^( CASE2 expr ( ^( WHEN expr expr ) )+ ( ^( ELSE expr ) )? ) );
	[GrammarRule("caseExpr")]
	private void caseExpr()
	{
		EnterRule_caseExpr();
		EnterRule("caseExpr", 45);
		TraceIn("caseExpr", 45);
		try { DebugEnterRule(GrammarFileName, "caseExpr");
		DebugLocation(332, 1);
		try
		{
			// SqlGenerator.g:333:2: ( ^( CASE ( ^( WHEN booleanExpr[false] expr ) )+ ( ^( ELSE expr ) )? ) | ^( CASE2 expr ( ^( WHEN expr expr ) )+ ( ^( ELSE expr ) )? ) )
			int alt65=2;
			try { DebugEnterDecision(65, false);
			int LA65_1 = input.LA(1);

			if ((LA65_1==CASE))
			{
				alt65 = 1;
			}
			else if ((LA65_1==CASE2))
			{
				alt65 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 65, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(65); }
			switch (alt65)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:333:4: ^( CASE ( ^( WHEN booleanExpr[false] expr ) )+ ( ^( ELSE expr ) )? )
				{
				DebugLocation(333, 4);
				DebugLocation(333, 6);
				Match(input,CASE,Follow._CASE_in_caseExpr1877); if (state.failed) return;

				DebugLocation(333, 11);
				if (state.backtracking == 0)
				{
					 Out("case"); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(334, 3);
				// SqlGenerator.g:334:3: ( ^( WHEN booleanExpr[false] expr ) )+
				int cnt61=0;
				try { DebugEnterSubRule(61);
				while (true)
				{
					int alt61=2;
					try { DebugEnterDecision(61, false);
					int LA61_1 = input.LA(1);

					if ((LA61_1==WHEN))
					{
						alt61 = 1;
					}


					} finally { DebugExitDecision(61); }
					switch (alt61)
					{
					case 1:
						DebugEnterAlt(1);
						// SqlGenerator.g:334:5: ^( WHEN booleanExpr[false] expr )
						{
						DebugLocation(334, 5);
						DebugLocation(334, 7);
						Match(input,WHEN,Follow._WHEN_in_caseExpr1887); if (state.failed) return;

						DebugLocation(334, 12);
						if (state.backtracking == 0)
						{
							 Out( " when "); 
						}

						Match(input, TokenTypes.Down, null); if (state.failed) return;
						DebugLocation(334, 32);
						PushFollow(Follow._booleanExpr_in_caseExpr1891);
						booleanExpr(false);
						PopFollow();
						if (state.failed) return;
						DebugLocation(334, 51);
						if (state.backtracking == 0)
						{
							 Out(" then "); 
						}
						DebugLocation(334, 70);
						PushFollow(Follow._expr_in_caseExpr1896);
						expr();
						PopFollow();
						if (state.failed) return;

						Match(input, TokenTypes.Up, null); if (state.failed) return;


						}
						break;

					default:
						if (cnt61 >= 1)
							goto loop61;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee61 = new EarlyExitException( 61, input );
						DebugRecognitionException(eee61);
						throw eee61;
					}
					cnt61++;
				}
				loop61:
					;

				} finally { DebugExitSubRule(61); }

				DebugLocation(335, 3);
				// SqlGenerator.g:335:3: ( ^( ELSE expr ) )?
				int alt62=2;
				try { DebugEnterSubRule(62);
				try { DebugEnterDecision(62, false);
				int LA62_1 = input.LA(1);

				if ((LA62_1==ELSE))
				{
					alt62 = 1;
				}
				} finally { DebugExitDecision(62); }
				switch (alt62)
				{
				case 1:
					DebugEnterAlt(1);
					// SqlGenerator.g:335:5: ^( ELSE expr )
					{
					DebugLocation(335, 5);
					DebugLocation(335, 7);
					Match(input,ELSE,Follow._ELSE_in_caseExpr1908); if (state.failed) return;

					DebugLocation(335, 12);
					if (state.backtracking == 0)
					{
						 Out(" else "); 
					}

					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(335, 31);
					PushFollow(Follow._expr_in_caseExpr1912);
					expr();
					PopFollow();
					if (state.failed) return;

					Match(input, TokenTypes.Up, null); if (state.failed) return;


					}
					break;

				}
				} finally { DebugExitSubRule(62); }

				DebugLocation(336, 3);
				if (state.backtracking == 0)
				{
					 Out(" end"); 
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:337:4: ^( CASE2 expr ( ^( WHEN expr expr ) )+ ( ^( ELSE expr ) )? )
				{
				DebugLocation(337, 4);
				DebugLocation(337, 6);
				Match(input,CASE2,Follow._CASE2_in_caseExpr1928); if (state.failed) return;

				DebugLocation(337, 12);
				if (state.backtracking == 0)
				{
					 Out("case "); 
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(337, 30);
				PushFollow(Follow._expr_in_caseExpr1932);
				expr();
				PopFollow();
				if (state.failed) return;
				DebugLocation(338, 3);
				// SqlGenerator.g:338:3: ( ^( WHEN expr expr ) )+
				int cnt63=0;
				try { DebugEnterSubRule(63);
				while (true)
				{
					int alt63=2;
					try { DebugEnterDecision(63, false);
					int LA63_1 = input.LA(1);

					if ((LA63_1==WHEN))
					{
						alt63 = 1;
					}


					} finally { DebugExitDecision(63); }
					switch (alt63)
					{
					case 1:
						DebugEnterAlt(1);
						// SqlGenerator.g:338:5: ^( WHEN expr expr )
						{
						DebugLocation(338, 5);
						DebugLocation(338, 7);
						Match(input,WHEN,Follow._WHEN_in_caseExpr1939); if (state.failed) return;

						DebugLocation(338, 12);
						if (state.backtracking == 0)
						{
							 Out( " when "); 
						}

						Match(input, TokenTypes.Down, null); if (state.failed) return;
						DebugLocation(338, 32);
						PushFollow(Follow._expr_in_caseExpr1943);
						expr();
						PopFollow();
						if (state.failed) return;
						DebugLocation(338, 37);
						if (state.backtracking == 0)
						{
							 Out(" then "); 
						}
						DebugLocation(338, 56);
						PushFollow(Follow._expr_in_caseExpr1947);
						expr();
						PopFollow();
						if (state.failed) return;

						Match(input, TokenTypes.Up, null); if (state.failed) return;


						}
						break;

					default:
						if (cnt63 >= 1)
							goto loop63;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee63 = new EarlyExitException( 63, input );
						DebugRecognitionException(eee63);
						throw eee63;
					}
					cnt63++;
				}
				loop63:
					;

				} finally { DebugExitSubRule(63); }

				DebugLocation(339, 3);
				// SqlGenerator.g:339:3: ( ^( ELSE expr ) )?
				int alt64=2;
				try { DebugEnterSubRule(64);
				try { DebugEnterDecision(64, false);
				int LA64_1 = input.LA(1);

				if ((LA64_1==ELSE))
				{
					alt64 = 1;
				}
				} finally { DebugExitDecision(64); }
				switch (alt64)
				{
				case 1:
					DebugEnterAlt(1);
					// SqlGenerator.g:339:5: ^( ELSE expr )
					{
					DebugLocation(339, 5);
					DebugLocation(339, 7);
					Match(input,ELSE,Follow._ELSE_in_caseExpr1959); if (state.failed) return;

					DebugLocation(339, 12);
					if (state.backtracking == 0)
					{
						 Out(" else "); 
					}

					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(339, 31);
					PushFollow(Follow._expr_in_caseExpr1963);
					expr();
					PopFollow();
					if (state.failed) return;

					Match(input, TokenTypes.Up, null); if (state.failed) return;


					}
					break;

				}
				} finally { DebugExitSubRule(64); }

				DebugLocation(340, 3);
				if (state.backtracking == 0)
				{
					 Out(" end"); 
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("caseExpr", 45);
			LeaveRule("caseExpr", 45);
			LeaveRule_caseExpr();
		}
		DebugLocation(341, 1);
		} finally { DebugExitRule(GrammarFileName, "caseExpr"); }
		return;

	}
	// $ANTLR end "caseExpr"

	partial void EnterRule_aggregate();
	partial void LeaveRule_aggregate();
	// $ANTLR start "aggregate"
	// SqlGenerator.g:343:1: aggregate : ^(a= AGGREGATE expr ) ;
	[GrammarRule("aggregate")]
	private void aggregate()
	{
		EnterRule_aggregate();
		EnterRule("aggregate", 46);
		TraceIn("aggregate", 46);
		IASTNode a = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "aggregate");
		DebugLocation(343, 1);
		try
		{
			// SqlGenerator.g:344:2: ( ^(a= AGGREGATE expr ) )
			DebugEnterAlt(1);
			// SqlGenerator.g:344:4: ^(a= AGGREGATE expr )
			{
			DebugLocation(344, 4);
			DebugLocation(344, 7);
			a=(IASTNode)Match(input,AGGREGATE,Follow._AGGREGATE_in_aggregate1987); if (state.failed) return;

			DebugLocation(344, 18);
			if (state.backtracking == 0)
			{
				 Out(a); Out("("); 
			}

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(344, 41);
			PushFollow(Follow._expr_in_aggregate1992);
			expr();
			PopFollow();
			if (state.failed) return;
			DebugLocation(344, 46);
			if (state.backtracking == 0)
			{
				 Out(")"); 
			}

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("aggregate", 46);
			LeaveRule("aggregate", 46);
			LeaveRule_aggregate();
		}
		DebugLocation(345, 1);
		} finally { DebugExitRule(GrammarFileName, "aggregate"); }
		return;

	}
	// $ANTLR end "aggregate"

	partial void EnterRule_methodCall();
	partial void LeaveRule_methodCall();
	// $ANTLR start "methodCall"
	// SqlGenerator.g:348:1: methodCall : ^(m= METHOD_CALL i= METHOD_NAME ( ^( EXPR_LIST ( arguments )? ) )? ) ;
	[GrammarRule("methodCall")]
	private void methodCall()
	{
		EnterRule_methodCall();
		EnterRule("methodCall", 47);
		TraceIn("methodCall", 47);
		IASTNode m = default(IASTNode);
		IASTNode i = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "methodCall");
		DebugLocation(348, 1);
		try
		{
			// SqlGenerator.g:349:2: ( ^(m= METHOD_CALL i= METHOD_NAME ( ^( EXPR_LIST ( arguments )? ) )? ) )
			DebugEnterAlt(1);
			// SqlGenerator.g:349:4: ^(m= METHOD_CALL i= METHOD_NAME ( ^( EXPR_LIST ( arguments )? ) )? )
			{
			DebugLocation(349, 4);
			DebugLocation(349, 7);
			m=(IASTNode)Match(input,METHOD_CALL,Follow._METHOD_CALL_in_methodCall2011); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(349, 21);
			i=(IASTNode)Match(input,METHOD_NAME,Follow._METHOD_NAME_in_methodCall2015); if (state.failed) return;
			DebugLocation(349, 34);
			if (state.backtracking == 0)
			{
				 BeginFunctionTemplate(m,i); 
			}
			DebugLocation(350, 3);
			// SqlGenerator.g:350:3: ( ^( EXPR_LIST ( arguments )? ) )?
			int alt67=2;
			try { DebugEnterSubRule(67);
			try { DebugEnterDecision(67, false);
			int LA67_1 = input.LA(1);

			if ((LA67_1==EXPR_LIST))
			{
				alt67 = 1;
			}
			} finally { DebugExitDecision(67); }
			switch (alt67)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:350:5: ^( EXPR_LIST ( arguments )? )
				{
				DebugLocation(350, 5);
				DebugLocation(350, 7);
				Match(input,EXPR_LIST,Follow._EXPR_LIST_in_methodCall2024); if (state.failed) return;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(350, 17);
					// SqlGenerator.g:350:17: ( arguments )?
					int alt66=2;
					try { DebugEnterSubRule(66);
					try { DebugEnterDecision(66, false);
					int LA66_1 = input.LA(1);

					if ((LA66_1==AGGREGATE||LA66_1==ALL||LA66_1==ANY||(LA66_1>=BAND && LA66_1<=BOR)||(LA66_1>=BXOR && LA66_1<=CASE2)||LA66_1==CONSTANT||LA66_1==COUNT||(LA66_1>=DIV && LA66_1<=DOT)||LA66_1==EQ||LA66_1==EXISTS||LA66_1==FALSE||LA66_1==GE||LA66_1==GT||LA66_1==IDENT||(LA66_1>=IN && LA66_1<=INDEX_OP)||(LA66_1>=IS_NOT_NULL && LA66_1<=JAVA_CONSTANT)||LA66_1==LE||LA66_1==LIKE||LA66_1==LT||LA66_1==METHOD_CALL||(LA66_1>=MINUS && LA66_1<=NE)||(LA66_1>=NOT_BETWEEN && LA66_1<=NUM_LONG)||(LA66_1>=PARAM && LA66_1<=PLUS)||LA66_1==QUOTED_String||LA66_1==SELECT||LA66_1==SOME||LA66_1==STAR||(LA66_1>=TRUE && LA66_1<=UNARY_MINUS)||LA66_1==UNION||LA66_1==VECTOR_EXPR||LA66_1==ALIAS_REF||LA66_1==NAMED_PARAM||LA66_1==RESULT_VARIABLE_REF||LA66_1==SQL_TOKEN))
					{
						alt66 = 1;
					}
					} finally { DebugExitDecision(66); }
					switch (alt66)
					{
					case 1:
						DebugEnterAlt(1);
						// SqlGenerator.g:350:18: arguments
						{
						DebugLocation(350, 18);
						PushFollow(Follow._arguments_in_methodCall2027);
						arguments();
						PopFollow();
						if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(66); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(67); }

			DebugLocation(351, 3);
			if (state.backtracking == 0)
			{
				 EndFunctionTemplate(m); 
			}

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("methodCall", 47);
			LeaveRule("methodCall", 47);
			LeaveRule_methodCall();
		}
		DebugLocation(352, 1);
		} finally { DebugExitRule(GrammarFileName, "methodCall"); }
		return;

	}
	// $ANTLR end "methodCall"

	partial void EnterRule_arguments();
	partial void LeaveRule_arguments();
	// $ANTLR start "arguments"
	// SqlGenerator.g:354:1: arguments : ( expr | comparisonExpr[true] ) ( ( expr | comparisonExpr[true] ) )* ;
	[GrammarRule("arguments")]
	private void arguments()
	{
		EnterRule_arguments();
		EnterRule("arguments", 48);
		TraceIn("arguments", 48);
		try { DebugEnterRule(GrammarFileName, "arguments");
		DebugLocation(354, 1);
		try
		{
			// SqlGenerator.g:355:2: ( ( expr | comparisonExpr[true] ) ( ( expr | comparisonExpr[true] ) )* )
			DebugEnterAlt(1);
			// SqlGenerator.g:355:4: ( expr | comparisonExpr[true] ) ( ( expr | comparisonExpr[true] ) )*
			{
			DebugLocation(355, 4);
			// SqlGenerator.g:355:4: ( expr | comparisonExpr[true] )
			int alt68=2;
			try { DebugEnterSubRule(68);
			try { DebugEnterDecision(68, false);
			int LA68_1 = input.LA(1);

			if ((LA68_1==AGGREGATE||LA68_1==ALL||LA68_1==ANY||LA68_1==BAND||(LA68_1>=BNOT && LA68_1<=BOR)||(LA68_1>=BXOR && LA68_1<=CASE2)||LA68_1==CONSTANT||LA68_1==COUNT||(LA68_1>=DIV && LA68_1<=DOT)||LA68_1==FALSE||LA68_1==IDENT||LA68_1==INDEX_OP||LA68_1==JAVA_CONSTANT||LA68_1==METHOD_CALL||LA68_1==MINUS||(LA68_1>=NULL && LA68_1<=NUM_LONG)||(LA68_1>=PARAM && LA68_1<=PLUS)||LA68_1==QUOTED_String||LA68_1==SELECT||LA68_1==SOME||LA68_1==STAR||(LA68_1>=TRUE && LA68_1<=UNARY_MINUS)||LA68_1==UNION||LA68_1==VECTOR_EXPR||LA68_1==ALIAS_REF||LA68_1==NAMED_PARAM||LA68_1==RESULT_VARIABLE_REF||LA68_1==SQL_TOKEN))
			{
				alt68 = 1;
			}
			else if ((LA68_1==BETWEEN||LA68_1==EQ||LA68_1==EXISTS||LA68_1==GE||LA68_1==GT||LA68_1==IN||(LA68_1>=IS_NOT_NULL && LA68_1<=IS_NULL)||LA68_1==LE||LA68_1==LIKE||LA68_1==LT||LA68_1==NE||(LA68_1>=NOT_BETWEEN && LA68_1<=NOT_LIKE)))
			{
				alt68 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 68, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(68); }
			switch (alt68)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:355:5: expr
				{
				DebugLocation(355, 5);
				PushFollow(Follow._expr_in_arguments2052);
				expr();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:355:12: comparisonExpr[true]
				{
				DebugLocation(355, 12);
				PushFollow(Follow._comparisonExpr_in_arguments2056);
				comparisonExpr(true);
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(68); }

			DebugLocation(355, 34);
			// SqlGenerator.g:355:34: ( ( expr | comparisonExpr[true] ) )*
			try { DebugEnterSubRule(70);
			while (true)
			{
				int alt70=2;
				try { DebugEnterDecision(70, false);
				int LA70_1 = input.LA(1);

				if ((LA70_1==AGGREGATE||LA70_1==ALL||LA70_1==ANY||(LA70_1>=BAND && LA70_1<=BOR)||(LA70_1>=BXOR && LA70_1<=CASE2)||LA70_1==CONSTANT||LA70_1==COUNT||(LA70_1>=DIV && LA70_1<=DOT)||LA70_1==EQ||LA70_1==EXISTS||LA70_1==FALSE||LA70_1==GE||LA70_1==GT||LA70_1==IDENT||(LA70_1>=IN && LA70_1<=INDEX_OP)||(LA70_1>=IS_NOT_NULL && LA70_1<=JAVA_CONSTANT)||LA70_1==LE||LA70_1==LIKE||LA70_1==LT||LA70_1==METHOD_CALL||(LA70_1>=MINUS && LA70_1<=NE)||(LA70_1>=NOT_BETWEEN && LA70_1<=NUM_LONG)||(LA70_1>=PARAM && LA70_1<=PLUS)||LA70_1==QUOTED_String||LA70_1==SELECT||LA70_1==SOME||LA70_1==STAR||(LA70_1>=TRUE && LA70_1<=UNARY_MINUS)||LA70_1==UNION||LA70_1==VECTOR_EXPR||LA70_1==ALIAS_REF||LA70_1==NAMED_PARAM||LA70_1==RESULT_VARIABLE_REF||LA70_1==SQL_TOKEN))
				{
					alt70 = 1;
				}


				} finally { DebugExitDecision(70); }
				switch ( alt70 )
				{
				case 1:
					DebugEnterAlt(1);
					// SqlGenerator.g:355:36: ( expr | comparisonExpr[true] )
					{
					DebugLocation(355, 36);
					if (state.backtracking == 0)
					{
						 CommaBetweenParameters(", "); 
					}
					DebugLocation(355, 70);
					// SqlGenerator.g:355:70: ( expr | comparisonExpr[true] )
					int alt69=2;
					try { DebugEnterSubRule(69);
					try { DebugEnterDecision(69, false);
					int LA69_1 = input.LA(1);

					if ((LA69_1==AGGREGATE||LA69_1==ALL||LA69_1==ANY||LA69_1==BAND||(LA69_1>=BNOT && LA69_1<=BOR)||(LA69_1>=BXOR && LA69_1<=CASE2)||LA69_1==CONSTANT||LA69_1==COUNT||(LA69_1>=DIV && LA69_1<=DOT)||LA69_1==FALSE||LA69_1==IDENT||LA69_1==INDEX_OP||LA69_1==JAVA_CONSTANT||LA69_1==METHOD_CALL||LA69_1==MINUS||(LA69_1>=NULL && LA69_1<=NUM_LONG)||(LA69_1>=PARAM && LA69_1<=PLUS)||LA69_1==QUOTED_String||LA69_1==SELECT||LA69_1==SOME||LA69_1==STAR||(LA69_1>=TRUE && LA69_1<=UNARY_MINUS)||LA69_1==UNION||LA69_1==VECTOR_EXPR||LA69_1==ALIAS_REF||LA69_1==NAMED_PARAM||LA69_1==RESULT_VARIABLE_REF||LA69_1==SQL_TOKEN))
					{
						alt69 = 1;
					}
					else if ((LA69_1==BETWEEN||LA69_1==EQ||LA69_1==EXISTS||LA69_1==GE||LA69_1==GT||LA69_1==IN||(LA69_1>=IS_NOT_NULL && LA69_1<=IS_NULL)||LA69_1==LE||LA69_1==LIKE||LA69_1==LT||LA69_1==NE||(LA69_1>=NOT_BETWEEN && LA69_1<=NOT_LIKE)))
					{
						alt69 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 69, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(69); }
					switch (alt69)
					{
					case 1:
						DebugEnterAlt(1);
						// SqlGenerator.g:355:71: expr
						{
						DebugLocation(355, 71);
						PushFollow(Follow._expr_in_arguments2065);
						expr();
						PopFollow();
						if (state.failed) return;

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// SqlGenerator.g:355:78: comparisonExpr[true]
						{
						DebugLocation(355, 78);
						PushFollow(Follow._comparisonExpr_in_arguments2069);
						comparisonExpr(true);
						PopFollow();
						if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(69); }


					}
					break;

				default:
					goto loop70;
				}
			}

			loop70:
				;

			} finally { DebugExitSubRule(70); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("arguments", 48);
			LeaveRule("arguments", 48);
			LeaveRule_arguments();
		}
		DebugLocation(356, 1);
		} finally { DebugExitRule(GrammarFileName, "arguments"); }
		return;

	}
	// $ANTLR end "arguments"

	partial void EnterRule_parameter();
	partial void LeaveRule_parameter();
	// $ANTLR start "parameter"
	// SqlGenerator.g:358:1: parameter : (n= NAMED_PARAM |p= PARAM );
	[GrammarRule("parameter")]
	private void parameter()
	{
		EnterRule_parameter();
		EnterRule("parameter", 49);
		TraceIn("parameter", 49);
		IASTNode n = default(IASTNode);
		IASTNode p = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "parameter");
		DebugLocation(358, 1);
		try
		{
			// SqlGenerator.g:359:2: (n= NAMED_PARAM |p= PARAM )
			int alt71=2;
			try { DebugEnterDecision(71, false);
			int LA71_1 = input.LA(1);

			if ((LA71_1==NAMED_PARAM))
			{
				alt71 = 1;
			}
			else if ((LA71_1==PARAM))
			{
				alt71 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 71, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(71); }
			switch (alt71)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:359:4: n= NAMED_PARAM
				{
				DebugLocation(359, 5);
				n=(IASTNode)Match(input,NAMED_PARAM,Follow._NAMED_PARAM_in_parameter2087); if (state.failed) return;
				DebugLocation(359, 18);
				if (state.backtracking == 0)
				{
					 Out(n); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:360:4: p= PARAM
				{
				DebugLocation(360, 5);
				p=(IASTNode)Match(input,PARAM,Follow._PARAM_in_parameter2096); if (state.failed) return;
				DebugLocation(360, 12);
				if (state.backtracking == 0)
				{
					 Out(p); 
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("parameter", 49);
			LeaveRule("parameter", 49);
			LeaveRule_parameter();
		}
		DebugLocation(361, 1);
		} finally { DebugExitRule(GrammarFileName, "parameter"); }
		return;

	}
	// $ANTLR end "parameter"

	partial void EnterRule_limitValue();
	partial void LeaveRule_limitValue();
	// $ANTLR start "limitValue"
	// SqlGenerator.g:363:1: limitValue : ( NUM_INT | NAMED_PARAM | PARAM );
	[GrammarRule("limitValue")]
	private TreeRuleReturnScope<IASTNode> limitValue()
	{
		EnterRule_limitValue();
		EnterRule("limitValue", 50);
		TraceIn("limitValue", 50);
		TreeRuleReturnScope<IASTNode> retval = new TreeRuleReturnScope<IASTNode>();
		retval.Start = (IASTNode)input.LT(1);

		try { DebugEnterRule(GrammarFileName, "limitValue");
		DebugLocation(363, 1);
		try
		{
			// SqlGenerator.g:364:2: ( NUM_INT | NAMED_PARAM | PARAM )
			DebugEnterAlt(1);
			// SqlGenerator.g:
			{
			DebugLocation(364, 2);
			if (input.LA(1)==NUM_INT||input.LA(1)==PARAM||input.LA(1)==NAMED_PARAM)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("limitValue", 50);
			LeaveRule("limitValue", 50);
			LeaveRule_limitValue();
		}
		DebugLocation(367, 1);
		} finally { DebugExitRule(GrammarFileName, "limitValue"); }
		return retval;

	}
	// $ANTLR end "limitValue"

	partial void EnterRule_addrExpr();
	partial void LeaveRule_addrExpr();
	// $ANTLR start "addrExpr"
	// SqlGenerator.g:369:1: addrExpr : ( ^(r= DOT . . ) |i= ALIAS_REF | ^(j= INDEX_OP ( . )* ) |v= RESULT_VARIABLE_REF );
	[GrammarRule("addrExpr")]
	private void addrExpr()
	{
		EnterRule_addrExpr();
		EnterRule("addrExpr", 51);
		TraceIn("addrExpr", 51);
		IASTNode r = default(IASTNode);
		IASTNode i = default(IASTNode);
		IASTNode j = default(IASTNode);
		IASTNode v = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "addrExpr");
		DebugLocation(369, 1);
		try
		{
			// SqlGenerator.g:370:2: ( ^(r= DOT . . ) |i= ALIAS_REF | ^(j= INDEX_OP ( . )* ) |v= RESULT_VARIABLE_REF )
			int alt73=4;
			try { DebugEnterDecision(73, false);
			switch (input.LA(1))
			{
			case DOT:
				{
				alt73 = 1;
				}
				break;
			case ALIAS_REF:
				{
				alt73 = 2;
				}
				break;
			case INDEX_OP:
				{
				alt73 = 3;
				}
				break;
			case RESULT_VARIABLE_REF:
				{
				alt73 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 73, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(73); }
			switch (alt73)
			{
			case 1:
				DebugEnterAlt(1);
				// SqlGenerator.g:370:4: ^(r= DOT . . )
				{
				DebugLocation(370, 4);
				DebugLocation(370, 7);
				r=(IASTNode)Match(input,DOT,Follow._DOT_in_addrExpr2133); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(370, 12);
				MatchAny(input); if (state.failed) return;
				DebugLocation(370, 14);
				MatchAny(input); if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(370, 17);
				if (state.backtracking == 0)
				{
					 Out(r); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// SqlGenerator.g:371:4: i= ALIAS_REF
				{
				DebugLocation(371, 5);
				i=(IASTNode)Match(input,ALIAS_REF,Follow._ALIAS_REF_in_addrExpr2147); if (state.failed) return;
				DebugLocation(371, 16);
				if (state.backtracking == 0)
				{
					 Out(i); 
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// SqlGenerator.g:372:4: ^(j= INDEX_OP ( . )* )
				{
				DebugLocation(372, 4);
				DebugLocation(372, 7);
				j=(IASTNode)Match(input,INDEX_OP,Follow._INDEX_OP_in_addrExpr2157); if (state.failed) return;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(372, 17);
					// SqlGenerator.g:372:17: ( . )*
					try { DebugEnterSubRule(72);
					while (true)
					{
						int alt72=2;
						try { DebugEnterDecision(72, false);
						int LA72_1 = input.LA(1);

						if (((LA72_1>=AGGREGATE && LA72_1<=THETA_JOINS)))
						{
							alt72 = 1;
						}
						else if ((LA72_1==UP))
						{
							alt72 = 2;
						}


						} finally { DebugExitDecision(72); }
						switch ( alt72 )
						{
						case 1:
							DebugEnterAlt(1);
							// SqlGenerator.g:372:17: .
							{
							DebugLocation(372, 17);
							MatchAny(input); if (state.failed) return;

							}
							break;

						default:
							goto loop72;
						}
					}

					loop72:
						;

					} finally { DebugExitSubRule(72); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}

				DebugLocation(372, 21);
				if (state.backtracking == 0)
				{
					 Out(j); 
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// SqlGenerator.g:373:4: v= RESULT_VARIABLE_REF
				{
				DebugLocation(373, 5);
				v=(IASTNode)Match(input,RESULT_VARIABLE_REF,Follow._RESULT_VARIABLE_REF_in_addrExpr2170); if (state.failed) return;
				DebugLocation(373, 26);
				if (state.backtracking == 0)
				{
					 Out(v); 
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("addrExpr", 51);
			LeaveRule("addrExpr", 51);
			LeaveRule_addrExpr();
		}
		DebugLocation(374, 1);
		} finally { DebugExitRule(GrammarFileName, "addrExpr"); }
		return;

	}
	// $ANTLR end "addrExpr"

	partial void EnterRule_sqlToken();
	partial void LeaveRule_sqlToken();
	// $ANTLR start "sqlToken"
	// SqlGenerator.g:376:1: sqlToken : ^(t= SQL_TOKEN ( . )* ) ;
	[GrammarRule("sqlToken")]
	private void sqlToken()
	{
		EnterRule_sqlToken();
		EnterRule("sqlToken", 52);
		TraceIn("sqlToken", 52);
		IASTNode t = default(IASTNode);

		try { DebugEnterRule(GrammarFileName, "sqlToken");
		DebugLocation(376, 1);
		try
		{
			// SqlGenerator.g:377:2: ( ^(t= SQL_TOKEN ( . )* ) )
			DebugEnterAlt(1);
			// SqlGenerator.g:377:4: ^(t= SQL_TOKEN ( . )* )
			{
			DebugLocation(377, 4);
			DebugLocation(377, 7);
			t=(IASTNode)Match(input,SQL_TOKEN,Follow._SQL_TOKEN_in_sqlToken2186); if (state.failed) return;

			DebugLocation(377, 18);
			if (state.backtracking == 0)
			{
				 Out(t); 
			}

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(377, 30);
				// SqlGenerator.g:377:30: ( . )*
				try { DebugEnterSubRule(74);
				while (true)
				{
					int alt74=2;
					try { DebugEnterDecision(74, false);
					int LA74_1 = input.LA(1);

					if (((LA74_1>=AGGREGATE && LA74_1<=THETA_JOINS)))
					{
						alt74 = 1;
					}
					else if ((LA74_1==UP))
					{
						alt74 = 2;
					}


					} finally { DebugExitDecision(74); }
					switch ( alt74 )
					{
					case 1:
						DebugEnterAlt(1);
						// SqlGenerator.g:377:30: .
						{
						DebugLocation(377, 30);
						MatchAny(input); if (state.failed) return;

						}
						break;

					default:
						goto loop74;
					}
				}

				loop74:
					;

				} finally { DebugExitSubRule(74); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("sqlToken", 52);
			LeaveRule("sqlToken", 52);
			LeaveRule_sqlToken();
		}
		DebugLocation(378, 1);
		} finally { DebugExitRule(GrammarFileName, "sqlToken"); }
		return;

	}
	// $ANTLR end "sqlToken"

	partial void EnterRule_synpred1_SqlGenerator_fragment();
	partial void LeaveRule_synpred1_SqlGenerator_fragment();

	// $ANTLR start synpred1_SqlGenerator
	private void synpred1_SqlGenerator_fragment()
	{
		EnterRule_synpred1_SqlGenerator_fragment();
		EnterRule("synpred1_SqlGenerator_fragment", 53);
		TraceIn("synpred1_SqlGenerator_fragment", 53);
		try
		{
			// SqlGenerator.g:85:4: ( SQL_TOKEN )
			DebugEnterAlt(1);
			// SqlGenerator.g:85:5: SQL_TOKEN
			{
			DebugLocation(85, 5);
			Match(input,SQL_TOKEN,Follow._SQL_TOKEN_in_synpred1_SqlGenerator370); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_SqlGenerator_fragment", 53);
			LeaveRule("synpred1_SqlGenerator_fragment", 53);
			LeaveRule_synpred1_SqlGenerator_fragment();
		}
	}
	// $ANTLR end synpred1_SqlGenerator

	partial void EnterRule_synpred2_SqlGenerator_fragment();
	partial void LeaveRule_synpred2_SqlGenerator_fragment();

	// $ANTLR start synpred2_SqlGenerator
	private void synpred2_SqlGenerator_fragment()
	{
		EnterRule_synpred2_SqlGenerator_fragment();
		EnterRule("synpred2_SqlGenerator_fragment", 54);
		TraceIn("synpred2_SqlGenerator_fragment", 54);
		try
		{
			// SqlGenerator.g:321:4: ( additiveExpr )
			DebugEnterAlt(1);
			// SqlGenerator.g:321:5: additiveExpr
			{
			DebugLocation(321, 5);
			PushFollow(Follow._additiveExpr_in_synpred2_SqlGenerator1807);
			additiveExpr();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_SqlGenerator_fragment", 54);
			LeaveRule("synpred2_SqlGenerator_fragment", 54);
			LeaveRule_synpred2_SqlGenerator_fragment();
		}
	}
	// $ANTLR end synpred2_SqlGenerator

	partial void EnterRule_synpred3_SqlGenerator_fragment();
	partial void LeaveRule_synpred3_SqlGenerator_fragment();

	// $ANTLR start synpred3_SqlGenerator
	private void synpred3_SqlGenerator_fragment()
	{
		EnterRule_synpred3_SqlGenerator_fragment();
		EnterRule("synpred3_SqlGenerator_fragment", 55);
		TraceIn("synpred3_SqlGenerator_fragment", 55);
		try
		{
			// SqlGenerator.g:322:4: ( bitwiseExpr )
			DebugEnterAlt(1);
			// SqlGenerator.g:322:5: bitwiseExpr
			{
			DebugLocation(322, 5);
			PushFollow(Follow._bitwiseExpr_in_synpred3_SqlGenerator1822);
			bitwiseExpr();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_SqlGenerator_fragment", 55);
			LeaveRule("synpred3_SqlGenerator_fragment", 55);
			LeaveRule_synpred3_SqlGenerator_fragment();
		}
	}
	// $ANTLR end synpred3_SqlGenerator

	partial void EnterRule_synpred4_SqlGenerator_fragment();
	partial void LeaveRule_synpred4_SqlGenerator_fragment();

	// $ANTLR start synpred4_SqlGenerator
	private void synpred4_SqlGenerator_fragment()
	{
		EnterRule_synpred4_SqlGenerator_fragment();
		EnterRule("synpred4_SqlGenerator_fragment", 56);
		TraceIn("synpred4_SqlGenerator_fragment", 56);
		try
		{
			// SqlGenerator.g:328:4: ( arithmeticExpr )
			DebugEnterAlt(1);
			// SqlGenerator.g:328:5: arithmeticExpr
			{
			DebugLocation(328, 5);
			PushFollow(Follow._arithmeticExpr_in_synpred4_SqlGenerator1851);
			arithmeticExpr();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred4_SqlGenerator_fragment", 56);
			LeaveRule("synpred4_SqlGenerator_fragment", 56);
			LeaveRule_synpred4_SqlGenerator_fragment();
		}
	}
	// $ANTLR end synpred4_SqlGenerator
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _selectStatement_in_statement59 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _updateStatement_in_statement64 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _deleteStatement_in_statement69 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _insertStatement_in_statement74 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SELECT_in_selectStatement86 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _selectClause_in_selectStatement92 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _from_in_selectStatement96 = new BitSet(new ulong[]{0x28000000000008UL,0x42000800000000UL,0x4UL});
		public static readonly BitSet _WHERE_in_selectStatement103 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _whereExpr_in_selectStatement107 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _GROUP_in_selectStatement119 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _groupExprs_in_selectStatement123 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _HAVING_in_selectStatement135 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _booleanExpr_in_selectStatement139 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ORDER_in_selectStatement151 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _orderExprs_in_selectStatement155 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SKIP_in_selectStatement167 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _limitValue_in_selectStatement171 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TAKE_in_selectStatement183 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _limitValue_in_selectStatement187 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _UPDATE_in_updateStatement214 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _FROM_in_updateStatement222 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _fromTable_in_updateStatement224 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _setClause_in_updateStatement230 = new BitSet(new ulong[]{0x8UL,0x0UL,0x4UL});
		public static readonly BitSet _whereClause_in_updateStatement235 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DELETE_in_deleteStatement254 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _from_in_deleteStatement260 = new BitSet(new ulong[]{0x8UL,0x0UL,0x4UL});
		public static readonly BitSet _whereClause_in_deleteStatement265 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _INSERT_in_insertStatement282 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _INTO_in_insertStatement291 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _selectStatement_in_insertStatement301 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SET_in_setClause321 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _comparisonExpr_in_setClause325 = new BitSet(new ulong[]{0x414024000002008UL,0x720A4CUL});
		public static readonly BitSet _comparisonExpr_in_setClause332 = new BitSet(new ulong[]{0x414024000002008UL,0x720A4CUL});
		public static readonly BitSet _WHERE_in_whereClause352 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _whereClauseExpr_in_whereClause356 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _conditionList_in_whereClauseExpr375 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _booleanExpr_in_whereClauseExpr380 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_orderExprs396 = new BitSet(new ulong[]{0x8801003540ED552UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _orderDirection_in_orderExprs403 = new BitSet(new ulong[]{0x8801003140ED152UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _orderExprs_in_orderExprs413 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_groupExprs428 = new BitSet(new ulong[]{0x8801003140ED152UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _groupExprs_in_groupExprs434 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _filters_in_whereExpr471 = new BitSet(new ulong[]{0x414024000002082UL,0x4007A4A4CUL,0xC00000UL});
		public static readonly BitSet _thetaJoins_in_whereExpr479 = new BitSet(new ulong[]{0x414024000002082UL,0x4007A4A4CUL,0x400000UL});
		public static readonly BitSet _booleanExpr_in_whereExpr490 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _thetaJoins_in_whereExpr500 = new BitSet(new ulong[]{0x414024000002082UL,0x4007A4A4CUL,0x400000UL});
		public static readonly BitSet _booleanExpr_in_whereExpr508 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _booleanExpr_in_whereExpr519 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FILTERS_in_filters532 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _conditionList_in_filters534 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _THETA_JOINS_in_thetaJoins548 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _conditionList_in_thetaJoins550 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _sqlToken_in_conditionList563 = new BitSet(new ulong[]{0x2UL,0x0UL,0x400000UL});
		public static readonly BitSet _conditionList_in_conditionList569 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SELECT_CLAUSE_in_selectClause584 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _distinctOrAll_in_selectClause587 = new BitSet(new ulong[]{0x8010031C0ED010UL,0x61044C01F014010UL,0x608080UL});
		public static readonly BitSet _selectColumn_in_selectClause593 = new BitSet(new ulong[]{0x8010031C0ED018UL,0x61044C01F014010UL,0x608080UL});
		public static readonly BitSet _selectExpr_in_selectColumn611 = new BitSet(new ulong[]{0x2UL,0x0UL,0x100000UL});
		public static readonly BitSet _SELECT_COLUMNS_in_selectColumn616 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selectAtom_in_selectExpr636 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _count_in_selectExpr643 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONSTRUCTOR_in_selectExpr649 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _set_in_selectExpr651 = new BitSet(new ulong[]{0x8010031C0ED010UL,0x61044C01F014010UL,0x608080UL});
		public static readonly BitSet _selectColumn_in_selectExpr661 = new BitSet(new ulong[]{0x8010031C0ED018UL,0x61044C01F014010UL,0x608080UL});
		public static readonly BitSet _methodCall_in_selectExpr671 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _aggregate_in_selectExpr676 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_selectExpr683 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arithmeticExpr_in_selectExpr690 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parameter_in_selectExpr695 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selectStatement_in_selectExpr704 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COUNT_in_count718 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _distinctOrAll_in_count725 = new BitSet(new ulong[]{0x8801003140ED010UL,0x61024C01F814010UL,0x428080UL});
		public static readonly BitSet _countExpr_in_count731 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DISTINCT_in_distinctOrAll746 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ALL_in_distinctOrAll754 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ROW_STAR_in_countExpr773 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _simpleExpr_in_countExpr780 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_selectAtom792 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _SQL_TOKEN_in_selectAtom802 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ALIAS_REF_in_selectAtom812 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _SELECT_EXPR_in_selectAtom822 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _FROM_in_from845 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _fromTable_in_from852 = new BitSet(new ulong[]{0x8UL,0x0UL,0x1400UL});
		public static readonly BitSet _FROM_FRAGMENT_in_fromTable878 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _tableJoin_in_fromTable884 = new BitSet(new ulong[]{0x8UL,0x0UL,0x1400UL});
		public static readonly BitSet _JOIN_FRAGMENT_in_fromTable899 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _tableJoin_in_fromTable905 = new BitSet(new ulong[]{0x8UL,0x0UL,0x1400UL});
		public static readonly BitSet _JOIN_FRAGMENT_in_tableJoin928 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _tableJoin_in_tableJoin933 = new BitSet(new ulong[]{0x8UL,0x0UL,0x1400UL});
		public static readonly BitSet _FROM_FRAGMENT_in_tableJoin949 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _tableJoin_in_tableJoin954 = new BitSet(new ulong[]{0x8UL,0x0UL,0x1400UL});
		public static readonly BitSet _AND_in_booleanOp974 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _booleanExpr_in_booleanOp976 = new BitSet(new ulong[]{0x414024000002080UL,0x4007A4A4CUL,0x400000UL});
		public static readonly BitSet _booleanExpr_in_booleanOp981 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _OR_in_booleanOp989 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _booleanExpr_in_booleanOp993 = new BitSet(new ulong[]{0x414024000002080UL,0x4007A4A4CUL,0x400000UL});
		public static readonly BitSet _booleanExpr_in_booleanOp998 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _NOT_in_booleanOp1008 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _booleanExpr_in_booleanOp1012 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _booleanOp_in_booleanExpr1029 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _comparisonExpr_in_booleanExpr1036 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _methodCall_in_booleanExpr1043 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SQL_TOKEN_in_booleanExpr1050 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _binaryComparisonExpression_in_comparisonExpr1068 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _exoticComparisonExpression_in_comparisonExpr1075 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EQ_in_binaryComparisonExpression1090 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_binaryComparisonExpression1092 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _expr_in_binaryComparisonExpression1096 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _NE_in_binaryComparisonExpression1103 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_binaryComparisonExpression1105 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _expr_in_binaryComparisonExpression1109 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _GT_in_binaryComparisonExpression1116 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_binaryComparisonExpression1118 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _expr_in_binaryComparisonExpression1122 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _GE_in_binaryComparisonExpression1129 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_binaryComparisonExpression1131 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _expr_in_binaryComparisonExpression1135 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LT_in_binaryComparisonExpression1142 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_binaryComparisonExpression1144 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _expr_in_binaryComparisonExpression1148 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LE_in_binaryComparisonExpression1155 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_binaryComparisonExpression1157 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _expr_in_binaryComparisonExpression1161 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LIKE_in_exoticComparisonExpression1175 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_exoticComparisonExpression1177 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _expr_in_exoticComparisonExpression1181 = new BitSet(new ulong[]{0x8000000008UL});
		public static readonly BitSet _likeEscape_in_exoticComparisonExpression1183 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _NOT_LIKE_in_exoticComparisonExpression1191 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_exoticComparisonExpression1193 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _expr_in_exoticComparisonExpression1197 = new BitSet(new ulong[]{0x8000000008UL});
		public static readonly BitSet _likeEscape_in_exoticComparisonExpression1199 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BETWEEN_in_exoticComparisonExpression1206 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_exoticComparisonExpression1208 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _expr_in_exoticComparisonExpression1212 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _expr_in_exoticComparisonExpression1216 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _NOT_BETWEEN_in_exoticComparisonExpression1223 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_exoticComparisonExpression1225 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _expr_in_exoticComparisonExpression1229 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _expr_in_exoticComparisonExpression1233 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _IN_in_exoticComparisonExpression1240 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_exoticComparisonExpression1242 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _inList_in_exoticComparisonExpression1246 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _NOT_IN_in_exoticComparisonExpression1254 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_exoticComparisonExpression1256 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _inList_in_exoticComparisonExpression1260 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EXISTS_in_exoticComparisonExpression1268 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _quantified_in_exoticComparisonExpression1272 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _IS_NULL_in_exoticComparisonExpression1280 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_exoticComparisonExpression1282 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _IS_NOT_NULL_in_exoticComparisonExpression1291 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_exoticComparisonExpression1293 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ESCAPE_in_likeEscape1310 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_likeEscape1314 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _IN_LIST_in_inList1330 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _parenSelect_in_inList1336 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _simpleExprList_in_inList1340 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _simpleExpr_in_simpleExprList1361 = new BitSet(new ulong[]{0x8801003140ED012UL,0x61004C01F814010UL,0x428080UL});
		public static readonly BitSet _simpleExpr_in_expr1380 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VECTOR_EXPR_in_expr1387 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr1394 = new BitSet(new ulong[]{0x8801003140ED158UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _parenSelect_in_expr1409 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ANY_in_expr1415 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _quantified_in_expr1419 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ALL_in_expr1427 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _quantified_in_expr1431 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SOME_in_expr1439 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _quantified_in_expr1443 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _sqlToken_in_quantified1461 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selectStatement_in_quantified1465 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selectStatement_in_parenSelect1484 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _UNION_in_parenSelect1493 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _selectStatement_in_parenSelect1497 = new BitSet(new ulong[]{0x0UL,0x1000400000000000UL});
		public static readonly BitSet _parenSelect_in_parenSelect1501 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _constant_in_simpleExpr1520 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NULL_in_simpleExpr1527 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _addrExpr_in_simpleExpr1534 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _sqlToken_in_simpleExpr1539 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _aggregate_in_simpleExpr1544 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _methodCall_in_simpleExpr1549 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _count_in_simpleExpr1554 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parameter_in_simpleExpr1559 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arithmeticExpr_in_simpleExpr1564 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _additiveExpr_in_arithmeticExpr1638 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseExpr_in_arithmeticExpr1643 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _multiplicativeExpr_in_arithmeticExpr1648 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _UNARY_MINUS_in_arithmeticExpr1655 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _nestedExprAfterMinusDiv_in_arithmeticExpr1659 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _caseExpr_in_arithmeticExpr1665 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PLUS_in_additiveExpr1677 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_additiveExpr1679 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _expr_in_additiveExpr1683 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _MINUS_in_additiveExpr1690 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_additiveExpr1692 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _nestedExprAfterMinusDiv_in_additiveExpr1696 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BAND_in_bitwiseExpr1709 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_bitwiseExpr1713 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _nestedExpr_in_bitwiseExpr1715 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BOR_in_bitwiseExpr1724 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_bitwiseExpr1728 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _nestedExpr_in_bitwiseExpr1730 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BXOR_in_bitwiseExpr1739 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_bitwiseExpr1743 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _nestedExpr_in_bitwiseExpr1745 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BNOT_in_bitwiseExpr1754 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _nestedExpr_in_bitwiseExpr1758 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _STAR_in_multiplicativeExpr1773 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _nestedExpr_in_multiplicativeExpr1775 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _nestedExpr_in_multiplicativeExpr1779 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DIV_in_multiplicativeExpr1786 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _nestedExpr_in_multiplicativeExpr1788 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _nestedExprAfterMinusDiv_in_multiplicativeExpr1792 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _additiveExpr_in_nestedExpr1814 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseExpr_in_nestedExpr1829 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_nestedExpr1836 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arithmeticExpr_in_nestedExprAfterMinusDiv1858 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_nestedExprAfterMinusDiv1865 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CASE_in_caseExpr1877 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _WHEN_in_caseExpr1887 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _booleanExpr_in_caseExpr1891 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _expr_in_caseExpr1896 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ELSE_in_caseExpr1908 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_caseExpr1912 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CASE2_in_caseExpr1928 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_caseExpr1932 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _WHEN_in_caseExpr1939 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_caseExpr1943 = new BitSet(new ulong[]{0x8801003140ED150UL,0x561444C01F814010UL,0x428080UL});
		public static readonly BitSet _expr_in_caseExpr1947 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ELSE_in_caseExpr1959 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_caseExpr1963 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _AGGREGATE_in_aggregate1987 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_aggregate1992 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _METHOD_CALL_in_methodCall2011 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _METHOD_NAME_in_methodCall2015 = new BitSet(new ulong[]{0x80000000008UL});
		public static readonly BitSet _EXPR_LIST_in_methodCall2024 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _arguments_in_methodCall2027 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _expr_in_arguments2052 = new BitSet(new ulong[]{0xC941243140EF152UL,0x561444C01FF34A5CUL,0x428080UL});
		public static readonly BitSet _comparisonExpr_in_arguments2056 = new BitSet(new ulong[]{0xC941243140EF152UL,0x561444C01FF34A5CUL,0x428080UL});
		public static readonly BitSet _expr_in_arguments2065 = new BitSet(new ulong[]{0xC941243140EF152UL,0x561444C01FF34A5CUL,0x428080UL});
		public static readonly BitSet _comparisonExpr_in_arguments2069 = new BitSet(new ulong[]{0xC941243140EF152UL,0x561444C01FF34A5CUL,0x428080UL});
		public static readonly BitSet _NAMED_PARAM_in_parameter2087 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PARAM_in_parameter2096 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_addrExpr2133 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ALIAS_REF_in_addrExpr2147 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INDEX_OP_in_addrExpr2157 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _RESULT_VARIABLE_REF_in_addrExpr2170 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SQL_TOKEN_in_sqlToken2186 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _SQL_TOKEN_in_synpred1_SqlGenerator370 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _additiveExpr_in_synpred2_SqlGenerator1807 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseExpr_in_synpred3_SqlGenerator1822 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arithmeticExpr_in_synpred4_SqlGenerator1851 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  NHibernate.Hql.Ast.ANTLR 
