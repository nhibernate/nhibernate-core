using System;
using System.Collections.Generic;
using System.Data.Common;
using NHibernate.Engine;
using NHibernate.SqlCommand;

namespace NHibernate.Multi
{
	/// <summary>
	/// Interface for wrapping query to be batched by <see cref="IQueryBatch"/>
	/// </summary>
	public interface IQueryBatchItem<TResult> : IQueryBatchItem
	{
		/// <summary>
		/// Returns loaded typed results by query.
		/// Must be called only after <see cref="IQueryBatch.Execute"/>.
		/// </summary>
		IList<TResult> GetResults();

		/// <summary>
		/// Callback is executed after results are loaded by batch.
		/// Loaded results are provided in action parameter.
		/// </summary>
		Action<IList<TResult>> AfterLoadCallback { get; set; }
	}

	/// <summary>
	/// Interface for wrapping query to be batched by <see cref="IQueryBatch"/>
	/// </summary>
	public partial interface IQueryBatchItem
	{
		/// <summary>
		/// Method is called right before batch execution.
		/// Can be used for various delayed initialization logic.
		/// </summary>
		/// <param name="session"></param>
		void Init(ISessionImplementor session);
		
		/// <summary>
		/// Returns commands generated by query
		/// </summary>
		IEnumerable<ISqlCommand> GetCommands();

		/// <summary>
		/// Returns delegates for processing result sets generated by <see cref="GetCommands"/>.
		/// Delegate should return number of rows loaded by command.
		/// </summary>
		/// <returns></returns>
		IEnumerable<Func<DbDataReader, int>> GetResultSetHandler();

		/// <summary>
		/// Executed after all commands in batch are processed
		/// </summary>
		void ProcessResults();

		/// <summary>
		/// Immediate query execution in case the dialect does not support batches
		/// </summary>
		void ExecuteNonBatched();

		/// <summary>
		/// Get cache query spaces
		/// </summary>
		IEnumerable<string> GetQuerySpaces();
	}
}
