<xs:schema targetNamespace="urn:nhibernate-configuration-2.2" xmlns="urn:nhibernate-configuration-2.2" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:NS="urn:nhibernate-configuration-2.2">
	<xs:annotation>
		<xs:documentation>
			-- This schema was automatically generated by Syntext Dtd2Schema and changed for NH use --
			-- conversion tool (from file: hibernate-configuration-3.0.dtd) --
			-- Copyright (C) 2002, 2003 Syntext Inc. See http://www.syntext.com for updates. --
		</xs:documentation>
	</xs:annotation>
	<!-- Type definitions -->
	<xs:element name="hibernate-configuration">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="bytecode-provider" minOccurs="0" maxOccurs="1" >
					<xs:annotation>
						<xs:documentation>
							There are 2 default short-cut values
							- lcg     : default for .NET2.0 and higher.
							- null    : Disable the reflection optimization completely.
							In addition you can specify the AssemblyQualifiedName of your custom bytecode-provider (implementation of IBytecodeProvider).
							Note: the bytecode-provider will be effective only when specified in the app.config or web.config.
						</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element ref="objects-factory" minOccurs="0" maxOccurs="1" >
					<xs:annotation>
						<xs:documentation>
							Specify the AssemblyQualifiedName of your custom objects-factory (implementation of IObjectsFactory).
							Note: the objects-factory will be effective only when specified in the app.config or web.config.
						</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element ref="reflection-optimizer" maxOccurs="1" minOccurs="0" />
				<xs:element ref="session-factory" minOccurs="0" maxOccurs="1" />
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<xs:element name="class-cache">
		<xs:complexType>
			<xs:sequence>
			</xs:sequence>
			<xs:attribute name="class" type="xs:string" use="required" />
			<xs:attributeGroup ref="cacheSpecification" />
			<xs:attribute name="include">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="all" />
						<xs:enumeration value="non-lazy" />
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="collection-cache">
		<xs:complexType>
			<xs:sequence />
			<xs:attribute name="collection" type="xs:string" use="required" />
			<xs:attributeGroup ref="cacheSpecification" />
		</xs:complexType>
	</xs:element>
	<xs:element name="mapping">
		<xs:annotation>
			<xs:documentation>
				There are 3 possible combinations of mapping attributes
				1 - resource &amp; assembly:  NHibernate will read the mapping resource from the specified assembly
				2 - file only: NHibernate will read the mapping from the file.
				3 - assembly only: NHibernate will find all the resources ending in hbm.xml from the assembly.
			</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="resource" />
			<xs:attribute name="file" />
			<xs:attribute name="assembly" />
		</xs:complexType>
	</xs:element>
	<xs:element name="property">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="xs:string">
					<xs:attribute name="name" use="required">
						<xs:simpleType>
							<xs:union>
								<xs:simpleType>
									<xs:restriction base="xs:string">
										<xs:enumeration value="connection.provider" />
										<xs:enumeration value="connection.driver_class" />
										<xs:enumeration value="connection.connection_string" />
										<xs:enumeration value="connection.isolation" />
										<xs:enumeration value="connection.release_mode" />
										<xs:enumeration value="connection.connection_string_name" />
										<xs:enumeration value="dialect" />
										<xs:enumeration value="default_schema" />
										<xs:enumeration value="show_sql" />
										<xs:enumeration value="max_fetch_depth" />
										<xs:enumeration value="detect_fetch_loops" />
										<xs:enumeration value="current_session_context_class" />
										<xs:enumeration value="transaction.factory_class">
											<xs:annotation>
												<xs:documentation>
													The class name of a custom ITransactionFactory implementation.
													Defaults to the built-in AdoNetWithSystemTransactionFactory.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="cache.provider_class" />
										<xs:enumeration value="cache.use_query_cache" />
										<xs:enumeration value="cache.query_cache_factory" />
										<xs:enumeration value="cache.read_write_lock_factory">
											<xs:annotation>
												<xs:documentation>
													Specify the cache lock factory to use for read-write cache regions.
													Defaults to the built-in async cache lock factory.
													Use async, or sync, or classname.of.CacheLockFactory, assembly.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="cache.use_second_level_cache" />
										<xs:enumeration value="cache.region_prefix" />
										<xs:enumeration value="cache.use_minimal_puts" />
										<xs:enumeration value="cache.default_expiration" />
										<xs:enumeration value="cache.use_sliding_expiration">
											<xs:annotation>
												<xs:documentation>
													The use_sliding_expiration value is whether you wish to use a
													sliding expiration or not. Defaults
													to false. Not all providers support this setting, it may be ignored.
													Check their respective
													documentation.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="query.substitutions" />
										<xs:enumeration value="query.factory_class" />
										<xs:enumeration value="query.linq_provider_class" />
										<xs:enumeration value="query.imports" />
										<xs:enumeration value="query.plan_parameter_metadata_max_size" />
										<xs:enumeration value="query.plan_cache_max_size" />
										<xs:enumeration value="hbm2ddl.auto" />
										<xs:enumeration value="hbm2ddl.keywords" />
										<xs:enumeration value="hbm2ddl.throw_on_update">
											<xs:annotation>
												<!-- 6.0 TODO: should become true -->
												<xs:documentation>
													Whether to throw or not on schema auto-update failures. false by default.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="sql_exception_converter" />
										<xs:enumeration value="adonet.wrap_result_sets" />
										<xs:enumeration value="prepare_sql" />
										<xs:enumeration value="command_timeout">
											<xs:annotation>
												<xs:documentation>
													Set the default timeout in seconds for ADO.NET queries.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="adonet.batch_size" />
										<xs:enumeration value="use_proxy_validator" />
										<xs:enumeration value="xml.output_stylesheet" />
										<xs:enumeration value="generate_statistics" />
										<xs:enumeration value="query.startup_check" />
										<xs:enumeration value="query.throw_never_cached">
											<xs:annotation>
												<xs:documentation>
													Should queries set as cacheable raise an error if they reference an entity using the cache
													strategy "never" (the default is enabled).
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="default_catalog" />
										<xs:enumeration value="proxyfactory.factory_class" />
										<xs:enumeration value="adonet.factory_class" />
										<xs:enumeration value="default_batch_fetch_size" />
										<xs:enumeration value="batch_fetch_style" />
										<xs:enumeration value="default_entity_mode" />
										<xs:enumeration value="default_flush_mode" />
										<xs:enumeration value="use_sql_comments" />
										<xs:enumeration value="format_sql" />
										<xs:enumeration value="collectiontype.factory_class" />
										<xs:enumeration value="order_inserts" />
										<xs:enumeration value="order_updates" />
										<xs:enumeration value="query.query_model_rewriter_factory" />
										<xs:enumeration value="query.pre_transformer_registrar">
											<xs:annotation>
												<xs:documentation>
													The pre-transformer registrar used to register custom expression transformers.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="linqtohql.generatorsregistry" />
										<xs:enumeration value="linqtohql.legacy_preevaluation">
											<xs:annotation>
												<xs:documentation>
													Whether to use the legacy pre-evaluation or not in Linq queries. true by default.

													Legacy pre-evaluation is causing special properties or functions like DateTime.Now or Guid.NewGuid()
													to be always evaluated with the .Net runtime and replaced in the query by parameter values.

													The new pre-evaluation allows them to be converted to HQL function calls which will be run on the db
													side. This allows for example to retrieve the server time instead of the client time, or to generate
													UUIDs for each row instead of an unique one for all rows.

													The new pre-evaluation will likely be enabled by default in the next major version (6.0).
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="linqtohql.fallback_on_preevaluation">
											<xs:annotation>
												<xs:documentation>
													When the new pre-evaluation is enabled, should methods which translation is not supported by the current
													dialect fallback to pre-evaluation? false by default.

													When this fallback option is enabled while legacy pre-evaluation is disabled, properties or functions
													like DateTime.Now or Guid.NewGuid() used in Linq expressions will not fail when the dialect does not
													support them, but will instead be pre-evaluated.

													When this fallback option is disabled while legacy pre-evaluation is disabled, properties or functions
													like DateTime.Now or Guid.NewGuid() used in Linq expressions will fail when the dialect does not
													support them.

													This option has no effect if the legacy pre-evaluation is enabled.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="odbc.explicit_datetime_scale" />
										<xs:enumeration value="adonet.batch_versioned_data" />
										<xs:enumeration value="transaction.system_completion_lock_timeout">
											<xs:annotation>
												<xs:documentation>
													Timeout duration in milliseconds for the system transaction completion lock.

													When a system transaction completes, it may have its completion events running on concurrent threads,
													after scope disposal. This occurs when the transaction is distributed.
													This notably concerns ISessionImplementor.AfterTransactionCompletion(bool, ITransaction).
													NHibernate protects the session from being concurrently used by the code following the scope disposal
													with a lock. To prevent any application freeze, this lock has a default timeout of five seconds. If the
													application appears to require longer (!) running transaction completion events, this setting allows to
													raise this timeout. -1 disables the timeout.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="transaction.use_connection_on_system_prepare">
											<xs:annotation>
												<xs:documentation>
													When a system transaction is being prepared/prepared, is using connection during this process enabled?
													Default is true, for supporting FlushMode.Commit with transaction factories
													supporting system transactions. But this requires enlisting additional connections, retaining disposed
													sessions and their connections till transaction end, and may trigger undesired transaction promotions to
													distributed. Set to false for disabling using connections from system
													transaction preparation, while still benefiting from FlushMode.Auto on querying.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="transaction.auto_join">
											<xs:annotation>
												<xs:documentation>
													Should sessions check on every operation whether there is an ongoing system transaction or not, and enlist
													into it if any? Default is true. It can also be controlled at session opening, with
													ISessionFactory.WithOptions. A session can also be instructed to explicitly join the current
													transaction by calling ISession.JoinTransaction. This setting has no effect when using a
													transaction factory that is not system transactions aware.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="oracle.use_n_prefixed_types_for_unicode">
											<xs:annotation>
												<xs:documentation>
													Oracle has a dual Unicode support model.
													Either the whole database use an Unicode encoding, and then all string types
													will be Unicode. In such case, Unicode strings should be mapped to non N prefixed
													types, such as Varchar2. This is the default.
													Or N prefixed types such as NVarchar2 are to be used for Unicode strings.
													See https://docs.oracle.com/cd/B19306_01/server.102/b14225/ch6unicode.htm#CACHCAHF
													https://docs.oracle.com/database/121/ODPNT/featOraCommand.htm#i1007557
													This setting applies only to Oracle dialects and ODP.Net managed or unmanaged driver.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="oracle.use_binary_floating_point_types">
											<xs:annotation>
												<xs:documentation>
													Oracle 10g introduced BINARY_DOUBLE and BINARY_FLOAT types which are compatible with .NET
													double and float types, where FLOAT and DOUBLE are not. Oracle FLOAT and DOUBLE types do
													not conform to the IEEE standard as they are internally implemented as NUMBER type, which
													makes them an exact numeric type.
													False by default.
													See https://docs.oracle.com/database/121/TTSQL/types.htm#TTSQL126
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="oracle.suppress_decimal_invalid_cast_exception">
											<xs:annotation>
												<xs:documentation>
													This setting specifies whether to suppress the InvalidCastException and return a rounded-off
													28 precision value if the Oracle NUMBER value has more than 28 precision.
													False by default.
													See https://docs.oracle.com/en/database/oracle/oracle-data-access-components/19.3/odpnt/DataReaderSuppressGetDecimalInvalidCastException.html
													This setting works only with ODP.NET 19.10 or newer.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="firebird.disable_parameter_casting">
											<xs:annotation>
												<xs:documentation>
													Firebird with FirebirdSql.Data.FirebirdClient may be unable to determine the type
													of parameters in many circumstances, unless they are explicitly casted in the SQL
													query. To avoid this trouble, the NHibernate FirebirdClientDriver parses SQL
													commands for detecting parameters in them and adding an explicit SQL cast around
													parameters which may trigger the issue.
													For disabling this behavior, set this setting to true.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="sqlite.binaryguid">
											<xs:annotation>
												<xs:documentation>
													SQLite can store GUIDs in binary or text form, controlled by the BinaryGuid
													connection string parameter (default is 'true'). The BinaryGuid setting will affect
													how to cast GUID to string in SQL. NHibernate will attempt to detect this
													setting automatically from the connection string, but if the connection
													or connection string is being handled by the application instead of by NHibernate,
													you can use the 'sqlite.binaryguid' NHibernate setting to override the behavior.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="sql_types.keep_datetime">
											<xs:annotation>
												<xs:documentation>
													Disable switching built-in NHibernate date-time types from DbType.DateTime to DbType.DateTime2
													for dialects supporting datetime2.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="query.default_cast_length">
											<xs:annotation>
												<xs:documentation>
													Set the default length used in casting when the target type is length bound and
													does not specify it. 4000 by default, automatically trimmed down according to dialect type registration.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="query.default_cast_precision">
											<xs:annotation>
												<xs:documentation>
													Set the default precision used in casting when the target type is decimal and
													does not specify it. 29 by default, automatically trimmed down according to dialect type registration.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="query.default_cast_scale">
											<xs:annotation>
												<xs:documentation>
													Set the default scale used in casting when the target type is decimal and
													does not specify it. 10 by default, automatically trimmed down according to dialect type registration.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="track_session_id">
											<xs:annotation>
												<xs:documentation>
													Set whether tracking the session id or not. When true, each session will have an unique Guid
													that can be retrieved by ISessionImplementor.SessionId, otherwise ISessionImplementor.SessionId will
													always be Guid.Empty. Session id is used for logging purpose that can be also retrieved in a static
													context by SessionIdLoggingContext.SessionId, where the current session id is stored, when tracking
													is enabled. In case the current session id won't be used, it is recommended to disable it, in order
													to increase performance.
													True by default.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="multi_tenancy.strategy">
											<xs:annotation>
												<xs:documentation>
													Strategy for multi-tenancy. Supported Values: Database, None. Corresponds to MultiTenancyStrategy enum.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
										<xs:enumeration value="multi_tenancy.connection_provider">
											<xs:annotation>
												<xs:documentation>
													Connection provider for given multi-tenancy strategy. Class name implementing IMultiTenancyConnectionProvider.
												</xs:documentation>
											</xs:annotation>
										</xs:enumeration>
									</xs:restriction>
								</xs:simpleType>
								<xs:simpleType>
									<xs:restriction base="xs:string">
										<xs:pattern value="cache\.[\w._]+"/>
									</xs:restriction>
								</xs:simpleType>
							</xs:union>
						</xs:simpleType>
					</xs:attribute>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="session-factory">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="property" minOccurs="0" maxOccurs="unbounded" />
				<xs:element ref="mapping" minOccurs="0" maxOccurs="unbounded" />
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element ref="class-cache" />
					<xs:element ref="collection-cache" />
				</xs:choice>
				<xs:element ref="event" minOccurs="0" maxOccurs="unbounded" />
				<xs:element ref="listener" minOccurs="0" maxOccurs="unbounded" />
			</xs:sequence>
			<xs:attribute name="name" use="optional" />
		</xs:complexType>
	</xs:element>
	<xs:attributeGroup name="cacheSpecification">
		<xs:attribute name="region" type="xs:string" use="optional" />
		<xs:attribute name="usage" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="read-only" />
					<xs:enumeration value="read-write" />
					<xs:enumeration value="nonstrict-read-write" />
					<xs:enumeration value="transactional" />
					<xs:enumeration value="never" />
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:element name="event">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="listener" minOccurs="1" maxOccurs="unbounded" />
			</xs:sequence>
			<xs:attribute name="type" type="listenerType" use="required" />
		</xs:complexType>
	</xs:element>
	<xs:element name="listener">
		<xs:complexType>
			<xs:sequence />
			<xs:attribute name="class" type="xs:string" use="required" />
			<xs:attribute name="type" type="listenerType" use="optional" />
		</xs:complexType>
	</xs:element>
	<xs:simpleType name="listenerType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="auto-flush" />
			<xs:enumeration value="merge" />
			<xs:enumeration value="create" />
			<xs:enumeration value="create-onflush" />
			<xs:enumeration value="delete" />
			<xs:enumeration value="dirty-check" />
			<xs:enumeration value="evict" />
			<xs:enumeration value="flush" />
			<xs:enumeration value="flush-entity" />
			<xs:enumeration value="load" />
			<xs:enumeration value="load-collection" />
			<xs:enumeration value="lock" />
			<xs:enumeration value="refresh" />
			<xs:enumeration value="replicate" />
			<xs:enumeration value="save-update" />
			<xs:enumeration value="save" />
			<xs:enumeration value="pre-update" />
			<xs:enumeration value="update" />
			<xs:enumeration value="pre-load" />
			<xs:enumeration value="pre-delete" />
			<xs:enumeration value="pre-insert" />
			<xs:enumeration value="post-load" />
			<xs:enumeration value="post-insert" />
			<xs:enumeration value="post-update" />
			<xs:enumeration value="post-delete" />
			<xs:enumeration value="post-commit-update" />
			<xs:enumeration value="post-commit-insert" />
			<xs:enumeration value="post-commit-delete" />
			<xs:enumeration value="pre-collection-recreate" />
			<xs:enumeration value="pre-collection-remove" />
			<xs:enumeration value="pre-collection-update" />
			<xs:enumeration value="post-collection-recreate" />
			<xs:enumeration value="post-collection-remove" />
			<xs:enumeration value="post-collection-update" />
		</xs:restriction>
	</xs:simpleType>
	<xs:element name="bytecode-provider">
		<xs:complexType>
			<xs:sequence>
			</xs:sequence>
			<xs:attribute name="type" default="lcg">
				<xs:simpleType>
					<xs:union>
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:enumeration value="lcg" />
								<xs:enumeration value="null" />
							</xs:restriction>
						</xs:simpleType>
						<xs:simpleType>
							<xs:restriction base="xs:string" />
						</xs:simpleType>
					</xs:union>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="objects-factory">
		<xs:complexType>
			<xs:sequence />
			<xs:attribute name="type" type="xs:string" />
		</xs:complexType>
	</xs:element>
	<xs:element name="reflection-optimizer">
		<xs:complexType>
			<xs:sequence />
			<xs:attribute name="use" type="xs:boolean" />
		</xs:complexType>
	</xs:element>
</xs:schema>
