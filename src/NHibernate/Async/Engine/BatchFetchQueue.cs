//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System.Collections;
using NHibernate.Cache;
using NHibernate.Collection;
using NHibernate.Persister.Collection;
using NHibernate.Persister.Entity;
using NHibernate.Util;
using System.Collections.Generic;
using Iesi.Collections.Generic;

namespace NHibernate.Engine
{
	using System.Threading.Tasks;
	using System.Threading;
	public partial class BatchFetchQueue
	{

		/// <summary>
		/// Get a batch of uninitialized collection keys for a given role
		/// </summary>
		/// <param name="collectionPersister">The persister for the collection role.</param>
		/// <param name="id">A key that must be included in the batch fetch</param>
		/// <param name="batchSize">the maximum number of keys to return</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns>an array of collection keys, of length batchSize (padded with nulls)</returns>
		public async Task<object[]> GetCollectionBatchAsync(ICollectionPersister collectionPersister, object id, int batchSize, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			object[] keys = new object[batchSize];
			keys[0] = id;
			int i = 1;
			int end = -1;
			bool checkForEnd = false;

			if (batchLoadableCollections.TryGetValue(collectionPersister.Role, out var map))
			{
				foreach (KeyValuePair<CollectionEntry, IPersistentCollection> me in map)
				{
					var ce = me.Key;
					var collection = me.Value;
					if (ce.LoadedKey == null)
					{
						// the LoadedKey of the CollectionEntry might be null as it might have been reset to null
						// (see for example Collections.ProcessDereferencedCollection()
						// and CollectionEntry.AfterAction())
						// though we clear the queue on flush, it seems like a good idea to guard
						// against potentially null LoadedKey:s
						continue;
					}

					if (collection.WasInitialized)
					{
						log.Warn("Encountered initialized collection in BatchFetchQueue, this should not happen.");
						continue;
					}

					if (checkForEnd && i == end)
					{
						return keys; //the first key found after the given key
					}

					bool isEqual = collectionPersister.KeyType.IsEqual(id, ce.LoadedKey, collectionPersister.Factory);

					if (isEqual)
					{
						end = i;
						//checkForEnd = false;
					}
					else if (!await (IsCachedAsync(ce.LoadedKey, collectionPersister, cancellationToken)).ConfigureAwait(false))
					{
						keys[i++] = ce.LoadedKey;
						//count++;
					}

					if (i == batchSize)
					{
						i = 1; //end of array, start filling again from start
						if (end != -1)
						{
							checkForEnd = true;
						}
					}
				}
			}

			return keys; //we ran out of keys to try
		}

		/// <summary>
		/// Get a batch of unloaded identifiers for this class, using a slightly
		/// complex algorithm that tries to grab keys registered immediately after
		/// the given key.
		/// </summary>
		/// <param name="persister">The persister for the entities being loaded.</param>
		/// <param name="id">The identifier of the entity currently demanding load.</param>
		/// <param name="batchSize">The maximum number of keys to return</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns>an array of identifiers, of length batchSize (possibly padded with nulls)</returns>
		public async Task<object[]> GetEntityBatchAsync(IEntityPersister persister, object id, int batchSize, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			object[] ids = new object[batchSize];
			ids[0] = id; //first element of array is reserved for the actual instance we are loading!
			int i = 1;
			int end = -1;
			bool checkForEnd = false;

			if (batchLoadableEntityKeys.TryGetValue(persister.EntityName, out var set))
			{
				foreach (var key in set)
				{
					//TODO: this needn't exclude subclasses...
					if (checkForEnd && i == end)
					{
						//the first id found after the given id
						return ids;
					}
					if (persister.IdentifierType.IsEqual(id, key.Identifier))
					{
						end = i;
					}
					else
					{
						if (!await (IsCachedAsync(key, persister, cancellationToken)).ConfigureAwait(false))
						{
							ids[i++] = key.Identifier;
						}
					}
					if (i == batchSize)
					{
						i = 1; //end of array, start filling again from start
						if (end != -1)
							checkForEnd = true;
					}
				}
			}
			return ids; //we ran out of ids to try
		}

		private async Task<bool> IsCachedAsync(EntityKey entityKey, IEntityPersister persister, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (persister.HasCache && context.Session.CacheMode.HasFlag(CacheMode.Get))
			{
				CacheKey key = context.Session.GenerateCacheKey(entityKey.Identifier, persister.IdentifierType, entityKey.EntityName);
				return await (persister.Cache.Cache.GetAsync(key, cancellationToken)).ConfigureAwait(false) != null;
			}
			return false;
		}

		private async Task<bool> IsCachedAsync(object collectionKey, ICollectionPersister persister, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (persister.HasCache && context.Session.CacheMode.HasFlag(CacheMode.Get))
			{
				CacheKey cacheKey = context.Session.GenerateCacheKey(collectionKey, persister.KeyType, persister.Role);
				return await (persister.Cache.Cache.GetAsync(cacheKey, cancellationToken)).ConfigureAwait(false) != null;
			}
			return false;
		}
	}
}
