//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using NHibernate.AdoNet;
using NHibernate.Cache;
using NHibernate.Cache.Entry;
using NHibernate.Collection;
using NHibernate.Driver;
using NHibernate.Engine;
using NHibernate.Event;
using NHibernate.Exceptions;
using NHibernate.Hql.Util;
using NHibernate.Impl;
using NHibernate.Intercept;
using NHibernate.Param;
using NHibernate.Persister.Collection;
using NHibernate.Persister.Entity;
using NHibernate.Proxy;
using NHibernate.SqlCommand;
using NHibernate.Transform;
using NHibernate.Type;
using NHibernate.Util;

namespace NHibernate.Loader
{
	using System.Threading.Tasks;
	using System.Threading;
	public abstract partial class Loader
	{

		/// <summary>
		/// Execute an SQL query and attempt to instantiate instances of the class mapped by the given
		/// persister from each row of the <c>DataReader</c>. If an object is supplied, will attempt to
		/// initialize that object. If a collection is supplied, attempt to initialize that collection.
		/// </summary>
		private Task<IList> DoQueryAndInitializeNonLazyCollectionsAsync(ISessionImplementor session, QueryParameters queryParameters,
															 bool returnProxies, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<IList>(cancellationToken);
			}
			return DoQueryAndInitializeNonLazyCollectionsAsync(session, queryParameters, returnProxies, null, null, cancellationToken);
		}


		private async Task<IList> DoQueryAndInitializeNonLazyCollectionsAsync(ISessionImplementor session, QueryParameters queryParameters, bool returnProxies, 
		                                                     IResultTransformer forcedResultTransformer,
		                                                     QueryCacheResultBuilder queryCacheResultBuilder, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			IPersistenceContext persistenceContext = session.PersistenceContext;
			bool defaultReadOnlyOrig = persistenceContext.DefaultReadOnly;

			if (queryParameters.IsReadOnlyInitialized)
				persistenceContext.DefaultReadOnly = queryParameters.ReadOnly;
			else
				queryParameters.ReadOnly = persistenceContext.DefaultReadOnly;

			persistenceContext.BeforeLoad();
			IList result;
			try
			{
				try
				{
					result = await (DoQueryAsync(session, queryParameters, returnProxies, forcedResultTransformer, queryCacheResultBuilder, cancellationToken)).ConfigureAwait(false);
				}
				finally
				{
					persistenceContext.AfterLoad();
				}
				await (persistenceContext.InitializeNonLazyCollectionsAsync(cancellationToken)).ConfigureAwait(false);
			}
			finally
			{
				persistenceContext.DefaultReadOnly = defaultReadOnlyOrig;
			}

			return result;
		}

		/// <summary>
		/// Loads a single row from the result set.  This is the processing used from the
		/// ScrollableResults where no collection fetches were encountered.
		/// </summary>
		/// <param name="resultSet">The result set from which to do the load.</param>
		/// <param name="session">The session from which the request originated.</param>
		/// <param name="queryParameters">The query parameters specified by the user.</param>
		/// <param name="returnProxies">Should proxies be generated</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns>The loaded "row".</returns>
		/// <exception cref="HibernateException" />
		// Since v5.3
		[Obsolete("This method has no more usages and will be removed in a future version")]
		protected async Task<object> LoadSingleRowAsync(DbDataReader resultSet, ISessionImplementor session, QueryParameters queryParameters,
									   bool returnProxies, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			int entitySpan = EntityPersisters.Length;
			IList hydratedObjects = entitySpan == 0 ? null : new List<object>(entitySpan);
			var cacheBatcher = new CacheBatcher(session);

			object result;
			try
			{
				result =
					await (GetRowFromResultSetAsync(resultSet, session, queryParameters, GetLockModes(queryParameters.LockModes), null,
					                    hydratedObjects, new EntityKey[entitySpan], returnProxies, null, null,
					                    (persister, data) => cacheBatcher.AddToBatch(persister, data), cancellationToken)).ConfigureAwait(false);
			}
			catch (OperationCanceledException) { throw; }
			catch (HibernateException)
			{
				throw; // Don't call Convert on HibernateExceptions
			}
			catch (Exception sqle)
			{
				throw ADOExceptionHelper.Convert(Factory.SQLExceptionConverter, sqle, "could not read next row of results",
												 SqlString, queryParameters.PositionalParameterValues,
												 queryParameters.NamedParameters);
			}

			await (InitializeEntitiesAndCollectionsAsync(hydratedObjects, resultSet, session, queryParameters.IsReadOnly(session), cacheBatcher, cancellationToken)).ConfigureAwait(false);
			await (cacheBatcher.ExecuteBatchAsync(cancellationToken)).ConfigureAwait(false);
			await (session.PersistenceContext.InitializeNonLazyCollectionsAsync(cancellationToken)).ConfigureAwait(false);
			return result;
		}

		internal async Task<object> GetRowFromResultSetAsync(DbDataReader resultSet, ISessionImplementor session,
											QueryParameters queryParameters, LockMode[] lockModeArray,
											EntityKey optionalObjectKey, IList hydratedObjects, EntityKey[] keys,
											bool returnProxies, IResultTransformer forcedResultTransformer,
											QueryCacheResultBuilder queryCacheResultBuilder,
		                                    Action<IEntityPersister, CachePutData> cacheBatchingHandler, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			ILoadable[] persisters = EntityPersisters;
			int entitySpan = persisters.Length;

			for (int i = 0; i < entitySpan; i++)
			{
				keys[i] =
					await (GetKeyFromResultSetAsync(i, persisters[i], i == entitySpan - 1 ? queryParameters.OptionalId : null, resultSet, session, cancellationToken)).ConfigureAwait(false);
				//TODO: the i==entitySpan-1 bit depends upon subclass implementation (very bad)
			}

			RegisterNonExists(keys, session);

			// this call is side-effecty
			object[] row =
				await (GetRowAsync(resultSet, persisters, keys, queryParameters.OptionalObject, optionalObjectKey, lockModeArray,
					   hydratedObjects, session, !returnProxies, cacheBatchingHandler, cancellationToken)).ConfigureAwait(false);

			var collections = await (ReadCollectionElementsAsync(row, resultSet, session, cancellationToken)).ConfigureAwait(false);

			if (returnProxies)
			{
				// now get an existing proxy for each row element (if there is one)
				for (int i = 0; i < entitySpan; i++)
				{
					object entity = row[i];
					var key = keys[i];
					if (entity == null && key != null && IsChildFetchEntity(i))
					{
						// The entity was missing in the session, fallback on internal load (which will just yield a
						// proxy if the persister supports it).
						row[i] = await (session.InternalLoadAsync(key.EntityName, key.Identifier, false, false, cancellationToken)).ConfigureAwait(false);
					}
					else
					{
						object proxy = session.PersistenceContext.ProxyFor(persisters[i], keys[i], entity);

						if (entity != proxy)
						{
							// Force the proxy to resolve itself
							((INHibernateProxy) proxy).HibernateLazyInitializer.SetImplementation(entity);
							row[i] = proxy;
						}
					}
				}
			}

			var result = forcedResultTransformer == null
					   ? await (GetResultColumnOrRowAsync(row, queryParameters.ResultTransformer, resultSet, session, cancellationToken)).ConfigureAwait(false)
					   : forcedResultTransformer.TransformTuple(await (GetResultRowAsync(row, resultSet, session, cancellationToken)).ConfigureAwait(false),
																ResultRowAliases);

			queryCacheResultBuilder?.AddRow(result, row, collections);

			return result;
		}

		/// <summary>
		/// Read any collection elements contained in a single row of the result set
		/// </summary>
		private async Task<IPersistentCollection[]> ReadCollectionElementsAsync(object[] row, DbDataReader resultSet, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			//TODO: make this handle multiple collection roles!

			ICollectionPersister[] collectionPersisters = CollectionPersisters;

			if (collectionPersisters != null)
			{
				var result = new IPersistentCollection[collectionPersisters.Length];
				ICollectionAliases[] descriptors = CollectionAliases;
				int[] collectionOwners = CollectionOwners;

				for (int i = 0; i < collectionPersisters.Length; i++)
				{
					bool hasCollectionOwners = collectionOwners != null && collectionOwners[i] > -1;
					//true if this is a query and we are loading multiple instances of the same collection role
					//otherwise this is a CollectionInitializer and we are loading up a single collection or batch

					object owner = hasCollectionOwners ? row[collectionOwners[i]] : null;
					//if null, owner will be retrieved from session

					ICollectionPersister collectionPersister = collectionPersisters[i];
					object key;

					if (owner == null)
					{
						key = null;
					}
					else
					{
						key = await (collectionPersister.CollectionType.GetKeyOfOwnerAsync(owner, session, cancellationToken)).ConfigureAwait(false);
						//TODO: old version did not require hashmap lookup:
						//keys[collectionOwner].getIdentifier()
					}

					result[i] = await (ReadCollectionElementAsync(owner, key, collectionPersister, descriptors[i], resultSet, session, cancellationToken)).ConfigureAwait(false);
				}

				return result;
			}

			return null;
		}

		private async Task<IList> DoQueryAsync(ISessionImplementor session, QueryParameters queryParameters, bool returnProxies, 
		                      IResultTransformer forcedResultTransformer, QueryCacheResultBuilder queryCacheResultBuilder, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (session.BeginProcess())
			{
				RowSelection selection = queryParameters.RowSelection;
				int maxRows = HasMaxRows(selection) ? selection.MaxRows : int.MaxValue;

				int entitySpan = EntityPersisters.Length;

				List<object> hydratedObjects = entitySpan == 0 ? null : new List<object>(entitySpan*10);

				var st = await (PrepareQueryCommandAsync(queryParameters, false, session, cancellationToken)).ConfigureAwait(false);

				var rs = await (GetResultSetAsync(st, queryParameters, session, forcedResultTransformer, cancellationToken)).ConfigureAwait(false);
				// would be great to move all this below here into another method that could also be used
				// from the new scrolling stuff.
				//
				// Would need to change the way the max-row stuff is handled (i.e. behind an interface) so
				// that I could do the control breaking at the means to know when to stop
				LockMode[] lockModeArray = GetLockModes(queryParameters.LockModes);
				EntityKey optionalObjectKey = GetOptionalObjectKey(queryParameters, session);

				bool createSubselects = IsSubselectLoadingEnabled;
				List<EntityKey[]> subselectResultKeys = createSubselects ? new List<EntityKey[]>() : null;
				IList results = new List<object>();
				var cacheBatcher = new CacheBatcher(session);

				try
				{
					HandleEmptyCollections(queryParameters.CollectionKeys, rs, session);
					EntityKey[] keys = new EntityKey[entitySpan]; // we can reuse it each time

					if (Log.IsDebugEnabled())
					{
						Log.Debug("processing result set");
					}

					int count;
					for (count = 0; count < maxRows && await (rs.ReadAsync(cancellationToken)).ConfigureAwait(false); count++)
					{
						if (Log.IsDebugEnabled())
						{
							Log.Debug("result set row: {0}", count);
						}

						object result = await (GetRowFromResultSetAsync(rs, session, queryParameters, lockModeArray, optionalObjectKey,
															hydratedObjects,
															keys, returnProxies, forcedResultTransformer, queryCacheResultBuilder,
						                                    (persister, data) => cacheBatcher.AddToBatch(persister, data), cancellationToken)).ConfigureAwait(false);
						results.Add(result);

						if (createSubselects)
						{
							subselectResultKeys.Add(keys);
							keys = new EntityKey[entitySpan]; //can't reuse in this case
						}
					}

					if (Log.IsDebugEnabled())
					{
						Log.Debug("done processing result set ({0} rows)", count);
					}
				}
				catch (OperationCanceledException) { throw; }
				catch (Exception e)
				{
					e.Data["actual-sql-query"] = st.CommandText;
					throw;
				}
				finally
				{
					session.Batcher.CloseCommand(st, rs);
				}

				await (InitializeEntitiesAndCollectionsAsync(hydratedObjects, rs, session, queryParameters.IsReadOnly(session), cacheBatcher, cancellationToken)).ConfigureAwait(false);
				await (cacheBatcher.ExecuteBatchAsync(cancellationToken)).ConfigureAwait(false);

				if (createSubselects)
				{
					CreateSubselects(subselectResultKeys, queryParameters, session);
				}

				return results;
			}
		}

		internal async Task InitializeEntitiesAndCollectionsAsync(
			IList hydratedObjects, DbDataReader reader, ISessionImplementor session, bool readOnly,
			CacheBatcher cacheBatcher, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			ICollectionPersister[] collectionPersisters = CollectionPersisters;
			var ownCacheBatcher = cacheBatcher == null;
			if (ownCacheBatcher)
				cacheBatcher = new CacheBatcher(session);

			if (collectionPersisters != null)
			{
				foreach (var collectionPersister in collectionPersisters)
				{
					if (collectionPersister.IsArray)
					{
						//for arrays, we should end the collection load before resolving
						//the entities, since the actual array instances are not instantiated
						//during loading
						//TODO: or we could do this polymorphically, and have two
						//      different operations implemented differently for arrays
						await (EndCollectionLoadAsync(reader, session, collectionPersister, cacheBatcher, cancellationToken)).ConfigureAwait(false);
					}
				}
			}
			//important: reuse the same event instances for performance!
			PreLoadEvent pre;
			PostLoadEvent post;
			if (session.IsEventSource)
			{
				var eventSourceSession = (IEventSource)session;
				pre = new PreLoadEvent(eventSourceSession);
				post = new PostLoadEvent(eventSourceSession);
			}
			else
			{
				pre = null;
				post = null;
			}

			if (hydratedObjects != null)
			{
				int hydratedObjectsSize = hydratedObjects.Count;

				if (Log.IsDebugEnabled())
				{
					Log.Debug("total objects hydrated: {0}", hydratedObjectsSize);
				}

				for (int i = 0; i < hydratedObjectsSize; i++)
				{
					await (TwoPhaseLoad.InitializeEntityAsync(
						hydratedObjects[i], readOnly, session, pre, post,
						(persister, data) => cacheBatcher.AddToBatch(persister, data), cancellationToken)).ConfigureAwait(false);
				}
			}

			if (collectionPersisters != null)
			{
				foreach (var collectionPersister in collectionPersisters)
				{
					if (!collectionPersister.IsArray)
					{
						//for sets, we should end the collection load after resolving
						//the entities, since we might call hashCode() on the elements
						//TODO: or we could do this polymorphically, and have two
						//      different operations implemented differently for arrays
						await (EndCollectionLoadAsync(reader, session, collectionPersister, cacheBatcher, cancellationToken)).ConfigureAwait(false);
					}
				}
			}

			if (ownCacheBatcher)
				await (cacheBatcher.ExecuteBatchAsync(cancellationToken)).ConfigureAwait(false);
		}

		private Task EndCollectionLoadAsync(DbDataReader reader, ISessionImplementor session, ICollectionPersister collectionPersister,
		                               CacheBatcher cacheBatcher, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				//this is a query and we are loading multiple instances of the same collection role
				return session.PersistenceContext.LoadContexts.GetCollectionLoadContext(reader).EndLoadingCollectionsAsync(
				collectionPersister, !IsCollectionPersisterCacheable(collectionPersister), cacheBatcher, cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}


		/// <summary>
		/// Get the actual object that is returned in the user-visible result list.
		/// </summary>
		/// <remarks>
		/// This empty implementation merely returns its first argument. This is
		/// overridden by some subclasses.
		/// </remarks>
		protected virtual Task<object> GetResultColumnOrRowAsync(object[] row, IResultTransformer resultTransformer, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				return Task.FromResult<object>(GetResultColumnOrRow(row, resultTransformer, rs, session));
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		protected virtual Task<object[]> GetResultRowAsync(Object[] row, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object[]>(cancellationToken);
			}
			try
			{
				return Task.FromResult<object[]>(GetResultRow(row, rs, session));
			}
			catch (Exception ex)
			{
				return Task.FromException<object[]>(ex);
			}
		}

		/// <summary>
		/// Read one collection element from the current row of the ADO.NET result set
		/// </summary>
		private static async Task<IPersistentCollection> ReadCollectionElementAsync(object optionalOwner, object optionalKey, ICollectionPersister persister,
												  ICollectionAliases descriptor, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			IPersistenceContext persistenceContext = session.PersistenceContext;

			object collectionRowKey = await (persister.ReadKeyAsync(rs, descriptor.SuffixedKeyAliases, session, cancellationToken)).ConfigureAwait(false);

			if (collectionRowKey != null)
			{
				// we found a collection element in the result set

				if (Log.IsDebugEnabled())
				{
					Log.Debug("found row of collection: {0}", MessageHelper.CollectionInfoString(persister, collectionRowKey));
				}

				object owner = optionalOwner;
				if (owner == null)
				{
					owner = persistenceContext.GetCollectionOwner(collectionRowKey, persister);
					if (owner == null)
					{
						//TODO: This is assertion is disabled because there is a bug that means the
						//      original owner of a transient, uninitialized collection is not known 
						//      if the collection is re-referenced by a different object associated 
						//      with the current Session
						//throw new AssertionFailure("bug loading unowned collection");
					}
				}
				IPersistentCollection rowCollection =
					persistenceContext.LoadContexts.GetCollectionLoadContext(rs).GetLoadingCollection(persister, collectionRowKey);

				if (rowCollection != null)
				{
					await (rowCollection.ReadFromAsync(rs, persister, descriptor, owner, cancellationToken)).ConfigureAwait(false);
				}

				return rowCollection;
			}
			else if (optionalKey != null)
			{
				// we did not find a collection element in the result set, so we
				// ensure that a collection is created with the owner's identifier,
				// since what we have is an empty collection

				if (Log.IsDebugEnabled())
				{
					Log.Debug("result set contains (possibly empty) collection: {0}", MessageHelper.CollectionInfoString(persister, optionalKey));
				}

				// handle empty collection
				return persistenceContext.LoadContexts.GetCollectionLoadContext(rs).GetLoadingCollection(persister, optionalKey);
			}

			// else no collection element, but also no owner
			return null;
		}

		/// <summary>
		/// Read a row of <c>EntityKey</c>s from the <c>DbDataReader</c> into the given array.
		/// </summary>
		/// <remarks>
		/// Warning: this method is side-effecty. If an <c>id</c> is given, don't bother going
		/// to the <c>DbDataReader</c>
		/// </remarks>
		private async Task<EntityKey> GetKeyFromResultSetAsync(int i, IEntityPersister persister, object id, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			object resultId;

			// if we know there is exactly 1 row, we can skip.
			// it would be great if we could _always_ skip this;
			// it is a problem for <key-many-to-one>

			if (IsSingleRowLoader && id != null)
			{
				resultId = id;
			}
			else
			{
				IType idType = persister.IdentifierType;
				resultId = await (idType.NullSafeGetAsync(rs, EntityAliases[i].SuffixedKeyAliases, session, null, cancellationToken)).ConfigureAwait(false);

				bool idIsResultId = id != null && resultId != null && idType.IsEqual(id, resultId, _factory);

				if (idIsResultId)
				{
					resultId = id; //use the id passed in
				}
			}

			return resultId == null ? null : session.GenerateEntityKey(resultId, persister);
		}

		/// <summary>
		/// Check the version of the object in the <c>DbDataReader</c> against
		/// the object version in the session cache, throwing an exception
		/// if the version numbers are different.
		/// </summary>
		/// <exception cref="StaleObjectStateException"></exception>
		private async Task CheckVersionAsync(int i, IEntityPersister persister, object id, object entity, DbDataReader rs, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			object version = session.PersistenceContext.GetEntry(entity).Version;

			// null version means the object is in the process of being loaded somewhere else in the ResultSet
			if (version != null)
			{
				IVersionType versionType = persister.VersionType;
				object currentVersion = await (versionType.NullSafeGetAsync(rs, EntityAliases[i].SuffixedVersionAliases, session, null, cancellationToken)).ConfigureAwait(false);
				if (!versionType.IsEqual(version, currentVersion))
				{
					if (session.Factory.Statistics.IsStatisticsEnabled)
					{
						session.Factory.StatisticsImplementor.OptimisticFailure(persister.EntityName);
					}

					throw new StaleObjectStateException(persister.EntityName, id);
				}
			}
		}

		/// <summary>
		/// Resolve any ids for currently loaded objects, duplications within the <c>DbDataReader</c>,
		/// etc. Instantiate empty objects to be initialized from the <c>DbDataReader</c>. Return an
		/// array of objects (a row of results) and an array of booleans (by side-effect) that determine
		/// whether the corresponding object should be initialized
		/// </summary>
		private async Task<object[]> GetRowAsync(DbDataReader rs, ILoadable[] persisters, EntityKey[] keys, object optionalObject,
								EntityKey optionalObjectKey, LockMode[] lockModes, IList hydratedObjects,
								ISessionImplementor session, bool mustLoadMissingEntity, Action<IEntityPersister, CachePutData> cacheBatchingHandler, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			int cols = persisters.Length;

			if (Log.IsDebugEnabled())
			{
				Log.Debug("result row: {0}", StringHelper.ToString(keys));
			}

			object[] rowResults = new object[cols];

			for (int i = 0; i < cols; i++)
			{
				object obj = null;
				EntityKey key = keys[i];

				// null keys are handled in RegisterNonExists
				if(key != null)
				{
					//If the object is already loaded, return the loaded one
					obj = await (session.GetEntityUsingInterceptorAsync(key, cancellationToken)).ConfigureAwait(false);
					var alreadyLoaded = obj != null;
					var persister = persisters[i];
					if (IsChildFetchEntity(i))
					{
						if (!alreadyLoaded && mustLoadMissingEntity)
						{
							// Missing in session while its data has not been selected: fallback on immediate load
							obj = await (session.ImmediateLoadAsync(key.EntityName, key.Identifier, cancellationToken)).ConfigureAwait(false);
						}
						rowResults[i] = obj;
						continue;
					}

					if (alreadyLoaded)
					{
						//its already loaded so dont need to hydrate it
						await (InstanceAlreadyLoadedAsync(rs, i, persister, key, obj, lockModes[i], session, cacheBatchingHandler, cancellationToken)).ConfigureAwait(false);
					}
					else
					{
						obj =
							await (InstanceNotYetLoadedAsync(rs, i, persister, key, lockModes[i], optionalObjectKey,
												 optionalObject, hydratedObjects, session, cancellationToken)).ConfigureAwait(false);

						// IUniqueKeyLoadable.CacheByUniqueKeys caches all unique keys of the entity, regardless of
						// associations loaded by the query. So if the entity is already loaded, it has forcibly already
						// been cached too for all its unique keys, provided its persister implement it. With this new
						// way of caching unique keys, it is no more needed to handle caching for alreadyLoaded path
						// too.
						var cacheByUniqueKeysTask = (persister as IUniqueKeyLoadable)?.CacheByUniqueKeysAsync(obj, session, cancellationToken);

						// IUniqueKeyLoadable.CacheByUniqueKeys caches all unique keys of the entity, regardless of
						// associations loaded by the query. So if the entity is already loaded, it has forcibly already
						// been cached too for all its unique keys, provided its persister implement it. With this new
						// way of caching unique keys, it is no more needed to handle caching for alreadyLoaded path
						// too.
						if (cacheByUniqueKeysTask != null)

						// IUniqueKeyLoadable.CacheByUniqueKeys caches all unique keys of the entity, regardless of
						// associations loaded by the query. So if the entity is already loaded, it has forcibly already
						// been cached too for all its unique keys, provided its persister implement it. With this new
						// way of caching unique keys, it is no more needed to handle caching for alreadyLoaded path
						// too.
						{

							// IUniqueKeyLoadable.CacheByUniqueKeys caches all unique keys of the entity, regardless of
							// associations loaded by the query. So if the entity is already loaded, it has forcibly already
							// been cached too for all its unique keys, provided its persister implement it. With this new
							// way of caching unique keys, it is no more needed to handle caching for alreadyLoaded path
							// too.
							await (cacheByUniqueKeysTask).ConfigureAwait(false);

						// IUniqueKeyLoadable.CacheByUniqueKeys caches all unique keys of the entity, regardless of
						// associations loaded by the query. So if the entity is already loaded, it has forcibly already
						// been cached too for all its unique keys, provided its persister implement it. With this new
						// way of caching unique keys, it is no more needed to handle caching for alreadyLoaded path
						// too.
						}
					}
					// 6.0 TODO: this call is nor more needed for up-to-date persisters, remove once CacheByUniqueKeys
					// is merged in IUniqueKeyLoadable interface instead of being an extension method
					// #1226 old fix: Even if it is already loaded, if it can be loaded from an association with a property ref,
					// make sure it is also cached by its unique key.
					CacheByUniqueKey(i, persister, obj, session, alreadyLoaded);
				}

				rowResults[i] = obj;
			}
			return rowResults;
		}

		/// <summary>
		/// The entity instance is already in the session cache
		/// </summary>
		private async Task InstanceAlreadyLoadedAsync(DbDataReader rs, int i, ILoadable persister, EntityKey key, object obj,
										   LockMode lockMode, ISessionImplementor session, Action<IEntityPersister, CachePutData> cacheBatchingHandler, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (!persister.IsInstance(obj))
			{
				string errorMsg = string.Format("loading object was of wrong class [{0}]", obj.GetType().FullName);
				throw new WrongClassException(errorMsg, key.Identifier, persister.EntityName);
			}

			EntityEntry entry = null;
			if (LockMode.None != lockMode && UpgradeLocks())
			{
				entry = session.PersistenceContext.GetEntry(obj);
				bool isVersionCheckNeeded = persister.IsVersioned && entry.LockMode.LessThan(lockMode);

				// we don't need to worry about existing version being uninitialized
				// because this block isn't called by a re-entrant load (re-entrant
				// load _always_ have lock mode NONE
				if (isVersionCheckNeeded)
				{
					// we only check the version when _upgrading_ lock modes
					await (CheckVersionAsync(i, persister, key.Identifier, obj, rs, session, cancellationToken)).ConfigureAwait(false);
					// we need to upgrade the lock mode to the mode requested
					entry.LockMode = lockMode;
				}
			}

			if (!persister.HasLazyProperties)
			{
				return;
			}

			var instanceClass = await (GetInstanceClassAsync(rs, i, persister, key.Identifier, session, cancellationToken)).ConfigureAwait(false);
			entry = entry ?? session.PersistenceContext.GetEntry(obj);
			await (UpdateLazyPropertiesFromResultSetAsync(rs, i, obj, instanceClass, key, entry, persister, session, cacheBatchingHandler, cancellationToken)).ConfigureAwait(false);
		}

		/// <summary>
		/// The entity instance is not in the session cache
		/// </summary>
		private async Task<object> InstanceNotYetLoadedAsync(DbDataReader dr, int i, ILoadable persister, EntityKey key, LockMode lockMode,
											EntityKey optionalObjectKey, object optionalObject,
											IList hydratedObjects, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			object obj;

			string instanceClass = await (GetInstanceClassAsync(dr, i, persister, key.Identifier, session, cancellationToken)).ConfigureAwait(false);

			if (optionalObjectKey != null && key.Equals(optionalObjectKey))
			{
				// its the given optional object
				obj = optionalObject;
			}
			else
			{
				obj = session.Instantiate(instanceClass, key.Identifier);
			}

			// need to hydrate it

			// grab its state from the DataReader and keep it in the Session
			// (but don't yet initialize the object itself)
			// note that we acquired LockMode.READ even if it was not requested
			LockMode acquiredLockMode = lockMode == LockMode.None ? LockMode.Read : lockMode;
			await (LoadFromResultSetAsync(dr, i, obj, instanceClass, key, acquiredLockMode, persister, session, cancellationToken)).ConfigureAwait(false);

			// materialize associations (and initialize the object) later
			hydratedObjects.Add(obj);

			return obj;
		}

		private async Task UpdateLazyPropertiesFromResultSetAsync(DbDataReader rs, int i, object obj, string instanceClass, EntityKey key,
		                                               EntityEntry entry, ILoadable rootPersister, ISessionImplementor session,
		                                               Action<IEntityPersister, CachePutData> cacheBatchingHandler, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			var fetchAllProperties = IsEagerPropertyFetchEnabled(i);
			var fetchLazyProperties = GetFetchLazyProperties(i);

			if (!fetchAllProperties && fetchLazyProperties == null)
			{
				return; // No lazy properties were loaded
			}

			// Get the persister for the _subclass_
			var persister = instanceClass == rootPersister.EntityName
				? rootPersister
				: (ILoadable) Factory.GetEntityPersister(instanceClass);

			// The property values will not be set when the entry status is Loading so in that case we have to get
			// the uninitialized lazy properties from the loaded state
			var uninitializedProperties = entry.Status == Status.Loading
				? persister.EntityMetamodel.BytecodeEnhancementMetadata.GetUninitializedLazyProperties(entry.LoadedState)
				: persister.EntityMetamodel.BytecodeEnhancementMetadata.GetUninitializedLazyProperties(obj);

			var updateLazyProperties = fetchLazyProperties?.Intersect(uninitializedProperties).ToArray();
			if (updateLazyProperties?.Length == 0)
			{
				return; // No new lazy properites were loaded
			}

			var id = key.Identifier;

			if (Log.IsDebugEnabled())
			{
				Log.Debug("Updating lazy properites from DataReader: {0}", MessageHelper.InfoString(persister, id));
			}

			var cols = persister == rootPersister
				? EntityAliases[i].SuffixedPropertyAliases
				: GetSubclassEntityAliases(i, persister);

			if (!await (persister.InitializeLazyPropertiesAsync(rs, id, obj, rootPersister, cols, updateLazyProperties, fetchAllProperties, session, cancellationToken)).ConfigureAwait(false))
			{
				return;
			}

			await (UpdateCacheForEntityAsync(obj, id, entry, persister, session, cacheBatchingHandler, cancellationToken)).ConfigureAwait(false);
		}

		internal static async Task UpdateCacheForEntityAsync(
			object obj, object id, EntityEntry entry, IEntityPersister persister, ISessionImplementor session,
			Action<IEntityPersister, CachePutData> cacheBatchingHandler, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (entry.Status == Status.Loading || !persister.HasCache ||
			    !session.CacheMode.HasFlag(CacheMode.Put) || !persister.IsLazyPropertiesCacheable)
			{
				return;
			}

			if (Log.IsDebugEnabled())
			{
				Log.Debug("Updating entity to second-level cache: {0}", MessageHelper.InfoString(persister, id, session.Factory));
			}

			var factory = session.Factory;
			var state = persister.GetPropertyValues(obj);
			var version = Versioning.GetVersion(state, persister);
			var cacheEntry = await (CacheEntry.CreateAsync(state, persister, version, session, obj, cancellationToken)).ConfigureAwait(false);
			var cacheKey = session.GenerateCacheKey(id, persister.IdentifierType, persister.RootEntityName);

			if (cacheBatchingHandler != null && persister.IsBatchLoadable)
			{
				cacheBatchingHandler(
					persister,
					new CachePutData(
						cacheKey,
						persister.CacheEntryStructure.Structure(cacheEntry),
						version,
						persister.IsVersioned ? persister.VersionType.Comparator : null,
						false));
			}
			else
			{
				var put =
					await (persister.Cache.PutAsync(cacheKey, persister.CacheEntryStructure.Structure(cacheEntry), session.Timestamp, version,
										persister.IsVersioned ? persister.VersionType.Comparator : null,
										false, cancellationToken)).ConfigureAwait(false);

				if (put && factory.Statistics.IsStatisticsEnabled)
				{
					factory.StatisticsImplementor.SecondLevelCachePut(persister.Cache.RegionName);
				}
			}
		}

		/// <summary>
		/// Hydrate the state of an object from the SQL <c>DbDataReader</c>, into
		/// an array of "hydrated" values (do not resolve associations yet),
		/// and pass the hydrated state to the session.
		/// </summary>
		private async Task LoadFromResultSetAsync(DbDataReader rs, int i, object obj, string instanceClass, EntityKey key,
									   LockMode lockMode, ILoadable rootPersister,
									   ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			object id = key.Identifier;

			// Get the persister for the _subclass_
			ILoadable persister = instanceClass == rootPersister.EntityName
				? rootPersister
				: (ILoadable) Factory.GetEntityPersister(instanceClass);

			if (Log.IsDebugEnabled())
			{
				Log.Debug("Initializing object from DataReader: {0}", MessageHelper.InfoString(persister, id));
			}

			bool fetchAllProperties = IsEagerPropertyFetchEnabled(i);
			var eagerFetchProperties = GetFetchLazyProperties(i);

			// add temp entry so that the next step is circular-reference
			// safe - only needed because some types don't take proper
			// advantage of two-phase-load (esp. components)
			TwoPhaseLoad.AddUninitializedEntity(key, obj, persister, lockMode, session);

			string[][] cols = persister == rootPersister
								? EntityAliases[i].SuffixedPropertyAliases
								: GetSubclassEntityAliases(i, persister);

			object[] values = await (persister.HydrateAsync(rs, id, obj, cols, eagerFetchProperties, fetchAllProperties, session, cancellationToken)).ConfigureAwait(false);

			object rowId = persister.HasRowId ? rs[EntityAliases[i].RowIdAlias] : null;

			TwoPhaseLoad.PostHydrate(persister, id, values, rowId, obj, lockMode, session);
		}

		/// <summary>
		/// Determine the concrete class of an instance for the <c>DbDataReader</c>
		/// </summary>
		private async Task<string> GetInstanceClassAsync(DbDataReader rs, int i, ILoadable persister, object id, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (persister.HasSubclasses)
			{
				// code to handle subclasses of topClass
				object discriminatorValue =
					await (persister.DiscriminatorType.NullSafeGetAsync(rs, EntityAliases[i].SuffixedDiscriminatorAlias, session, null, cancellationToken)).ConfigureAwait(false);

				string result = persister.GetSubclassForDiscriminatorValue(discriminatorValue);

				if (result == null)
				{
					// woops we got an instance of another class hierarchy branch.
					throw new WrongClassException(string.Format("Discriminator was: '{0}'", discriminatorValue), id,
												  persister.EntityName);
				}

				return result;
			}
			return persister.EntityName;
		}

		/// <summary>
		/// Advance the cursor to the first required row of the <c>DbDataReader</c>
		/// </summary>
		internal static async Task AdvanceAsync(DbDataReader rs, RowSelection selection, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			int firstRow = GetFirstRow(selection);

			if (firstRow != 0)
			{
				// DataReaders are forward-only, readonly, so we have to step through
				for (int i = 0; i < firstRow; i++)
				{
					await (rs.ReadAsync(cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		/// <summary>
		/// Obtain an <c>DbCommand</c> with all parameters pre-bound. Bind positional parameters,
		/// named parameters, and limit parameters.
		/// </summary>
		/// <remarks>
		/// Creates an DbCommand object and populates it with the values necessary to execute it against the 
		/// database to Load an Entity.
		/// </remarks>
		/// <param name="queryParameters">The <see cref="QueryParameters"/> to use for the DbCommand.</param>
		/// <param name="scroll">TODO: find out where this is used...</param>
		/// <param name="session">The SessionImpl this Command is being prepared in.</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns>A CommandWrapper wrapping an DbCommand that is ready to be executed.</returns>
		protected internal virtual async Task<DbCommand> PrepareQueryCommandAsync(QueryParameters queryParameters, bool scroll, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			ISqlCommand sqlCommand = CreateSqlCommand(queryParameters, session);
			SqlString sqlString = sqlCommand.Query;

			sqlCommand.ResetParametersIndexesForTheCommand(0);
			var command = session.Batcher.PrepareQueryCommand(CommandType.Text, sqlString, sqlCommand.ParameterTypes);

			try
			{
				RowSelection selection = queryParameters.RowSelection;
				if (selection != null && selection.Timeout != RowSelection.NoValue)
				{
					command.CommandTimeout = selection.Timeout;
				}

				await (sqlCommand.BindAsync(command, session, cancellationToken)).ConfigureAwait(false);

				IDriver driver = _factory.ConnectionProvider.Driver;
				driver.RemoveUnusedCommandParameters(command, sqlString);
				driver.ExpandQueryParameters(command, sqlString, sqlCommand.ParameterTypes);
			}
			catch (OperationCanceledException) { throw; }
			catch (HibernateException)
			{
				session.Batcher.CloseCommand(command, null);
				throw;
			}
			catch (Exception sqle)
			{
				session.Batcher.CloseCommand(command, null);
				ADOExceptionReporter.LogExceptions(sqle);
				throw;
			}
			return command;
		}

		/// <summary>
		/// Fetch a <c>DbCommand</c>, call <c>SetMaxRows</c> and then execute it,
		/// advance to the first result and return an SQL <c>DbDataReader</c>
		/// </summary>
		/// <param name="st">The <see cref="DbCommand" /> to execute.</param>
		/// <param name="selection">The <see cref="RowSelection"/> to apply to the <see cref="DbCommand"/> and <see cref="DbDataReader"/>.</param>
		/// <param name="autoDiscoverTypes">true if result types need to be auto-discovered by the loader; false otherwise.</param>
		/// <param name="session">The <see cref="ISession" /> to load in.</param>
		/// <param name="callable"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns>An DbDataReader advanced to the first record in RowSelection.</returns>
		// Since v5.1
		[Obsolete("Please use overload with a QueryParameter parameter.")]
		protected Task<DbDataReader> GetResultSetAsync(DbCommand st, bool autoDiscoverTypes, bool callable, RowSelection selection, ISessionImplementor session, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<DbDataReader>(cancellationToken);
			}
			return GetResultSetAsync(
				st,
				new QueryParameters
				{
					HasAutoDiscoverScalarTypes = autoDiscoverTypes, Callable = callable, RowSelection = selection
				},
				session,
				null, cancellationToken);
		}

		/// <summary>
		/// Fetch a <c>DbCommand</c>, call <c>SetMaxRows</c> and then execute it,
		/// advance to the first result and return an SQL <c>DbDataReader</c>
		/// </summary>
		/// <param name="st">The <see cref="DbCommand" /> to execute.</param>
		/// <param name="queryParameters">The <see cref="QueryParameters"/>.</param>
		/// <param name="session">The <see cref="ISession" /> to load in.</param>
		/// <param name="forcedResultTransformer">The forced result transformer for the query.</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns>A DbDataReader advanced to the first record in RowSelection.</returns>
		protected async Task<DbDataReader> GetResultSetAsync(
			DbCommand st, QueryParameters queryParameters, ISessionImplementor session, IResultTransformer forcedResultTransformer, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			DbDataReader rs = null;
			try
			{
				// TODO NH: Callable
				rs = await (session.Batcher.ExecuteReaderAsync(st, cancellationToken)).ConfigureAwait(false);

				//NH: this is checked outside the WrapResultSet because we
				// want to avoid the syncronization overhead in the vast majority
				// of cases where IsWrapResultSetsEnabled is set to false
				if (session.Factory.Settings.IsWrapResultSetsEnabled)
					rs = WrapResultSet(rs);

				Dialect.Dialect dialect = session.Factory.Dialect;
				if (!dialect.SupportsLimitOffset || !UseLimit(queryParameters.RowSelection, dialect))
				{
					await (AdvanceAsync(rs, queryParameters.RowSelection, cancellationToken)).ConfigureAwait(false);
				}

				if (queryParameters.HasAutoDiscoverScalarTypes)
				{
					AutoDiscoverTypes(rs, queryParameters, forcedResultTransformer);
				}
				return rs;
			}
			catch (OperationCanceledException) { throw; }
			catch (Exception sqle)
			{
				ADOExceptionReporter.LogExceptions(sqle);
				session.Batcher.CloseCommand(st, rs);
				throw;
			}
		}

		/// <summary>
		/// Called by subclasses that load entities
		/// </summary>
		protected async Task<IList> LoadEntityAsync(ISessionImplementor session, object id, IType identifierType, object optionalObject,
								   string optionalEntityName, object optionalIdentifier, IEntityPersister persister, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (Log.IsDebugEnabled())
			{
				Log.Debug("loading entity: {0}", MessageHelper.InfoString(persister, id, identifierType, Factory));
			}

			IList result;

			try
			{
				QueryParameters qp =
					new QueryParameters(new IType[] { identifierType }, new object[] { id }, optionalObject, optionalEntityName,
										optionalIdentifier);
				result = await (DoQueryAndInitializeNonLazyCollectionsAsync(session, qp, false, cancellationToken)).ConfigureAwait(false);
			}
			catch (OperationCanceledException) { throw; }
			catch (HibernateException)
			{
				throw;
			}
			catch (Exception sqle)
			{
				ILoadable[] persisters = EntityPersisters;
				throw ADOExceptionHelper.Convert(Factory.SQLExceptionConverter, sqle,
												 "could not load an entity: "
												 +
												 MessageHelper.InfoString(persisters[persisters.Length - 1], id, identifierType,
																		  Factory), SqlString);
			}

			Log.Debug("done entity load");

			return result;
		}

		protected async Task<IList> LoadEntityAsync(ISessionImplementor session, object key, object index, IType keyType, IType indexType,
								   IEntityPersister persister, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			Log.Debug("loading collection element by index");

			IList result;
			try
			{
				result =
					await (DoQueryAndInitializeNonLazyCollectionsAsync(session,
														   new QueryParameters(new IType[] { keyType, indexType },
																			   new object[] { key, index }), false, cancellationToken)).ConfigureAwait(false);
			}
			catch (OperationCanceledException) { throw; }
			catch (Exception sqle)
			{
				throw ADOExceptionHelper.Convert(_factory.SQLExceptionConverter, sqle, "could not collection element by index",
												 SqlString);
			}

			Log.Debug("done entity load");

			return result;
		}

		/// <summary>
		/// Called by subclasses that batch load entities
		/// </summary>
		protected internal async Task<IList> LoadEntityBatchAsync(ISessionImplementor session, object[] ids, IType idType,
												 object optionalObject, string optionalEntityName, object optionalId,
												 IEntityPersister persister, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (Log.IsDebugEnabled())
			{
				Log.Debug("batch loading entity: {0}", MessageHelper.InfoString(persister, ids, Factory));
			}

			IType[] types = new IType[ids.Length];
			ArrayHelper.Fill(types, idType);
			IList result;
			try
			{
				result =
					await (DoQueryAndInitializeNonLazyCollectionsAsync(session,
														   new QueryParameters(types, ids, optionalObject, optionalEntityName,
																			   optionalId), false, cancellationToken)).ConfigureAwait(false);
			}
			catch (OperationCanceledException) { throw; }
			catch (HibernateException)
			{
				throw;
			}
			catch (Exception sqle)
			{
				throw ADOExceptionHelper.Convert(Factory.SQLExceptionConverter, sqle,
												 "could not load an entity batch: "
												 + MessageHelper.InfoString(persister, ids, Factory), SqlString);
				// NH: Hibernate3 passes EntityPersisters[0] instead of persister, I think it's wrong.
			}

			Log.Debug("done entity batch load");
			return result;
		}

		/// <summary>
		/// Called by subclasses that load collections
		/// </summary>
		public async Task LoadCollectionAsync(ISessionImplementor session, object id, IType type, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (Log.IsDebugEnabled())
			{
				Log.Debug("loading collection: {0}", MessageHelper.CollectionInfoString(CollectionPersisters[0], id));
			}

			object[] ids = new object[] { id };
			try
			{
				await (DoQueryAndInitializeNonLazyCollectionsAsync(session, new QueryParameters(new IType[] { type }, ids, ids), true, cancellationToken)).ConfigureAwait(false);
			}
			catch (OperationCanceledException) { throw; }
			catch (HibernateException)
			{
				// Do not call Convert on HibernateExceptions
				throw;
			}
			catch (Exception sqle)
			{
				throw ADOExceptionHelper.Convert(Factory.SQLExceptionConverter, sqle,
												 "could not initialize a collection: "
												 + MessageHelper.CollectionInfoString(CollectionPersisters[0], id), SqlString);
			}

			Log.Debug("done loading collection");
		}

		/// <summary>
		/// Called by wrappers that batch initialize collections
		/// </summary>
		public async Task LoadCollectionBatchAsync(ISessionImplementor session, object[] ids, IType type, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (Log.IsDebugEnabled())
			{
				Log.Debug("batch loading collection: {0}", MessageHelper.CollectionInfoString(CollectionPersisters[0], ids));
			}

			IType[] idTypes = new IType[ids.Length];
			ArrayHelper.Fill(idTypes, type);
			try
			{
				await (DoQueryAndInitializeNonLazyCollectionsAsync(session, new QueryParameters(idTypes, ids, ids), true, cancellationToken)).ConfigureAwait(false);
			}
			catch (OperationCanceledException) { throw; }
			catch (HibernateException)
			{
				// Do not call Convert on HibernateExceptions
				throw;
			}
			catch (Exception sqle)
			{
				throw ADOExceptionHelper.Convert(Factory.SQLExceptionConverter, sqle,
												 "could not initialize a collection batch: "
												 + MessageHelper.CollectionInfoString(CollectionPersisters[0], ids), SqlString);
			}

			Log.Debug("done batch load");
		}

		/// <summary>
		/// Called by subclasses that batch initialize collections
		/// </summary>
		protected async Task LoadCollectionSubselectAsync(ISessionImplementor session, object[] ids, object[] parameterValues,
											   IType[] parameterTypes, IDictionary<string, TypedValue> namedParameters,
											   IType type, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			try
			{
				await (DoQueryAndInitializeNonLazyCollectionsAsync(session,
													   new QueryParameters(parameterTypes, parameterValues, namedParameters, ids),
													   true, cancellationToken)).ConfigureAwait(false);
			}
			catch (OperationCanceledException) { throw; }
			catch (HibernateException)
			{
				// Do not call Convert on HibernateExceptions
				throw;
			}
			catch (Exception sqle)
			{
				throw ADOExceptionHelper.Convert(Factory.SQLExceptionConverter, sqle,
												 "could not load collection by subselect: "
												 + MessageHelper.CollectionInfoString(CollectionPersisters[0], ids), SqlString,
												 parameterValues, namedParameters);
			}
		}

		/// <summary>
		/// Return the query results, using the query cache, called
		/// by subclasses that implement cacheable queries
		/// </summary>
		/// <param name="session"></param>
		/// <param name="queryParameters"></param>
		/// <param name="querySpaces"></param>
		/// <param name="resultTypes"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns></returns>
		// Since v5.1
		[Obsolete("Please use overload without resultTypes")]
		protected Task<IList> ListAsync(ISessionImplementor session, QueryParameters queryParameters, ISet<string> querySpaces, IType[] resultTypes, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<IList>(cancellationToken);
			}
			try
			{
				ResultTypes = resultTypes;
				return ListAsync(session, queryParameters, querySpaces, cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<IList>(ex);
			}
		}

		/// <summary>
		/// Return the query results, using the query cache, called
		/// by subclasses that implement cacheable queries
		/// </summary>
		/// <param name="session"></param>
		/// <param name="queryParameters"></param>
		/// <param name="querySpaces"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns></returns>
		protected Task<IList> ListAsync(ISessionImplementor session, QueryParameters queryParameters, ISet<string> querySpaces, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<IList>(cancellationToken);
			}
			try
			{
				var cacheable = IsCacheable(queryParameters);

				if (cacheable)
				{
					return ListUsingQueryCacheAsync(session, queryParameters, querySpaces, cancellationToken);
				}
				return ListIgnoreQueryCacheAsync(session, queryParameters, cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<IList>(ex);
			}
		}

		private async Task<IList> ListIgnoreQueryCacheAsync(ISessionImplementor session, QueryParameters queryParameters, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			return GetResultList(await (DoListAsync(session, queryParameters, cancellationToken)).ConfigureAwait(false), queryParameters.ResultTransformer);
		}

		private async Task<IList> ListUsingQueryCacheAsync(ISessionImplementor session, QueryParameters queryParameters, ISet<string> querySpaces, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			IQueryCache queryCache = _factory.GetQueryCache(queryParameters.CacheRegion);

			QueryKey key = GenerateQueryKey(session, queryParameters);
			var queryCacheBuilder = new QueryCacheResultBuilder(this);

			IList result = await (GetResultFromQueryCacheAsync(session, queryParameters, querySpaces, queryCache, key, cancellationToken)).ConfigureAwait(false);

			if (result == null)
			{
				result = await (DoListAsync(session, queryParameters, key.ResultTransformer, queryCacheBuilder, cancellationToken)).ConfigureAwait(false);
				await (PutResultInQueryCacheAsync(session, queryParameters, queryCache, key, queryCacheBuilder.Result, cancellationToken)).ConfigureAwait(false);
			}
			else
			{
				result = queryCacheBuilder.GetResultList(result);
			}

			result = TransformCacheableResults(queryParameters, key.ResultTransformer, result);

			return GetResultList(result, queryParameters.ResultTransformer);
		}

		private async Task<IList> GetResultFromQueryCacheAsync(
			ISessionImplementor session, QueryParameters queryParameters, ISet<string> querySpaces,
			IQueryCache queryCache, QueryKey key, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (!queryParameters.CanGetFromCache(session))
				return null;

			var result = await (queryCache.GetAsync(
				key, queryParameters, 
				queryParameters.HasAutoDiscoverScalarTypes
					? null
					: key.ResultTransformer.GetCachedResultTypes(CacheTypes),
				querySpaces, session, cancellationToken)).ConfigureAwait(false);

			if (_factory.Statistics.IsStatisticsEnabled)
			{
				if (result == null)
				{
					_factory.StatisticsImplementor.QueryCacheMiss(QueryIdentifier, queryCache.RegionName);
				}
				else
				{
					_factory.StatisticsImplementor.QueryCacheHit(QueryIdentifier, queryCache.RegionName);
				}
			}

			return result;
		}

		private async Task PutResultInQueryCacheAsync(ISessionImplementor session, QueryParameters queryParameters,
										   IQueryCache queryCache, QueryKey key, IList result, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (!queryParameters.CanPutToCache(session))
				return;

			var put = await (queryCache.PutAsync(
				key, queryParameters,
				key.ResultTransformer.GetCachedResultTypes(CacheTypes),
				result, session, cancellationToken)).ConfigureAwait(false);

			if (put && _factory.Statistics.IsStatisticsEnabled)
			{
				_factory.StatisticsImplementor.QueryCachePut(QueryIdentifier, queryCache.RegionName);
			}
		}

		/// <summary>
		/// Actually execute a query, ignoring the query cache
		/// </summary>
		/// <param name="session"></param>
		/// <param name="queryParameters"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns></returns>
		protected Task<IList> DoListAsync(ISessionImplementor session, QueryParameters queryParameters, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<IList>(cancellationToken);
			}
			return DoListAsync(session, queryParameters, null, null, cancellationToken);
		}

		// Since 5.3
		[Obsolete("Use the overload with queryCacheResultBuilder parameter")]
		protected Task<IList> DoListAsync(ISessionImplementor session, QueryParameters queryParameters, IResultTransformer forcedResultTransformer, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<IList>(cancellationToken);
			}
			return DoListAsync(session, queryParameters, forcedResultTransformer, null, cancellationToken);
		}

		protected async Task<IList> DoListAsync(ISessionImplementor session, QueryParameters queryParameters, IResultTransformer forcedResultTransformer,
		                       QueryCacheResultBuilder queryCacheResultBuilder, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			bool statsEnabled = Factory.Statistics.IsStatisticsEnabled;
			var stopWatch = new Stopwatch();
			if (statsEnabled)
			{
				stopWatch.Start();
			}

			IList result;
			try
			{
				result = await (DoQueryAndInitializeNonLazyCollectionsAsync(session, queryParameters, true, forcedResultTransformer, queryCacheResultBuilder, cancellationToken)).ConfigureAwait(false);
			}
			catch (OperationCanceledException) { throw; }
			catch (HibernateException)
			{
				// Do not call Convert on HibernateExceptions
				throw;
			}
			catch (Exception sqle)
			{
				throw ADOExceptionHelper.Convert(Factory.SQLExceptionConverter, sqle, "could not execute query", SqlString,
												 queryParameters.PositionalParameterValues, queryParameters.NamedParameters);
			}
			if (statsEnabled)
			{
				stopWatch.Stop();
				Factory.StatisticsImplementor.QueryExecuted(QueryIdentifier, result.Count, stopWatch.Elapsed);
			}
			return result;
		}
	}
}
