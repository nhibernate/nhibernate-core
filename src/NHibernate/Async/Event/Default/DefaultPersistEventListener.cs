//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;

using NHibernate.Engine;
using NHibernate.Persister.Entity;
using NHibernate.Proxy;
using NHibernate.Util;

namespace NHibernate.Event.Default
{
	using System.Threading.Tasks;
	using System.Threading;
	/// <content>
	/// Contains generated async methods
	/// </content>
	public partial class DefaultPersistEventListener : AbstractSaveEventListener, IPersistEventListener
	{

		public virtual Task OnPersistAsync(PersistEvent @event, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				return OnPersistAsync(@event, IdentityMap.Instantiate(10), cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		public virtual async Task OnPersistAsync(PersistEvent @event, IDictionary createdAlready, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			ISessionImplementor source = @event.Session;
			object obj = @event.Entity;

			object entity;
			if (obj.IsProxy())
			{
				ILazyInitializer li = ((INHibernateProxy)obj).HibernateLazyInitializer;
				if (li.IsUninitialized)
				{
					if (li.Session == source)
					{
						return; //NOTE EARLY EXIT!
					}
					else
					{
						throw new PersistentObjectException("uninitialized proxy passed to persist()");
					}
				}
				entity = await (li.GetImplementationAsync(cancellationToken)).ConfigureAwait(false);
			}
			else
			{
				entity = obj;
			}

			EntityState entityState = await (GetEntityStateAsync(entity, @event.EntityName, source.PersistenceContext.GetEntry(entity), source, cancellationToken)).ConfigureAwait(false);

			switch (entityState)
			{
				case EntityState.Persistent:
					await (EntityIsPersistentAsync(@event, createdAlready, cancellationToken)).ConfigureAwait(false);
					break;
				case EntityState.Transient:
					await (EntityIsTransientAsync(@event, createdAlready, cancellationToken)).ConfigureAwait(false);
					break;
				case EntityState.Detached:
					throw new PersistentObjectException("detached entity passed to persist: " + GetLoggableName(@event.EntityName, entity));
				default:
					throw new ObjectDeletedException("deleted instance passed to merge", null, GetLoggableName(@event.EntityName, entity));
			}
		}

		protected virtual async Task EntityIsPersistentAsync(PersistEvent @event, IDictionary createCache, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			log.Debug("ignoring persistent instance");
			IEventSource source = @event.Session;

			//TODO: check that entry.getIdentifier().equals(requestedId)
			object entity = source.PersistenceContext.Unproxy(@event.Entity);
			/* NH-2565: the UnProxy may return a "field interceptor proxy". When EntityName is null the session.GetEntityPersister will try to guess it.
			 * Instead change a session's method I'll try to guess the EntityName here.
			 * Because I'm using a session's method perhaps could be better if each session's method, which implementation forward to a method having the EntityName as parameter,
			 * use the BestGuessEntityName directly instead do "70 turns" before call it.
			*/
			if (@event.EntityName == null)
			{
				@event.EntityName = source.BestGuessEntityName(entity);
			}
			IEntityPersister persister = source.GetEntityPersister(@event.EntityName, entity);

			object tempObject;
			tempObject = createCache[entity];
			createCache[entity] = entity;
			if (tempObject == null)
			{
				//TODO: merge into one method!
				await (CascadeBeforeSaveAsync(source, persister, entity, createCache, cancellationToken)).ConfigureAwait(false);
				await (CascadeAfterSaveAsync(source, persister, entity, createCache, cancellationToken)).ConfigureAwait(false);
			}
		}

		/// <summary> Handle the given create event. </summary>
		/// <param name="event">The save event to be handled. </param>
		/// <param name="createCache"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		protected virtual Task EntityIsTransientAsync(PersistEvent @event, IDictionary createCache, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				log.Debug("saving transient instance");

				IEventSource source = @event.Session;
				object entity = source.PersistenceContext.Unproxy(@event.Entity);

				object tempObject;
				tempObject = createCache[entity];
				createCache[entity] = entity;
				if (tempObject == null)
				{
					return SaveWithGeneratedIdAsync(entity, @event.EntityName, createCache, source, false, cancellationToken);
				}
				return Task.CompletedTask;
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}
	}
}
