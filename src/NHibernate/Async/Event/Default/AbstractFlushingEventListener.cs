//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using NHibernate.Action;
using NHibernate.Collection;
using NHibernate.Engine;
using NHibernate.Impl;
using NHibernate.Persister.Entity;
using NHibernate.Util;

namespace NHibernate.Event.Default
{
	using System.Threading.Tasks;
	using System.Threading;
	public abstract partial class AbstractFlushingEventListener
	{

		/// <summary> 
		/// Coordinates the processing necessary to get things ready for executions
		/// as db calls by preparing the session caches and moving the appropriate
		/// entities and collections to their respective execution queues. 
		/// </summary>
		/// <param name="event">The flush event.</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		protected virtual async Task FlushEverythingToExecutionsAsync(FlushEvent @event, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			log.Debug("flushing session");

			IEventSource session = @event.Session;
			IPersistenceContext persistenceContext = session.PersistenceContext;

			session.Interceptor.PreFlush((ICollection) persistenceContext.EntitiesByKey.Values);

			persistenceContext.Flushing = true;
			try
			{
				await (PrepareEntityFlushesAsync(session, cancellationToken)).ConfigureAwait(false);
				// we could move this inside if we wanted to
				// tolerate collection initializations during
				// collection dirty checking:
				await (PrepareCollectionFlushesAsync(session, cancellationToken)).ConfigureAwait(false);
				// now, any collections that are initialized
				// inside this block do not get updated - they
				// are ignored until the next flush

				await (FlushEntitiesAsync(@event, cancellationToken)).ConfigureAwait(false);
				await (FlushCollectionsAsync(session, cancellationToken)).ConfigureAwait(false);
			}
			finally
			{
				persistenceContext.Flushing = false;
			}

			//some statistics
			if (log.IsDebugEnabled())
			{
				log.Debug(
					"Flushed: {0} insertions, {1} updates, {2} deletions to {3} objects",
					session.ActionQueue.InsertionsCount,
					session.ActionQueue.UpdatesCount,
					session.ActionQueue.DeletionsCount,
					persistenceContext.EntityEntries.Count);

				log.Debug(
					"Flushed: {0} (re)creations, {1} updates, {2} removals to {3} collections",
					session.ActionQueue.CollectionCreationsCount,
					session.ActionQueue.CollectionUpdatesCount,
					session.ActionQueue.CollectionRemovalsCount,
					persistenceContext.CollectionEntries.Count);
				new Printer(session.Factory).ToString(persistenceContext.EntitiesByKey.Values.ToArray());
			}
		}

		protected virtual async Task FlushCollectionsAsync(IEventSource session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			log.Debug("Processing unreferenced collections");

			ICollection list = IdentityMap.Entries(session.PersistenceContext.CollectionEntries);
			foreach (DictionaryEntry me in list)
			{
				CollectionEntry ce = (CollectionEntry) me.Value;
				if (!ce.IsReached && !ce.IsIgnore)
				{
					await (Collections.ProcessUnreachableCollectionAsync((IPersistentCollection) me.Key, session, cancellationToken)).ConfigureAwait(false);
				}
			}

			// Schedule updates to collections:

			log.Debug("Scheduling collection removes/(re)creates/updates");

			list = IdentityMap.Entries(session.PersistenceContext.CollectionEntries);
			ActionQueue actionQueue = session.ActionQueue;
			foreach (DictionaryEntry me in list)
			{
				IPersistentCollection coll = (IPersistentCollection) me.Key;
				CollectionEntry ce = (CollectionEntry) me.Value;

				if (ce.IsDorecreate)
				{
					session.Interceptor.OnCollectionRecreate(coll, ce.CurrentKey);
					actionQueue.AddAction(new CollectionRecreateAction(coll, ce.CurrentPersister, ce.CurrentKey, session));
				}
				if (ce.IsDoremove)
				{
					session.Interceptor.OnCollectionRemove(coll, ce.LoadedKey);
					actionQueue.AddAction(
						new CollectionRemoveAction(coll, ce.LoadedPersister, ce.LoadedKey, ce.IsSnapshotEmpty(coll), session));
				}
				if (ce.IsDoupdate)
				{
					session.Interceptor.OnCollectionUpdate(coll, ce.LoadedKey);
					actionQueue.AddAction(
						new CollectionUpdateAction(coll, ce.LoadedPersister, ce.LoadedKey, ce.IsSnapshotEmpty(coll), session));
				}
			}
			actionQueue.SortCollectionActions();
		}

		// 1. detect any dirty entities
		// 2. schedule any entity updates
		// 3. search out any reachable collections
		protected virtual async Task FlushEntitiesAsync(FlushEvent @event, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			log.Debug("Flushing entities and processing referenced collections");

			// Among other things, updateReachables() will recursively load all
			// collections that are moving roles. This might cause entities to
			// be loaded.

			// So this needs to be safe from concurrent modification problems.
			// It is safe because of how IdentityMap implements entrySet()
			IEventSource source = @event.Session;

			ICollection list = IdentityMap.ConcurrentEntries(source.PersistenceContext.EntityEntries);
			foreach (DictionaryEntry me in list)
			{
				// Update the status of the object and if necessary, schedule an update
				EntityEntry entry = (EntityEntry) me.Value;
				Status status = entry.Status;

				if (status != Status.Loading && status != Status.Gone)
				{
					FlushEntityEvent entityEvent = new FlushEntityEvent(source, me.Key, entry);
					IFlushEntityEventListener[] listeners = source.Listeners.FlushEntityEventListeners;
					foreach (IFlushEntityEventListener listener in listeners)
					{
						await (listener.OnFlushEntityAsync(entityEvent, cancellationToken)).ConfigureAwait(false);
					}
				}
			}
			source.ActionQueue.SortActions();
		}

		// Initialize the flags of the CollectionEntry, including the dirty check.
		protected virtual async Task PrepareCollectionFlushesAsync(ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			// Initialize dirty flags for arrays + collections with composite elements
			// and reset reached, doupdate, etc.
			log.Debug("dirty checking collections");

			ICollection list = IdentityMap.Entries(session.PersistenceContext.CollectionEntries);
			foreach (DictionaryEntry entry in list)
			{
				await (((CollectionEntry) entry.Value).PreFlushAsync((IPersistentCollection) entry.Key, cancellationToken)).ConfigureAwait(false);
			}
		}

		//process cascade save/update at the start of a flush to discover
		//any newly referenced entity that must be passed to saveOrUpdate(),
		//and also apply orphan delete
		protected virtual async Task PrepareEntityFlushesAsync(IEventSource session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			log.Debug("processing flush-time cascades");

			ICollection list = IdentityMap.ConcurrentEntries(session.PersistenceContext.EntityEntries);
			//safe from concurrent modification because of how entryList() is implemented on IdentityMap
			foreach (DictionaryEntry me in list)
			{
				EntityEntry entry = (EntityEntry) me.Value;
				Status status = entry.Status;
				if (status == Status.Loaded || status == Status.Saving || status == Status.ReadOnly)
				{
					await (CascadeOnFlushAsync(session, entry.Persister, me.Key, Anything, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		protected virtual async Task CascadeOnFlushAsync(IEventSource session, IEntityPersister persister, object key, object anything, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			session.PersistenceContext.IncrementCascadeLevel();
			try
			{
				await (new Cascade(CascadingAction, CascadePoint.BeforeFlush, session).CascadeOnAsync(persister, key, anything, cancellationToken)).ConfigureAwait(false);
			}
			finally
			{
				session.PersistenceContext.DecrementCascadeLevel();
			}
		}

		/// <summary> 
		/// Execute all SQL and second-level cache updates, in a
		/// special order so that foreign-key constraints cannot
		/// be violated:
		/// <list type="bullet">
		/// <item> <description>Inserts, in the order they were performed</description> </item>
		/// <item> <description>Updates</description> </item>
		/// <item> <description>Deletion of collection elements</description> </item>
		/// <item> <description>Insertion of collection elements</description> </item>
		/// <item> <description>Deletes, in the order they were performed</description> </item>
		/// </list>
		/// </summary>
		/// <param name="session">The session being flushed</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		protected virtual async Task PerformExecutionsAsync(IEventSource session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (log.IsDebugEnabled())
			{
				log.Debug("executing flush");
			}

			try
			{
				session.ConnectionManager.FlushBeginning();
				// IMPL NOTE : here we alter the flushing flag of the persistence context to allow
				//		during-flush callbacks more leniency in regards to initializing proxies and
				//		lazy collections during their processing.
				// For more information, see HHH-2763 / NH-1882
				session.PersistenceContext.Flushing = true;
				// we need to lock the collection caches before
				// executing entity inserts/updates in order to
				// account for bidi associations
				await (session.ActionQueue.PrepareActionsAsync(cancellationToken)).ConfigureAwait(false);
				await (session.ActionQueue.ExecuteActionsAsync(cancellationToken)).ConfigureAwait(false);
			}
			catch (HibernateException he)
			{
				if (log.IsErrorEnabled())
				{
					log.Error(he, "Could not synchronize database state with session");
				}
				throw;
			}
			finally
			{
				session.PersistenceContext.Flushing = false;
				session.ConnectionManager.FlushEnding();
			}
		}
	}
}
