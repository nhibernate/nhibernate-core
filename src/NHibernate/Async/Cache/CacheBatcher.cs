//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using NHibernate.Engine;
using NHibernate.Persister.Collection;
using NHibernate.Persister.Entity;

namespace NHibernate.Cache
{
	using System.Threading.Tasks;
	using System.Threading;
	public sealed partial class CacheBatcher
	{

		/// <summary>
		/// Executes the pending batches.
		/// </summary>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		internal async Task ExecuteBatchAsync(CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (_putBatches.Count == 0)
			{
				return;
			}

			try
			{
				Stopwatch duration = null;
				if (Log.IsDebugEnabled())
				{
					duration = Stopwatch.StartNew();
				}

				foreach (var batch in _putBatches.Values)
				{
					await (batch.ExecuteAsync(cancellationToken)).ConfigureAwait(false);
				}

				if (Log.IsDebugEnabled() && duration != null)
				{
					Log.Debug(
						"ExecuteBatch for {0} batches totaling {1} keys took {2} ms",
						_putBatches.Count, _putBatches.Values.Sum(b => b.BatchSize),
						duration.ElapsedMilliseconds);
				}
			}
			finally
			{
				Cleanup();
			}
		}
	}
}
