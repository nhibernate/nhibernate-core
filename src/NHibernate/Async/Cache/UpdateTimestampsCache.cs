//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

using NHibernate.Cfg;
using NHibernate.Util;

namespace NHibernate.Cache
{
	using System.Threading.Tasks;
	using System.Threading;
	public partial class UpdateTimestampsCache
	{
		private readonly NHibernate.Util.AsyncLock _preInvalidate = new NHibernate.Util.AsyncLock();
		private readonly NHibernate.Util.AsyncLock _invalidate = new NHibernate.Util.AsyncLock();
		private readonly NHibernate.Util.AsyncLock _isUpToDate = new NHibernate.Util.AsyncLock();
		private readonly NHibernate.Util.AsyncLock _areUpToDate = new NHibernate.Util.AsyncLock();

		public virtual Task ClearAsync(CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return updateTimestamps.ClearAsync(cancellationToken);
		}

		//Since v5.1
		[Obsolete("Please use PreInvalidate(IReadOnlyCollection<string>) instead.")]
		public Task PreInvalidateAsync(object[] spaces, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				//Only for backwards compatibility.
				return PreInvalidateAsync(spaces.OfType<string>().ToList(), cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		[MethodImpl()]
		public virtual async Task PreInvalidateAsync(IReadOnlyCollection<string> spaces, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (await _preInvalidate.LockAsync())
			{
				//TODO: to handle concurrent writes correctly, this should return a Lock to the client
				var ts = updateTimestamps.NextTimestamp() + updateTimestamps.Timeout;
				await (SetSpacesTimestampAsync(spaces, ts, cancellationToken)).ConfigureAwait(false);

				//TODO: return new Lock(ts);
			}

			//TODO: return new Lock(ts);
		}

		//Since v5.1
		[Obsolete("Please use PreInvalidate(IReadOnlyCollection<string>) instead.")]
		public Task InvalidateAsync(object[] spaces, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				//Only for backwards compatibility.
				return InvalidateAsync(spaces.OfType<string>().ToList(), cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		[MethodImpl()]
		public virtual async Task InvalidateAsync(IReadOnlyCollection<string> spaces, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (await _invalidate.LockAsync())
			{
				//TODO: to handle concurrent writes correctly, the client should pass in a Lock
				long ts = updateTimestamps.NextTimestamp();
				//TODO: if lock.getTimestamp().equals(ts)
				if (log.IsDebugEnabled())
					log.Debug("Invalidating spaces [{0}]", StringHelper.CollectionToString(spaces));
				await (SetSpacesTimestampAsync(spaces, ts, cancellationToken)).ConfigureAwait(false);
			}
		}

		private async Task SetSpacesTimestampAsync(IReadOnlyCollection<string> spaces, long ts, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (_batchUpdateTimestamps != null)
			{
				if (spaces.Count == 0)
					return;

				var timestamps = new object[spaces.Count];
				for (var i = 0; i < timestamps.Length; i++)
				{
					timestamps[i] = ts;
				}

				await (_batchUpdateTimestamps.PutManyAsync(spaces.ToArray(), timestamps, cancellationToken)).ConfigureAwait(false);
			}
			else
			{
				foreach (var space in spaces)
				{
					await (updateTimestamps.PutAsync(space, ts, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		[MethodImpl()]
		public virtual async Task<bool> IsUpToDateAsync(ISet<string> spaces, long timestamp /* H2.1 has Long here */, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (await _isUpToDate.LockAsync())
			{
				if (_batchReadOnlyUpdateTimestamps != null)
				{
					if (spaces.Count == 0)
						return true;

					var keys = new object[spaces.Count];
					var index = 0;
					foreach (var space in spaces)
					{
						keys[index++] = space;
					}
					var lastUpdates = await (_batchReadOnlyUpdateTimestamps.GetManyAsync(keys, cancellationToken)).ConfigureAwait(false);
					return lastUpdates.All(lastUpdate => !IsOutdated(lastUpdate as long?, timestamp));
				}

				return spaces.Select(space => updateTimestamps.Get(space))
			             .All(lastUpdate => !IsOutdated(lastUpdate as long?, timestamp));
			}
		}

		[MethodImpl()]
		public virtual async Task<bool[]> AreUpToDateAsync(ISet<string>[] spaces, long[] timestamps, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (await _areUpToDate.LockAsync())
			{
				var results = new bool[spaces.Length];
				var allSpaces = new HashSet<string>();
				foreach (var sp in spaces)
				{
					allSpaces.UnionWith(sp);
				}

				if (_batchReadOnlyUpdateTimestamps != null)
				{
					if (allSpaces.Count == 0)
					{
						for (var i = 0; i < spaces.Length; i++)
						{
							results[i] = true;
						}

						return results;
					}

					var keys = new object[allSpaces.Count];
					var index = 0;
					foreach (var space in allSpaces)
					{
						keys[index++] = space;
					}

					index = 0;
					var lastUpdatesBySpace =
					(await (_batchReadOnlyUpdateTimestamps
						.GetManyAsync(keys, cancellationToken)).ConfigureAwait(false))
						.ToDictionary(u => keys[index++], u => u as long?);

					for (var i = 0; i < spaces.Length; i++)
					{
						var timestamp = timestamps[i];
						results[i] = spaces[i].All(space => !IsOutdated(lastUpdatesBySpace[space], timestamp));
					}
				}
				else
				{
					for (var i = 0; i < spaces.Length; i++)
					{
						results[i] = await (IsUpToDateAsync(spaces[i], timestamps[i], cancellationToken)).ConfigureAwait(false);
					}
				}

				return results;
			}
		}
	}
}
