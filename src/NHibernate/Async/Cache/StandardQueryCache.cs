//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Collections.Generic;

using NHibernate.Cfg;
using NHibernate.Engine;
using NHibernate.Type;
using NHibernate.Util;

namespace NHibernate.Cache
{
	using System.Threading.Tasks;
	using System.Threading;
	public partial class StandardQueryCache : IQueryCache
	{

		#region IQueryCache Members

		public Task ClearAsync(CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return _queryCache.ClearAsync(cancellationToken);
		}

		public async Task<bool> PutAsync(QueryKey key, ICacheAssembler[] returnTypes, IList result, bool isNaturalKeyLookup, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (isNaturalKeyLookup && result.Count == 0)
				return false;

			long ts = session.Factory.Settings.CacheProvider.NextTimestamp();

			if (Log.IsDebugEnabled())
				Log.Debug("caching query results in region: '{0}'; {1}", _regionName, key);

			IList cacheable = new List<object>(result.Count + 1) {ts};
			for (int i = 0; i < result.Count; i++)
			{
				if (returnTypes.Length == 1)
				{
					cacheable.Add(await (returnTypes[0].DisassembleAsync(result[i], session, null, cancellationToken)).ConfigureAwait(false));
				}
				else
				{
					cacheable.Add(await (TypeHelper.DisassembleAsync((object[]) result[i], returnTypes, null, session, null, cancellationToken)).ConfigureAwait(false));
				}
			}

			await (_queryCache.PutAsync(key, cacheable, cancellationToken)).ConfigureAwait(false);

			return true;
		}

		public async Task<IList> GetAsync(QueryKey key, ICacheAssembler[] returnTypes, bool isNaturalKeyLookup, ISet<string> spaces, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (Log.IsDebugEnabled())
				Log.Debug("checking cached query results in region: '{0}'; {1}", _regionName, key);

			var cacheable = (IList)await (_queryCache.GetAsync(key, cancellationToken)).ConfigureAwait(false);
			if (cacheable == null)
			{
				Log.Debug("query results were not found in cache: {0}", key);
				return null;
			}

			var timestamp = (long)cacheable[0];

			if (Log.IsDebugEnabled())
				Log.Debug("Checking query spaces for up-to-dateness [{0}]", StringHelper.CollectionToString(spaces));

			if (!isNaturalKeyLookup && !await (IsUpToDateAsync(spaces, timestamp, cancellationToken)).ConfigureAwait(false))
			{
				Log.Debug("cached query results were not up to date for: {0}", key);
				return null;
			}

			Log.Debug("returning cached query results for: {0}", key);
			if (key.ResultTransformer?.AutoDiscoverTypes == true && cacheable.Count > 0)
			{
				returnTypes = GuessTypes(cacheable);
			}

			for (int i = 1; i < cacheable.Count; i++)
			{
				if (returnTypes.Length == 1)
				{
					var beforeAssembleTask = returnTypes[0]?.BeforeAssembleAsync(cacheable[i], session, cancellationToken);
					if (beforeAssembleTask != null)
					{
						await (beforeAssembleTask).ConfigureAwait(false);
					}
				}
				else
				{
					await (TypeHelper.BeforeAssembleAsync((object[])cacheable[i], returnTypes, session, cancellationToken)).ConfigureAwait(false);
				}
			}

			IList result = new List<object>(cacheable.Count - 1);
			for (int i = 1; i < cacheable.Count; i++)
			{
				try
				{
					if (returnTypes.Length == 1)
					{
						result.Add(await (returnTypes[0].AssembleAsync(cacheable[i], session, null, cancellationToken)).ConfigureAwait(false));
					}
					else
					{
						result.Add(await (TypeHelper.AssembleAsync((object[])cacheable[i], returnTypes, session, null, cancellationToken)).ConfigureAwait(false));
					}
				}
				catch (UnresolvableObjectException ex)
				{
					if (isNaturalKeyLookup)
					{
						//TODO: not really completely correct, since
						//      the UnresolvableObjectException could occur while resolving
						//      associations, leaving the PC in an inconsistent state
						Log.Debug(ex, "could not reassemble cached result set");
						await (_queryCache.RemoveAsync(key, cancellationToken)).ConfigureAwait(false);
						return null;
					}

					throw;
				}
			}

			return result;
		}

		#endregion

		protected virtual Task<bool> IsUpToDateAsync(ISet<string> spaces, long timestamp, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<bool>(cancellationToken);
			}
			return _updateTimestampsCache.IsUpToDateAsync(spaces, timestamp, cancellationToken);
		}
	}
}
