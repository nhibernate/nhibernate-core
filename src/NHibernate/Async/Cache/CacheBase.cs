//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Threading;
using System.Threading.Tasks;
using NHibernate.Cache.Entry;
using NHibernate.Type;

namespace NHibernate.Cache
{
	public abstract partial class CacheBase :
		// 6.0 TODO: remove ICache
#pragma warning disable 618
		ICache
#pragma warning restore 618
	{

		#region Batch operations default implementation

		/// <summary>
		/// Get multiple items from the cache.
		/// </summary>
		/// <param name="keys">The keys to be retrieved from the cache.</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns>The cached items, matching each key of <paramref name="keys"/> respectively. For each missed key,
		/// it will contain a <see langword="null" />.</returns>
		/// <remarks>
		/// <para>As all other <c>Many</c> method, its default implementation just falls back on calling
		/// the single operation method in a loop. Cache providers should override it with an actual multiple
		/// implementation if they can support it.</para>
		/// <para>Additionally, if overriding <c>GetMany</c>, consider overriding also
		/// <see cref="PreferMultipleGet"/>.</para>
		/// </remarks>
		public virtual Task<object[]> GetManyAsync(object[] keys, CancellationToken cancellationToken)
		{
			if (keys == null)
				throw new ArgumentNullException(nameof(keys));
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object[]>(cancellationToken);
			}
			return InternalGetManyAsync();
			async Task<object[]> InternalGetManyAsync()
			{
				var result = new object[keys.Length];
				for (var i = 0; i < keys.Length; i++)
				{
					result[i] = await (GetAsync(keys[i], cancellationToken)).ConfigureAwait(false);
				}

				return result;
			}
		}

		/// <summary>
		/// Add multiple items to the cache.
		/// </summary>
		/// <param name="keys">The keys of the items.</param>
		/// <param name="values">The items.</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		public virtual Task PutManyAsync(object[] keys, object[] values, CancellationToken cancellationToken)
		{
			if (keys == null)
				throw new ArgumentNullException(nameof(keys));
			if (values == null)
				throw new ArgumentNullException(nameof(values));
			if (keys.Length != values.Length)
				throw new ArgumentException(
					$"{nameof(keys)} and {nameof(values)} must have the same length. Found {keys.Length} and " +
					$"{values.Length} respectively");
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return InternalPutManyAsync();
			async Task InternalPutManyAsync()
			{

				for (var i = 0; i < keys.Length; i++)
				{
					await (PutAsync(keys[i], values[i], cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		/// <summary>
		/// Lock the items from being concurrently changed.
		/// </summary>
		/// <param name="keys">The keys of the items.</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns>A lock object to use for unlocking the items. Can be <see langword="null" />.</returns>
		/// <remarks>The implementation is allowed to do nothing for non-clustered cache.</remarks>
		public virtual Task<object> LockManyAsync(object[] keys, CancellationToken cancellationToken)
		{
			if (keys == null)
				throw new ArgumentNullException(nameof(keys));
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return InternalLockManyAsync();
			async Task<object> InternalLockManyAsync()
			{
				// When delegating to the single operation lock, agreggate lock values into one.
				var lockValues = new object[keys.Length];
				for (var i = 0; i < keys.Length; i++)
				{
					lockValues[i] = await (LockAsync(keys[i], cancellationToken)).ConfigureAwait(false);
				}

				return lockValues;
			}
		}

		/// <summary>
		/// Unlock the items that were previously locked.
		/// </summary>
		/// <param name="keys">The keys of the items.</param>
		/// <param name="lockValue">The lock object to use for unlocking the items, as received from <see cref="Lock"/>.</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <remarks>The implementation should do nothing if <see cref="Lock"/> own implementation does nothing.</remarks>
		public virtual Task UnlockManyAsync(object[] keys, object lockValue, CancellationToken cancellationToken)
		{
			if (keys == null)
				throw new ArgumentNullException(nameof(keys));
			if (!(lockValue is object[] lockValues) || lockValues.Length != keys.Length)
				throw new ArgumentException(
					$"When {nameof(UnlockManyAsync)} is not overriden, {nameof(lockValue)} must be an array of the lock " +
					$"values resulting of sequentially single-locking each key.",
					nameof(lockValue));
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return InternalUnlockManyAsync();
			async Task InternalUnlockManyAsync()
			{
				for (var i = 0; i < keys.Length; i++)
				{
					await (UnlockAsync(keys[i], lockValues[i], cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		#endregion
		#region Obsolete ICache implementation

		Task ICache.UnlockAsync(object key, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return UnlockAsync(key, null, cancellationToken);
		}

		#endregion
	}
}
