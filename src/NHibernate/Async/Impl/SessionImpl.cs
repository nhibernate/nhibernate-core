//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Collections.Generic;
using System.Data.Common;
using System.Linq.Expressions;
using System.Runtime.Serialization;
using System.Security;
using NHibernate.AdoNet;
using NHibernate.Collection;
using NHibernate.Criterion;
using NHibernate.Engine;
using NHibernate.Engine.Query;
using NHibernate.Engine.Query.Sql;
using NHibernate.Event;
using NHibernate.Hql;
using NHibernate.Intercept;
using NHibernate.Loader.Criteria;
using NHibernate.Loader.Custom;
using NHibernate.Persister.Collection;
using NHibernate.Persister.Entity;
using NHibernate.Proxy;
using NHibernate.Stat;
using NHibernate.Type;
using NHibernate.Util;

namespace NHibernate.Impl
{
	using System.Threading.Tasks;
	using System.Threading;
	public sealed partial class SessionImpl : AbstractSessionImpl, IEventSource, ISerializable, IDeserializationCallback
	{

		/// <summary>
		/// Ensure that the locks are downgraded to <see cref="LockMode.None"/>
		/// and that all of the softlocks in the <see cref="Cache"/> have
		/// been released.
		/// </summary>
		public override async Task AfterTransactionCompletionAsync(bool success, ITransaction tx, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginContext())
			{
				log.Debug("transaction completion");

				persistenceContext.AfterTransactionCompletion();
				await (actionQueue.AfterTransactionCompletionAsync(success, cancellationToken)).ConfigureAwait(false);

				if (Factory.Statistics.IsStatisticsEnabled)
				{
					Factory.StatisticsImplementor.EndTransaction(success);
				}

				try
				{
					Interceptor.AfterTransactionCompletion(tx);
				}
				catch (Exception t)
				{
					log.Error(t, "exception in interceptor afterTransactionCompletion()");
				}

				if (IsClosed)
				{
					// Cleanup was delayed to transaction completion, do it now.
					persistenceContext.Clear();
				}

				//if (autoClear)
				//	Clear();
			}
		}

		/// <summary>
		/// Save a transient object. An id is generated, assigned to the object and returned
		/// </summary>
		/// <param name="obj"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns></returns>
		public async Task<object> SaveAsync(object obj, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				return await (FireSaveAsync(new SaveOrUpdateEvent(null, obj, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public async Task<object> SaveAsync(string entityName, object obj, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				return await (FireSaveAsync(new SaveOrUpdateEvent(entityName, obj, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public async Task SaveAsync(string entityName, object obj, object id, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireSaveAsync(new SaveOrUpdateEvent(entityName, obj, id, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		/// <summary>
		/// Save a transient object with a manually assigned ID
		/// </summary>
		/// <param name="obj"></param>
		/// <param name="id"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		public async Task SaveAsync(object obj, object id, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireSaveAsync(new SaveOrUpdateEvent(null, obj, id, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		/// <summary>
		/// Delete a persistent object
		/// </summary>
		/// <param name="obj"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		public async Task DeleteAsync(object obj, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireDeleteAsync(new DeleteEvent(obj, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		/// <summary> Delete a persistent object (by explicit entity name)</summary>
		public async Task DeleteAsync(string entityName, object obj, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireDeleteAsync(new DeleteEvent(entityName, obj, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public async Task UpdateAsync(object obj, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireUpdateAsync(new SaveOrUpdateEvent(null, obj, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public async Task UpdateAsync(string entityName, object obj, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireUpdateAsync(new SaveOrUpdateEvent(entityName, obj, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public async Task UpdateAsync(string entityName, object obj, object id, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireUpdateAsync(new SaveOrUpdateEvent(entityName, obj, id, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public async Task SaveOrUpdateAsync(object obj, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireSaveOrUpdateAsync(new SaveOrUpdateEvent(null, obj, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public async Task SaveOrUpdateAsync(string entityName, object obj, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireSaveOrUpdateAsync(new SaveOrUpdateEvent(entityName, obj, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public async Task SaveOrUpdateAsync(string entityName, object obj, object id, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireSaveOrUpdateAsync(new SaveOrUpdateEvent(entityName, obj, id, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public async Task UpdateAsync(object obj, object id, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireUpdateAsync(new SaveOrUpdateEvent(null, obj, id, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		async Task<IList> FindAsync(string query, object[] values, IType[] types, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				return await (ListAsync(query.ToQueryExpression(), new QueryParameters(types, values), cancellationToken)).ConfigureAwait(false);
			}
		}

		public override Task ListAsync(IQueryExpression queryExpression, QueryParameters queryParameters, IList results, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return ListAsync(queryExpression, queryParameters, results, null, cancellationToken);
		}

		protected override Task ListFilterAsync(object collection, IQueryExpression queryExpression, QueryParameters queryParameters, IList results, CancellationToken cancellationToken)
		{
			if (collection == null)
				throw new ArgumentNullException(nameof(collection));
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return ListAsync(queryExpression, queryParameters, results, collection, cancellationToken);
		}

		private async Task ListAsync(IQueryExpression queryExpression, QueryParameters queryParameters, IList results, object filterConnection, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				queryParameters.ValidateParameters();

				var isFilter = filterConnection != null;
				var plan = isFilter
					? await (GetFilterQueryPlanAsync(filterConnection, queryExpression, queryParameters, false, cancellationToken)).ConfigureAwait(false)
					: GetHQLQueryPlan(queryExpression, false);

				// GetFilterQueryPlan has already auto flushed or fully flush.
				if (!isFilter)
					await (AutoFlushIfRequiredAsync(plan.QuerySpaces, cancellationToken)).ConfigureAwait(false);

				bool success = false;
				using (SuspendAutoFlush()) //stops flush being called multiple times if this method is recursively called
				{
					try
					{
						await (plan.PerformListAsync(queryParameters, this, results, cancellationToken)).ConfigureAwait(false);
						success = true;
					}
					catch (OperationCanceledException) { throw; }
					catch (HibernateException)
					{
						// Do not call Convert on HibernateExceptions
						throw;
					}
					catch (Exception e)
					{
						throw Convert(e, "Could not execute query");
					}
					finally
					{
						await (AfterOperationAsync(success, cancellationToken)).ConfigureAwait(false);
					}
				}
			}
		}

		// Since v5.2
		[Obsolete("This method has no usages and will be removed in a future version")]
		public override async Task<IQueryTranslator[]> GetQueriesAsync(IQueryExpression query, bool scalar, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				var plan = Factory.QueryPlanCache.GetHQLQueryPlan(query, scalar, enabledFilters);
				await (AutoFlushIfRequiredAsync(plan.QuerySpaces, cancellationToken)).ConfigureAwait(false);
				return plan.Translators;
			}
		}

		/// <inheritdoc />
		// Since v5.3
		[Obsolete("Use AsyncEnumerable extension method instead.")]
		public override Task<IEnumerable<T>> EnumerableAsync<T>(IQueryExpression queryExpression, QueryParameters queryParameters, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<IEnumerable<T>>(cancellationToken);
			}
			try
			{
				return Task.FromResult<IEnumerable<T>>(Enumerable<T>(queryExpression, queryParameters));
			}
			catch (Exception ex)
			{
				return Task.FromException<IEnumerable<T>>(ex);
			}
		}

		/// <inheritdoc />
		// Since v5.3
		[Obsolete("Use AsyncEnumerable extension method instead.")]
		public override Task<IEnumerable> EnumerableAsync(IQueryExpression queryExpression, QueryParameters queryParameters, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<IEnumerable>(cancellationToken);
			}
			try
			{
				return Task.FromResult<IEnumerable>(Enumerable(queryExpression, queryParameters));
			}
			catch (Exception ex)
			{
				return Task.FromException<IEnumerable>(ex);
			}
		}

		// TODO: Scroll(string query, QueryParameters queryParameters)

		public Task<int> DeleteAsync(string query, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<int>(cancellationToken);
			}
			return DeleteAsync(query, NoArgs, NoTypes, cancellationToken);
		}

		public Task<int> DeleteAsync(string query, object value, IType type, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<int>(cancellationToken);
			}
			return DeleteAsync(query, new[] { value }, new[] { type }, cancellationToken);
		}

		public async Task<int> DeleteAsync(string query, object[] values, IType[] types, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				if (string.IsNullOrEmpty(query))
				{
					throw new ArgumentNullException("query", "attempt to perform delete-by-query with null query");
				}

				if (log.IsDebugEnabled())
				{
					log.Debug("delete: {0}", query);
					if (values.Length != 0)
					{
						log.Debug("parameters: {0}", StringHelper.ToString(values));
					}
				}

				IList list = await (FindAsync(query, values, types, cancellationToken)).ConfigureAwait(false);
				int count = list.Count;
				for (int i = 0; i < count; i++)
				{
					await (DeleteAsync(list[i], cancellationToken)).ConfigureAwait(false);
				}
				return count;
			}
		}

		public async Task LockAsync(object obj, LockMode lockMode, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireLockAsync(new LockEvent(obj, lockMode, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public async Task LockAsync(string entityName, object obj, LockMode lockMode, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireLockAsync(new LockEvent(entityName, obj, lockMode, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public async Task<IQuery> CreateFilterAsync(object collection, string queryString, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				var plan = await (GetFilterQueryPlanAsync(collection, queryString, null, false, cancellationToken)).ConfigureAwait(false);
				var filter = new CollectionFilterImpl(queryString, collection, this, plan.ParameterMetadata);
				//filter.SetComment(queryString);
				return filter;
			}
		}

		public override async Task<IQuery> CreateFilterAsync(object collection, IQueryExpression queryExpression, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				var plan = await (GetFilterQueryPlanAsync(collection, queryExpression, null, false, cancellationToken)).ConfigureAwait(false);
				var filter = new ExpressionFilterImpl(plan.QueryExpression, collection, this, plan.ParameterMetadata);
				return filter;
			}
		}

		private Task<IQueryExpressionPlan> GetFilterQueryPlanAsync(object collection, IQueryExpression queryExpression, QueryParameters parameters, bool shallow, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<IQueryExpressionPlan>(cancellationToken);
			}
			return GetFilterQueryPlanAsync(collection, parameters, shallow, null, queryExpression, cancellationToken);
		}

		private Task<IQueryExpressionPlan> GetFilterQueryPlanAsync(object collection, string filter, QueryParameters parameters, bool shallow, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<IQueryExpressionPlan>(cancellationToken);
			}
			return GetFilterQueryPlanAsync(collection, parameters, shallow, filter, null, cancellationToken);
		}

		private Task<IQueryExpressionPlan> GetFilterQueryPlanAsync(object collection, QueryParameters parameters, bool shallow,
			string filter, IQueryExpression queryExpression, CancellationToken cancellationToken)
		{
			if (collection == null)
				throw new ArgumentNullException(nameof(collection), "null collection passed to filter");
			if (filter != null && queryExpression != null)
				throw new ArgumentException($"Either {nameof(filter)} or {nameof(queryExpression)} must be specified, not both.");
			if (filter == null && queryExpression == null)
				throw new ArgumentException($"{nameof(filter)} and {nameof(queryExpression)} were both null.");
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<IQueryExpressionPlan>(cancellationToken);
			}
			return InternalGetFilterQueryPlanAsync();
			async Task<IQueryExpressionPlan> InternalGetFilterQueryPlanAsync()
			{

				var entry = persistenceContext.GetCollectionEntryOrNull(collection);
				var roleBeforeFlush = entry?.LoadedPersister;

				IQueryExpressionPlan plan;
				if (roleBeforeFlush == null)
				{
					// if it was previously unreferenced, we need to flush in order to
					// get its state into the database in order to execute query
					await (FlushAsync(cancellationToken)).ConfigureAwait(false);
					entry = persistenceContext.GetCollectionEntryOrNull(collection);
					var roleAfterFlush = entry?.LoadedPersister;
					if (roleAfterFlush == null)
					{
						throw new QueryException("The collection was unreferenced");
					}
					plan = GetFilterQueryPlan(roleAfterFlush.Role, shallow, filter, queryExpression);
				}
				else
				{
					// otherwise, we only need to flush if there are in-memory changes
					// to the queried tables
					plan = GetFilterQueryPlan(roleBeforeFlush.Role, shallow, filter, queryExpression);
					if (await (AutoFlushIfRequiredAsync(plan.QuerySpaces, cancellationToken)).ConfigureAwait(false))
					{
						// might need to run a different filter entirely after the flush
						// because the collection role may have changed
						entry = persistenceContext.GetCollectionEntryOrNull(collection);
						var roleAfterFlush = entry?.LoadedPersister;
						if (roleBeforeFlush != roleAfterFlush)
						{
							if (roleAfterFlush == null)
							{
								throw new QueryException("The collection was dereferenced");
							}
							plan = GetFilterQueryPlan(roleAfterFlush.Role, shallow, filter, queryExpression);
						}
					}
				}

				if (parameters != null)
				{
					parameters.PositionalParameterValues[0] = entry.LoadedKey;
					parameters.PositionalParameterTypes[0] = entry.LoadedPersister.KeyType;
				}

				return plan;
			}
		}

		#region IEventSource Members
		/// <summary> Force an immediate flush</summary>
		public async Task ForceFlushAsync(EntityEntry entityEntry, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				if (log.IsDebugEnabled())
				{
					log.Debug("flushing to force deletion of re-saved object: {0}",
					          MessageHelper.InfoString(entityEntry.Persister, entityEntry.Id, Factory));
				}

				if (persistenceContext.CascadeLevel > 0)
				{
					throw new ObjectDeletedException(
						"deleted object would be re-saved by cascade (remove deleted object from associations)",
						entityEntry.Id,
						entityEntry.EntityName);
				}

				await (FlushAsync(cancellationToken)).ConfigureAwait(false);
			}
		}

		/// <summary> Cascade merge an entity instance</summary>
		public async Task MergeAsync(string entityName, object obj, IDictionary copiedAlready, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireMergeAsync(copiedAlready, new MergeEvent(entityName, obj, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		/// <summary> Cascade persist an entity instance</summary>
		public async Task PersistAsync(string entityName, object obj, IDictionary createdAlready, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FirePersistAsync(createdAlready, new PersistEvent(entityName, obj, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		/// <summary> Cascade persist an entity instance during the flush process</summary>
		public async Task PersistOnFlushAsync(string entityName, object obj, IDictionary copiedAlready, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FirePersistOnFlushAsync(copiedAlready, new PersistEvent(entityName, obj, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		/// <summary> Cascade refresh an entity instance</summary>
		public async Task RefreshAsync(object obj, IDictionary refreshedAlready, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireRefreshAsync(refreshedAlready, new RefreshEvent(obj, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		/// <summary> Cascade delete an entity instance</summary>
		public async Task DeleteAsync(string entityName, object child, bool isCascadeDeleteEnabled, ISet<object> transientEntities, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireDeleteAsync(new DeleteEvent(entityName, child, isCascadeDeleteEnabled, this), transientEntities, cancellationToken)).ConfigureAwait(false);
			}
		}

		#endregion

		public async Task<object> MergeAsync(string entityName, object obj, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				return await (FireMergeAsync(new MergeEvent(entityName, obj, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public async Task<T> MergeAsync<T>(T entity, CancellationToken cancellationToken = default(CancellationToken)) where T : class
		{
			cancellationToken.ThrowIfCancellationRequested();
			return (T)await (MergeAsync((object)entity, cancellationToken)).ConfigureAwait(false);
		}

		public async Task<T> MergeAsync<T>(string entityName, T entity, CancellationToken cancellationToken = default(CancellationToken)) where T : class
		{
			cancellationToken.ThrowIfCancellationRequested();
			return (T)await (MergeAsync(entityName, (object)entity, cancellationToken)).ConfigureAwait(false);
		}

		public Task<object> MergeAsync(object obj, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return MergeAsync(null, obj, cancellationToken);
		}

		public async Task PersistAsync(string entityName, object obj, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FirePersistAsync(new PersistEvent(entityName, obj, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public Task PersistAsync(object obj, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return PersistAsync(null, obj, cancellationToken);
		}

		public async Task PersistOnFlushAsync(string entityName, object obj, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FirePersistOnFlushAsync(new PersistEvent(entityName, obj, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public Task PersistOnFlushAsync(object obj, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return PersistAsync(null, obj, cancellationToken);
		}

		public override async Task<object> GetEntityUsingInterceptorAsync(EntityKey key, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				// todo : should this get moved to PersistentContext?
				// logically, is PersistentContext the "thing" to which an interceptor gets attached?
				object result = persistenceContext.GetEntity(key);

				if (result == null)
				{
					object newObject = Interceptor.GetEntity(key.EntityName, key.Identifier);
					if (newObject != null)
					{
						await (LockAsync(newObject, LockMode.None, cancellationToken)).ConfigureAwait(false);
					}
					return newObject;
				}
				else
				{
					return result;
				}
			}
		}

		/// <summary>
		/// detect in-memory changes, determine if the changes are to tables
		/// named in the query and, if so, complete execution the flush
		/// </summary>
		/// <param name="querySpaces"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns>Returns true if flush was executed</returns>
		public override async Task<bool> AutoFlushIfRequiredAsync(ISet<string> querySpaces, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				if (!ConnectionManager.IsInActiveTransaction)
				{
					// do not auto-flush while outside a transaction
					return false;
				}
				AutoFlushEvent autoFlushEvent = new AutoFlushEvent(querySpaces, this);
				IAutoFlushEventListener[] autoFlushEventListener = listeners.AutoFlushEventListeners;
				for (int i = 0; i < autoFlushEventListener.Length; i++)
				{
					await (autoFlushEventListener[i].OnAutoFlushAsync(autoFlushEvent, cancellationToken)).ConfigureAwait(false);
				}
				return autoFlushEvent.FlushRequired;
			}
		}

		#region load()/get() operations

		public async Task LoadAsync(object obj, object id, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				LoadEvent loadEvent = new LoadEvent(id, obj, this);
				await (FireLoadAsync(loadEvent, LoadEventListener.Reload, cancellationToken)).ConfigureAwait(false);
			}
		}

		public async Task<T> LoadAsync<T>(object id, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				return (T)await (LoadAsync(typeof(T), id, cancellationToken)).ConfigureAwait(false);
			}
		}

		public async Task<T> LoadAsync<T>(object id, LockMode lockMode, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				return (T)await (LoadAsync(typeof(T), id, lockMode, cancellationToken)).ConfigureAwait(false);
			}
		}

		/// <summary>
		/// Load the data for the object with the specified id into a newly created object
		/// using "for update", if supported. A new key will be assigned to the object.
		/// This should return an existing proxy where appropriate.
		///
		/// If the object does not exist in the database, an exception is thrown.
		/// </summary>
		/// <param name="entityClass"></param>
		/// <param name="id"></param>
		/// <param name="lockMode"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns></returns>
		/// <exception cref="ObjectNotFoundException">
		/// Thrown when the object with the specified id does not exist in the database.
		/// </exception>
		public Task<object> LoadAsync(System.Type entityClass, object id, LockMode lockMode, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return LoadAsync(entityClass.FullName, id, lockMode, cancellationToken);
		}

		public async Task<object> LoadAsync(string entityName, object id, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				if (id == null)
				{
					throw new ArgumentNullException("id", "null is not a valid identifier");
				}

				var @event = new LoadEvent(id, entityName, false, this);
				bool success = false;
				try
				{
					await (FireLoadAsync(@event, LoadEventListener.Load, cancellationToken)).ConfigureAwait(false);
					if (@event.Result == null)
					{
						Factory.EntityNotFoundDelegate.HandleEntityNotFound(entityName, id);
					}
					success = true;
					return @event.Result;
				}
				finally
				{
					await (AfterOperationAsync(success, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		public async Task<object> LoadAsync(string entityName, object id, LockMode lockMode, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				var @event = new LoadEvent(id, entityName, lockMode, this);
				await (FireLoadAsync(@event, LoadEventListener.Load, cancellationToken)).ConfigureAwait(false);
				return @event.Result;
			}
		}

		public Task<object> LoadAsync(System.Type entityClass, object id, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return LoadAsync(entityClass.FullName, id, cancellationToken);
		}

		public async Task<T> GetAsync<T>(object id, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				return (T)await (GetAsync(typeof(T), id, cancellationToken)).ConfigureAwait(false);
			}
		}

		public async Task<T> GetAsync<T>(object id, LockMode lockMode, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				return (T)await (GetAsync(typeof(T), id, lockMode, cancellationToken)).ConfigureAwait(false);
			}
		}

		public Task<object> GetAsync(System.Type entityClass, object id, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return GetAsync(entityClass.FullName, id, cancellationToken);
		}

		/// <summary>
		/// Load the data for the object with the specified id into a newly created object
		/// using "for update", if supported. A new key will be assigned to the object.
		/// This should return an existing proxy where appropriate.
		///
		/// If the object does not exist in the database, null is returned.
		/// </summary>
		/// <param name="clazz"></param>
		/// <param name="id"></param>
		/// <param name="lockMode"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns></returns>
		public async Task<object> GetAsync(System.Type clazz, object id, LockMode lockMode, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				LoadEvent loadEvent = new LoadEvent(id, clazz.FullName, lockMode, this);
				await (FireLoadAsync(loadEvent, LoadEventListener.Get, cancellationToken)).ConfigureAwait(false);
				return loadEvent.Result;
			}
		}

		public async Task<string> GetEntityNameAsync(object obj, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				if (obj.IsProxy())
				{
					var proxy = obj as INHibernateProxy;

					if (!persistenceContext.ContainsProxy(proxy))
					{
						throw new TransientObjectException("proxy was not associated with the session");
					}
					ILazyInitializer li = proxy.HibernateLazyInitializer;

					obj = await (li.GetImplementationAsync(cancellationToken)).ConfigureAwait(false);
				}

				EntityEntry entry = persistenceContext.GetEntry(obj);
				if (entry == null)
				{
					throw new TransientObjectException(
						"object references an unsaved transient instance - save the transient instance before flushing or set cascade action for the property to something that would make it autosave: "
						+ obj.GetType().FullName);
				}
				return entry.Persister.EntityName;
			}
		}

		public async Task<object> GetAsync(string entityName, object id, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				LoadEvent loadEvent = new LoadEvent(id, entityName, false, this);
				bool success = false;
				try
				{
					await (FireLoadAsync(loadEvent, LoadEventListener.Get, cancellationToken)).ConfigureAwait(false);
					success = true;
					return loadEvent.Result;
				}
				finally
				{
					await (AfterOperationAsync(success, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		/// <summary>
		/// Load the data for the object with the specified id into a newly created object.
		/// This is only called when lazily initializing a proxy.
		/// Do NOT return a proxy.
		/// </summary>
		public override async Task<object> ImmediateLoadAsync(string entityName, object id, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				if (log.IsDebugEnabled())
				{
					IEntityPersister persister = Factory.GetEntityPersister(entityName);
					log.Debug("initializing proxy: {0}", MessageHelper.InfoString(persister, id, Factory));
				}

				LoadEvent loadEvent = new LoadEvent(id, entityName, true, this);
				await (FireLoadAsync(loadEvent, LoadEventListener.ImmediateLoad, cancellationToken)).ConfigureAwait(false);
				return loadEvent.Result;
			}
		}

		/// <summary>
		/// Return the object with the specified id or throw exception if no row with that id exists. Defer the load,
		/// return a new proxy or return an existing proxy if possible. Do not check if the object was deleted.
		/// </summary>
		public override async Task<object> InternalLoadAsync(string entityName, object id, bool eager, bool isNullable, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				// todo : remove
				LoadType type = isNullable
									? LoadEventListener.InternalLoadNullable
									: (eager ? LoadEventListener.InternalLoadEager : LoadEventListener.InternalLoadLazy);
				LoadEvent loadEvent = new LoadEvent(id, entityName, true, this);
				await (FireLoadAsync(loadEvent, type, cancellationToken)).ConfigureAwait(false);
				if (!isNullable)
				{
					UnresolvableObjectException.ThrowIfNull(loadEvent.Result, id, entityName);
				}
				return loadEvent.Result;
			}
		}

		#endregion

		public async Task RefreshAsync(object obj, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireRefreshAsync(new RefreshEvent(obj, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public async Task RefreshAsync(object obj, LockMode lockMode, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireRefreshAsync(new RefreshEvent(obj, lockMode, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		/// <summary>
		///
		/// </summary>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <remarks>
		/// This can be called from commit() or at the start of a List() method.
		/// <para>
		/// Perform all the necessary SQL statements in a sensible order, to allow
		/// users to respect foreign key constraints:
		/// <list type="">
		///		<item>Inserts, in the order they were performed</item>
		///		<item>Updates</item>
		///		<item>Deletion of collection elements</item>
		///		<item>Insertion of collection elements</item>
		///		<item>Deletes, in the order they were performed</item>
		/// </list>
		/// </para>
		/// <para>
		/// Go through all the persistent objects and look for collections they might be
		/// holding. If they had a nonpersistable collection, substitute a persistable one
		/// </para>
		/// </remarks>
		public override async Task FlushAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				if (persistenceContext.CascadeLevel > 0)
				{
					throw new HibernateException("Flush during cascade is dangerous");
				}
				using (SuspendAutoFlush())
				{
					IFlushEventListener[] flushEventListener = listeners.FlushEventListeners;
					for (int i = 0; i < flushEventListener.Length; i++)
					{
						await (flushEventListener[i].OnFlushAsync(new FlushEvent(this), cancellationToken)).ConfigureAwait(false);
					}
				}
			}
		}

		public async Task<bool> IsDirtyAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				log.Debug("checking session dirtiness");
				if (actionQueue.AreInsertionsOrDeletionsQueued)
				{
					log.Debug("session dirty (scheduled updates and insertions)");
					return true;
				}
				else
				{
					DirtyCheckEvent dcEvent = new DirtyCheckEvent(this);
					IDirtyCheckEventListener[] dirtyCheckEventListener = listeners.DirtyCheckEventListeners;
					for (int i = 0; i < dirtyCheckEventListener.Length; i++)
					{
						await (dirtyCheckEventListener[i].OnDirtyCheckAsync(dcEvent, cancellationToken)).ConfigureAwait(false);
					}
					return dcEvent.Dirty;
				}
			}
		}

		/// <summary>
		/// called by a collection that wants to initialize itself
		/// </summary>
		/// <param name="collection"></param>
		/// <param name="writing"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		public override async Task InitializeCollectionAsync(IPersistentCollection collection, bool writing, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				IInitializeCollectionEventListener[] listener = listeners.InitializeCollectionEventListeners;
				for (int i = 0; i < listener.Length; i++)
				{
					await (listener[i].OnInitializeCollectionAsync(new InitializeCollectionEvent(collection, this), cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		private async Task FilterAsync(object collection, string filter, QueryParameters queryParameters, IList results, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				var plan = await (GetFilterQueryPlanAsync(collection, filter, queryParameters, false, cancellationToken)).ConfigureAwait(false);

				bool success = false;
				using (SuspendAutoFlush()) //stops flush being called multiple times if this method is recursively called
				{
					try
					{
						await (plan.PerformListAsync(queryParameters, this, results, cancellationToken)).ConfigureAwait(false);
						success = true;
					}
					catch (OperationCanceledException) { throw; }
					catch (HibernateException)
					{
						// Do not call Convert on HibernateExceptions
						throw;
					}
					catch (Exception e)
					{
						throw Convert(e, "could not execute query");
					}
					finally
					{
						await (AfterOperationAsync(success, cancellationToken)).ConfigureAwait(false);
					}
				}
			}
		}

		public override async Task<IList> ListFilterAsync(object collection, string filter, QueryParameters queryParameters, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			var results = new List<object>();
			await (FilterAsync(collection, filter, queryParameters, results, cancellationToken)).ConfigureAwait(false);
			return results;
		}

		public override async Task<IList<T>> ListFilterAsync<T>(object collection, string filter, QueryParameters queryParameters, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			List<T> results = new List<T>();
			await (FilterAsync(collection, filter, queryParameters, results, cancellationToken)).ConfigureAwait(false);
			return results;
		}

		/// <inheritdoc />
		// Since v5.3
		[Obsolete("Use AsyncEnumerableFilter extension method instead.")]
		public override async Task<IEnumerable> EnumerableFilterAsync(object collection, string filter, QueryParameters queryParameters, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				var plan = await (GetFilterQueryPlanAsync(collection, filter, queryParameters, true, cancellationToken)).ConfigureAwait(false);
				return plan.PerformIterate(queryParameters, this);
			}
		}

		/// <inheritdoc />
		// Since v5.3
		[Obsolete("Use AsyncEnumerableFilter extension method instead.")]
		public override async Task<IEnumerable<T>> EnumerableFilterAsync<T>(object collection, string filter, QueryParameters queryParameters, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				var plan = await (GetFilterQueryPlanAsync(collection, filter, queryParameters, true, cancellationToken)).ConfigureAwait(false);
				return plan.PerformIterate<T>(queryParameters, this);
			}
		}

		public override async Task ListAsync(CriteriaImpl criteria, IList results, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				string[] implementors = Factory.GetImplementors(criteria.EntityOrClassName);
				int size = implementors.Length;

				CriteriaLoader[] loaders = new CriteriaLoader[size];
				ISet<string> spaces = new HashSet<string>();

				for (int i = 0; i < size; i++)
				{
					loaders[i] = new CriteriaLoader(
						GetOuterJoinLoadable(implementors[i]),
						Factory,
						criteria,
						implementors[i],
						enabledFilters
						);

					spaces.UnionWith(loaders[i].QuerySpaces);
				}

				await (AutoFlushIfRequiredAsync(spaces, cancellationToken)).ConfigureAwait(false);

				bool success = false;
				using (SuspendAutoFlush())
				{
					try
					{
						for (int i = size - 1; i >= 0; i--)
						{
							ArrayHelper.AddAll(results, await (loaders[i].ListAsync(this, cancellationToken)).ConfigureAwait(false));
						}
						success = true;
					}
					catch (OperationCanceledException) { throw; }
					catch (HibernateException)
					{
						// Do not call Convert on HibernateExceptions
						throw;
					}
					catch (Exception sqle)
					{
						throw Convert(sqle, "Unable to perform find");
					}
					finally
					{
						await (AfterOperationAsync(success, cancellationToken)).ConfigureAwait(false);
					}
				}
			}
		}

		/// <summary>
		/// remove any hard references to the entity that are held by the infrastructure
		/// (references held by application or other persistant instances are okay)
		/// </summary>
		/// <param name="obj"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		public async Task EvictAsync(object obj, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireEvictAsync(new EvictEvent(obj, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public override async Task ListCustomQueryAsync(ICustomQuery customQuery, QueryParameters queryParameters, IList results, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				CustomLoader loader = new CustomLoader(customQuery, Factory);
				await (AutoFlushIfRequiredAsync(loader.QuerySpaces, cancellationToken)).ConfigureAwait(false);

				bool success = false;
				using (SuspendAutoFlush())
				{
					try
					{
						ArrayHelper.AddAll(results, await (loader.ListAsync(this, queryParameters, cancellationToken)).ConfigureAwait(false));
						success = true;
					}
					finally
					{
						await (AfterOperationAsync(success, cancellationToken)).ConfigureAwait(false);
					}
				}
			}
		}

		public async Task ReplicateAsync(object obj, ReplicationMode replicationMode, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireReplicateAsync(new ReplicateEvent(obj, replicationMode, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public async Task ReplicateAsync(string entityName, object obj, ReplicationMode replicationMode, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				await (FireReplicateAsync(new ReplicateEvent(entityName, obj, replicationMode, this), cancellationToken)).ConfigureAwait(false);
			}
		}

		public override async Task BeforeTransactionCompletionAsync(ITransaction tx, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginContext())
			{
				log.Debug("before transaction completion");
				var context = TransactionContext;
				if (tx == null && context == null)
					throw new InvalidOperationException("Cannot complete a transaction without neither an explicit transaction nor an ambient one.");
				// Always allow flushing from explicit transactions, otherwise check if flushing from scope is enabled.
				if (tx != null || context.CanFlushOnSystemTransactionCompleted)
					await (FlushBeforeTransactionCompletionAsync(cancellationToken)).ConfigureAwait(false);
				await (actionQueue.BeforeTransactionCompletionAsync(cancellationToken)).ConfigureAwait(false);
				try
				{
					Interceptor.BeforeTransactionCompletion(tx);
				}
				catch (Exception e)
				{
					log.Error(e, "exception in interceptor BeforeTransactionCompletion()");

					throw;
				}
			}
		}

		public override Task FlushBeforeTransactionCompletionAsync(CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			if (FlushMode != FlushMode.Manual)
				return FlushAsync(cancellationToken);
			return Task.CompletedTask;
		}

		private async Task FireDeleteAsync(DeleteEvent @event, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				IDeleteEventListener[] deleteEventListener = listeners.DeleteEventListeners;
				for (int i = 0; i < deleteEventListener.Length; i++)
				{
					await (deleteEventListener[i].OnDeleteAsync(@event, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		private async Task FireDeleteAsync(DeleteEvent @event, ISet<object> transientEntities, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				IDeleteEventListener[] deleteEventListener = listeners.DeleteEventListeners;
				for (int i = 0; i < deleteEventListener.Length; i++)
				{
					await (deleteEventListener[i].OnDeleteAsync(@event, transientEntities, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		private async Task FireEvictAsync(EvictEvent evictEvent, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				IEvictEventListener[] evictEventListener = listeners.EvictEventListeners;
				for (int i = 0; i < evictEventListener.Length; i++)
				{
					await (evictEventListener[i].OnEvictAsync(evictEvent, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		private async Task FireLoadAsync(LoadEvent @event, LoadType loadType, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				ILoadEventListener[] loadEventListener = listeners.LoadEventListeners;
				for (int i = 0; i < loadEventListener.Length; i++)
				{
					await (loadEventListener[i].OnLoadAsync(@event, loadType, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		private async Task FireLockAsync(LockEvent lockEvent, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				ILockEventListener[] lockEventListener = listeners.LockEventListeners;
				for (int i = 0; i < lockEventListener.Length; i++)
				{
					await (lockEventListener[i].OnLockAsync(lockEvent, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		private async Task<object> FireMergeAsync(MergeEvent @event, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				IMergeEventListener[] mergeEventListener = listeners.MergeEventListeners;
				for (int i = 0; i < mergeEventListener.Length; i++)
				{
					await (mergeEventListener[i].OnMergeAsync(@event, cancellationToken)).ConfigureAwait(false);
				}
				return @event.Result;
			}
		}

		private async Task FireMergeAsync(IDictionary copiedAlready, MergeEvent @event, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				IMergeEventListener[] mergeEventListener = listeners.MergeEventListeners;
				for (int i = 0; i < mergeEventListener.Length; i++)
				{
					await (mergeEventListener[i].OnMergeAsync(@event, copiedAlready, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		private async Task FirePersistAsync(IDictionary copiedAlready, PersistEvent @event, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				IPersistEventListener[] persistEventListener = listeners.PersistEventListeners;
				for (int i = 0; i < persistEventListener.Length; i++)
				{
					await (persistEventListener[i].OnPersistAsync(@event, copiedAlready, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		private async Task FirePersistAsync(PersistEvent @event, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				IPersistEventListener[] createEventListener = listeners.PersistEventListeners;
				for (int i = 0; i < createEventListener.Length; i++)
				{
					await (createEventListener[i].OnPersistAsync(@event, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		private async Task FirePersistOnFlushAsync(IDictionary copiedAlready, PersistEvent @event, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				IPersistEventListener[] persistEventListener = listeners.PersistOnFlushEventListeners;
				for (int i = 0; i < persistEventListener.Length; i++)
				{
					await (persistEventListener[i].OnPersistAsync(@event, copiedAlready, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		private async Task FirePersistOnFlushAsync(PersistEvent @event, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				IPersistEventListener[] createEventListener = listeners.PersistOnFlushEventListeners;
				for (int i = 0; i < createEventListener.Length; i++)
				{
					await (createEventListener[i].OnPersistAsync(@event, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		private async Task FireRefreshAsync(RefreshEvent refreshEvent, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				IRefreshEventListener[] refreshEventListener = listeners.RefreshEventListeners;
				for (int i = 0; i < refreshEventListener.Length; i++)
				{
					await (refreshEventListener[i].OnRefreshAsync(refreshEvent, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		private async Task FireRefreshAsync(IDictionary refreshedAlready, RefreshEvent refreshEvent, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				IRefreshEventListener[] refreshEventListener = listeners.RefreshEventListeners;
				for (int i = 0; i < refreshEventListener.Length; i++)
				{
					await (refreshEventListener[i].OnRefreshAsync(refreshEvent, refreshedAlready, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		private async Task FireReplicateAsync(ReplicateEvent @event, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				IReplicateEventListener[] replicateEventListener = listeners.ReplicateEventListeners;
				for (int i = 0; i < replicateEventListener.Length; i++)
				{
					await (replicateEventListener[i].OnReplicateAsync(@event, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		private async Task<object> FireSaveAsync(SaveOrUpdateEvent @event, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				ISaveOrUpdateEventListener[] saveEventListener = listeners.SaveEventListeners;
				for (int i = 0; i < saveEventListener.Length; i++)
				{
					await (saveEventListener[i].OnSaveOrUpdateAsync(@event, cancellationToken)).ConfigureAwait(false);
				}
				return @event.ResultId;
			}
		}

		private async Task FireSaveOrUpdateAsync(SaveOrUpdateEvent @event, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				ISaveOrUpdateEventListener[] saveOrUpdateEventListener = listeners.SaveOrUpdateEventListeners;
				for (int i = 0; i < saveOrUpdateEventListener.Length; i++)
				{
					await (saveOrUpdateEventListener[i].OnSaveOrUpdateAsync(@event, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		private async Task FireUpdateAsync(SaveOrUpdateEvent @event, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				ISaveOrUpdateEventListener[] updateEventListener = listeners.UpdateEventListeners;
				for (int i = 0; i < updateEventListener.Length; i++)
				{
					await (updateEventListener[i].OnSaveOrUpdateAsync(@event, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		public override async Task<int> ExecuteNativeUpdateAsync(NativeSQLQuerySpecification nativeQuerySpecification, QueryParameters queryParameters, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				queryParameters.ValidateParameters();
				NativeSQLQueryPlan plan = GetNativeSQLQueryPlan(nativeQuerySpecification);

				await (AutoFlushIfRequiredAsync(plan.CustomQuery.QuerySpaces, cancellationToken)).ConfigureAwait(false);

				bool success = false;
				int result;
				try
				{
					result = await (plan.PerformExecuteUpdateAsync(queryParameters, this, cancellationToken)).ConfigureAwait(false);
					success = true;
				}
				finally
				{
					await (AfterOperationAsync(success, cancellationToken)).ConfigureAwait(false);
				}
				return result;
			}
		}

		public override async Task<int> ExecuteUpdateAsync(IQueryExpression queryExpression, QueryParameters queryParameters, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			using (BeginProcess())
			{
				queryParameters.ValidateParameters();
				var plan = GetHQLQueryPlan(queryExpression, false);
				await (AutoFlushIfRequiredAsync(plan.QuerySpaces, cancellationToken)).ConfigureAwait(false);

				bool success = false;
				int result;
				try
				{
					result = await (plan.PerformExecuteUpdateAsync(queryParameters, this, cancellationToken)).ConfigureAwait(false);
					success = true;
				}
				finally
				{
					await (AfterOperationAsync(success, cancellationToken)).ConfigureAwait(false);
				}
				return result;
			}
		}
	}
}
