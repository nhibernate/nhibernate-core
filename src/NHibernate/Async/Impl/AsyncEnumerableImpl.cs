//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Collections.Generic;
using System.Data.Common;
using System.Threading;
using System.Threading.Tasks;
using NHibernate.Engine;
using NHibernate.Exceptions;
using NHibernate.SqlCommand;
using NHibernate.Transform;
using NHibernate.Type;

namespace NHibernate.Impl
{

	internal partial class AsyncEnumerableImpl<T> : IAsyncEnumerable<T>, IEnumerable<T>
	{

		internal sealed partial class AsyncEnumeratorImpl : IAsyncEnumerator<T>, IEnumerator<T>
		{

			private async Task ReadAsync(CancellationToken cancellationToken)
			{
				cancellationToken.ThrowIfCancellationRequested();
				try
				{
					_hasNext = await (_reader.ReadAsync(cancellationToken)).ConfigureAwait(false);
					_startedReading = true;
					_currentRow++;
				}
				catch (DbException e)
				{
					throw ADOExceptionHelper.Convert(_session.Factory.SQLExceptionConverter, e, "Error executing Enumerable() query",
													   new SqlString(_command.CommandText));
				}

				await (PostReadAsync(cancellationToken)).ConfigureAwait(false);
			}

			private async Task PostReadAsync(CancellationToken cancellationToken)
			{
				cancellationToken.ThrowIfCancellationRequested();
				if (_selection != null && _selection.MaxRows != RowSelection.NoValue)
				{
					_hasNext = _hasNext && (_currentRow < _selection.MaxRows);
				}

				bool sessionDefaultReadOnlyOrig = _session.PersistenceContext.DefaultReadOnly;
				_session.PersistenceContext.DefaultReadOnly = _readOnly;
				try
				{
					await (MaterializeAndSetCurrentAsync(cancellationToken)).ConfigureAwait(false);
				}
				finally
				{
					_session.PersistenceContext.DefaultReadOnly = sessionDefaultReadOnlyOrig;
				}
			}

			private async Task MaterializeAndSetCurrentAsync(CancellationToken cancellationToken)
			{
				cancellationToken.ThrowIfCancellationRequested();
				if (!_hasNext)
				{
					// there are no more records in the DataReader so clean up
					Log.Debug("exhausted results");
					Current = default;
					_session.Batcher.CloseCommand(_command, _reader);
					return;
				}

				Log.Debug("retrieving next results");
				if (_single && _resultTransformer == null)
				{
					SetCurrent(await (_types[0].NullSafeGetAsync(_reader, _columnNames[0], _session, null, cancellationToken)).ConfigureAwait(false));
					return;
				}

				var currentResults = new object[_types.Length];
				// move through each of the ITypes contained in the DbDataReader and convert them
				// to their objects.  
				for (int i = 0; i < _types.Length; i++)
				{
					// The IType knows how to extract its value out of the DbDataReader.  If the IType
					// is a value type then the value will simply be pulled out of the DbDataReader.  If
					// the IType is an Entity type then the IType will extract the id from the DbDataReader
					// and use the ISession to load an instance of the object.
					currentResults[i] = await (_types[i].NullSafeGetAsync(_reader, _columnNames[i], _session, null, cancellationToken)).ConfigureAwait(false);
				}

				SetCurrent(_resultTransformer != null
						? _resultTransformer.TransformTuple(currentResults, _returnAliases)
						: currentResults);
			}
		}
	}
}
