//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using NHibernate.Util;

namespace NHibernate.Id.Enhanced
{
	using System.Threading.Tasks;
	using System.Threading;
	public partial class OptimizerFactory
	{

		#region Nested type: HiLoOptimizer

		public partial class HiLoOptimizer : OptimizerSupport
		{

			public override async Task<object> GenerateAsync(IAccessCallback callback, CancellationToken cancellationToken)
			{
				cancellationToken.ThrowIfCancellationRequested();
				using (await (_asyncLock.LockAsync()).ConfigureAwait(false))
				{
					if (_lastSourceValue < 0)
					{
						_lastSourceValue = await (callback.GetNextValueAsync(cancellationToken)).ConfigureAwait(false);
						while (_lastSourceValue <= 0)
						{
							_lastSourceValue = await (callback.GetNextValueAsync(cancellationToken)).ConfigureAwait(false);
						}

						// upperLimit defines the upper end of the bucket values
						_upperLimit = (_lastSourceValue * IncrementSize) + 1;

						// initialize value to the low end of the bucket
						_value = _upperLimit - IncrementSize;
					}
					else if (_upperLimit <= _value)
					{
						_lastSourceValue = await (callback.GetNextValueAsync(cancellationToken)).ConfigureAwait(false);
						_upperLimit = (_lastSourceValue * IncrementSize) + 1;
					}

					return Make(_value++);
				}
			}
		}

		#endregion

		#region Nested type: NoopOptimizer

		public partial class NoopOptimizer : OptimizerSupport
		{

			public override async Task<object> GenerateAsync(IAccessCallback callback, CancellationToken cancellationToken)
			{
				cancellationToken.ThrowIfCancellationRequested();
				// We must use a local variable here to avoid concurrency issues.
				// With the local value we can avoid synchronizing the whole method.

				long val = -1;
				while (val <= 0)
					val = await (callback.GetNextValueAsync(cancellationToken)).ConfigureAwait(false);

				// This value is only stored for easy access in test. Should be no
				// threading concerns there.
				_lastSourceValue = val;

				return Make(val);
			}
		}

		#endregion

		#region Nested type: OptimizerSupport

		public abstract partial class OptimizerSupport : IOptimizer
		{

			#region IOptimizer Members

			public abstract Task<object> GenerateAsync(IAccessCallback param, CancellationToken cancellationToken);

			#endregion
		}

		#endregion

		#region Nested type: PooledOptimizer

		public partial class PooledOptimizer : OptimizerSupport, IInitialValueAwareOptimizer
		{

			public override async Task<object> GenerateAsync(IAccessCallback callback, CancellationToken cancellationToken)
			{
				cancellationToken.ThrowIfCancellationRequested();
				using (await (_asyncLock.LockAsync()).ConfigureAwait(false))
				{
					if (_hiValue < 0)
					{
						_value = await (callback.GetNextValueAsync(cancellationToken)).ConfigureAwait(false);
						if (_value < 1)
						{
							// unfortunately not really safe to normalize this
							// to 1 as an initial value like we do the others
							// because we would not be able to control this if
							// we are using a sequence...
							Log.Info("pooled optimizer source reported [{0}] as the initial value; use of 1 or greater highly recommended", _value);
						}

						if ((_initialValue == -1 && _value < IncrementSize) || _value == _initialValue)
							_hiValue = await (callback.GetNextValueAsync(cancellationToken)).ConfigureAwait(false);
						else
						{
							_hiValue = _value;
							_value = _hiValue - IncrementSize;
						}
					}
					else if (_value >= _hiValue)
					{
						_hiValue = await (callback.GetNextValueAsync(cancellationToken)).ConfigureAwait(false);
						_value = _hiValue - IncrementSize;
					}

					return Make(_value++);
				}
			}
		}

		#endregion

		#region Nested type: PooledLoOptimizer

		public partial class PooledLoOptimizer : OptimizerSupport
		{

			public override async Task<object> GenerateAsync(IAccessCallback callback, CancellationToken cancellationToken)
			{
				cancellationToken.ThrowIfCancellationRequested();
				using (await (_asyncLock.LockAsync()).ConfigureAwait(false))
				{
					if (_lastSourceValue < 0 || _value >= (_lastSourceValue + IncrementSize))
					{
						_lastSourceValue = await (callback.GetNextValueAsync(cancellationToken)).ConfigureAwait(false);
						_value = _lastSourceValue;
						// handle cases where initial-value is less than one (hsqldb for instance).
						while (_value < 1)
							_value++;
					}

					return Make(_value++);
				}
			}
		}

		#endregion
	}
}
