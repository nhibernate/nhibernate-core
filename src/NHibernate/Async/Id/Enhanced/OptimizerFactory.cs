//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections.Concurrent;
using System.Reflection;
using NHibernate.Util;

namespace NHibernate.Id.Enhanced
{
	using System.Threading.Tasks;
	using System.Threading;
	public partial class OptimizerFactory
	{

		#region Nested type: HiLoOptimizer

		public partial class HiLoOptimizer : OptimizerSupport
		{

			public override async Task<object> GenerateAsync(IAccessCallback callback, CancellationToken cancellationToken)
			{
				cancellationToken.ThrowIfCancellationRequested();
				using (await (_asyncLock.LockAsync()).ConfigureAwait(false))
				{
					var generationState = _stateStore.LocateGenerationState(callback.GetTenantIdentifier());

					if (generationState.LastSourceValue < 0)
					{
						generationState.LastSourceValue = await (callback.GetNextValueAsync(cancellationToken)).ConfigureAwait(false);
						while (generationState.LastSourceValue <= 0)
						{
							generationState.LastSourceValue = await (callback.GetNextValueAsync(cancellationToken)).ConfigureAwait(false);
						}

						// upperLimit defines the upper end of the bucket values
						generationState.UpperLimit = (generationState.LastSourceValue * IncrementSize) + 1;

						// initialize value to the low end of the bucket
						generationState.Value = generationState.UpperLimit - IncrementSize;
					}
					else if (generationState.UpperLimit <= generationState.Value)
					{
						generationState.LastSourceValue = await (callback.GetNextValueAsync(cancellationToken)).ConfigureAwait(false);
						generationState.UpperLimit = (generationState.LastSourceValue * IncrementSize) + 1;
					}

					return Make(generationState.Value++);
				}
			}
		}

		#endregion

		#region Nested type: NoopOptimizer

		public partial class NoopOptimizer : OptimizerSupport
		{

			public override async Task<object> GenerateAsync(IAccessCallback callback, CancellationToken cancellationToken)
			{
				cancellationToken.ThrowIfCancellationRequested();
				// We must use a local variable here to avoid concurrency issues.
				// With the local value we can avoid synchronizing the whole method.

				long val = -1;
				while (val <= 0)
					val = await (callback.GetNextValueAsync(cancellationToken)).ConfigureAwait(false);

				// This value is only stored for easy access in test. Should be no
				// threading concerns there.
				_lastSourceValue = val;

				return Make(val);
			}
		}

		#endregion

		#region Nested type: OptimizerSupport

		public abstract partial class OptimizerSupport : IOptimizer
		{

			#region IOptimizer Members

			public abstract Task<object> GenerateAsync(IAccessCallback param, CancellationToken cancellationToken);

			#endregion
		}

		#endregion

		#region Nested type: PooledOptimizer

		public partial class PooledOptimizer : OptimizerSupport, IInitialValueAwareOptimizer
		{

			public override async Task<object> GenerateAsync(IAccessCallback callback, CancellationToken cancellationToken)
			{
				cancellationToken.ThrowIfCancellationRequested();
				using (await (_asyncLock.LockAsync()).ConfigureAwait(false))
				{
					var generationState = _stateStore.LocateGenerationState(callback.GetTenantIdentifier());

					if (generationState.HiValue < 0)
					{
						generationState.Value = await (callback.GetNextValueAsync(cancellationToken)).ConfigureAwait(false);
						if (generationState.Value < 1)
						{
							// unfortunately not really safe to normalize this
							// to 1 as an initial value like we do the others
							// because we would not be able to control this if
							// we are using a sequence...
							Log.Info("pooled optimizer source reported [{0}] as the initial value; use of 1 or greater highly recommended", generationState.Value);
						}

						if ((_initialValue == -1 && generationState.Value < IncrementSize) || generationState.Value == _initialValue)
							generationState.HiValue = await (callback.GetNextValueAsync(cancellationToken)).ConfigureAwait(false);
						else
						{
							generationState.HiValue = generationState.Value;
							generationState.Value = generationState.HiValue - IncrementSize;
						}
					}
					else if (generationState.Value >= generationState.HiValue)
					{
						generationState.HiValue = await (callback.GetNextValueAsync(cancellationToken)).ConfigureAwait(false);
						generationState.Value = generationState.HiValue - IncrementSize;
					}

					return Make(generationState.Value++);
				}
			}
		}
		#endregion

		#region Nested type: PooledLoOptimizer

		public partial class PooledLoOptimizer : OptimizerSupport
		{

			public override async Task<object> GenerateAsync(IAccessCallback callback, CancellationToken cancellationToken)
			{
				cancellationToken.ThrowIfCancellationRequested();
				using (await (_asyncLock.LockAsync()).ConfigureAwait(false))
				{
					var generationState = _stateStore.LocateGenerationState(callback.GetTenantIdentifier());

					if (generationState.LastSourceValue < 0 || generationState.Value >= (generationState.LastSourceValue + IncrementSize))
					{
						generationState.LastSourceValue = await (callback.GetNextValueAsync(cancellationToken)).ConfigureAwait(false);
						generationState.Value = generationState.LastSourceValue;
						// handle cases where initial-value is less than one (hsqldb for instance).
						if (generationState.Value < 1)
						{
							generationState.Value = 1;
						}
					}

					return Make(generationState.Value++);
				}
			}
		}

		#endregion
	}
}
