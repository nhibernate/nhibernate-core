//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Collections.Generic;
using System.Data.Common;
using System.Linq;
using NHibernate.Cache;
using NHibernate.Engine;
using NHibernate.Loader;
using NHibernate.SqlCommand;
using NHibernate.Type;
using NHibernate.Util;

namespace NHibernate.Multi
{
	using System.Threading.Tasks;
	using System.Threading;
	public abstract partial class QueryBatchItemBase<TResult> : IQueryBatchItem<TResult>, IQueryBatchItemWithAsyncProcessResults
	{

		/// <inheritdoc />
		public async Task<int> ProcessResultsSetAsync(DbDataReader reader, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			ThrowIfNotInitialized();

			var dialect = Session.Factory.Dialect;
			var hydratedObjects = new List<object>[_queryInfos.Count];
			var isDebugLog = Log.IsDebugEnabled();

			using (Session.SwitchCacheMode(_cacheMode))
			{
				var rowCount = 0;
				for (var i = 0; i < _queryInfos.Count; i++)
				{
					var queryInfo = _queryInfos[i];
					var loader = queryInfo.QueryLoader;
					var queryParameters = queryInfo.Parameters;

					//Skip processing for items already loaded from cache
					if (queryInfo.IsResultFromCache)
					{
						continue;
					}

					var entitySpan = loader.EntityPersisters.Length;
					hydratedObjects[i] = entitySpan == 0 ? null : new List<object>(entitySpan);
					var keys = new EntityKey[entitySpan];

					var selection = queryParameters.RowSelection;
					var createSubselects = loader.IsSubselectLoadingEnabled;

					_subselectResultKeys[i] = createSubselects ? new List<EntityKey[]>() : null;
					var maxRows = Loader.Loader.HasMaxRows(selection) ? selection.MaxRows : int.MaxValue;
					var advanceSelection = !dialect.SupportsLimitOffset || !loader.UseLimit(selection, dialect);

					if (advanceSelection)
					{
						await (Loader.Loader.AdvanceAsync(reader, selection, cancellationToken)).ConfigureAwait(false);
					}

					var forcedResultTransformer = queryInfo.CacheKey?.ResultTransformer;
					if (queryParameters.HasAutoDiscoverScalarTypes)
					{
						loader.AutoDiscoverTypes(reader, queryParameters, forcedResultTransformer);
					}

					var lockModeArray = loader.GetLockModes(queryParameters.LockModes);
					var optionalObjectKey = Loader.Loader.GetOptionalObjectKey(queryParameters, Session);
					var tmpResults = new List<object>();
					var queryCacheBuilder = queryInfo.IsCacheable ? new QueryCacheResultBuilder(loader) : null;
					var cacheBatcher = queryInfo.CacheBatcher;
					var ownCacheBatcher = cacheBatcher == null;
					if (ownCacheBatcher)
						cacheBatcher = new CacheBatcher(Session);

					if (isDebugLog)
						Log.Debug("processing result set");

					int count;
					for (count = 0; count < maxRows && await (reader.ReadAsync(cancellationToken)).ConfigureAwait(false); count++)
					{
						if (isDebugLog)
							Log.Debug("result set row: {0}", count);

						rowCount++;

						var o =
							await (loader.GetRowFromResultSetAsync(
								reader,
								Session,
								queryParameters,
								lockModeArray,
								optionalObjectKey,
								hydratedObjects[i],
								keys,
								true,
								forcedResultTransformer,
								queryCacheBuilder,
								(persister, data) => cacheBatcher.AddToBatch(persister, data)
, cancellationToken							)).ConfigureAwait(false);
						if (loader.IsSubselectLoadingEnabled)
						{
							_subselectResultKeys[i].Add(keys);
							keys = new EntityKey[entitySpan]; //can't reuse in this case
						}

						tmpResults.Add(o);
					}

					if (isDebugLog)
						Log.Debug("done processing result set ({0} rows)", count);

					queryInfo.Result = tmpResults;
					if (queryInfo.CanPutToCache)
						queryInfo.ResultToCache = queryCacheBuilder.Result;

					if (ownCacheBatcher)
						await (cacheBatcher.ExecuteBatchAsync(cancellationToken)).ConfigureAwait(false);

					await (reader.NextResultAsync(cancellationToken)).ConfigureAwait(false);
				}

				StopLoadingCollections(reader);
				_reader = reader;
				_hydratedObjects = hydratedObjects;
				return rowCount;
			}
		}

		/// <inheritdoc cref="IQueryBatchItem.ProcessResults" />
		public async Task ProcessResultsAsync(CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			ThrowIfNotInitialized();

			using (Session.SwitchCacheMode(_cacheMode))
				await (InitializeEntitiesAndCollectionsAsync(_reader, _hydratedObjects, cancellationToken)).ConfigureAwait(false);

			for (var i = 0; i < _queryInfos.Count; i++)
			{
				var queryInfo = _queryInfos[i];
				if (_subselectResultKeys[i] != null)
				{
					queryInfo.QueryLoader.CreateSubselects(_subselectResultKeys[i], queryInfo.Parameters, Session);
				}

				if (queryInfo.IsCacheable)
				{
					if (queryInfo.IsResultFromCache)
					{
						var queryCacheBuilder = new QueryCacheResultBuilder(queryInfo.QueryLoader);
						queryInfo.Result = queryCacheBuilder.GetResultList(queryInfo.Result);
					}

					// This transformation must not be applied to ResultToCache.
					queryInfo.Result =
						queryInfo.QueryLoader.TransformCacheableResults(
							queryInfo.Parameters, queryInfo.CacheKey.ResultTransformer, queryInfo.Result);
				}
			}
			AfterLoadCallback?.Invoke(GetResults());
		}

		/// <inheritdoc />
		public async Task ExecuteNonBatchedAsync(CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			_finalResults = await (GetResultsNonBatchedAsync(cancellationToken)).ConfigureAwait(false);
			AfterLoadCallback?.Invoke(_finalResults);
		}

		protected abstract Task<IList<TResult>> GetResultsNonBatchedAsync(CancellationToken cancellationToken);

		private async Task InitializeEntitiesAndCollectionsAsync(DbDataReader reader, List<object>[] hydratedObjects, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			for (var i = 0; i < _queryInfos.Count; i++)
			{
				var queryInfo = _queryInfos[i];
				if (queryInfo.IsResultFromCache)
					continue;
				await (queryInfo.QueryLoader.InitializeEntitiesAndCollectionsAsync(
					hydratedObjects[i], reader, Session, queryInfo.Parameters.IsReadOnly(Session),
					queryInfo.CacheBatcher, cancellationToken)).ConfigureAwait(false);
			}
		}
	}
}
