//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Data.Common;
using NHibernate.AdoNet;
using NHibernate.Cache;
using NHibernate.Collection;
using NHibernate.Engine;
using NHibernate.Exceptions;
using NHibernate.Impl;
using NHibernate.Loader.Collection;
using NHibernate.Persister.Entity;
using NHibernate.SqlCommand;
using NHibernate.SqlTypes;
using NHibernate.Type;
using NHibernate.Util;
using System.Collections.Generic;

namespace NHibernate.Persister.Collection
{
	using System.Threading.Tasks;
	using System.Threading;
	public partial class BasicCollectionPersister : AbstractCollectionPersister
	{

		protected override async Task<int> DoUpdateRowsAsync(object id, IPersistentCollection collection, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (ArrayHelper.IsAllFalse(elementColumnIsSettable)) return 0;

			try
			{
				DbCommand st = null;
				IExpectation expectation = Expectations.AppropriateExpectation(UpdateCheckStyle);
				//bool callable = UpdateCallable;
				bool useBatch = expectation.CanBeBatched;
				IEnumerable entries = collection.Entries(this);
				int i = 0;
				int count = 0;
				foreach (object entry in entries)
				{
					if (await (collection.NeedsUpdatingAsync(entry, i, ElementType, cancellationToken)).ConfigureAwait(false))
					{
						int offset = 0;
						var batcher = session.Batcher;
						if (useBatch)
						{
							if (st == null)
							{
								st =
									await (batcher.PrepareBatchCommandAsync(SqlUpdateRowString.CommandType, SqlUpdateRowString.Text,
																		SqlUpdateRowString.ParameterTypes, cancellationToken)).ConfigureAwait(false);
							}
						}
						else
						{
							st =
								await (batcher.PrepareCommandAsync(SqlUpdateRowString.CommandType, SqlUpdateRowString.Text,
															   SqlUpdateRowString.ParameterTypes, cancellationToken)).ConfigureAwait(false);
						}

						try
						{
							//offset += expectation.Prepare(st, Factory.ConnectionProvider.Driver);

							int loc = await (WriteElementAsync(st, collection.GetElement(entry), offset, session, cancellationToken)).ConfigureAwait(false);
							if (hasIdentifier)
							{
								await (WriteIdentifierAsync(st, collection.GetIdentifier(entry, i), loc, session, cancellationToken)).ConfigureAwait(false);
							}
							else
							{
								loc = await (WriteKeyAsync(st, id, loc, session, cancellationToken)).ConfigureAwait(false);
								if (HasIndex && !indexContainsFormula)
								{
									await (WriteIndexToWhereAsync(st, collection.GetIndex(entry, i, this), loc, session, cancellationToken)).ConfigureAwait(false);
								}
								else
								{
									await (WriteElementToWhereAsync(st, collection.GetSnapshotElement(entry, i), loc, session, cancellationToken)).ConfigureAwait(false);
								}
							}

							if (useBatch)
							{
								await (batcher.AddToBatchAsync(expectation, cancellationToken)).ConfigureAwait(false);
							}
							else
							{
								expectation.VerifyOutcomeNonBatched(await (batcher.ExecuteNonQueryAsync(st, cancellationToken)).ConfigureAwait(false), st);
							}
						}
						catch (Exception e)
						{
							if (useBatch)
							{
								batcher.AbortBatch(e);
							}
							throw;
						}
						finally
						{
							if (!useBatch)
							{
								batcher.CloseCommand(st, null);
							}
						}
						count++;
					}
					i++;
				}
				return count;
			}
			catch (DbException sqle)
			{
				throw ADOExceptionHelper.Convert(SQLExceptionConverter, sqle,
												 "could not update collection rows: " + MessageHelper.CollectionInfoString(this, collection, id, session),
												 SqlUpdateRowString.Text);
			}
		}
	}
}
