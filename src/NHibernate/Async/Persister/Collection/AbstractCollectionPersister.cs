//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Linq;
using System.Text;
using NHibernate.AdoNet;
using NHibernate.Cache;
using NHibernate.Cache.Entry;
using NHibernate.Collection;
using NHibernate.Engine;
using NHibernate.Exceptions;
using NHibernate.Id;
using NHibernate.Id.Insert;
using NHibernate.Impl;
using NHibernate.Loader.Collection;
using NHibernate.Mapping;
using NHibernate.Metadata;
using NHibernate.Persister.Entity;
using NHibernate.SqlCommand;
using NHibernate.SqlTypes;
using NHibernate.Type;
using NHibernate.Util;
using Array = NHibernate.Mapping.Array;

namespace NHibernate.Persister.Collection
{
	using System.Threading.Tasks;
	using System.Threading;
	public abstract partial class AbstractCollectionPersister : ICollectionMetadata, ISqlLoadableCollection,
		IPostInsertIdentityPersister, ISupportSelectModeJoinable, ICompositeKeyPostInsertIdentityPersister, ISupportLazyPropsJoinable
	{

		public Task InitializeAsync(object key, ISessionImplementor session, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				return GetAppropriateInitializer(key, session).InitializeAsync(key, session, cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		/// <summary>
		/// Reads the Element from the DbDataReader.  The DbDataReader will probably only contain
		/// the id of the Element.
		/// </summary>
		/// <remarks>See ReadElementIdentifier for an explanation of why this method will be depreciated.</remarks>
		public Task<object> ReadElementAsync(DbDataReader rs, object owner, string[] aliases, ISessionImplementor session, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return ElementType.NullSafeGetAsync(rs, aliases, session, owner, cancellationToken);
		}

		public async Task<object> ReadIndexAsync(DbDataReader rs, string[] aliases, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			object index = await (IndexType.NullSafeGetAsync(rs, aliases, session, null, cancellationToken)).ConfigureAwait(false);
			if (index == null)
			{
				throw new HibernateException("null index column for collection: " + role);
			}
			index = DecrementIndexByBase(index);
			return index;
		}

		public async Task<object> ReadIdentifierAsync(DbDataReader rs, string alias, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			object id = await (IdentifierType.NullSafeGetAsync(rs, alias, session, null, cancellationToken)).ConfigureAwait(false);
			if (id == null)
			{
				throw new HibernateException("null identifier column for collection: " + role);
			}

			return id;
		}

		public Task<object> ReadKeyAsync(DbDataReader dr, string[] aliases, ISessionImplementor session, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return KeyType.NullSafeGetAsync(dr, aliases, session, null, cancellationToken);
		}

		public async Task RemoveAsync(object id, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (!isInverse && RowDeleteEnabled)
			{
				if (log.IsDebugEnabled())
				{
					log.Debug("Deleting collection: {0}", MessageHelper.CollectionInfoString(this, id, Factory));
				}

				// Remove all the old entries
				try
				{
					int offset = 0;
					IExpectation expectation = Expectations.AppropriateExpectation(DeleteAllCheckStyle);
					//bool callable = DeleteAllCallable;
					bool useBatch = expectation.CanBeBatched;
					var st = useBatch
						? await (session.Batcher.PrepareBatchCommandAsync(SqlDeleteString.CommandType, SqlDeleteString.Text, SqlDeleteString.ParameterTypes, cancellationToken)).ConfigureAwait(false)
						: await (session.Batcher.PrepareCommandAsync(SqlDeleteString.CommandType, SqlDeleteString.Text, SqlDeleteString.ParameterTypes, cancellationToken)).ConfigureAwait(false);

					try
					{
						//offset += expectation.Prepare(st, factory.ConnectionProvider.Driver);
						WriteKey(st, id, offset, session);
						if (useBatch)
						{
							await (session.Batcher.AddToBatchAsync(expectation, cancellationToken)).ConfigureAwait(false);
						}
						else
						{
							expectation.VerifyOutcomeNonBatched(await (session.Batcher.ExecuteNonQueryAsync(st, cancellationToken)).ConfigureAwait(false), st);
						}
					}
					catch (OperationCanceledException) { throw; }
					catch (Exception e)
					{
						if (useBatch)
						{
							session.Batcher.AbortBatch(e);
						}
						throw;
					}
					finally
					{
						if (!useBatch)
						{
							session.Batcher.CloseCommand(st, null);
						}
					}

					if (log.IsDebugEnabled())
					{
						log.Debug("done deleting collection");
					}
				}
				catch (DbException sqle)
				{
					throw ADOExceptionHelper.Convert(sqlExceptionConverter, sqle,
													 "could not delete collection: " + MessageHelper.CollectionInfoString(this, id));
				}
			}
		}

		public async Task RecreateAsync(IPersistentCollection collection, object id, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (!isInverse && RowInsertEnabled)
			{
				if (log.IsDebugEnabled())
				{
					log.Debug("Inserting collection: {0}", MessageHelper.CollectionInfoString(this, collection, id, session));
				}

				try
				{
					IExpectation expectation = null;
					bool useBatch = false;
					int i = 0;
					int count = 0;

					// create all the new entries
					foreach (var entry in collection.Entries(this))
					{
						// Init, if we're on the first element.
						if (count == 0)
						{
							expectation = Expectations.AppropriateExpectation(insertCheckStyle);
							await (collection.PreInsertAsync(this, cancellationToken)).ConfigureAwait(false);
							//bool callable = InsertCallable;
							useBatch = expectation.CanBeBatched;
						}
						
						if (collection.EntryExists(entry, i))
						{
							object entryId;
							if (!IsIdentifierAssignedByInsert)
							{
								// NH Different implementation: write once
								entryId = await (PerformInsertAsync(id, collection, expectation, entry, i, useBatch, false, session, cancellationToken)).ConfigureAwait(false);
							}
							else
							{
								entryId = await (PerformInsertAsync(id, collection, entry, i, session, cancellationToken)).ConfigureAwait(false);
							}
							collection.AfterRowInsert(this, entry, i, entryId);
							count++;
						}
						i++;
					}

					if (log.IsDebugEnabled())
					{
						if (count > 0)
							log.Debug("done inserting collection: {0} rows inserted", count);
						else
							log.Debug("collection was empty");
					}
				}
				catch (DbException sqle)
				{
					throw ADOExceptionHelper.Convert(sqlExceptionConverter, sqle,
													 "could not insert collection: " + MessageHelper.CollectionInfoString(this, collection, id, session));
				}
			}
		}

		public async Task DeleteRowsAsync(IPersistentCollection collection, object id, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (!isInverse && RowDeleteEnabled)
			{
				if (log.IsDebugEnabled())
				{
					log.Debug("Deleting rows of collection: {0}", MessageHelper.CollectionInfoString(this, collection, id, session));
				}

				bool deleteByIndex = !IsOneToMany && hasIndex && !indexContainsFormula;

				try
				{
					// delete all the deleted entries
					var offset = 0;
					var count = 0;

					foreach (var entry in collection.GetDeletes(this, !deleteByIndex))
					{
						DbCommand st;
						var expectation = Expectations.AppropriateExpectation(deleteCheckStyle);
						//var callable = DeleteCallable;
						var commandInfo = GetDeleteCommand(deleteByIndex, entry, out var columnNullness);

						var useBatch = expectation.CanBeBatched;
						if (useBatch)
						{
							st = await (session.Batcher.PrepareBatchCommandAsync(
								commandInfo.CommandType, commandInfo.Text, commandInfo.ParameterTypes, cancellationToken)).ConfigureAwait(false);
						}
						else
						{
							st = await (session.Batcher.PrepareCommandAsync(
								commandInfo.CommandType, commandInfo.Text, commandInfo.ParameterTypes, cancellationToken)).ConfigureAwait(false);
						}
						try
						{
							var loc = offset;
							if (hasIdentifier)
							{
								WriteIdentifier(st, entry, loc, session);
							}
							else
							{
								loc = WriteKey(st, id, loc, session);

								if (deleteByIndex)
								{
									WriteIndexToWhere(st, entry, loc, session);
								}
								else
								{
									WriteElementToWhere(st, entry, columnNullness, loc, session);
								}
							}
							if (useBatch)
							{
								await (session.Batcher.AddToBatchAsync(expectation, cancellationToken)).ConfigureAwait(false);
							}
							else
							{
								expectation.VerifyOutcomeNonBatched(await (session.Batcher.ExecuteNonQueryAsync(st, cancellationToken)).ConfigureAwait(false), st);
							}
							count++;
						}
						catch (OperationCanceledException) { throw; }
						catch (Exception e)
						{
							if (useBatch)
							{
								session.Batcher.AbortBatch(e);
							}
							throw;
						}
						finally
						{
							if (!useBatch)
							{
								session.Batcher.CloseCommand(st, null);
							}
						}
					}

					if (log.IsDebugEnabled())
					{
						if (count > 0)
							log.Debug("done deleting collection rows: {0} deleted", count);
						else
							log.Debug("no rows to delete");
					}
				}
				catch (DbException sqle)
				{
					throw ADOExceptionHelper.Convert(sqlExceptionConverter, sqle,
						"could not delete collection rows: " + MessageHelper.CollectionInfoString(this, collection, id, session));
				}
			}
		}

		public async Task InsertRowsAsync(IPersistentCollection collection, object id, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (!isInverse && RowInsertEnabled)
			{
				if (log.IsDebugEnabled())
				{
					log.Debug("Inserting rows of collection: {0}", MessageHelper.CollectionInfoString(this, collection, id, session));
				}

				try
				{
					// insert all the new entries
					await (collection.PreInsertAsync(this, cancellationToken)).ConfigureAwait(false);
					IExpectation expectation = Expectations.AppropriateExpectation(insertCheckStyle);
					//bool callable = InsertCallable;
					bool useBatch = expectation.CanBeBatched;
					int i = 0;
					int count = 0;

					IEnumerable entries = collection.Entries(this);
					foreach (object entry in entries)
					{
						if (collection.NeedsInserting(entry, i, elementType))
						{
							object entryId;
							if (!IsIdentifierAssignedByInsert)
							{
								// NH Different implementation: write once
								entryId = await (PerformInsertAsync(id, collection, expectation, entry, i, useBatch, false, session, cancellationToken)).ConfigureAwait(false);
							}
							else
							{
								entryId = await (PerformInsertAsync(id, collection, entry, i, session, cancellationToken)).ConfigureAwait(false);
							}
							collection.AfterRowInsert(this, entry, i, entryId);
							count++;
						}
						i++;
					}

					if (log.IsDebugEnabled())
					{
						log.Debug("done inserting rows: {0} inserted", count);
					}
				}
				catch (DbException sqle)
				{
					throw ADOExceptionHelper.Convert(sqlExceptionConverter, sqle,
													 "could not insert collection rows: " + MessageHelper.CollectionInfoString(this, collection, id, session));
				}
			}
		}

		public async Task UpdateRowsAsync(IPersistentCollection collection, object id, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (!isInverse && collection.RowUpdatePossible)
			{
				if (log.IsDebugEnabled())
				{
					log.Debug("Updating rows of collection: {0}#{1}", role, id);
				}

				// update all the modified entries
				int count = await (DoUpdateRowsAsync(id, collection, session, cancellationToken)).ConfigureAwait(false);

				if (log.IsDebugEnabled())
				{
					log.Debug("done updating rows: {0} updated", count);
				}
			}
		}

		protected abstract Task<int> DoUpdateRowsAsync(object key, IPersistentCollection collection, ISessionImplementor session, CancellationToken cancellationToken);

		protected async Task<object> PerformInsertAsync(object ownerId, IPersistentCollection collection, IExpectation expectation,
									   object entry, int index, bool useBatch, bool callable, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			object entryId = null;
			int offset = 0;
			var st = useBatch
				? await (session.Batcher.PrepareBatchCommandAsync(SqlInsertRowString.CommandType, SqlInsertRowString.Text, SqlInsertRowString.ParameterTypes, cancellationToken)).ConfigureAwait(false)
				: await (session.Batcher.PrepareCommandAsync(SqlInsertRowString.CommandType, SqlInsertRowString.Text, SqlInsertRowString.ParameterTypes, cancellationToken)).ConfigureAwait(false);
			try
			{
				//offset += expectation.Prepare(st, factory.ConnectionProvider.Driver);
				offset = WriteKey(st, ownerId, offset, session);
				if (hasIdentifier)
				{
					entryId = collection.GetIdentifier(entry, index);
					offset = WriteIdentifier(st, entryId, offset, session);
				}
				if (hasIndex)
				{
					offset = WriteIndex(st, collection.GetIndex(entry, index, this), offset, session);
				}
				WriteElement(st, collection.GetElement(entry), offset, session);
				if (useBatch)
				{
					await (session.Batcher.AddToBatchAsync(expectation, cancellationToken)).ConfigureAwait(false);
				}
				else
				{
					expectation.VerifyOutcomeNonBatched(await (session.Batcher.ExecuteNonQueryAsync(st, cancellationToken)).ConfigureAwait(false), st);
				}
			}
			catch (OperationCanceledException) { throw; }
			catch (Exception e)
			{
				if (useBatch)
				{
					session.Batcher.AbortBatch(e);
				}
				throw;
			}
			finally
			{
				if (!useBatch)
				{
					session.Batcher.CloseCommand(st, null);
				}
			}
			return entryId;
		}

		#region NH specific


		/// <summary>
		/// Perform an SQL INSERT, and then retrieve a generated identifier.
		/// </summary>
		/// <returns> the id of the collection entry </returns>
		/// <remarks>
		/// This form is used for PostInsertIdentifierGenerator-style ids (IDENTITY, select, etc).
		/// </remarks>
		protected Task<object> PerformInsertAsync(object ownerId, IPersistentCollection collection, object entry, int index,
									   ISessionImplementor session, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			IBinder binder = new GeneratedIdentifierBinder(ownerId, collection, entry, index, session, this);
			return identityDelegate.PerformInsertAsync(SqlInsertRowString, session, binder, cancellationToken);
		}

		#endregion
	}
}
