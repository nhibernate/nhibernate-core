//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Data.Common;
using NHibernate.Collection;
using NHibernate.Engine;
using NHibernate.Persister.Collection;
using NHibernate.Persister.Entity;
using NHibernate.Proxy;
using NHibernate.SqlTypes;
using NHibernate.Util;
using System.Collections.Generic;
using System.Linq;
using NHibernate.Impl;

namespace NHibernate.Type
{
	using System.Threading.Tasks;
	using System.Threading;
	public abstract partial class CollectionType : AbstractType, IAssociationType
	{

		public override Task<object> NullSafeGetAsync(DbDataReader rs, string name, ISessionImplementor session, object owner, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return NullSafeGetAsync(rs, new string[] { name }, session, owner, cancellationToken);
		}

		public override Task<object> NullSafeGetAsync(DbDataReader rs, string[] name, ISessionImplementor session, object owner, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return ResolveIdentifierAsync(null, session, owner, cancellationToken);
		}

		public override Task NullSafeSetAsync(DbCommand st, object value, int index, bool[] settable, ISessionImplementor session, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				NullSafeSet(st, value, index, settable, session);
				return Task.CompletedTask;
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		public override Task NullSafeSetAsync(DbCommand cmd, object value, int index, ISessionImplementor session, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				NullSafeSet(cmd, value, index, session);
				return Task.CompletedTask;
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		public override async Task<object> DisassembleAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			//remember the uk value

			//This solution would allow us to eliminate the owner arg to disassemble(), but
			//what if the collection was null, and then later had elements added? seems unsafe
			//session.getPersistenceContext().getCollectionEntry( (PersistentCollection) value ).getKey();

			object key = await (GetKeyOfOwnerAsync(owner, session, cancellationToken)).ConfigureAwait(false);
			if (key == null)
			{
				return null;
			}
			else
			{
				return await (GetPersister(session).KeyType.DisassembleAsync(key, session, owner, cancellationToken)).ConfigureAwait(false);
			}
		}

		public override async Task BeforeAssembleAsync(object oid, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			var queryCacheQueue = session.PersistenceContext.BatchFetchQueue.QueryCacheQueue;
			if (queryCacheQueue == null)
			{
				return;
			}

			var persister = GetPersister(session);
			var key = await (persister.KeyType.AssembleAsync(oid, session, null, cancellationToken)).ConfigureAwait(false);
			queryCacheQueue.AddCollection(persister, new CollectionKey(persister, key));
		}

		public override async Task<object> AssembleAsync(object cached, ISessionImplementor session, object owner, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			//we must use the "remembered" uk value, since it is 
			//not available from the EntityEntry during assembly
			if (cached == null)
			{
				return null;
			}
			else
			{
				object key = await (GetPersister(session).KeyType.AssembleAsync(cached, session, owner, cancellationToken)).ConfigureAwait(false);
				return await (ResolveKeyAsync(key, session, owner, cancellationToken)).ConfigureAwait(false);
			}
		}

		public override async Task<bool> IsDirtyAsync(object old, object current, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			// collections don't dirty an unversioned parent entity

			// TODO: I don't like this implementation; it would be better if this was handled by SearchForDirtyCollections();
			return IsOwnerVersioned(session) && await (base.IsDirtyAsync(old, current, session, cancellationToken)).ConfigureAwait(false);
		}

		public override Task<object> HydrateAsync(DbDataReader rs, string[] name, ISessionImplementor session, object owner, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				return Task.FromResult<object>(Hydrate(rs, name, session, owner));
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		public override async Task<object> ResolveIdentifierAsync(object key, ISessionImplementor session, object owner, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			return await (ResolveKeyAsync(await (GetKeyOfOwnerAsync(owner, session, cancellationToken)).ConfigureAwait(false), session, owner, cancellationToken)).ConfigureAwait(false);
		}

		private Task<object> ResolveKeyAsync(object key, ISessionImplementor session, object owner, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return key == null ? Task.FromResult<object>(null ): GetCollectionAsync(key, session, owner, cancellationToken);
		}

		public async Task<object> GetCollectionAsync(object key, ISessionImplementor session, object owner, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			ICollectionPersister persister = GetPersister(session);
			IPersistenceContext persistenceContext = session.PersistenceContext;

			// check if collection is currently being loaded
			IPersistentCollection collection = persistenceContext.LoadContexts.LocateLoadingCollection(persister, key);
			if (collection == null)
			{
				// check if it is already completely loaded, but unowned
				collection = persistenceContext.UseUnownedCollection(new CollectionKey(persister, key));
				if (collection == null)
				{
					// create a new collection wrapper, to be initialized later
					collection = Instantiate(session, persister, key);
					collection.Owner = owner;

					persistenceContext.AddUninitializedCollection(persister, collection, key);

					// some collections are not lazy:
					if (InitializeImmediately())
					{
						await (session.InitializeCollectionAsync(collection, false, cancellationToken)).ConfigureAwait(false);
					}
					else if (!persister.IsLazy)
					{
						persistenceContext.AddNonLazyCollection(collection);
					}

					if (HasHolder())
					{
						session.PersistenceContext.AddCollectionHolder(collection);
					}
				}

				if (log.IsDebugEnabled())
				{
					log.Debug("Created collection wrapper: {0}", MessageHelper.CollectionInfoString(persister, collection, key, session));
				}
			}
			collection.Owner = owner;
			return collection.GetValue();
		}

		public override Task<object> SemiResolveAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken)
		{
			throw new NotSupportedException("collection mappings may not form part of a property-ref");
		}

		public override async Task<object> ReplaceAsync(object original, object target, ISessionImplementor session, object owner,
									   IDictionary copyCache, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (original == null)
			{
				return null;
			}

			if (!NHibernateUtil.IsInitialized(original))
			{
				return target;
			}

			object result = target == null || target == original
								? InstantiateResult(original)
								: target;

			//for arrays, replaceElements() may return a different reference, since
			//the array length might not match
			result = await (ReplaceElementsAsync(original, result, owner, copyCache, session, cancellationToken)).ConfigureAwait(false);

			if (original == target)
			{
				//get the elements back into the target
				//TODO: this is a little inefficient, don't need to do a whole
				//	  deep replaceElements() call
				await (ReplaceElementsAsync(result, target, owner, copyCache, session, cancellationToken)).ConfigureAwait(false);
				result = target;
			}

			return result;
		}

		public virtual async Task<object> ReplaceElementsAsync(object original, object target, object owner, IDictionary copyCache, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			var elemType = GetElementType(session.Factory);
			var targetPc = target as IPersistentCollection;
			var originalPc = original as IPersistentCollection;
			var iterOriginal = (IEnumerable)original;
			var clearTargetsDirtyFlag = ShouldTargetsDirtyFlagBeCleared(targetPc, originalPc, iterOriginal);

			// copy elements into newly empty target collection
			Clear(target);
			foreach (var obj in iterOriginal)
			{
				Add(target, await (elemType.ReplaceAsync(obj, null, session, owner, copyCache, cancellationToken)).ConfigureAwait(false));
			}

			if(clearTargetsDirtyFlag)
			{
				targetPc.ClearDirty();
			}

			return target;
		}

		public override Task<bool> IsDirtyAsync(object old, object current, bool[] checkable, ISessionImplementor session, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<bool>(cancellationToken);
			}
			return IsDirtyAsync(old, current, session, cancellationToken);
		}

		public override Task<bool> IsModifiedAsync(object oldHydratedState, object currentState, bool[] checkable,
										ISessionImplementor session, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<bool>(cancellationToken);
			}
			try
			{
				return Task.FromResult<bool>(IsModified(oldHydratedState, currentState, checkable, session));
			}
			catch (Exception ex)
			{
				return Task.FromException<bool>(ex);
			}
		}

		/// <summary>
		/// Get the key value from the owning entity instance. It is usually the identifier, but it might be some
		/// other unique key, in the case of a property-ref.
		/// </summary>
		public async Task<object> GetKeyOfOwnerAsync(object owner, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			var entityEntry = session.PersistenceContext.GetEntry(owner);
			if (entityEntry == null)
			{
				// This just handles a particular case of component
				// projection, perhaps get rid of it and throw an exception
				return null;
			}

			if (foreignKeyPropertyName == null)
			{
				return entityEntry.Id;
			}

			var key = entityEntry.LoadedState != null
				? entityEntry.GetLoadedValue(foreignKeyPropertyName)
				: entityEntry.Persister.GetPropertyValue(owner, foreignKeyPropertyName);

			// At the point where we are resolving collection references for loading
			// a collection element from an entity query with eager loads, the uk value
			// is not yet resolved in the entity state. This means that an uk value being
			// a component will be represented by just its properties values, and an uk value
			// being an entity (one-to-one or many-to-one) will be represented by just its
			// identifier.
			// We detect this by checking the type of the key value.
			// (This condition was also occuring with simple entity load previously, when the
			// property-ref target was mapped after the collection. But TwoPhaseLoad has been
			// adjusted for resolving collections after all other properties, avoiding this
			// trouble when initializing the entities. (It occurs after having processed each row of the
			// row of the result set.) Unfortunately for eager loads, we must resolve the collection
			// earlier, during the row processing, for associating a read collection element
			// to its collection.)
			var keyType = GetPersister(session).KeyType;
			if (keyType.ReturnedClass.IsInstanceOfType(key))
				return key;

			// key value is not yet resolved
			var resolvedKey = await (keyType.SemiResolveAsync(key, session, owner, cancellationToken)).ConfigureAwait(false);
			if (key != resolvedKey)
				return resolvedKey;

			// The key type SemiResolve was a no-op, which happens with entity types.
			// We have to fully resolve it here, potentially causing n+1 loads. (It happens if
			// the entity has lazy loading disabled while being a key property-ref for a collection:
			// quite a special case mapping.)
			// But anyway, Loader.ReadCollectionElement does already that some instructions later, when
			// there is a collection element. This is due to its "collectionRowKey = persister.ReadKey"
			// call which does a keyType.NullSafeGet which ends up calling keyType.ResolveIdentifier for
			// entity types.
			// So better do it here too, otherwise when there are no collection element, the logic
			// handling empty collections fail by having a wrong key. (When there are collection elements,
			// they supply the right key by the way, and the key resolved here is ignored.)
			resolvedKey = await (keyType.ResolveIdentifierAsync(key, session, owner, cancellationToken)).ConfigureAwait(false);

			if (key != resolvedKey)
				return resolvedKey;

			// This should not happen. If that changes, at least yield null, instead of yielding
			// a value of an unexpected type.
			throw new AssertionFailure(
				$"Unable to correctly resolve the owner key, property {foreignKeyPropertyName} for " +
				$"collection {role}. Unresolved value '{key}', key type '{keyType}', owner '{owner}'.");
		}
	}
}
