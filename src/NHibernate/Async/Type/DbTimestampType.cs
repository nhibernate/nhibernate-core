//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Data;
using System.Data.Common;

using NHibernate.Engine;
using NHibernate.Exceptions;
using NHibernate.Impl;
using NHibernate.SqlCommand;
using NHibernate.SqlTypes;

namespace NHibernate.Type
{
	using System.Threading.Tasks;
	using System.Threading;
	/// <content>
	/// Contains generated async methods
	/// </content>
	public partial class DbTimestampType : TimestampType, IVersionType
	{

		public override Task<object> SeedAsync(ISessionImplementor session, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				if (session == null)
				{
					log.Debug("incoming session was null; using current vm time");
					return base.SeedAsync(session, cancellationToken);
				}
				else if (!session.Factory.Dialect.SupportsCurrentTimestampSelection)
				{
					log.Debug("falling back to vm-based timestamp, as dialect does not support current timestamp selection");
					return base.SeedAsync(session, cancellationToken);
				}
				else
				{
					return GetCurrentTimestampAsync(session, cancellationToken);
				}
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		private Task<object> GetCurrentTimestampAsync(ISessionImplementor session, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				Dialect.Dialect dialect = session.Factory.Dialect;
				string timestampSelectString = dialect.CurrentTimestampSelectString;
				return UsePreparedStatementAsync(timestampSelectString, session, cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		protected virtual async Task<object> UsePreparedStatementAsync(string timestampSelectString, ISessionImplementor session, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			var tsSelect = new SqlString(timestampSelectString);
			DbCommand ps = null;
			DbDataReader rs = null;
			using (new SessionIdLoggingContext(session.SessionId)) 
			try
			{
				ps = await (session.Batcher.PrepareCommandAsync(CommandType.Text, tsSelect, EmptyParams, cancellationToken)).ConfigureAwait(false);
				rs = await (session.Batcher.ExecuteReaderAsync(ps, cancellationToken)).ConfigureAwait(false);
				await (rs.ReadAsync(cancellationToken)).ConfigureAwait(false);
				DateTime ts = rs.GetDateTime(0);
				if (log.IsDebugEnabled)
				{
					log.Debug("current timestamp retreived from db : " + ts + " (tiks=" + ts.Ticks + ")");
				}
				return ts;
			}
			catch (DbException sqle)
			{
				throw ADOExceptionHelper.Convert(session.Factory.SQLExceptionConverter, sqle,
				                                 "could not select current db timestamp", tsSelect);
			}
			finally
			{
				if (ps != null)
				{
					try
					{
						session.Batcher.CloseCommand(ps, rs);
					}
					catch (DbException sqle)
					{
						log.Warn("unable to clean up prepared statement", sqle);
					}
				}
			}
		}
	}
}