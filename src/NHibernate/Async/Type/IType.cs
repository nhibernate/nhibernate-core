//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System.Collections;
using System.Data.Common;
using NHibernate.Engine;
using NHibernate.SqlTypes;

namespace NHibernate.Type
{
	using System.Threading.Tasks;
	using System.Threading;

	public partial interface IType : ICacheAssembler
	{

		/// <summary>
		/// When implemented by a class, should the parent be considered dirty,
		/// given both the old and current field or element value?
		/// </summary>
		/// <param name="old">The old value</param>
		/// <param name="current">The current value</param>
		/// <param name="session">The <see cref="ISessionImplementor"/> </param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns>true if the field is dirty</returns>
		Task<bool> IsDirtyAsync(object old, object current, ISessionImplementor session, CancellationToken cancellationToken);

		/// <summary>
		/// When implemented by a class, should the parent be considered dirty,
		/// given both the old and current field or element value?
		/// </summary>
		/// <param name="old">The old value</param>
		/// <param name="current">The current value</param>
		/// <param name="checkable">Indicates which columns are to be checked.</param>
		/// <param name="session">The <see cref="ISessionImplementor"/> </param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns>true if the field is dirty</returns>
		Task<bool> IsDirtyAsync(object old, object current, bool[] checkable, ISessionImplementor session, CancellationToken cancellationToken);

		Task<bool> IsModifiedAsync(object oldHydratedState, object currentState, bool[] checkable, ISessionImplementor session, CancellationToken cancellationToken);

		/// <summary>
		/// When implemented by a class, gets an instance of the object mapped by
		/// this IType from the <see cref="DbDataReader"/>.
		/// </summary>
		/// <param name="rs">The <see cref="DbDataReader"/> that contains the values</param>
		/// <param name="names">
		/// The names of the columns in the <see cref="DbDataReader"/> that contain the
		/// value to populate the IType with.
		/// </param>
		/// <param name="session"></param>
		/// <param name="owner"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns>The object mapped by this IType.</returns>
		/// <remarks>
		/// Implementors should handle possibility of null values.
		/// </remarks>
		Task<object> NullSafeGetAsync(DbDataReader rs, string[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);

		/// <summary>
		/// When implemented by a class, gets an instance of the object
		/// mapped by this IType from the <see cref="DbDataReader"/>.
		/// </summary>
		/// <param name="rs">The <see cref="DbDataReader"/> that contains the values</param>
		/// <param name="name">The name of the column in the <see cref="DbDataReader"/> that contains the
		/// value to populate the IType with.</param>
		/// <param name="session"></param>
		/// <param name="owner"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns>The object mapped by this IType.</returns>
		/// <remarks>
		/// Implementations should handle possibility of null values.
		/// This method might be called if the IType is known to be a single-column type.
		/// </remarks>
		Task<object> NullSafeGetAsync(DbDataReader rs, string name, ISessionImplementor session, object owner, CancellationToken cancellationToken);

		/// <summary>
		/// When implemented by a class, puts the value/values from the mapped
		/// class into the <see cref="DbCommand"/>.
		/// </summary>
		/// <param name="st">The <see cref="DbCommand"/> to put the values into.</param>
		/// <param name="value">The object that contains the values.</param>
		/// <param name="index">The index of the <see cref="DbParameter"/> to start writing the values to.</param>
		/// <param name="settable">Indicates which columns are to be set.</param>
		/// <param name="session"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <remarks>
		/// Implementors should handle possibility of null values.
		/// A multi-column type should be written to parameters starting from <paramref name="index"/>.
		/// </remarks>
		Task NullSafeSetAsync(DbCommand st, object value, int index, bool[] settable, ISessionImplementor session, CancellationToken cancellationToken);

		/// <summary>
		/// 	When implemented by a class, puts the value/values from the mapped
		/// 	class into the <see cref="DbCommand"/>.
		/// </summary>
		/// <param name="st">
		/// 	The <see cref="DbCommand"/> to put the values into.
		/// </param>
		/// <param name="value">The object that contains the values.</param>
		/// <param name="index">
		/// 	The index of the <see cref="DbParameter"/> to start writing the values to.
		/// </param>
		/// <param name="session"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <remarks>
		/// 	Implementors should handle possibility of null values.
		/// 	A multi-column type should be written to parameters starting from <paramref name="index"/>.
		/// </remarks>
		Task NullSafeSetAsync(DbCommand st, object value, int index, ISessionImplementor session, CancellationToken cancellationToken);

		/// <summary>
		/// When implemented by a class, retrieves an instance of the mapped class,
		/// or the identifier of an entity or collection from a <see cref="DbDataReader"/>.
		/// </summary>
		/// <param name="rs">The <see cref="DbDataReader"/> that contains the values.</param>
		/// <param name="names">
		/// The names of the columns in the <see cref="DbDataReader"/> that contain the
		/// value to populate the IType with.
		/// </param>
		/// <param name="session">The session.</param>
		/// <param name="owner">The parent Entity.</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns>An identifier or actual object mapped by this IType.</returns>
		/// <remarks>
		/// <para>
		/// This is useful for 2-phase property initialization - the second phase is a call to
		/// <c>ResolveIdentifier()</c>
		/// </para>
		/// <para>
		/// Most implementors of this method will just pass the call to <c>NullSafeGet()</c>.
		/// </para>
		/// </remarks>
		Task<object> HydrateAsync(DbDataReader rs, string[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken);

		/// <summary>
		/// When implemented by a class, maps identifiers to Entities or Collections.
		/// </summary>
		/// <param name="value">An identifier or value returned by <c>Hydrate()</c>.</param>
		/// <param name="session">The session.</param>
		/// <param name="owner">The parent Entity.</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns>The Entity or Collection referenced by this Identifier.</returns>
		/// <remarks>
		/// This is the second phase of 2-phase property initialization.
		/// </remarks>
		Task<object> ResolveIdentifierAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);

		/// <summary>
		/// Given a hydrated, but unresolved value, return a value that may be used to
		/// reconstruct property-ref associations.
		/// </summary>
		Task<object> SemiResolveAsync(object value, ISessionImplementor session, object owner, CancellationToken cancellationToken);

		/// <summary>
		/// During merge, replace the existing (target) value in the entity we are merging to
		/// with a new (original) value from the detached entity we are merging. For immutable
		/// objects, or null values, it is safe to simply return the first parameter. For
		/// mutable objects, it is safe to return a copy of the first parameter. For objects
		/// with component values, it might make sense to recursively replace component values.
		/// </summary>
		/// <param name="original">The value from the detached entity being merged.</param>
		/// <param name="target">The value in the managed entity.</param>
		/// <param name="session"></param>
		/// <param name="owner"></param>
		/// <param name="copiedAlready"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns>The value to be merged.</returns>
		Task<object> ReplaceAsync(object original, object target, ISessionImplementor session, object owner, IDictionary copiedAlready, CancellationToken cancellationToken);

		/// <summary>
		/// During merge, replace the existing (target) value in the entity we are merging to
		/// with a new (original) value from the detached entity we are merging. For immutable
		/// objects, or null values, it is safe to simply return the first parameter. For
		/// mutable objects, it is safe to return a copy of the first parameter. For objects
		/// with component values, it might make sense to recursively replace component values.
		/// </summary>
		/// <param name="original">The value from the detached entity being merged.</param>
		/// <param name="target">The value in the managed entity.</param>
		/// <param name="session"></param>
		/// <param name="owner"></param>
		/// <param name="copyCache"></param>
		/// <param name="foreignKeyDirection"></param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <returns>The value to be merged.</returns>
		Task<object> ReplaceAsync(object original, object target, ISessionImplementor session, object owner, IDictionary copyCache, ForeignKeyDirection foreignKeyDirection, CancellationToken cancellationToken);
	}
}
