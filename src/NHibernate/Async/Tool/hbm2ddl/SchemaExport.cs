//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.IO;

using NHibernate.AdoNet.Util;
using NHibernate.Cfg;
using NHibernate.Connection;
using NHibernate.MultiTenancy;
using NHibernate.Util;
using Environment=NHibernate.Cfg.Environment;

namespace NHibernate.Tool.hbm2ddl
{
	using System.Threading.Tasks;
	using System.Threading;
	public partial class SchemaExport
	{

		private async Task InitializeAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			if(wasInitialized)
			{
				return;
			}
			dialect = Dialect.Dialect.GetDialect(configProperties);

			string autoKeyWordsImport = PropertiesHelper.GetString(Environment.Hbm2ddlKeyWords, configProperties, "not-defined");
			if (autoKeyWordsImport == Hbm2DDLKeyWords.AutoQuote)
			{
				await (SchemaMetadataUpdater.UpdateAsync(cfg, dialect, cancellationToken)).ConfigureAwait(false);
				SchemaMetadataUpdater.QuoteTableAndColumns(cfg, dialect);
			}

			dropSQL = cfg.GenerateDropSchemaScript(dialect);
			createSQL = cfg.GenerateSchemaCreationScript(dialect);
			formatter = (PropertiesHelper.GetBoolean(Environment.FormatSql, configProperties, true) ? FormatStyle.Ddl : FormatStyle.None).Formatter;
			_requireTenantConnection = PropertiesHelper.GetEnum(Environment.MultiTenant, configProperties, MultiTenancyStrategy.None) == MultiTenancyStrategy.Database;
			wasInitialized = true;
		}

		//TODO 6.0: Remove (replaced by method with optional connection parameter)
		/// <summary>
		/// Run the schema creation script
		/// </summary>
		/// <param name="useStdOut"><see langword="true" /> if the ddl should be outputted in the Console.</param>
		/// <param name="execute"><see langword="true" /> if the ddl should be executed against the Database.</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <remarks>
		/// This is a convenience method that calls <see cref="ExecuteAsync(bool, bool, bool,CancellationToken)"/> and sets
		/// the justDrop parameter to false.
		/// </remarks>
		public Task CreateAsync(bool useStdOut, bool execute, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return CreateAsync(useStdOut, execute, null, cancellationToken);
		}

		//TODO 6.0: Make connection parameter optional: DbConnection connection = null
		/// <summary>
		/// Run the schema creation script
		/// </summary>
		/// <param name="useStdOut"><see langword="true" /> if the ddl should be outputted in the Console.</param>
		/// <param name="execute"><see langword="true" /> if the ddl should be executed against the Database.</param>
		/// <param name="connection"> Optional explicit connection. Required for multi-tenancy.
		/// Must be an opened connection. The method doesn't close the connection. </param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <remarks>
		/// This is a convenience method that calls <see cref="ExecuteAsync(bool, bool, bool,CancellationToken)"/> and sets
		/// the justDrop parameter to false.
		/// </remarks>
		public Task CreateAsync(bool useStdOut, bool execute, DbConnection connection, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				return InitConnectionAndExecuteAsync(GetAction(useStdOut), execute, false, connection, null, cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		//TODO 6.0: Remove (replaced by method with optional connection parameter)
		/// <summary>
		/// Run the schema creation script
		/// </summary>
		/// <param name="scriptAction"> an action that will be called for each line of the generated ddl.</param>
		/// <param name="execute"><see langword="true" /> if the ddl should be executed against the Database.</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <remarks>
		/// This is a convenience method that calls <see cref="ExecuteAsync(bool, bool, bool,CancellationToken)"/> and sets
		/// the justDrop parameter to false.
		/// </remarks>
		public Task CreateAsync(Action<string> scriptAction, bool execute, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return CreateAsync(scriptAction, execute, null, cancellationToken);
		}

		//TODO 6.0: Make connection parameter optional: DbConnection connection = null
		/// <summary>
		/// Run the schema creation script
		/// </summary>
		/// <param name="scriptAction"> an action that will be called for each line of the generated ddl.</param>
		/// <param name="execute"><see langword="true" /> if the ddl should be executed against the Database.</param>
		/// <param name="connection"> Optional explicit connection. Required for multi-tenancy.
		/// Must be an opened connection. The method doesn't close the connection. </param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <remarks>
		/// This is a convenience method that calls <see cref="ExecuteAsync(bool, bool, bool,CancellationToken)"/> and sets
		/// the justDrop parameter to false.
		/// </remarks>
		public Task CreateAsync(Action<string> scriptAction, bool execute, DbConnection connection, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return InitConnectionAndExecuteAsync(scriptAction, execute, false, connection, null, cancellationToken);
		}

		//TODO 6.0: Remove (replaced by method with optional connection parameter)
		/// <summary>
		/// Run the schema creation script
		/// </summary>
		/// <param name="exportOutput"> if non-null, the ddl will be written to this TextWriter.</param>
		/// <param name="execute"><see langword="true" /> if the ddl should be executed against the Database.</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <remarks>
		/// This is a convenience method that calls <see cref="ExecuteAsync(bool, bool, bool,CancellationToken)"/> and sets
		/// the justDrop parameter to false.
		/// </remarks>
		public Task CreateAsync(TextWriter exportOutput, bool execute, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return CreateAsync(exportOutput, execute, null, cancellationToken);
		}

		//TODO 6.0: Make connection parameter optional: DbConnection connection = null
		/// <summary>
		/// Run the schema creation script
		/// </summary>
		/// <param name="exportOutput"> if non-null, the ddl will be written to this TextWriter.</param>
		/// <param name="execute"><see langword="true" /> if the ddl should be executed against the Database.</param>
		/// <param name="connection"> Optional explicit connection. Required for multi-tenancy.
		/// Must be an opened connection. The method doesn't close the connection. </param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <remarks>
		/// This is a convenience method that calls <see cref="ExecuteAsync(bool, bool, bool,CancellationToken)"/> and sets
		/// the justDrop parameter to false.
		/// </remarks>
		public Task CreateAsync(TextWriter exportOutput, bool execute, DbConnection connection, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return InitConnectionAndExecuteAsync(null, execute, false, connection, exportOutput, cancellationToken);
		}

		//TODO 6.0: Remove (replaced by method with optional connection parameter)
		/// <summary>
		/// Run the drop schema script
		/// </summary>
		/// <param name="useStdOut"><see langword="true" /> if the ddl should be outputted in the Console.</param>
		/// <param name="execute"><see langword="true" /> if the ddl should be executed against the Database.</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <remarks>
		/// This is a convenience method that calls <see cref="ExecuteAsync(bool, bool, bool,CancellationToken)"/> and sets
		/// the justDrop parameter to true.
		/// </remarks>
		public Task DropAsync(bool useStdOut, bool execute, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return DropAsync(useStdOut, execute, null, cancellationToken);
		}

		//TODO 6.0: Make connection parameter optional: DbConnection connection = null
		/// <summary>
		/// Run the drop schema script
		/// </summary>
		/// <param name="useStdOut"><see langword="true" /> if the ddl should be outputted in the Console.</param>
		/// <param name="execute"><see langword="true" /> if the ddl should be executed against the Database.</param>
		/// <param name="connection"> Optional explicit connection. Required for multi-tenancy.
		/// Must be an opened connection. The method doesn't close the connection. </param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <remarks>
		/// This is a convenience method that calls <see cref="ExecuteAsync(bool, bool, bool,CancellationToken)"/> and sets
		/// the justDrop parameter to true.
		/// </remarks>
		public Task DropAsync(bool useStdOut, bool execute, DbConnection connection, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				return InitConnectionAndExecuteAsync(GetAction(useStdOut), execute, true, connection, null, cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		//TODO 6.0: Remove (replaced by method with optional connection parameter) 
		/// <summary>
		/// Run the drop schema script
		/// </summary>
		/// <param name="exportOutput"> if non-null, the ddl will be written to this TextWriter.</param>
		/// <param name="execute"><see langword="true" /> if the ddl should be executed against the Database.</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <remarks>
		/// This is a convenience method that calls <see cref="ExecuteAsync(Action&lt;string&gt;, bool, bool, TextWriter,CancellationToken)"/> and sets
		/// the justDrop parameter to true.
		/// </remarks>
		public Task DropAsync(TextWriter exportOutput, bool execute, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return DropAsync(exportOutput, execute, null, cancellationToken);
		}

		//TODO 6.0: Make connection parameter optional: DbConnection connection = null
		/// <summary>
		/// Run the drop schema script
		/// </summary>
		/// <param name="exportOutput"> if non-null, the ddl will be written to this TextWriter.</param>
		/// <param name="execute"><see langword="true" /> if the ddl should be executed against the Database.</param>
		/// <param name="connection"> Optional explicit connection. Required for multi-tenancy.
		/// Must be an opened connection. The method doesn't close the connection. </param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <remarks>
		/// This is a convenience method that calls <see cref="ExecuteAsync(Action&lt;string&gt;, bool, bool, TextWriter,CancellationToken)"/> and sets
		/// the justDrop parameter to true.
		/// </remarks>
		public Task DropAsync(TextWriter exportOutput, bool execute, DbConnection connection, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return InitConnectionAndExecuteAsync(null, execute, true, connection, exportOutput, cancellationToken);
		}

		private async Task ExecuteInitializedAsync(Action<string> scriptAction, bool execute, bool throwOnError, TextWriter exportOutput,
							 DbCommand statement, string sql, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			try
			{
				string formatted = formatter.Format(sql);

				if (delimiter != null)
				{
					formatted += delimiter;
				}
				if (scriptAction != null)
				{
					scriptAction(formatted);
				}
				log.Debug(formatted);
				if (exportOutput != null)
				{
					exportOutput.WriteLine(formatted);
				}
				if (execute)
				{
					await (ExecuteSqlAsync(statement, sql, cancellationToken)).ConfigureAwait(false);
				}
			}
			catch (OperationCanceledException) { throw; }
			catch (Exception e)
			{
				log.Warn(e, "Unsuccessful: {0}", sql);
				if (throwOnError)
				{
					throw;
				}
			}
		}

		private async Task ExecuteSqlAsync(DbCommand cmd, string sql, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			if (dialect.SupportsSqlBatches)
			{
				foreach (var stmt in new ScriptSplitter(sql))
				{
					log.Debug("SQL Batch: {0}", stmt);
					cmd.CommandText = stmt;
					cmd.CommandType = CommandType.Text;
					await (cmd.ExecuteNonQueryAsync(cancellationToken)).ConfigureAwait(false);
				}
			}
			else
			{
				cmd.CommandText = sql;
				cmd.CommandType = CommandType.Text;
				await (cmd.ExecuteNonQueryAsync(cancellationToken)).ConfigureAwait(false);
			}
		}

		/// <summary>
		/// Executes the Export of the Schema in the given connection
		/// </summary>
		/// <param name="useStdOut"><see langword="true" /> if the ddl should be outputted in the Console.</param>
		/// <param name="execute"><see langword="true" /> if the ddl should be executed against the Database.</param>
		/// <param name="justDrop"><see langword="true" /> if only the ddl to drop the Database objects should be executed.</param>
		/// <param name="connection">
		/// The connection to use when executing the commands when export is <see langword="true" />.
		/// Must be an opened connection. The method doesn't close the connection.
		/// </param>
		/// <param name="exportOutput">The writer used to output the generated schema</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <remarks>
		/// This method allows for both the drop and create ddl script to be executed.
		/// This overload is provided mainly to enable use of in memory databases. 
		/// It does NOT close the given connection!
		/// </remarks>
		public Task ExecuteAsync(bool useStdOut, bool execute, bool justDrop, DbConnection connection,
							TextWriter exportOutput, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				return ExecuteAsync(GetAction(useStdOut), execute, justDrop, connection, exportOutput, cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		public async Task ExecuteAsync(Action<string> scriptAction, bool execute, bool justDrop, DbConnection connection,
							TextWriter exportOutput, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			await (InitializeAsync(cancellationToken)).ConfigureAwait(false);
			DbCommand statement = null;

			if (execute && connection == null)
			{
				throw new ArgumentNullException("connection", "When export is set to true, you need to pass a non null connection");
			}
			if (execute)
			{
				statement = connection.CreateCommand();
			}

			try
			{
				for (int i = 0; i < dropSQL.Length; i++)
				{
					await (ExecuteInitializedAsync(scriptAction, execute, false, exportOutput, statement, dropSQL[i], cancellationToken)).ConfigureAwait(false);
				}

				if (!justDrop)
				{
					for (int j = 0; j < createSQL.Length; j++)
					{
						await (ExecuteInitializedAsync(scriptAction, execute, true, exportOutput, statement, createSQL[j], cancellationToken)).ConfigureAwait(false);
					}
				}
			}
			finally
			{
				try
				{
					if (statement != null)
					{
						statement.Dispose();
					}
				}
				catch (Exception e)
				{
					log.Error(e, "Could not close connection: {0}", e.Message);
				}
				if (exportOutput != null)
				{
					try
					{
						exportOutput.Close();
					}
					catch (Exception ioe)
					{
						log.Error(ioe, "Error closing output file {0}: {1}", outputFile, ioe.Message);
					}
				}
			}
		}

		/// <summary>
		/// Executes the Export of the Schema.
		/// </summary>
		/// <param name="useStdOut"><see langword="true" /> if the ddl should be outputted in the Console.</param>
		/// <param name="execute"><see langword="true" /> if the ddl should be executed against the Database.</param>
		/// <param name="justDrop"><see langword="true" /> if only the ddl to drop the Database objects should be executed.</param>
		/// <param name="cancellationToken">A cancellation token that can be used to cancel the work</param>
		/// <remarks>
		/// This method allows for both the drop and create ddl script to be executed.
		/// </remarks>
		public Task ExecuteAsync(bool useStdOut, bool execute, bool justDrop, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				return InitConnectionAndExecuteAsync(GetAction(useStdOut), execute, justDrop, null, null, cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		public Task ExecuteAsync(Action<string> scriptAction, bool execute, bool justDrop, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return ExecuteAsync(scriptAction, execute, justDrop, null, cancellationToken);
		}

		public Task ExecuteAsync(Action<string> scriptAction, bool execute, bool justDrop, TextWriter exportOutput, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return InitConnectionAndExecuteAsync(scriptAction, execute, justDrop, null, exportOutput, cancellationToken);
		}

		private async Task InitConnectionAndExecuteAsync(Action<string> scriptAction, bool execute, bool justDrop, DbConnection connection, TextWriter exportOutput, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			await (InitializeAsync(cancellationToken)).ConfigureAwait(false);
			TextWriter fileOutput = exportOutput;
			IConnectionProvider connectionProvider = null;

			try
			{
				if (fileOutput == null && outputFile != null)
				{
					fileOutput = new StreamWriter(outputFile);
				}

				if (execute && connection == null)
				{
					if (_requireTenantConnection)
					{
						throw new ArgumentException("When Database multi-tenancy is enabled you need to provide explicit connection. Please use overload with connection parameter.");
					}

					var props = new Dictionary<string, string>();
					foreach (var de in dialect.DefaultProperties)
					{
						props[de.Key] = de.Value;
					}

					if (configProperties != null)
					{
						foreach (var de in configProperties)
						{
							props[de.Key] = de.Value;
						}
					}

					connectionProvider = ConnectionProviderFactory.NewConnectionProvider(props);
					connection = await (connectionProvider.GetConnectionAsync(cancellationToken)).ConfigureAwait(false);
				}

				await (ExecuteAsync(scriptAction, execute, justDrop, connection, fileOutput, cancellationToken)).ConfigureAwait(false);
			}
			catch (OperationCanceledException) { throw; }
			catch (HibernateException)
			{
				// So that we don't wrap HibernateExceptions in HibernateExceptions
				throw;
			}
			catch (Exception e)
			{
				log.Error(e, e.Message);
				throw new HibernateException(e.Message, e);
			}
			finally
			{
				if (connectionProvider != null)
				{
					connectionProvider.CloseConnection(connection);
					connectionProvider.Dispose();
				}
			}
		}
	}
}
