<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NVelocity</name>
    </assembly>
    <members>
        <member name="T:NVelocity.App.Events.EventCartridge">
            <summary>  'Package' of event handlers...
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <author> <a href="mailto:j_a_fernandez@yahoo.com">Jose Alberto Fernandez</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="T:NVelocity.App.Events.ReferenceInsertionEventHandler">
            <summary>  Reference 'Stream insertion' event handler.  Called with object
            that will be inserted into stream via value.toString().
            *
            Please return an Object that will toString() nicely :)
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="T:NVelocity.App.Events.EventHandler">
            <summary>  Base interface for all event handlers
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.App.Events.ReferenceInsertionEventHandler.referenceInsert(System.String,System.Object)">
            <summary> A call-back which is executed during Velocity merge before a
            reference value is inserted into the output stream.
            *
            </summary>
            <param name="reference">Reference from template about to be inserted.
            </param>
            <param name="value">Value about to be inserted (after its
            <code>toString()</code> method is called).
            </param>
            <returns>Object on which <code>toString()</code> should be
            called for output.
            
            </returns>
        </member>
        <member name="T:NVelocity.App.Events.NullSetEventHandler">
            <summary>  Event handler : lets an app approve / veto
            writing a log message when RHS of #set() is null.
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.App.Events.NullSetEventHandler.shouldLogOnNullSet(System.String,System.String)">
            <summary>  Called when the RHS of a #set() is null, which will result
            in a null LHS.
            *
            </summary>
            <param name="lhs"> reference literal of left-hand-side of set statement
            </param>
            <param name="rhs"> reference literal of right-hand-side of set statement
            </param>
            <returns>true if log message should be written, false otherwise
            
            </returns>
        </member>
        <member name="T:NVelocity.App.Events.MethodExceptionEventHandler">
            <summary>  Called when a method throws an exception.  This gives the
            application a chance to deal with it and either
            return something nice, or throw.
            *
            Please return what you want rendered into the output stream.
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.App.Events.EventCartridge.addEventHandler(NVelocity.App.Events.EventHandler)">
            <summary>  Adds an event handler(s) to the Cartridge.  This method
            will find all possible event handler interfaces supported
            by the passed in object.
            *
            </summary>
            <param name="ev">object impementing a valid EventHandler-derived interface
            </param>
            <returns>true if a supported interface, false otherwise or if null
            
            </returns>
        </member>
        <member name="M:NVelocity.App.Events.EventCartridge.removeEventHandler(NVelocity.App.Events.EventHandler)">
            <summary>  Removes an event handler(s) from the Cartridge.  This method
            will find all possible event handler interfaces supported
            by the passed in object and remove them.
            *
            </summary>
            <param name="ev">object impementing a valid EventHandler-derived interface
            </param>
            <returns>true if a supported interface, false otherwise or if null
            
            </returns>
        </member>
        <member name="M:NVelocity.App.Events.EventCartridge.referenceInsert(System.String,System.Object)">
            <summary>  Implementation of ReferenceInsertionEventHandler method
            <code>referenceInsert()</code>.
            *
            Called during Velocity merge before a reference value will
            be inserted into the output stream.
            *
            </summary>
            <param name="reference">reference from template about to be inserted
            </param>
            <param name="value"> value about to be inserted (after toString() )
            </param>
            <returns>Object on which toString() should be called for output.
            
            </returns>
        </member>
        <member name="M:NVelocity.App.Events.EventCartridge.shouldLogOnNullSet(System.String,System.String)">
            <summary>  Implementation of NullSetEventHandler method
            <code>shouldLogOnNullSet()</code>.
            *
            Called during Velocity merge to determine if when
            a #set() results in a null assignment, a warning
            is logged.
            *
            </summary>
            <param name="reference">reference from template about to be inserted
            </param>
            <returns>true if to be logged, false otherwise
            
            </returns>
        </member>
        <member name="M:NVelocity.App.Events.EventCartridge.methodException(System.Type,System.String,System.Exception)">
            <summary>  Implementation of MethodExceptionEventHandler  method
            <code>methodException()</code>.
            *
            Called during Velocity merge if a reference is null
            *
            </summary>
            <param name="claz"> Class that is causing the exception
            </param>
            <param name="method">method called that causes the exception
            </param>
            <param name="e">Exception thrown by the method
            </param>
            <returns>Object to return as method result
            @throws exception to be wrapped and propogated to app
            
            </returns>
        </member>
        <member name="M:NVelocity.App.Events.EventCartridge.attachToContext(NVelocity.Context.IContext)">
            <summary>  Attached the EventCartridge to the context
            *
            Final because not something one should mess with lightly :)
            *
            </summary>
            <param name="context">context to attach to
            </param>
            <returns>true if successful, false otherwise
            
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NVelocity.App.Tools.VelocityFormatter" -->
        <member name="M:NVelocity.App.Tools.VelocityFormatter.#ctor(NVelocity.Context.IContext)">
            <summary> Constructor needs a backpointer to the context.
            *
            </summary>
            <param name="context">A Context.
            
            </param>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.formatShortDate(System.DateTime)">
            <summary> Formats a date in 'short' style.
            *
            </summary>
            <param name="date">A Date.
            </param>
            <returns>A String.
            
            </returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.formatLongDate(System.DateTime)">
            <summary> Formats a date in 'long' style.
            *
            </summary>
            <param name="date">A Date.
            </param>
            <returns>A String.
            
            </returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.formatShortDateTime(System.DateTime)">
            <summary> Formats a date/time in 'short' style.
            *
            </summary>
            <param name="date">A Date.
            </param>
            <returns>A String.
            
            </returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.formatLongDateTime(System.DateTime)">
            <summary> Formats a date/time in 'long' style.
            *
            </summary>
            <param name="date">A Date.
            </param>
            <returns>A String.
            
            </returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.formatArray(System.Object)">
            <summary> Formats an array into the form "A, B and C".
            *
            </summary>
            <param name="array">An Object.
            </param>
            <returns>A String.
            
            </returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.formatArray(System.Object,System.String)">
            <summary> Formats an array into the form
            "A&lt;delim&gt;B&lt;delim&gt;C".
            *
            </summary>
            <param name="array">An Object.
            </param>
            <param name="delim">A String.
            </param>
            <returns>A String.
            
            </returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.formatArray(System.Object,System.String,System.String)">
            <summary> Formats an array into the form
            "A&lt;delim&gt;B&lt;finaldelim&gt;C".
            *
            </summary>
            <param name="array">An Object.
            </param>
            <param name="delim">A String.
            </param>
            <param name="finalDelim">A String.
            </param>
            <returns>A String.
            
            </returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.formatVector(System.Collections.ArrayList)">
            <summary> Formats a vector into the form "A, B and C".
            *
            </summary>
            <param name="vector">A Vector.
            </param>
            <returns>A String.
            
            </returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.formatVector(System.Collections.ArrayList,System.String)">
            <summary> Formats a vector into the form "A&lt;delim&gt;B&lt;delim&gt;C".
            *
            </summary>
            <param name="vector">A Vector.
            </param>
            <param name="delim">A String.
            </param>
            <returns>A String.
            
            </returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.formatVector(System.Collections.ArrayList,System.String,System.String)">
            <summary> Formats a vector into the form
            "Adelim&gt;B&lt;finaldelim&gt;C".
            *
            </summary>
            <param name="vector">A Vector.
            </param>
            <param name="delim">A String.
            </param>
            <param name="finalDelim">A String.
            </param>
            <returns>A String.
            
            </returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.limitLen(System.Int32,System.String)">
            <summary> Limits 'string' to 'maxlen' characters.  If the string gets
            curtailed, "..." is appended to it.
            *
            </summary>
            <param name="maxlen">An int with the maximum length.
            </param>
            <param name="string">A String.
            </param>
            <returns>A String.
            
            </returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.limitLen(System.Int32,System.String,System.String)">
            <summary> Limits 'string' to 'maxlen' character.  If the string gets
            curtailed, 'suffix' is appended to it.
            *
            </summary>
            <param name="maxlen">An int with the maximum length.
            </param>
            <param name="string">A String.
            </param>
            <param name="suffix">A String.
            </param>
            <returns>A String.
            
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.App.Tools.VelocityFormatter.makeAlternator(System.String,System.String,System.String)" -->
        <member name="M:NVelocity.App.Tools.VelocityFormatter.makeAlternator(System.String,System.String,System.String,System.String)">
            <summary> Makes an alternator object that alternates between three
            values.
            *
            </summary>
            <seealso cref="!: #makeAlternator(String name, String alt1, String alt2)
            
            "/>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.makeAlternator(System.String,System.String,System.String,System.String,System.String)">
            <summary> Makes an alternator object that alternates between four values.
            *
            </summary>
            <seealso cref="!: #makeAlternator(String name, String alt1, String alt2)
            
            "/>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.makeAutoAlternator(System.String,System.String,System.String)">
            <summary> Makes an alternator object that alternates between two values
            automatically.
            *
            </summary>
            <seealso cref="!: #makeAlternator(String name, String alt1, String alt2)
            
            "/>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.isNull(System.Object,System.Object)">
            <summary> Returns a default value if the object passed is null.
            </summary>
        </member>
        <member name="T:NVelocity.App.Tools.VelocityFormatter.VelocityAlternator">
            <summary> Class that returns alternating values in a template.  It stores
            a list of alternate Strings, whenever alternate() is called it
            switches to the next in the list.  The current alternate is
            retrieved through toString() - i.e. just by referencing the
            object in a Velocity template.  For an example of usage see the
            makeAlternator() method below.
            </summary>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.VelocityAlternator.#ctor(NVelocity.App.Tools.VelocityFormatter,System.String[])">
            <summary> Constructor takes an array of Strings.
            *
            </summary>
            <param name="alternates">A String[].
            
            </param>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.VelocityAlternator.alternate">
            <summary> Alternates to the next in the list.
            *
            </summary>
            <returns>The current alternate in the sequence.
            
            </returns>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.VelocityAlternator.ToString">
            <summary> Returns the current alternate.
            *
            </summary>
            <returns>A String.
            
            </returns>
        </member>
        <member name="T:NVelocity.App.Tools.VelocityFormatter.VelocityAutoAlternator">
            <summary> As VelocityAlternator, but calls <code>alternate()</code>
            automatically on rendering in a template.
            </summary>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.VelocityAutoAlternator.#ctor(NVelocity.App.Tools.VelocityFormatter,System.String[])">
            <summary> Constructor takes an array of Strings.
            *
            </summary>
            <param name="alternates">A String[].
            
            </param>
        </member>
        <member name="M:NVelocity.App.Tools.VelocityFormatter.VelocityAutoAlternator.ToString">
            <summary> Returns the current alternate, and automatically alternates
            to the next alternate in its sequence (trigged upon
            rendering).
            *
            </summary>
            <returns>The current alternate in the sequence.
            
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NVelocity.App.FieldMethodizer" -->
        <member name="F:NVelocity.App.FieldMethodizer.fieldHash">
            <summary>
            Hold the field objects by field name
            </summary>
        </member>
        <member name="F:NVelocity.App.FieldMethodizer.classHash">
            <summary>
            Hold the class objects by field name
            </summary>
        </member>
        <member name="M:NVelocity.App.FieldMethodizer.#ctor">
            <summary>
            Allow object to be initialized without any data. You would use
            addObject() to add data later.
            </summary>
        </member>
        <member name="M:NVelocity.App.FieldMethodizer.#ctor(System.String)">
            <summary>
            Constructor that takes as it's arg the name of the class
            to methodize.
            </summary>
            <param name="s">Name of class to methodize.</param>
        </member>
        <member name="M:NVelocity.App.FieldMethodizer.#ctor(System.Object)">
            <summary>
            Constructor that takes as it's arg a living
            object to methodize.  Note that it will still
            only methodized the public static fields of
            the class.
            </summary>
            <param name="o">object to methodize.</param>
        </member>
        <member name="M:NVelocity.App.FieldMethodizer.addObject(System.String)">
            <summary>
            Add the Name of the class to methodize
            </summary>
        </member>
        <member name="M:NVelocity.App.FieldMethodizer.addObject(System.Object)">
            <summary> Add an Object to methodize
            </summary>
        </member>
        <member name="M:NVelocity.App.FieldMethodizer.Get(System.String)">
            <summary>
            Accessor method to get the fields by name.
            </summary>
            <param name="fieldName">Name of static field to retrieve</param>
            <returns>The value of the given field.</returns>
        </member>
        <member name="M:NVelocity.App.FieldMethodizer.inspect(System.Type)">
            <summary>  Method that retrieves all public static fields
            in the class we are methodizing.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NVelocity.App.Velocity" -->
        <member name="M:NVelocity.App.Velocity.Init">
            <summary>
            initialize the NVelocity runtime engine, using the default
            properties of the NVelocity distribution
            </summary>
        </member>
        <member name="M:NVelocity.App.Velocity.Init(System.String)">
            <summary>
            initialize the Velocity runtime engine, using default properties
            plus the properties in the properties file passed in as the arg
            </summary>
            <param name="propsFilename">
            file containing properties to use to initialize
            the Velocity runtime
            </param>
        </member>
        <member name="M:NVelocity.App.Velocity.Init(Commons.Collections.ExtendedProperties)">
            <summary>
            initialize the Velocity runtime engine, using default properties
            plus the properties in the passed in java.util.Properties object
            </summary>
            <param name="p">
            Proprties object containing initialization properties
            </param>
        </member>
        <member name="M:NVelocity.App.Velocity.SetProperty(System.String,System.Object)">
            <summary>
            Set a Velocity Runtime property.
            </summary>
            <param name="String">key</param>
            <param name="Object">value</param>
        </member>
        <member name="M:NVelocity.App.Velocity.AddProperty(System.String,System.Object)">
            <summary>
            Add a Velocity Runtime property.
            </summary>
            <param name="String">key</param>
            <param name="Object">value</param>
        </member>
        <member name="M:NVelocity.App.Velocity.ClearProperty(System.String)">
            <summary>
            Clear a NVelocity Runtime property.
            </summary>
            <param name="key">of property to clear</param>
        </member>
        <member name="M:NVelocity.App.Velocity.GetProperty(System.String)">
            <summary>
            Get a Velocity Runtime property.
            </summary>
            <param name="key">property to retrieve</param>
            <returns>property value or null if the property not currently set</returns>
        </member>
        <member name="M:NVelocity.App.Velocity.Evaluate(NVelocity.Context.IContext,System.IO.TextWriter,System.String,System.String)">
            <summary>
            renders the input string using the context into the output writer.
            To be used when a template is dynamically constructed, or want to use
            Velocity as a token replacer.
            </summary>
            <param name="context">context to use in rendering input string
            </param>
            <param name="out"> Writer in which to render the output
            </param>
            <param name="logTag"> string to be used as the template name for log
            messages in case of error
            </param>
            <param name="instring">input string containing the VTL to be rendered
            </param>
            <returns>true if successful, false otherwise.  If false, see
            Velocity runtime log
            </returns>
        </member>
        <member name="M:NVelocity.App.Velocity.Evaluate(NVelocity.Context.IContext,System.IO.TextWriter,System.String,System.IO.Stream)">
            <summary>
            Renders the input stream using the context into the output writer.
            To be used when a template is dynamically constructed, or want to
            use Velocity as a token replacer.
            </summary>
            <param name="context">context to use in rendering input string
            </param>
            <param name="out"> Writer in which to render the output
            </param>
            <param name="logTag"> string to be used as the template name for log messages
            in case of error
            </param>
            <param name="instream">input stream containing the VTL to be rendered
            </param>
            <returns>true if successful, false otherwise.  If false, see
            Velocity runtime log
            </returns>
            <deprecated>Use
            {@link #evaluate( Context context, Writer writer,
            String logTag, Reader reader ) }
            </deprecated>
        </member>
        <member name="M:NVelocity.App.Velocity.Evaluate(NVelocity.Context.IContext,System.IO.TextWriter,System.String,System.IO.TextReader)">
            <summary>
            Renders the input reader using the context into the output writer.
            To be used when a template is dynamically constructed, or want to
            use Velocity as a token replacer.
            </summary>
            <param name="context">context to use in rendering input string</param>
            <param name="out"> Writer in which to render the output</param>
            <param name="logTag"> string to be used as the template name for log messages in case of error</param>
            <param name="reader">Reader containing the VTL to be rendered</param>
            <returns>true if successful, false otherwise.  If false, see Velocity runtime log</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.App.Velocity.InvokeVelocimacro(System.String,System.String,System.String[],NVelocity.Context.IContext,System.IO.TextWriter)" -->
        <member name="M:NVelocity.App.Velocity.MergeTemplate(System.String,NVelocity.Context.IContext,System.IO.TextWriter)">
            <summary>
            merges a template and puts the rendered stream into the writer
            </summary>
            <param name="templateName">name of template to be used in merge
            </param>
            <param name="context"> filled context to be used in merge
            </param>
            <param name="writer"> writer to write template into
            </param>
            <returns>true if successful, false otherwise.  Errors
            logged to velocity log.
            </returns>
            <deprecated>Use
            {@link #mergeTemplate( String templateName, String encoding,
            Context context, Writer writer )}
            </deprecated>
        </member>
        <member name="M:NVelocity.App.Velocity.MergeTemplate(System.String,System.String,NVelocity.Context.IContext,System.IO.TextWriter)">
            <summary>
            merges a template and puts the rendered stream into the writer
            </summary>
            <param name="templateName">name of template to be used in merge
            </param>
            <param name="encoding">encoding used in template
            </param>
            <param name="context"> filled context to be used in merge
            </param>
            <param name="writer"> writer to write template into
            </param>
            <returns>true if successful, false otherwise.  Errors
            logged to velocity log
            @since Velocity v1.1
            </returns>
        </member>
        <member name="M:NVelocity.App.Velocity.GetTemplate(System.String)">
            <summary>
            Returns a <code>Template</code> from the Velocity
            resource management system.
            </summary>
            <param name="name">The file name of the desired template.
            </param>
            <returns>    The template.
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception if an error occurs in template initialization
            </returns>
        </member>
        <member name="M:NVelocity.App.Velocity.GetTemplate(System.String,System.String)">
            <summary>
            Returns a <code>Template</code> from the Velocity
            resource management system.
            </summary>
            <param name="name">The file name of the desired template.
            </param>
            <param name="encoding">The character encoding to use for the template.
            </param>
            <returns>    The template.
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception if an error occurs in template initialization
            @since Velocity v1.1
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.App.Velocity.TemplateExists(System.String)" -->
        <member name="M:NVelocity.App.Velocity.Warn(System.Object)">
            <summary>
            Log a warning message.
            </summary>
            <param name="Object">message to log
            </param>
        </member>
        <member name="M:NVelocity.App.Velocity.Info(System.Object)">
            <summary>
            Log an info message.
            </summary>
            <param name="Object">message to log</param>
        </member>
        <member name="M:NVelocity.App.Velocity.Error(System.Object)">
            <summary>
            Log an error message.
            </summary>
            <param name="Object">message to log</param>
        </member>
        <member name="M:NVelocity.App.Velocity.Debug(System.Object)">
            <summary>
            Log a debug message.
            </summary>
            <param name="Object">message to log</param>
        </member>
        <member name="M:NVelocity.App.Velocity.SetApplicationAttribute(System.Object,System.Object)">
            <summary>
            <p>
            Set the an ApplicationAttribue, which is an Object
            set by the application which is accessable from
            any component of the system that gets a RuntimeServices.
            This allows communication between the application
            environment and custom pluggable components of the
            Velocity engine, such as loaders and loggers.
            </p>
            <p>
            Note that there is no enfocement or rules for the key
            used - it is up to the application developer.  However, to
            help make the intermixing of components possible, using
            the target Class name (e.g.  com.foo.bar ) as the key
            might help avoid collision.
            </p>
            </summary>
            <param name="key">object 'name' under which the object is stored
            </param>
            <param name="value">object to store under this key
            </param>
        </member>
        <member name="P:NVelocity.App.Velocity.ExtendedProperties">
            <summary>
            Set an entire configuration at once. This is
            useful in cases where the parent application uses
            the ExtendedProperties class and the velocity configuration
            is a subset of the parent application's configuration.
            </summary>
            <param name="ExtendedProperties">configuration</param>
        </member>
        <member name="T:NVelocity.App.VelocityEngine">
            <summary>
            <p>
            This class provides a separate new-able instance of the
            Velocity template engine.  The alternative model for use
            is using the Velocity class which employs the singleton
            model.
            </p>
            <p>
            Please ensure that you call one of the init() variants.
            This is critical for proper behavior.
            </p>
            <p> Coming soon : Velocity will call
            the parameter-less init() at the first use of this class
            if the init() wasn't explicitly called.  While this will
            ensure that Velocity functions, it almost certainly won't
            function in the way you intend, so please make sure to
            call init().
            </p>
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Init">
            <summary>
            initialize the Velocity runtime engine, using the default
            properties of the Velocity distribution
            </summary>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Init(System.String)">
            <summary>
            initialize the Velocity runtime engine, using default properties
            plus the properties in the properties file passed in as the arg
            </summary>
            <param name="propsFilename">file containing properties to use to initialize
            the Velocity runtime</param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Init(Commons.Collections.ExtendedProperties)">
            <summary>
            initialize the Velocity runtime engine, using default properties
            plus the properties in the passed in java.util.Properties object
            </summary>
            <param name="p"> Proprties object containing initialization properties</param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.SetProperty(System.String,System.Object)">
            <summary>
            Set a Velocity Runtime property.
            </summary>
            <param name="String">key</param>
            <param name="Object">value</param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.AddProperty(System.String,System.Object)">
            <summary>
            Add a Velocity Runtime property.
            </summary>
            <param name="String">key
            </param>
            <param name="Object">value
            </param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.ClearProperty(System.String)">
            <summary>
            Clear a Velocity Runtime property.
            </summary>
            <param name="key">of property to clear
            </param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.GetProperty(System.String)">
            <summary>
            Get a Velocity Runtime property.
            </summary>
            <param name="key">property to retrieve
            </param>
            <returns>property value or null if the property
            not currently set
            </returns>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Evaluate(NVelocity.Context.IContext,System.IO.TextWriter,System.String,System.String)">
            <summary>
            renders the input string using the context into the output writer.
            To be used when a template is dynamically constructed, or want to use
            Velocity as a token replacer.
            </summary>
            <param name="context">context to use in rendering input string
            </param>
            <param name="out"> Writer in which to render the output
            </param>
            <param name="logTag"> string to be used as the template name for log
            messages in case of error
            </param>
            <param name="instring">input string containing the VTL to be rendered
            </param>
            <returns>true if successful, false otherwise.  If false, see
            Velocity runtime log
            </returns>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Evaluate(NVelocity.Context.IContext,System.IO.TextWriter,System.String,System.IO.Stream)">
            <summary>
            Renders the input stream using the context into the output writer.
            To be used when a template is dynamically constructed, or want to
            use Velocity as a token replacer.
            </summary>
            <param name="context">context to use in rendering input string
            </param>
            <param name="out"> Writer in which to render the output
            </param>
            <param name="logTag"> string to be used as the template name for log messages
            in case of error
            </param>
            <param name="instream">input stream containing the VTL to be rendered
            </param>
            <returns>true if successful, false otherwise.  If false, see
            Velocity runtime log
            </returns>
            <deprecated>Use
            {@link #evaluate( Context context, Writer writer,
            String logTag, Reader reader ) }
            </deprecated>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Evaluate(NVelocity.Context.IContext,System.IO.TextWriter,System.String,System.IO.TextReader)">
            <summary>
            Renders the input reader using the context into the output writer.
            To be used when a template is dynamically constructed, or want to
            use Velocity as a token replacer.
            </summary>
            <param name="context">context to use in rendering input string
            </param>
            <param name="out"> Writer in which to render the output
            </param>
            <param name="logTag"> string to be used as the template name for log messages
            in case of error
            </param>
            <param name="reader">Reader containing the VTL to be rendered
            </param>
            <returns>true if successful, false otherwise.  If false, see
            Velocity runtime log
            @since Velocity v1.1
            </returns>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.InvokeVelocimacro(System.String,System.String,System.String[],NVelocity.Context.IContext,System.IO.TextWriter)">
            <summary>
            Invokes a currently registered Velocimacro with the parms provided
            and places the rendered stream into the writer.
            Note : currently only accepts args to the VM if they are in the context.
            </summary>
            <param name="vmName">name of Velocimacro to call
            </param>
            <param name="logTag">string to be used for template name in case of error
            </param>
            <param name="params[]">args used to invoke Velocimacro. In context key format :
            eg  "foo","bar" (rather than "$foo","$bar")
            </param>
            <param name="context">Context object containing data/objects used for rendering.
            </param>
            <param name="writer"> Writer for output stream
            </param>
            <returns>true if Velocimacro exists and successfully invoked, false otherwise.
            </returns>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.MergeTemplate(System.String,NVelocity.Context.IContext,System.IO.TextWriter)">
            <summary>
            merges a template and puts the rendered stream into the writer
            </summary>
            <param name="templateName">name of template to be used in merge
            </param>
            <param name="context"> filled context to be used in merge
            </param>
            <param name="writer"> writer to write template into
            </param>
            <returns>true if successful, false otherwise.  Errors
            logged to velocity log.
            </returns>
            <deprecated>Use
            {@link #mergeTemplate( String templateName, String encoding,
            Context context, Writer writer )}
            </deprecated>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.MergeTemplate(System.String,System.String,NVelocity.Context.IContext,System.IO.TextWriter)">
            <summary>
            merges a template and puts the rendered stream into the writer
            </summary>
            <param name="templateName">name of template to be used in merge
            </param>
            <param name="encoding">encoding used in template
            </param>
            <param name="context"> filled context to be used in merge
            </param>
            <param name="writer"> writer to write template into
            </param>
            <returns>true if successful, false otherwise.  Errors
            logged to velocity log
            @since Velocity v1.1
            </returns>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.GetTemplate(System.String)">
            <summary>
            Returns a <code>Template</code> from the Velocity
            resource management system.
            </summary>
            <param name="name">The file name of the desired template.
            </param>
            <returns>    The template.
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception if an error occurs in template initialization
            </returns>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.GetTemplate(System.String,System.String)">
            <summary>
            Returns a <code>Template</code> from the Velocity
            resource management system.
            </summary>
            <param name="name">The file name of the desired template.
            </param>
            <param name="encoding">The character encoding to use for the template.
            </param>
            <returns>    The template.
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception if an error occurs in template initialization
            @since Velocity v1.1
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.App.VelocityEngine.TemplateExists(System.String)" -->
        <member name="M:NVelocity.App.VelocityEngine.Warn(System.Object)">
            <summary>
            Log a warning message.
            </summary>
            <param name="Object">message to log</param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Info(System.Object)">
            
            <summary>
            Log an info message.
            </summary>
            <param name="Object">message to log</param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Error(System.Object)">
            <summary>
            Log an error message.
            </summary>
            <param name="Object">message to log</param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.Debug(System.Object)">
            <summary>
            Log a debug message.
            </summary>
            <param name="Object">message to log</param>
        </member>
        <member name="M:NVelocity.App.VelocityEngine.SetApplicationAttribute(System.Object,System.Object)">
            <summary>
            <p>
            Set the an ApplicationAttribue, which is an Object
            set by the application which is accessable from
            any component of the system that gets a RuntimeServices.
            This allows communication between the application
            environment and custom pluggable components of the
            Velocity engine, such as loaders and loggers.
            </p>
            <p>
            Note that there is no enfocement or rules for the key
            used - it is up to the application developer.  However, to
            help make the intermixing of components possible, using
            the target Class name (e.g.  com.foo.bar ) as the key
            might help avoid collision.
            </p>
            </summary>
            <param name="key">object 'name' under which the object is stored</param>
            <param name="value">object to store under this key</param>
        </member>
        <member name="P:NVelocity.App.VelocityEngine.ExtendedProperties">
            <summary>
            Set an entire configuration at once. This is
            useful in cases where the parent application uses
            the ExtendedProperties class and the velocity configuration
            is a subset of the parent application's configuration.
            </summary>
            <param name="ExtendedProperties">configuration
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NVelocity.Context.AbstractContext" -->
        <member name="T:NVelocity.Context.InternalContextBase">
            <summary>  class to encapsulate the 'stuff' for internal operation of velocity.
            We use the context as a thread-safe storage : we take advantage of the
            fact that it's a visitor  of sorts  to all nodes (that matter) of the
            AST during init() and render().
            Currently, it carries the template name for namespace
            support, as well as node-local context data introspection caching.
            *
            Note that this is not a public class.  It is for package access only to
            keep application code from accessing the internals, as AbstractContext
            is derived from this.
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="T:NVelocity.Context.InternalHousekeepingContext">
            <summary>
            interface to encapsulate the 'stuff' for internal operation of velocity.
            We use the context as a thread-safe storage : we take advantage of the
            fact that it's a visitor  of sorts  to all nodes (that matter) of the
            AST during init() and render().
            
            Currently, it carries the template name for namespace
            support, as well as node-local context data introspection caching.
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
            <author> <a href="mailto:Christoph.Reck@dlr.de">Christoph Reck</a></author>
            <version> $Id$</version>
        </member>
        <member name="M:NVelocity.Context.InternalHousekeepingContext.PushCurrentTemplateName(System.String)">
            <summary>
            set the current template name on top of stack
            </summary>
            <param name="s">current template name</param>
        </member>
        <member name="M:NVelocity.Context.InternalHousekeepingContext.PopCurrentTemplateName">
            <summary>
            remove the current template name from stack
            </summary>
        </member>
        <member name="M:NVelocity.Context.InternalHousekeepingContext.ICacheGet(System.Object)">
            <summary>  get the current template name
            *
            </summary>
            <returns>String current template name
            
            </returns>
            <summary>  Returns the template name stack in form of an array.
            *
            </summary>
            <returns>Object[] with the template name stack contents.
            
            </returns>
            <seealso cref="!: IntrospectionCacheData)
            object if exists for the key
            *
            "/>
            <param name="key"> key to find in cache
            </param>
            <returns>cache object
            
            </returns>
        </member>
        <member name="M:NVelocity.Context.InternalHousekeepingContext.ICachePut(System.Object,NVelocity.Util.Introspection.IntrospectionCacheData)">
            <seealso cref="!: IntrospectionCacheData)
            element in the cache for specified key
            *
            "/>
            <param name="key"> key
            </param>
            <param name="o"> IntrospectionCacheData object to place in cache
            
            </param>
        </member>
        <member name="T:NVelocity.Context.InternalEventContext">
            <summary>
            Interface for event support.  Note that this is a public internal
            interface, as it is something that will be accessed from outside
            of the .context package.
            </summary>
        </member>
        <member name="F:NVelocity.Context.InternalContextBase.introspectionCache">
            <summary>  cache for node/context specific introspection information
            </summary>
        </member>
        <member name="F:NVelocity.Context.InternalContextBase.templateNameStack">
            <summary>  Template name stack. The stack top contains the current template name.
            </summary>
        </member>
        <member name="F:NVelocity.Context.InternalContextBase.eventCartridge">
            <summary>  EventCartridge we are to carry.  Set by application
            </summary>
        </member>
        <member name="F:NVelocity.Context.InternalContextBase.currentResource">
            <summary>  Current resource - used for carrying encoding and other
            information down into the rendering process
            </summary>
        </member>
        <member name="M:NVelocity.Context.InternalContextBase.PushCurrentTemplateName(System.String)">
            <summary>  set the current template name on top of stack
            *
            </summary>
            <param name="s">current template name
            
            </param>
        </member>
        <member name="M:NVelocity.Context.InternalContextBase.PopCurrentTemplateName">
            <summary>  remove the current template name from stack
            </summary>
        </member>
        <member name="M:NVelocity.Context.InternalContextBase.ICacheGet(System.Object)">
            <seealso cref="!: IntrospectionCacheData)
            object if exists for the key
            *
            "/>
            <param name="key"> key to find in cache
            </param>
            <returns>cache object
            
            </returns>
        </member>
        <member name="M:NVelocity.Context.InternalContextBase.ICachePut(System.Object,NVelocity.Util.Introspection.IntrospectionCacheData)">
            <seealso cref="!: IntrospectionCacheData)
            element in the cache for specified key
            *
            "/>
            <param name="key"> key
            </param>
            <param name="o"> IntrospectionCacheData object to place in cache
            
            </param>
        </member>
        <member name="T:NVelocity.Context.IContext">
            <summary>
            Interface describing the application data context.  This set of
            routines is used by the application to set and remove 'named' data
            object to pass them to the template engine to use when rendering
            a template.
            
            This is the same set of methods supported by the original Context
            class
            </summary>
            <seealso cref="T:NVelocity.Context.AbstractContext"/>
            <seealso cref="T:NVelocity.VelocityContext"/>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
        </member>
        <member name="M:NVelocity.Context.IContext.Put(System.String,System.Object)">
            <summary>
            Adds a name/value pair to the context.
            </summary>
            <param name="key">The name to key the provided value with.</param>
            <param name="value">The corresponding value.</param>
        </member>
        <member name="M:NVelocity.Context.IContext.Get(System.String)">
            <summary>
            Gets the value corresponding to the provided key from the context.
            </summary>
            <param name="key">The name of the desired value.</param>
            <returns>The value corresponding to the provided key.</returns>
        </member>
        <member name="M:NVelocity.Context.IContext.ContainsKey(System.Object)">
            <summary>
            Indicates whether the specified key is in the context.
            </summary>
            <param name="key">The key to look for.</param>
            <returns>Whether the key is in the context.</returns>
        </member>
        <member name="M:NVelocity.Context.IContext.Remove(System.Object)">
            <summary>
            Removes the value associated with the specified key from the context.
            </summary>
            <param name="key">The name of the value to remove.</param>
            <returns>The value that the key was mapped to, or <code>null</code> if unmapped.</returns>
        </member>
        <member name="P:NVelocity.Context.IContext.Keys">
            <summary>
            Get all the keys for the values in the context
            </summary>
        </member>
        <member name="F:NVelocity.Context.AbstractContext.innerContext">
            <summary>  the chained Context if any
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Context.AbstractContext.InternalGet(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Context.AbstractContext.InternalPut(System.String,System.Object)" -->
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Context.AbstractContext.InternalContainsKey(System.Object)" -->
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Context.AbstractContext.InternalGetKeys" -->
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Context.AbstractContext.InternalRemove(System.Object)" -->
        <member name="M:NVelocity.Context.AbstractContext.#ctor">
            <summary>  default CTOR
            </summary>
        </member>
        <member name="M:NVelocity.Context.AbstractContext.#ctor(NVelocity.Context.IContext)">
            <summary>  Chaining constructor accepts a Context argument.
            It will relay get() operations into this Context
            in the even the 'local' get() returns null.
            
            </summary>
            <param name="inner">context to be chained
            
            </param>
        </member>
        <member name="M:NVelocity.Context.AbstractContext.Put(System.String,System.Object)">
            <summary> Adds a name/value pair to the context.
            
            </summary>
            <param name="key">  The name to key the provided value with.
            </param>
            <param name="value">The corresponding value.
            </param>
            <returns>Object that was replaced in the the Context if
            applicable or null if not.
            
            </returns>
        </member>
        <member name="M:NVelocity.Context.AbstractContext.Get(System.String)">
            <summary>  Gets the value corresponding to the provided key from the context.
            *
            Supports the chaining context mechanism.  If the 'local' context
            doesn't have the value, we try to get it from the chained context.
            *
            </summary>
            <param name="key">The name of the desired value.
            </param>
            <returns>   The value corresponding to the provided key or null if
            the key param is null.
            
            </returns>
        </member>
        <member name="M:NVelocity.Context.AbstractContext.ContainsKey(System.Object)">
            <summary>  Indicates whether the specified key is in the context.  Provided for
            debugging purposes.
            *
            </summary>
            <param name="key">The key to look for.
            </param>
            <returns>true if the key is in the context, false if not.
            
            </returns>
        </member>
        <member name="M:NVelocity.Context.AbstractContext.Remove(System.Object)">
            <summary> Removes the value associated with the specified key from the context.
            *
            </summary>
            <param name="key">The name of the value to remove.
            </param>
            <returns>   The value that the key was mapped to, or <code>null</code>
            if unmapped.
            
            </returns>
        </member>
        <member name="T:NVelocity.Context.InternalContextAdapter">
            <summary>  interface to bring all necessary internal and user contexts together.
            this is what the AST expects to deal with.  If anything new comes
            along, add it here.
            *
            I will rename soon :)
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="T:NVelocity.Context.InternalWrapperContext">
            <summary>
            interface for internal context wrapping functionality
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
            <version> $Id$ </version>
        </member>
        <member name="P:NVelocity.Context.InternalWrapperContext.InternalUserContext">
            <summary>
            returns the wrapped user context
            </summary>
        </member>
        <member name="P:NVelocity.Context.InternalWrapperContext.BaseContext">
            <summary>
            returns the base full context impl
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NVelocity.Context.InternalContextAdapterImpl" -->
        <member name="F:NVelocity.Context.InternalContextAdapterImpl.context">
            
            <summary>  the user data Context that we are wrapping
            </summary>
        </member>
        <member name="F:NVelocity.Context.InternalContextAdapterImpl.icb">
            
            <summary>  the ICB we are wrapping.  We may need to make one
            if the user data context implementation doesn't
            support one.  The default AbstractContext-derived
            VelocityContext does, and it's recommended that
            people derive new contexts from AbstractContext
            rather than piecing things together
            </summary>
        </member>
        <member name="F:NVelocity.Context.InternalContextAdapterImpl.iec">
            <summary>  The InternalEventContext that we are wrapping.  If
            the context passed to us doesn't support it, no
            biggie.  We don't make it for them - since its a
            user context thing, nothing gained by making one
            for them now
            </summary>
        </member>
        <member name="M:NVelocity.Context.InternalContextAdapterImpl.#ctor(NVelocity.Context.IContext)">
            <summary>  CTOR takes a Context and wraps it, delegating all 'data' calls
            to it.
            
            For support of internal contexts, it will create an InternalContextBase
            if need be.
            </summary>
        </member>
        <member name="M:NVelocity.Context.InternalContextAdapterImpl.AttachEventCartridge(NVelocity.App.Events.EventCartridge)">
            <summary>  Returns the base context that we are
            wrapping. Here, its this, but for other thing
            like VM related context contortions, it can
            be something else
            </summary>
        </member>
        <member name="T:NVelocity.Context.VMContext">
            <summary>  This is a special, internal-use-only context implementation to be
            used for the new Velocimacro implementation.
            *
            The main distinguishing feature is the management of the VMProxyArg objects
            in the put() and get() methods.
            *
            Further, this context also supports the 'VM local context' mode, where
            any get() or put() of references that aren't args to the VM are considered
            local to the vm, protecting the global context.
            
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="F:NVelocity.Context.VMContext.vmproxyhash">
            <summary>container for our VMProxy Objects
            </summary>
        </member>
        <member name="F:NVelocity.Context.VMContext.localcontext">
            <summary>container for any local or constant VMProxy items
            </summary>
        </member>
        <member name="F:NVelocity.Context.VMContext.innerContext">
            <summary>the base context store.  This is the 'global' context
            </summary>
        </member>
        <member name="F:NVelocity.Context.VMContext.wrappedContext">
            <summary>context that we are wrapping
            </summary>
        </member>
        <member name="F:NVelocity.Context.VMContext.localcontextscope">
            <summary>support for local context scope feature, where all references are local
            </summary>
        </member>
        <member name="M:NVelocity.Context.VMContext.#ctor(NVelocity.Context.InternalContextAdapter,NVelocity.Runtime.RuntimeServices)">
            <summary>  CTOR, wraps an ICA
            </summary>
        </member>
        <member name="M:NVelocity.Context.VMContext.AddVMProxyArg(NVelocity.Runtime.Directive.VMProxyArg)">
            <summary>  Used to put VMProxyArgs into this context.  It separates
            the VMProxyArgs into constant and non-constant types
            pulling out the value of the constant types so they can
            be modified w/o damaging the VMProxyArg, and leaving the
            dynamic ones, as they modify context rather than their own
            state
            </summary>
            <param name="vmpa">VMProxyArg to add
            
            </param>
        </member>
        <member name="M:NVelocity.Context.VMContext.Put(System.String,System.Object)">
            <summary>  Impl of the Context.put() method.
            *
            </summary>
            <param name="key">name of item to set
            </param>
            <param name="value">object to set to key
            </param>
            <returns>old stored object
            
            </returns>
        </member>
        <member name="M:NVelocity.Context.VMContext.Get(System.String)">
            <summary>  Impl of the Context.gut() method.
            *
            </summary>
            <param name="key">name of item to get
            </param>
            <returns> stored object or null
            
            </returns>
        </member>
        <member name="M:NVelocity.Context.VMContext.ContainsKey(System.Object)">
            <summary>  not yet impl
            </summary>
        </member>
        <member name="M:NVelocity.Context.VMContext.Remove(System.Object)">
            <summary>  impl badly
            </summary>
        </member>
        <member name="T:NVelocity.Dvsl.Directive.MatchDirective">
            <summary>
            Velocity Directive to handle template registration of
            match declarations (like the XSLT match=)
            </summary>
            <author><a href="mailto:geirm@apache.org">Geir Magnusson Jr.</a></author>
        </member>
        <member name="T:NVelocity.Runtime.Directive.Directive">
            <summary> Base class for all directives used in Velocity.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Directive.setLocation(System.Int32,System.Int32)">
            <summary>Allows the template location to be set
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Directive.init(NVelocity.Runtime.RuntimeServices,NVelocity.Context.InternalContextAdapter,NVelocity.Runtime.Parser.Node.INode)">
            <summary> How this directive is to be initialized.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Directive.render(NVelocity.Context.InternalContextAdapter,System.IO.TextWriter,NVelocity.Runtime.Parser.Node.INode)">
            <summary> How this directive is to be rendered
            </summary>
        </member>
        <member name="T:NVelocity.Dvsl.Directive.NameDirective">
            <summary>
            To implement the functionality of &lt;xsl:template name=&gt;
            </summary>
            <author> <a href="mailto:geirm@apache.org">Geir Magnusson Jr.</a></author>
        </member>
        <member name="T:NVelocity.Dvsl.Dvsl">
            <summary>
            Main DVSL class - use this as the helper class for apps
            </summary>
            <author> <a href="mailto:geirm@apache.org">Geir Magnusson Jr.</a></author>
            <author> <a href="mailto:billb@progress.com">Bill Burton.</a></author>
        </member>
        <member name="M:NVelocity.Dvsl.Dvsl.SetStylesheet(System.String)">
            <summary>
            Convenience function.  See...
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.Dvsl.SetStylesheet(System.IO.FileInfo)">
            <summary>
            Convenience function.  See...
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.Dvsl.SetStylesheet(System.IO.TextReader)">
            <summary>
            <p>
            Sets the stylesheet for this transformation set
            </p>
            
            <p>
            Note that don't need this for each document you want
            to transform.  Just do it once, and transform away...
            </p>
            </summary>
            <param name="styleReader">Reader with stylesheet char stream</param>
        </member>
        <member name="M:NVelocity.Dvsl.Dvsl.ConfigureVelocityEngine(NVelocity.App.VelocityEngine,System.Collections.Hashtable)">
            <summary>
            <p>
            Add mapped properties from hashtable on VelocityEngine.
            </p>
            <p>
            If you are going to use this, ensure you do it *before* setting
            the stylesheet, as that creates the VelocityEngine
            </p>
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.Dvsl.MakeReady">
            <summary>
            sets up all the context goodies
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.Dvsl.XForm(System.IO.TextReader,System.IO.TextWriter)">
            <summary>
            does the transformation of the inputstream into
            the output writer
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.Dvsl.Transform(System.Xml.XmlDocument,System.IO.TextWriter)">
            <summary>
            Transforms the given dom4j Document into the writer.
            </summary>
            <param name="dom4jdoc">dom4j Document object</param>
            <param name="writer">Writer for output</param>
        </member>
        <member name="M:NVelocity.Dvsl.Dvsl.GetAppValue(System.Object)">
            <summary>
            Gets the application value for the specified key
            </summary>
            <param name="key">key to use to retrieve value</param>
            <returns>value if found, null otherwise</returns>
        </member>
        <member name="M:NVelocity.Dvsl.Dvsl.PutAppValue(System.Object,System.Object)">
            <summary>
            Sets the application value for the specified key
            </summary>
            <param name="key">key to use to store value</param>
            <param name="value">value to be stored</param>
            <returns>old value if any, null otherwise</returns>
        </member>
        <member name="M:NVelocity.Dvsl.Dvsl.Main(System.String[])">
            <summary>
            <p>
            Allows command-line access.
            </p>
            <p>
            Usage :  Dvsl.exe -STYLE stylesheeet [-IN infile] [-OUT outfile] [-TOOL toolboxname]
            </p>
            </summary>
        </member>
        <member name="P:NVelocity.Dvsl.Dvsl.LogFile">
            <summary>
            lets the user specify a filename for logging.
            </summary>
        </member>
        <member name="P:NVelocity.Dvsl.Dvsl.LogSystem">
            <summary>
            lets the user specify a class instance for logging.
            </summary>
        </member>
        <member name="P:NVelocity.Dvsl.Dvsl.VelocityConfig">
            <summary>
            lets the user pass a java.util.Properties containing
            properties for the configuration of the VelocityEngine
            used by DVSL
            </summary>
        </member>
        <member name="P:NVelocity.Dvsl.Dvsl.UserContext">
            <summary>
            Sets the user context.  The user context is
            a Velocity Context containing user-supplied
            objects and data that are to be made available
            in the template
            </summary>
            <param name="ctx">User context of data</param>
        </member>
        <member name="P:NVelocity.Dvsl.Dvsl.ValidatingParser">
            <summary>
            Uses a validating parser on all input documents
            </summary>
            <param name="">validate</param>
        </member>
        <member name="P:NVelocity.Dvsl.Dvsl.Toolbox">
            <summary>
            <p>Loads the toolbox from the input Properties.</p>
            <p>Currently supports specification of the Toolbox
            name in the context, creating classes, and string
            and integer values.  Ex :
            </p>
            
            <pre>
            toolbox.contextname = floyd
            toolbox.tool.footool = Footool
            toolbox.string.mystring = Hello there!
            toolbox.integer.myint = 7
            toolbox.string.sourcebase = ./xdocs/
            </pre>
            
            <p>
            So in template, this toolbox and it's values would
            be accessed as :
            </p>
            <pre>
            $context.floyd.footool.getFoo()
            $context.floyd.mystring
            $context.floyd.myint
            </pre>
            </summary>
        </member>
        <member name="T:NVelocity.Dvsl.DvslContext">
            <summary>
            Context implementation that handles wrapping several
            contexts simultaneously.  The style context gets
            special treatment, getting checked first.
            </summary>
            <author> <a href="mailto:geirm@apache.org">Geir Magnusson Jr.</a></author>
        </member>
        <member name="T:NVelocity.VelocityContext">
            <summary>
            General purpose implemention of the application Context
            interface for general application use.  This class should
            be used in place of the original Context class.
            </summary>
            <seealso cref="!: java.util.HashMap )
            for data storage.
            
            This context implementation cannot be shared between threads
            without those threads synchronizing access between them, as
            the HashMap is not synchronized, nor are some of the fundamentals
            of AbstractContext.  If you need to share a Context between
            threads with simultaneous access for some reason, please create
            your own and extend the interface Context
            
            "/>
            <seealso cref="!:NVelocity.Context.Context"/>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
            <author> <a href="mailto:fedor.karpelevitch@home.com">Fedor Karpelevitch</a></author>
            <author> <a href="mailto:dlr@finemaltcoding.com">Daniel Rall</a></author>
            <version> $Id$</version>
        </member>
        <member name="F:NVelocity.VelocityContext.context">
            <summary>
            Storage for key/value pairs.
            </summary>
        </member>
        <member name="M:NVelocity.VelocityContext.#ctor">
            <summary>
            Creates a new instance (with no inner context).
            </summary>
        </member>
        <member name="M:NVelocity.VelocityContext.#ctor(System.Collections.Hashtable)">
            
            <summary>
            Creates a new instance with the provided storage (and no inner context).
            </summary>
        </member>
        <member name="M:NVelocity.VelocityContext.#ctor(NVelocity.Context.IContext)">
            <summary>
            Chaining constructor, used when you want to
            wrap a context in another.  The inner context
            will be 'read only' - put() calls to the
            wrapping context will only effect the outermost
            context
            </summary>
            <param name="innerContext">The <code>Context</code> implementation to wrap.</param>
        </member>
        <member name="M:NVelocity.VelocityContext.#ctor(System.Collections.Hashtable,NVelocity.Context.IContext)">
            <summary>
            Initializes internal storage (never to <code>null</code>), and
            inner context.
            </summary>
            <param name="context">Internal storage, or <code>null</code> to
            create default storage.
            </param>
            <param name="innerContext">Inner context.
            
            </param>
        </member>
        <member name="M:NVelocity.VelocityContext.InternalGet(System.String)">
            <summary>
            retrieves value for key from internal
            storage
            </summary>
            <param name="key">name of value to get</param>
            <returns>value as object</returns>
        </member>
        <member name="M:NVelocity.VelocityContext.InternalPut(System.String,System.Object)">
            <summary>
            stores the value for key to internal
            storage
            </summary>
            <param name="key">name of value to store</param>
            <param name="value">value to store</param>
            <returns>previous value of key as Object</returns>
        </member>
        <member name="M:NVelocity.VelocityContext.InternalContainsKey(System.Object)">
            <summary>
            determines if there is a value for the
            given key
            </summary>
            <param name="key">name of value to check</param>
            <returns>true if non-null value in store</returns>
        </member>
        <member name="M:NVelocity.VelocityContext.InternalGetKeys">
            <summary>
            returns array of keys
            </summary>
            <returns>keys as []</returns>
        </member>
        <member name="M:NVelocity.VelocityContext.InternalRemove(System.Object)">
            <summary>
            remove a key/value pair from the
            internal storage
            </summary>
            <param name="key">name of value to remove</param>
            <returns>value removed</returns>
        </member>
        <member name="M:NVelocity.VelocityContext.Clone">
            <summary>
            Clones this context object.
            </summary>
            <returns>A deep copy of this <code>Context</code>.</returns>
        </member>
        <member name="F:NVelocity.Dvsl.DvslContext.nodeStack">
            <summary>
            Used to hold the nodes as we get invoked from
            within the document for applyTemplates() duties
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.DvslContext.InternalGet(System.String)">
            <summary>
            retrieves value for key from internal storage
            </summary>
            <param name="key">name of value to get</param>
            <returns>value as object</returns>
        </member>
        <member name="M:NVelocity.Dvsl.DvslContext.InternalPut(System.String,System.Object)">
            <summary>
            stores the value for key to internal storage
            </summary>
            <param name="key">name of value to store</param>
            <param name="value">value to store</param>
            <returns>previous value of key as Object</returns>
        </member>
        <member name="M:NVelocity.Dvsl.DvslContext.InternalContainsKey(System.Object)">
            <summary>
            determines if there is a value for the given key
            </summary>
            <param name="key">name of value to check</param>
            <returns>true if non-null value in store</returns>
        </member>
        <member name="M:NVelocity.Dvsl.DvslContext.InternalGetKeys">
            <summary>
            returns array of keys
            
            $$$ GMJ todo
            
            </summary>
            <returns>keys as []</returns>
        </member>
        <member name="M:NVelocity.Dvsl.DvslContext.InternalRemove(System.Object)">
            <summary>
            remove a key/value pair from the
            internal storage
            </summary>
            <param name="key">name of value to remove</param>
            <returns>value removed</returns>
        </member>
        <member name="T:NVelocity.Dvsl.DvslNode">
            <summary>
            wrapper interface for nodes exposed in the
            template.  Isolates the in-VSL DOM from that
            of the underlying implementation
            </summary>
            <author> <a href="mailto:geirm@apache.org">Geir Magnusson Jr.</a></author>
        </member>
        <member name="M:NVelocity.Dvsl.DvslNode.ValueOf(System.String)">
            <summary>
            returns the value of the XPath
            expression
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.DvslNode.Attrib(System.String)">
            <summary>
            returns attribute
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.DvslNode.SelectNodes(System.String)">
            <summary>
            returns a list of nodes that satisfy
            the xpath
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.DvslNode.SelectSingleNode(System.String)">
            <summary>  returns a single node that satisfies
            the xpath
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.DvslNode.Copy">
            <summary>
            renders a deep copy of the XML tree
            below the current node to the output
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.DvslNode.Copy(System.Collections.IList)">
            <summary>
            renders a deep copy of the nodes in
            the list ot the output
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.DvslNode.Children">
            <summary>
            returns a list of all children of the current node
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.DvslNode.ToString">
            <summary>
            returns the 'value' of the node
            </summary>
        </member>
        <member name="P:NVelocity.Dvsl.DvslNode.Name">
            <summary>
            returns the name of the node
            </summary>
        </member>
        <member name="P:NVelocity.Dvsl.DvslNode.Value">
            <summary>
            returns the 'value' of the node
            </summary>
        </member>
        <member name="P:NVelocity.Dvsl.DvslNode.NodeImpl">
            <summary>
            returns the object corresponding to the node
            in the implementaion that we are using.
            use only with the greatest of care
            </summary>
        </member>
        <member name="T:NVelocity.Dvsl.DVSLNodeContext">
            <summary>  <p>
            Context implementation that is the outer context
            during the transformation.  Holds the node stack
            and also protects the 'special' context elements
            like 'node'
            </p>
            <p>
            There are special elements like 'node', which is
            readonly and corresponds to the current node, and
            'attrib', which corresponds to a map of attributes
            for the current node.
            </p>
            </summary>
            <author> <a href="mailto:geirm@apache.org">Geir Magnusson Jr.</a></author>
        </member>
        <member name="F:NVelocity.Dvsl.DVSLNodeContext.NODE">
            <summary>
            Magic context entity that corresponds
            to the current node
            </summary>
        </member>
        <member name="F:NVelocity.Dvsl.DVSLNodeContext.ATTRIB">
            <summary>
            Magic context entity that corresponds to
            a Map of attributes for the current node
            </summary>
        </member>
        <member name="F:NVelocity.Dvsl.DVSLNodeContext.nodeStack">
            <summary>
            Used to hold the nodes as we get invoked from
            within the document for applyTemplates() duties
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.DVSLNodeContext.InternalGet(System.String)">
            <summary>
            retrieves value for key from internal storage
            </summary>
            <param name="key">name of value to get</param>
            <returns>value as object</returns>
        </member>
        <member name="M:NVelocity.Dvsl.DVSLNodeContext.InternalPut(System.String,System.Object)">
            <summary>
            stores the value for key to internal
            storage
            </summary>
            <param name="key">name of value to store
            </param>
            <param name="value">value to store
            </param>
            <returns>previous value of key as Object
            </returns>
        </member>
        <member name="M:NVelocity.Dvsl.DVSLNodeContext.InternalContainsKey(System.Object)">
            <summary>
            determines if there is a value for the
            given key
            </summary>
            <param name="key">name of value to check
            </param>
            <returns>true if non-null value in store
            </returns>
        </member>
        <member name="M:NVelocity.Dvsl.DVSLNodeContext.InternalGetKeys">
            <summary>
            returns array of keys
            $$$ GMJ todo
            </summary>
            <returns>keys as []
            </returns>
        </member>
        <member name="M:NVelocity.Dvsl.DVSLNodeContext.InternalRemove(System.Object)">
            <summary>
            remove a key/value pair from the internal storage
            </summary>
            <param name="key">name of value to remove</param>
            <returns>value removed</returns>
        </member>
        <member name="T:NVelocity.Dvsl.DvslNodeImpl">
            <summary>
            wrapper class for .Net nodes to implement the
            DVSLNode interface for template use
            </summary>
            <author> <a href="mailto:geirm@apache.org">Geir Magnusson Jr.</a></author>
        </member>
        <member name="M:NVelocity.Dvsl.DvslNodeImpl.#ctor(System.Xml.XmlElement)">
            <summary>
            this is a bit yecchy - need to revamp
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.DvslNodeImpl.Attribute(System.String)">
            <summary>
            returns a specificed attributeattribute
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.DvslNodeImpl.SelectNodes(System.String)">
            <summary>
            returns a list of nodes that satisfy the xpath
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.DvslNodeImpl.Copy(System.Collections.IList)">
            <summary>
            assumes a list of DVSLNodes
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.DvslNodeImpl.MakeDvslNode(System.Xml.XmlNode)">
            <summary>
            will recast all of this later
            </summary>
        </member>
        <member name="P:NVelocity.Dvsl.DvslNodeImpl.Name">
            <summary>
            returns the name of the node
            </summary>
        </member>
        <member name="T:NVelocity.Dvsl.TemplateHandler">
            <summary>
            Currently provides the match rule accumulation
            as well as the AST storage and rendering
            
            Rule stuff might be replaced with the dom4j RuleManager
            </summary>
            <author> <a href="mailto:geirm@apache.org?">Geir Magnusson Jr.</a></author>
        </member>
        <member name="T:NVelocity.Dvsl.Transformer">
            <summary>  <p>
            Class responsible for actual transformation
            of documents.
            </p>
            <p>
            Note that this class is <em>not</em> threadsafe.
            </p>
            </summary>
            <author> <a href="mailto:geirm@apache.org">Geir Magnusson Jr.</a></author>
        </member>
        <member name="T:NVelocity.Dvsl.TransformTool">
            <summary>
            This is the tool interface exposed to the stylesheet.
            </summary>
            <author> <a href="mailto:geirm@apache.org">Geir Magnusson Jr.</a></author>
        </member>
        <member name="M:NVelocity.Dvsl.TransformTool.ApplyTemplates(System.String)">
            <summary>
            Applies templates in the current stylesheet
            to the nodeset returned by the XPath expression
            </summary>
            <param name="xpath">XPath expression to select nodes</param>
            <returns>The rendered result</returns>
        </member>
        <member name="F:NVelocity.Dvsl.Transformer.ve">
            <summary>
            Instance of VelocityEngine we are currently using.
            This must be reset with a stylesheeet change
            </summary>
        </member>
        <member name="F:NVelocity.Dvsl.Transformer.baseContext">
            <summary>
            basic context passed to us - can contain tools
            and such for use.  Is protected from change via
            wrapping
            </summary>
        </member>
        <member name="F:NVelocity.Dvsl.Transformer.currentContext">
            <summary>
            context used during processing. Wraps the baseContext
            </summary>
        </member>
        <member name="F:NVelocity.Dvsl.Transformer.appValue">
            <summary>
            HashMap to hold application values
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.Transformer.#ctor(NVelocity.App.VelocityEngine,NVelocity.Dvsl.TemplateHandler,NVelocity.Context.IContext,System.Collections.Hashtable,System.Boolean)">
            <summary>
            Sole public CTOR.  We rely on the caller to give us a
            VelocityEngine ready with all macros registered.
            The context is the callers context with all tools and
            style drek.
            </summary>
        </member>
        <member name="M:NVelocity.Dvsl.Transformer.Transform(System.IO.TextReader,System.IO.TextWriter)">
            <summary>
            Method that performs the transformation on
            a document
            </summary>
            <param name="reader">XML document char stream</param>
            <param name="writer">Writer to output transformation to</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NVelocity.Exception.MethodInvocationException" -->
        <member name="T:NVelocity.Exception.VelocityException">
            <summary>  Base class for Velocity exceptions thrown to the
            application layer.
            *
            </summary>
            <author> <a href="mailto:kdowney@amberarcher.com">Kyle F. Downey</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Exception.MethodInvocationException.#ctor(System.String,System.Exception,System.String)">
            <summary>  CTOR - wraps the passed in exception for
            examination later
            *
            </summary>
            <param name="message">
            </param>
            <param name="e">Throwable that we are wrapping
            </param>
            <param name="methodName">name of method that threw the exception
            
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NVelocity.Exception.ParseErrorException" -->
        <!-- Badly formed XML comment ignored for member "T:NVelocity.Exception.ResourceNotFoundException" -->
        <member name="T:NVelocity.IO.VelocityWriter">
             Implementation of a fast Writer. It was originally taken from JspWriter
             and modified to have less syncronization going on.
            
             @author <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
             @author <a href="mailto:jon@latchkey.com">Jon S. Stevens</a>
             @author Anil K. Vijendran
             @version $Id$
        </member>
        <member name="F:NVelocity.IO.VelocityWriter.NO_BUFFER">
            constant indicating that the Writer is not buffering output
        </member>
        <member name="F:NVelocity.IO.VelocityWriter.DEFAULT_BUFFER">
            constant indicating that the Writer is buffered and is using the 
            implementation default buffer size
        </member>
        <member name="F:NVelocity.IO.VelocityWriter.UNBOUNDED_BUFFER">
            constant indicating that the Writer is buffered and is unbounded; 
            this is used in BodyContent
        </member>
        <member name="M:NVelocity.IO.VelocityWriter.#ctor(System.IO.TextWriter)">
             Create a buffered character-output stream that uses a default-sized
             output buffer.
            
             @param  response  A Servlet Response
        </member>
        <member name="M:NVelocity.IO.VelocityWriter.#ctor(System.Int32,System.Boolean)">
            private constructor.
        </member>
        <member name="M:NVelocity.IO.VelocityWriter.getBufferSize">
             This method returns the size of the buffer used by the JspWriter.
            
             @return the size of the buffer in bytes, or 0 is unbuffered.
        </member>
        <member name="M:NVelocity.IO.VelocityWriter.isAutoFlush">
             This method indicates whether the JspWriter is autoFlushing.
            
             @return if this JspWriter is auto flushing or throwing IOExceptions on 
                     buffer overflow conditions
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.IO.VelocityWriter.#ctor(System.IO.TextWriter,System.Int32,System.Boolean)" -->
        <member name="M:NVelocity.IO.VelocityWriter.flushBuffer">
            Flush the output buffer to the underlying character stream, without
            flushing the stream itself.  This method is non-private only so that it
            may be invoked by PrintStream.
        </member>
        <member name="M:NVelocity.IO.VelocityWriter.clear">
            Discard the output buffer.
        </member>
        <member name="M:NVelocity.IO.VelocityWriter.flush">
             Flush the stream.
            
        </member>
        <member name="M:NVelocity.IO.VelocityWriter.close">
             Close the stream.
            
        </member>
        <member name="M:NVelocity.IO.VelocityWriter.getRemaining">
            @return the number of bytes unused in the buffer
        </member>
        <member name="M:NVelocity.IO.VelocityWriter.write(System.Int32)">
             Write a single character.
            
        </member>
        <member name="M:NVelocity.IO.VelocityWriter.min(System.Int32,System.Int32)">
            Our own little min method, to avoid loading java.lang.Math if we've run
            out of file descriptors and we're trying to print a stack trace.
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.IO.VelocityWriter.write(System.Char[],System.Int32,System.Int32)" -->
        <member name="M:NVelocity.IO.VelocityWriter.write(System.Char[])">
            Write an array of characters.  This method cannot be inherited from the
            Writer class because it must suppress I/O exceptions.
        </member>
        <member name="M:NVelocity.IO.VelocityWriter.write(System.String,System.Int32,System.Int32)">
             Write a portion of a String.
            
             @param  s     String to be written
             @param  off   Offset from which to start reading characters
             @param  len   Number of characters to be written
            
        </member>
        <member name="M:NVelocity.IO.VelocityWriter.write(System.String)">
            Write a string.  This method cannot be inherited from the Writer class
            because it must suppress I/O exceptions.
        </member>
        <member name="M:NVelocity.IO.VelocityWriter.recycle(System.IO.TextWriter)">
             resets this class so that it can be reused
            
        </member>
        <member name="T:NVelocity.Runtime.Directive.DirectiveConstants_Fields">
            <summary>  Base class for all directives used in Velocity.
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="T:NVelocity.Runtime.Directive.Foreach">
            <summary>
            Foreach directive used for moving through arrays,
            or objects that provide an Iterator.
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
            <version> $Id$</version>
        </member>
        <member name="F:NVelocity.Runtime.Directive.Foreach.INFO_ARRAY">
            <summary> Flag to indicate that the list object being used
            in an array.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.Foreach.INFO_ITERATOR">
            <summary> Flag to indicate that the list object being used
            provides an Iterator.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.Foreach.INFO_MAP">
            <summary> Flag to indicate that the list object being used
            is a Map.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.Foreach.INFO_COLLECTION">
            <summary> Flag to indicate that the list object being used
            is a Collection.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.Foreach.INFO_ENUMERATION">
            <summary>  Flag to indicate that the list object being used
            is an Enumeration
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.Foreach.INFO_ENUMERABLE">
            <summary>  Flag to indicate that the list object being used
            is an IEnumerable
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.Foreach.UNKNOWN">
            <summary> Return type of this directive.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.Foreach.counterName">
            <summary> The name of the variable to use when placing
            the counter value into the context. Right
            now the default is $velocityCount.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.Foreach.counterInitialValue">
            <summary> What value to start the loop counter at.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.Foreach.elementKey">
            <summary> The reference name used to access each
            of the elements in the list object. It
            is the $item in the following:
            
            #foreach ($item in $list)
            
            This can be used class wide because
            it is immutable.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Foreach.init(NVelocity.Runtime.RuntimeServices,NVelocity.Context.InternalContextAdapter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>  simple init - init the tree and get the elementKey from
            the AST
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Foreach.getIterator(NVelocity.Context.InternalContextAdapter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>  returns an Iterator to the collection in the #foreach()
            
            </summary>
            <param name="context"> current context
            </param>
            <param name="node">  AST node
            </param>
            <returns>Iterator to do the dataset
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Foreach.render(NVelocity.Context.InternalContextAdapter,System.IO.TextWriter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>  renders the #foreach() block
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Directive.Include">
            <summary> Pluggable directive that handles the #include() statement in VTL.
            This #include() can take multiple arguments of either
            StringLiteral or Reference.
            *
            Notes:
            -----
            1) The included source material can only come from somewhere in
            the TemplateRoot tree for security reasons. There is no way
            around this.  If you want to include content from elsewhere on
            your disk, use a link from somwhere under Template Root to that
            content.
            *
            2) By default, there is no output to the render stream in the event of
            a problem.  You can override this behavior with two property values :
            include.output.errormsg.start
            include.output.errormsg.end
            If both are defined in velocity.properties, they will be used to
            in the render output to bracket the arg string that caused the
            problem.
            Ex. : if you are working in html then
            include.output.errormsg.start=<!-- #include error :
            include.output.errormsg.end= -->
            might be an excellent way to start...
            *
            3) As noted above, #include() can take multiple arguments.
            Ex : #include( "foo.vm" "bar.vm" $foo )
            will simply include all three if valid to output w/o any
            special separator.
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:kav@kav.dk">Kasper Nielsen</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Include.init(NVelocity.Runtime.RuntimeServices,NVelocity.Context.InternalContextAdapter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>  simple init - init the tree and get the elementKey from
            the AST
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Include.render(NVelocity.Context.InternalContextAdapter,System.IO.TextWriter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>  iterates through the argument list and renders every
            argument that is appropriate.  Any non appropriate
            arguments are logged, but render() continues.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Include.renderOutput(NVelocity.Runtime.Parser.Node.INode,NVelocity.Context.InternalContextAdapter,System.IO.TextWriter)">
            <summary>  does the actual rendering of the included file
            *
            </summary>
            <param name="node">AST argument of type StringLiteral or Reference
            </param>
            <param name="context">valid context so we can render References
            </param>
            <param name="writer">output Writer
            </param>
            <returns>boolean success or failure.  failures are logged
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Include.outputErrorToStream(System.IO.TextWriter,System.String)">
            <summary>  Puts a message to the render output stream if ERRORMSG_START / END
            are valid property strings.  Mainly used for end-user template
            debugging.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Directive.Literal">
            <summary> A very simple directive that leverages the Node.literal()
            to grab the literal rendition of a node. We basically
            grab the literal value on init(), then repeatedly use
            that during render().
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Literal.init(NVelocity.Runtime.RuntimeServices,NVelocity.Context.InternalContextAdapter,NVelocity.Runtime.Parser.Node.INode)">
            <summary> Store the literal rendition of a node using
            the Node.literal().
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Literal.render(NVelocity.Context.InternalContextAdapter,System.IO.TextWriter,NVelocity.Runtime.Parser.Node.INode)">
            <summary> Throw the literal rendition of the block between
            #literal()/#end into the writer.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Directive.Macro">
            <summary>
            Macro.java
            
            Macro implements the macro definition directive of VTL.
            
            example :
            
            #macro( isnull $i )
            #if( $i )
            $i
            #end
            #end
            
            This object is used at parse time to mainly process and register the
            macro.  It is used inline in the parser when processing a directive.
            
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
            <version> $Id$</version>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Macro.render(NVelocity.Context.InternalContextAdapter,System.IO.TextWriter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>   render() doesn't do anything in the final output rendering.
            There is no output from a #macro() directive.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Macro.processAndRegister(NVelocity.Runtime.RuntimeServices,NVelocity.Runtime.Parser.Node.INode,System.String)">
            <summary>
            Used by Parser.java to process VMs withing the parsing process
            
            processAndRegister() doesn't actually render the macro to the output
            Processes the macro body into the internal representation used by the
            VelocimacroProxy objects, and if not currently used, adds it
            to the macro Factory
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Macro.getArgArray(NVelocity.Runtime.Parser.Node.INode)">
            <summary>  creates an array containing the literal
            strings in the macro arguement
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Macro.getASTAsStringArray(NVelocity.Runtime.Parser.Node.INode)">
            <summary>  Returns an array of the literal rep of the AST
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Directive.Parse">
            <summary> Pluggable directive that handles the #parse() statement in VTL.
            *
            Notes:
            -----
            1) The parsed source material can only come from somewhere in
            the TemplateRoot tree for security reasons. There is no way
            around this.  If you want to include content from elsewhere on
            your disk, use a link from somwhere under Template Root to that
            content.
            *
            2) There is a limited parse depth.  It is set as a property
            "parse_directive.maxdepth = 10"  for example.  There is a 20 iteration
            safety in the event that the parameter isn't set.
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:Christoph.Reck@dlr.de">Christoph Reck</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Directive.Parse.render(NVelocity.Context.InternalContextAdapter,System.IO.TextWriter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>  iterates through the argument list and renders every
            argument that is appropriate.  Any non appropriate
            arguments are logged, but render() continues.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Directive.ParseDirectiveException">
            <summary> Exception for #parse() problems
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Directive.ParseDirectiveException.#ctor(System.String,System.Int32)">
            <summary> Constructor
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.ParseDirectiveException.addFile(System.String)">
            <summary> Add a file to the filename stack
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Directive.VelocimacroProxy">
            <summary>
            VelocimacroProxy.java
            a proxy Directive-derived object to fit with the current directive system
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
            <version> $Id$ </version>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VelocimacroProxy.render(NVelocity.Context.InternalContextAdapter,System.IO.TextWriter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>   Renders the macro using the context
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VelocimacroProxy.init(NVelocity.Runtime.RuntimeServices,NVelocity.Context.InternalContextAdapter,NVelocity.Runtime.Parser.Node.INode)">
            <summary>   The major meat of VelocimacroProxy, init() checks the # of arguments, patches the
            macro body, renders the macro into an AST, and then inits the AST, so it is ready
            for quick rendering.  Note that this is only AST dependant stuff. Not context.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VelocimacroProxy.setupMacro(System.String[],System.Int32[])">
            <summary>
            basic VM setup.  Sets up the proxy args for this
            use, and parses the tree
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VelocimacroProxy.parseTree(System.String[])">
            <summary>
            parses the macro.  We need to do this here, at init time, or else
            the local-scope template feature is hard to get to work :)
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VelocimacroProxy.getArgArray(NVelocity.Runtime.Parser.Node.INode)">
            <summary>   gets the args to the VM from the instance-use AST
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NVelocity.Runtime.Directive.VMProxyArg" -->
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.GENERALSTATIC">
            <summary>in the event our type is switched - we don't care really what it is
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.type">
            <summary>type of arg I will have
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.nodeTree">
            <summary>the AST if the type is such that it's dynamic (ex. JJTREFERENCE )
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.staticObject">
            <summary>reference for the object if we proxy for a static arg like an NumberLiteral
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.usercontext">
            <summary>not used in this impl : carries the appropriate user context
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.numTreeChildren">
            <summary>number of children in our tree if a reference
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.contextReference">
            <summary>our identity in the current context
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.callerReference">
            <summary>the reference we are proxying for
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.singleLevelRef">
            <summary>the 'de-dollared' reference if we are a ref but don't have a method attached
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Directive.VMProxyArg.constant">
            <summary>by default, we are dynamic.  safest
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VMProxyArg.#ctor(NVelocity.Runtime.RuntimeServices,System.String,System.String,System.Int32)">
            <summary>  ctor for current impl
            *
            takes the reference literal we are proxying for, the literal
            the VM we are for is called with...
            *
            </summary>
            <param name="contextRef">reference arg in the definition of the VM, used in the VM
            </param>
            <param name="callerRef"> reference used by the caller as an arg to the VM
            </param>
            <param name="t"> type of arg : JJTREFERENCE, JJTTRUE, etc
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VMProxyArg.isConstant">
            <summary>  tells if arg we are poxying for is
            dynamic or constant.
            *
            </summary>
            <returns>true of constant, false otherwise
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VMProxyArg.setObject(NVelocity.Context.InternalContextAdapter,System.Object)">
            <summary>  Invoked by VMContext when Context.put() is called for a proxied reference.
            *
            </summary>
            <param name="context">context to modify via direct placement, or AST.setValue()
            </param>
            <param name="o"> new value of reference
            </param>
            <returns>Object currently null
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VMProxyArg.getObject(NVelocity.Context.InternalContextAdapter)">
            <summary>  returns the value of the reference.  Generally, this is only
            called for dynamic proxies, as the static ones should have
            been stored in the VMContext's localcontext store
            *
            </summary>
            <param name="context">Context to use for getting current value
            </param>
            <returns>Object value
            *
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VMProxyArg.setup">
            <summary>  does the housekeeping upon creationg.  If a dynamic type
            it needs to make an AST for further get()/set() operations
            Anything else is constant.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Directive.VMProxyArg.#ctor(NVelocity.Runtime.Directive.VMProxyArg,NVelocity.Context.InternalContextAdapter)">
            <summary>  not used in current impl
            *
            Constructor for alternate impl where VelProxy class would make new
            VMProxyArg objects, and use this contructor to avoid reparsing the
            reference args
            *
            that impl also had the VMProxyArg carry it's context
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Exception.ReferenceException">
            <summary> Exception thrown when a bad reference is found.
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="T:NVelocity.Runtime.Log.Log4NetExtensionLogSystem">
            <summary>
            Simple wrapper for the servlet log
            </summary>
            <author> <a href="mailto:cort@xmission.com">Cort Schaefer</a></author>
        </member>
        <member name="T:NVelocity.Runtime.Log.LogSystem">
            <summary>
            Base interface that Logging systems need to implement.
            </summary>
            <author> <a href="mailto:jon@latchkey.com">Jon S. Stevens</a></author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
        </member>
        <member name="M:NVelocity.Runtime.Log.LogSystem.Init(NVelocity.Runtime.RuntimeServices)">
            <summary>
            init()
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Log.LogSystem.LogVelocityMessage(System.Int32,System.String)">
            <summary>
            Send a log message from Velocity.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Log.Log4NetExtensionLogSystem.#ctor">
            <summary>
            Default constructor, fine when NVelocity will be called from the same app domain.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Log.Log4NetExtensionLogSystem.#ctor(System.String)">
            <summary>
            to be used when NVelocity will be called from the same app domain and you want to name the category used
            for NVelocity messages.
            </summary>
            <param name="category">category to use for log messages instead of the name of the actual class</param>
        </member>
        <member name="M:NVelocity.Runtime.Log.Log4NetExtensionLogSystem.#ctor(System.Reflection.Assembly,System.String)">
            <summary>
            specify named category and domain that logging will participate with (needed when using NVelocity in environment
            where it will be hosted by external process; i.e. IIS or COM+).
            </summary>
            <param name="assembly"></param>
            <param name="category"></param>
        </member>
        <member name="M:NVelocity.Runtime.Log.Log4NetExtensionLogSystem.#ctor(System.Reflection.Assembly)">
            <summary>
            specify domain that logging will participate with (needed when using NVelocity in environment
            where it will be hosted by external process; i.e. IIS or COM+)
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="M:NVelocity.Runtime.Log.Log4NetExtensionLogSystem.Init(NVelocity.Runtime.RuntimeServices)">
            <summary>
            Init
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Log.Log4NetExtensionLogSystem.LogVelocityMessage(System.Int32,System.String)">
            <summary>
            Send a log message from NVelocity.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NVelocity.Runtime.Log.LogManager" -->
        <member name="M:NVelocity.Runtime.Log.LogManager.createLogSystem(NVelocity.Runtime.RuntimeServices)">
            <summary>  Creates a new logging system or returns an existing one
            specified by the application.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Log.LogSystem_Fields.DEBUG_ID">
            <summary>
            Prefix for debug messages.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Log.LogSystem_Fields.INFO_ID">
            <summary>
            Prefix for info messages.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Log.LogSystem_Fields.WARN_ID">
            <summary>
            Prefix for warning messages.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Log.LogSystem_Fields.ERROR_ID">
            <summary>
            Prefix for error messages.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Log.NullLogSystem">
            <summary>  Logger used in case of failure. Does nothing.
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Log.NullLogSystem.LogVelocityMessage(System.Int32,System.String)">
            <summary>
            logs messages to the great Garbage Collector in the sky
            </summary>
            <param name="level">severity level</param>
            <param name="message">complete error message</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NVelocity.Runtime.Log.PrimordialLogSystem" -->
        <member name="M:NVelocity.Runtime.Log.PrimordialLogSystem.#ctor">
            <summary>
            default CTOR.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Log.PrimordialLogSystem.LogVelocityMessage(System.Int32,System.String)">
            <summary>
            logs messages.  All we do is store them until 'later'.
            </summary>
            <param name="level">severity level</param>
            <param name="message">complete error message</param>
        </member>
        <member name="M:NVelocity.Runtime.Log.PrimordialLogSystem.DumpLogMessages(NVelocity.Runtime.Log.LogSystem)">
            <summary>
            dumps the log messages this logger is holding into a new logger
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Log.SimpleLog4NetLogSystem">
            <summary>
            Implementation of a simple log4net system that will either
            latch onto an existing category, or just do a simple
            rolling file log.  Derived from Jon's 'complicated'
            version :)
            </summary>
            <author> <a href="mailto:geirm@apache.org">Geir Magnusson Jr.</a></author>
        </member>
        <member name="F:NVelocity.Runtime.Log.SimpleLog4NetLogSystem.logger">
            <summary>
            log4net logging interface
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Log.SimpleLog4NetLogSystem.internalInit(System.String)">
            <summary>
            initializes the log system using the logfile argument
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Log.SimpleLog4NetLogSystem.LogVelocityMessage(System.Int32,System.String)">
            <summary>
            logs messages
            </summary>
            <param name="level">severity level</param>
            <param name="message">complete error message</param>
        </member>
        <member name="M:NVelocity.Runtime.Log.SimpleLog4NetLogSystem.Finalize">
            <summary>
            Also do a shutdown if the object is destroy()'d.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Log.SimpleLog4NetLogSystem.Shutdown">
            <summary>
            Close all destinations
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.AbstractExecutor">
            <summary> Abstract class that is used to execute an arbitrary
            method that is in introspected. This is the superclass
            for the GetExecutor and PropertyExecutor.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Node.AbstractExecutor.method">
            <summary> Method to be executed.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.AbstractExecutor.execute(System.Object,NVelocity.Context.InternalContextAdapter)">
            <summary> Execute method against context.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.AbstractExecutor.isAlive">
            <summary> Tell whether the executor is alive by looking
            at the value of the method.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.INode">
            <summary>  All AST nodes must implement this interface.  It provides basic
            machinery for constructing the parent and child relationships
            between nodes.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.INode.jjtOpen">
            <summary>  This method is called after the node has been made the current
            node.  It indicates that child nodes can now be added to it.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.INode.jjtClose">
            
            <summary>  This method is called after all the child nodes have been
            added.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.INode.jjtSetParent(NVelocity.Runtime.Parser.Node.INode)">
            
            <summary>  This pair of methods are used to inform the node of its
            parent.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.INode.jjtAddChild(NVelocity.Runtime.Parser.Node.INode,System.Int32)">
            
            <summary>  This method tells the node to add its argument to the node's
            list of children.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.INode.jjtGetChild(System.Int32)">
            
            <summary>  This method returns a child node.  The children are numbered
            from zero, left to right.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.INode.jjtGetNumChildren">
            <summary>Return the number of children the node has.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.INode.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.SimpleNode.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.SimpleNode.childrenAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTAddNode.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTAddNode.value_Renamed(NVelocity.Context.InternalContextAdapter)">
            <summary>  computes the sum of the two nodes.  Currently only integer operations are
            supported.
            </summary>
            <returns>Integer object with value, or null
            
            </returns>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTAndNode">
            <summary> Please look at the Parser.jjt file which is
            what controls the generation of this class.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTAndNode.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTAndNode.value_Renamed(NVelocity.Context.InternalContextAdapter)">
            <summary>  Returns the value of the expression.
            Since the value of the expression is simply the boolean
            result of evaluate(), lets return that.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Runtime.Parser.Node.ASTAndNode.evaluate(NVelocity.Context.InternalContextAdapter)" -->
        <member name="M:NVelocity.Runtime.Parser.Node.ASTAssignment.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTBlock.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTComment.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTDirective">
            <summary>
            This class is responsible for handling the pluggable
            directives in VTL. ex.  #foreach()
            
            Please look at the Parser.jjt file which is
            what controls the generation of this class.
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
            <author> <a href="mailto:kav@kav.dk">Kasper Nielsen</a></author>
            <version> $Id$</version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTDirective.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTDivNode">
            <summary> Handles integer division of nodes
            *
            Please look at the Parser.jjt file which is
            what controls the generation of this class.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTDivNode.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTDivNode.value_Renamed(NVelocity.Context.InternalContextAdapter)">
            <summary>  computes the result of the division. Currently limited to
            Integers.
            </summary>
            <returns>Integer(value) or null
            
            </returns>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTElseIfStatement">
            <summary> This class is responsible for handling the ElseIf VTL control statement.
            
            Please look at the Parser.jjt file which is
            what controls the generation of this class.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTElseIfStatement.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTElseIfStatement.evaluate(NVelocity.Context.InternalContextAdapter)">
            <summary> An ASTElseStatement is true if the expression
            it contains evaluates to true. Expressions know
            how to evaluate themselves, so we do that
            here and return the value back to ASTIfStatement
            where this node was originally asked to evaluate
            itself.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTElseIfStatement.render(NVelocity.Context.InternalContextAdapter,System.IO.TextWriter)">
            <summary>  renders the block
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTElseStatement">
            <summary> This class is responsible for handling the Else VTL control statement.
            
            Please look at the Parser.jjt file which is
            what controls the generation of this class.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTElseStatement.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTElseStatement.evaluate(NVelocity.Context.InternalContextAdapter)">
            <summary> An ASTElseStatement always evaluates to
            true. Basically behaves like an #if(true).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NVelocity.Runtime.Parser.Node.ASTEQNode" -->
        <member name="M:NVelocity.Runtime.Parser.Node.ASTEQNode.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTEQNode.evaluate(NVelocity.Context.InternalContextAdapter)">
            <summary>   Calculates the value of the logical expression
            *
            arg1 == arg2
            *
            All class types are supported.   Uses equals() to
            determine equivalence.  This should work as we represent
            with the types we already support, and anything else that
            implements equals() to mean more than identical references.
            *
            *
            </summary>
            <param name="context"> internal context used to evaluate the LHS and RHS
            </param>
            <returns>true if equivalent, false if not equivalent,
            false if not compatible arguments, or false
            if either LHS or RHS is null
            
            </returns>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTEscape">
            <summary> This class is responsible for handling Escapes
            in VTL.
            
            Please look at the Parser.jjt file which is
            what controls the generation of this class.
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTEscape.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTEscapedDirective">
            <summary> This class is responsible for handling EscapedDirectives
            in VTL.
            
            Please look at the Parser.jjt file which is
            what controls the generation of this class.
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTEscapedDirective.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTExpression.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTFalse.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTGENode.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTGTNode.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTIdentifier">
            <summary>  ASTIdentifier.java
            *
            Method support for identifiers :  $foo
            *
            mainly used by ASTRefrence
            *
            Introspection is now moved to 'just in time' or at render / execution
            time. There are many reasons why this has to be done, but the
            primary two are   thread safety, to remove any context-derived
            information from class member  variables.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTIdentifier.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTIdentifier.init(NVelocity.Context.InternalContextAdapter,System.Object)">
            <summary>  simple init - don't do anything that is context specific.
            just get what we need from the AST, which is static.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTIdentifier.doIntrospection(System.Type)">
            <summary>  introspects the class to find the method name of the node,
            or if that fails, treats the reference object as a map
            and treats the identifier as a key in that map.
            This needs work.
            *
            </summary>
            <param name="data">Class to be introspected
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTIdentifier.execute(System.Object,NVelocity.Context.InternalContextAdapter)">
            <summary>  invokes the method on the object passed in
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTIfStatement.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTIncludeStatement.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTIntegerRange.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTIntegerRange.value_Renamed(NVelocity.Context.InternalContextAdapter)">
            <summary>  does the real work.  Creates an Vector of Integers with the
            right value range
            *
            </summary>
            <param name="context"> app context used if Left or Right of .. is a ref
            </param>
            <returns>Object array of Integers
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTLENode.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTLTNode.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTMethod">
            <summary>
            ASTMethod.java
            
            Method support for references :  $foo.method()
            
            NOTE :
            
            introspection is now done at render time.
            
            Please look at the Parser.jjt file which is
            what controls the generation of this class.
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
            <version> $Id$ </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTMethod.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>
            Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTMethod.init(NVelocity.Context.InternalContextAdapter,System.Object)">
            <summary>
            simple init - init our subtree and get what we can from
            the AST
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTMethod.doIntrospection(NVelocity.Context.InternalContextAdapter,System.Type)">
            <summary>
            does the instrospection of the class for the method needed.
            Note, as this calls value() on the args if any, this must
            only be called at execute() / render() time.
            
            NOTE: this will try to flip the case of the first character for
            convience (compatability with Java version).  If there are no arguments,
            it will also try to find a property with the same name (also flipping first character).
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTMethod.execute(System.Object,NVelocity.Context.InternalContextAdapter)">
            <summary>
            invokes the method.  Returns null if a problem, the
            actual return if the method returns something, or
            an empty string "" if the method returns void
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTModNode.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTMulNode">
            <summary> Handles integer multiplication
            *
            Please look at the Parser.jjt file which is
            what controls the generation of this class.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTMulNode.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTMulNode.value_Renamed(NVelocity.Context.InternalContextAdapter)">
            <summary>  computes the product of the two args.  Returns null if either arg is null
            or if either arg is not an integer
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTNENode.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTNotNode.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTNumberLiteral.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTNumberLiteral.init(NVelocity.Context.InternalContextAdapter,System.Object)">
            <summary>  Initialization method - doesn't do much but do the object
            creation.  We only need to do it once.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTObjectArray.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTOrNode">
            <summary> Please look at the Parser.jjt file which is
            what controls the generation of this class.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTOrNode.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTOrNode.value_Renamed(NVelocity.Context.InternalContextAdapter)">
            <summary>  Returns the value of the expression.
            Since the value of the expression is simply the boolean
            result of evaluate(), lets return that.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTOrNode.evaluate(NVelocity.Context.InternalContextAdapter)">
            <summary>  the logical or :
            the rule :
            left || null -> left
            null || right -> right
            null || null -> false
            left || right ->  left || right
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTParameters.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTprocess.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NVelocity.Runtime.Parser.Node.ASTReference" -->
        <member name="M:NVelocity.Runtime.Parser.Node.ASTReference.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTReference.execute(System.Object,NVelocity.Context.InternalContextAdapter)">
            <summary>   gets an Object that 'is' the value of the reference
            *
            </summary>
            <param name="o">  unused Object parameter
            </param>
            <param name="context">context used to generate value
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTReference.render(NVelocity.Context.InternalContextAdapter,System.IO.TextWriter)">
            <summary>  gets the value of the reference and outputs it to the
            writer.
            *
            </summary>
            <param name="context"> context of data to use in getting value
            </param>
            <param name="writer">  writer to render to
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTReference.evaluate(NVelocity.Context.InternalContextAdapter)">
            <summary>   Computes boolean value of this reference
            Returns the actual value of reference return type
            boolean, and 'true' if value is not null
            *
            </summary>
            <param name="context">context to compute value with
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTReference.setValue(NVelocity.Context.InternalContextAdapter,System.Object)">
            <summary>  Sets the value of a complex reference (something like $foo.bar)
            Currently used by ASTSetReference()
            *
            </summary>
            <seealso cref="!: ASTSetDirective
            *
            "/>
            <param name="context">context object containing this reference
            </param>
            <param name="value">Object to set as value
            </param>
            <returns>true if successful, false otherwise
            
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Runtime.Parser.Node.ASTReference.literal" -->
        <member name="T:NVelocity.Runtime.Parser.Node.ASTSetDirective">
            <summary> Node for the #set directive
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTSetDirective.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTSetDirective.init(NVelocity.Context.InternalContextAdapter,System.Object)">
            <summary>  simple init.  We can get the RHS and LHS as the the tree structure is static
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTSetDirective.render(NVelocity.Context.InternalContextAdapter,System.IO.TextWriter)">
            <summary>   puts the value of the RHS into the context under the key of the LHS
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTStringLiteral">
            <summary> ASTStringLiteral support.  Will interpolate!
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTStringLiteral.init(NVelocity.Context.InternalContextAdapter,System.Object)">
            <summary>  init : we don't have to do much.  Init the tree (there
            shouldn't be one) and then see if interpolation is turned on.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTStringLiteral.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTStringLiteral.value_Renamed(NVelocity.Context.InternalContextAdapter)">
            <summary>  renders the value of the string literal
            If the properties allow, and the string literal contains a $ or a #
            the literal is rendered against the context
            Otherwise, the stringlit is returned.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.ASTSubtractNode">
            <summary> Handles integer subtraction of nodes (in #set() )
            *
            Please look at the Parser.jjt file which is
            what controls the generation of this class.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTSubtractNode.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTSubtractNode.value_Renamed(NVelocity.Context.InternalContextAdapter)">
            <summary>  computes the value of the subtraction.  Currently
            limited to integers
            </summary>
            <returns>Integer(value) or null
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTText.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTTrue.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTVariable.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.ASTWord.jjtAccept(NVelocity.Runtime.Parser.Node.ParserVisitor,System.Object)">
            <summary>Accept the visitor. *
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NVelocity.Runtime.Parser.Node.BooleanPropertyExecutor" -->
        <member name="T:NVelocity.Runtime.Parser.Node.PropertyExecutor">
            <summary>
            Returned the value of object property when executed.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.PropertyExecutor.execute(System.Object,NVelocity.Context.InternalContextAdapter)">
            <summary> Execute method against context.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.GetExecutor">
            <summary>
            Executor that simply tries to execute a get(key)
            operation. This will try to find a get(key) method
            for any type of object, not just objects that
            implement the Map interface as was previously
            the case.
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Node.GetExecutor.args">
            <summary>
            Container to hold the 'key' part of get(key).
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.GetExecutor.#ctor(NVelocity.Runtime.RuntimeServices,System.Type,System.String)">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.GetExecutor.execute(System.Object,NVelocity.Context.InternalContextAdapter)">
            <summary>
            Execute method against context.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Node.NodeUtils">
            <summary> Utilities for dealing with the AST node structure.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Runtime.Parser.Node.NodeUtils.specialText(NVelocity.Runtime.Parser.Token)" -->
        <member name="M:NVelocity.Runtime.Parser.Node.NodeUtils.tokenLiteral(NVelocity.Runtime.Parser.Token)">
            <summary>  complete node literal
            *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Node.NodeUtils.interpolate(System.String,NVelocity.Context.IContext)">
            <summary> Utility method to interpolate context variables
            into string literals. So that the following will
            work:
            *
            #set $name = "candy"
            $image.getURI("${name}.jpg")
            *
            And the string literal argument will
            be transformed into "candy.jpg" before
            the method is executed.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.CharStream">
            <summary> This interface describes a character stream that maintains line and
            column number positions of the characters.  It also has the capability
            to backup the stream to some extent.  An implementation of this
            interface is used in the TokenManager implementation generated by
            JavaCCParser.
            
            All the methods except backup can be implemented in any fashion. backup
            needs to be implemented correctly for the correct operation of the lexer.
            Rest of the methods are all used to get information like line number,
            column number and the String that constitutes a token and are not used
            by the lexer. Hence their implementation won't affect the generated lexer's
            operation.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.CharStream.readChar">
            <summary> Returns the next character from the selected input.  The method
            of selecting the input is the responsibility of the class
            implementing this interface.  Can throw any java.io.IOException.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.CharStream.backup(System.Int32)">
            <summary> Returns the column position of the character last read.
            </summary>
            <deprecated>
            </deprecated>
            <seealso cref="!: #getEndColumn
            
            "/>
            <summary> Returns the line number of the character last read.
            </summary>
            <deprecated>
            </deprecated>
            <seealso cref="!: #getEndLine
            
            "/>
            <summary> Returns the column number of the last character for current token (being
            matched after the last call to BeginTOken).
            </summary>
            <summary> Returns the line number of the last character for current token (being
            matched after the last call to BeginTOken).
            </summary>
            <summary> Returns the column number of the first character for current token (being
            matched after the last call to BeginTOken).
            </summary>
            <summary> Returns the line number of the first character for current token (being
            matched after the last call to BeginTOken).
            </summary>
            <summary> Backs up the input stream by amount steps. Lexer calls this method if it
            had already read some characters, but could not use them to match a
            (longer) token. So, they will be used again as the prefix of the next
            token and it is the implemetation's responsibility to do this right.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.CharStream.BeginToken">
            <summary> Returns the next character that marks the beginning of the next token.
            All characters must remain in the buffer between two successive calls
            to this method to implement backup correctly.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.CharStream.GetImage">
            <summary> Returns a string made up of characters from the marked token beginning
            to the current buffer position. Implementations have the choice of returning
            anything that they want to. For example, for efficiency, one might decide
            to just return null, which is a valid implementation.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.CharStream.GetSuffix(System.Int32)">
            <summary> Returns an array of characters that make up the suffix of length 'len' for
            the currently matched token. This is used to build up the matched string
            for use in actions in the case of MORE. A simple and inefficient
            implementation of this is as follows :
            
            {
            String t = GetImage();
            return t.substring(t.length() - len, t.length()).toCharArray();
            }
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.CharStream.Done">
            <summary> The lexer calls this function to indicate that it is done with the stream
            and hence implementations can free any resources held by this class.
            Again, the body of this function can be just empty and it will not
            affect the lexer's operation.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.ParseException">
            <summary> This exception is thrown when parse errors are encountered.
            You can explicitly create objects of this exception type by
            calling the method generateParseException in the generated
            parser.
            *
            You can modify this class to customize your error reporting
            mechanisms so long as you retain the public fields.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.ParseException.eol">
            <summary> The end of line string for this machine.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Runtime.Parser.ParseException.#ctor(NVelocity.Runtime.Parser.Token,System.Int32[][],System.String[])" -->
        <member name="M:NVelocity.Runtime.Parser.ParseException.#ctor">
            <summary> The following constructors are for use by you for whatever
            purpose you can think of.  Constructing the exception in this
            manner makes the exception behave in the normal way - i.e., as
            documented in the class "Throwable".  The fields "errorToken",
            "expectedTokenSequences", and "tokenImage" do not contain
            relevant information.  The JavaCC generated code does not use
            these constructors.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.ParseException.specialConstructor">
            <summary> This variable determines which constructor was used to create
            this object and thereby affects the semantics of the
            "getMessage" method (see below).
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.ParseException.currentToken">
            <summary> This is the last token that has been consumed successfully.  If
            this object has been created due to a parse error, the token
            followng this token will (therefore) be the first error token.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.ParseException.expectedTokenSequences">
            <summary> Each entry in this array is an array of integers.  Each array
            of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.ParseException.tokenImage">
            <summary> This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.ParseException.add_escapes(System.String)">
            <summary> Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII
            string literal.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Parser">
            <summary> This class is responsible for parsing a Velocity
            template. This class was generated by JavaCC using
            the JJTree extension to produce an Abstract
            Syntax Tree (AST) of the template.
            
            Please look at the Parser.jjt file which is
            what controls the generation of this class.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Parser.directives">
            <summary>  This Hashtable contains a list of all of the dynamic directives.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Parser.currentTemplateName">
            <summary>  Name of current template we are parsing.  Passed to us in parse()
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.#ctor(NVelocity.Runtime.RuntimeServices)">
            
            <summary> This constructor was added to allow the re-use of parsers.
            The normal constructor takes a single argument which
            an InputStream. This simply creates a re-usable parser
            object, we satisfy the requirement of an InputStream
            by using a newline character as an input stream.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.parse(System.IO.TextReader,System.String)">
            
            <summary> This was also added to allow parsers to be
            re-usable. Normal JavaCC use entails passing an
            input stream to the constructor and the parsing
            process is carried out once. We want to be able
            to re-use parsers: we do this by adding this
            method and re-initializing the lexer with
            the new stream that we want parsed.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.getDirective(System.String)">
            <summary>  This method gets a Directive from the directives Hashtable
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.isDirective(System.String)">
            <summary>  This method finds out of the directive exists in the directives
            Hashtable.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.escapedDirective(System.String)">
            <summary> Produces a processed output for an escaped control or
            pluggable directive
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.process">
            <summary> This method is what starts the whole parsing
            process. After the parsing is complete and
            the template has been turned into an AST,
            this method returns the root of AST which
            can subsequently be traversed by a visitor
            which implements the ParserVisitor interface
            which is generated automatically by JavaCC
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.Statement">
            <summary> These are the types of statements that
            are acceptable in Velocity templates.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.EscapedDirective">
            <summary>  used to separate the notion of a valid directive that has been
            escaped, versus something that looks like a directive and
            is just schmoo.  This is important to do as a separate production
            that creates a node, because we want this, in either case, to stop
            the further parsing of the Directive() tree.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Runtime.Parser.Parser.Escape" -->
        <member name="M:NVelocity.Runtime.Parser.Parser.Identifier">
            <summary> This method corresponds to variable
            references in Velocity templates.
            The following are examples of variable
            references that may be found in a
            template:
            *
            $foo
            $bar
            *
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.DirectiveArg">
            <summary>   Supports the arguments for the Pluggable Directives
            We add whitespace in here as a token so the VMs can
            easily reconstruct a macro body from the token stream
            See Directive()
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.Directive">
            <summary>   Supports the Pluggable Directives
            #foo( arg+ )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.IntegerRange">
            <summary>  supports the [n..m] vector generator for use in
            the #foreach() to generate measured ranges w/o
            needing explicit support from the app/servlet
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.Parameter">
            <summary> This method has yet to be fully implemented
            but will allow arbitrarily nested method
            calls
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.Method">
            <summary> This method has yet to be fully implemented
            but will allow arbitrarily nested method
            calls
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.Text">
            <summary> This method is responsible for allowing
            all non-grammar text to pass through
            unscathed.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.SetDirective">
            <summary>  Currently support both types of set :
            #set( expr )
            #set expr
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Parser.StopStatement">
            <summary> This method corresponds to the #stop
            directive which just simulates and EOF
            so that parsing stops. The #stop directive
            is useful for end-user debugging
            purposes.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Runtime.Parser.ParserTokenManager.stateStackPop" -->
        <member name="M:NVelocity.Runtime.Parser.ParserTokenManager.stateStackPush">
              pops a state off the stack, and restores paren counts
            
              @return bool : success of operation
        </member>
        <member name="M:NVelocity.Runtime.Parser.ParserTokenManager.clearStateVars">
            Clears all state variables, resets to
            start values, clears stateStack.  Call
            before parsing.
            @return void
        </member>
        <member name="M:NVelocity.Runtime.Parser.ParserTokenManager.RPARENHandler">
            handles the dropdown logic when encountering a RPAREN
        </member>
        <member name="M:NVelocity.Runtime.Parser.ParserTreeConstants.#ctor">
            <summary>
            private constructor as class is meant to hold constants only.
            Class was orginally an interface in Java, but as C# does not support Fields in an interface and
            the jjtNodeName field, I converted it to a class with no constructor.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.Token">
            <summary> Describes the input token stream.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Token.kind">
            <summary> An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.java.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Token.beginLine">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Token.beginColumn">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Token.endLine">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Token.endColumn">
            <summary> beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Token.image">
            <summary> The string image of the token.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Token.next">
            <summary> A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this field.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.Token.specialToken">
            <summary> This field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this field is set to null.
            When there are more than one such special token, this field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken field, and so on
            until the first special token (whose specialToken field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this field is null.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Token.ToString">
            <summary> Returns the image.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.Token.newToken(System.Int32)">
            <summary> Returns a new Token object, by default. However, if you want, you
            can create and return subclass objects based on the value of ofKind.
            Simply add the cases to the switch for all those special cases.
            For example, if you have a subclass of Token called IDToken that
            you want to create if ofKind is ID, simlpy add something like :
            *
            case MyParserConstants.ID : return new IDToken();
            *
            to the following switch statement. Then you can cast matchedToken
            variable to the appropriate type and use it in your lexical actions.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.TokenMgrError.LEXICAL_ERROR">
            <summary> Lexical error occured.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.TokenMgrError.STATIC_LEXER_ERROR">
            <summary> An attempt wass made to create a second instance of a static token manager.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.TokenMgrError.INVALID_LEXICAL_STATE">
            <summary> Tried to change to an invalid lexical state.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.TokenMgrError.LOOP_DETECTED">
            <summary> Detected (and bailed out of) an infinite loop in the token manager.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Parser.TokenMgrError.errorCode">
            <summary> Indicates the reason why the exception is thrown. It will have
            one of the above 4 values.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.TokenMgrError.addEscapes(System.String)">
            <summary> Replaces unprintable characters by their espaced (or unicode escaped)
            equivalents in the given string
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.TokenMgrError.LexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            <summary> Returns a detailed message for the Error when it is thrown by the
            token manager to indicate a lexical error.
            Parameters :
            EOFSeen     : indicates if EOF caused the lexicl error
            curLexState : lexical state in which this error occured
            errorLine   : line number when the error occured
            errorColumn : column number when the error occured
            errorAfter  : prefix that was seen before this error occured
            curchar     : the offending character
            Note: You can customize the lexical error message by modifying this method.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.TokenMgrError.#ctor">
            <summary> You can also modify the body of this method to customize your error messages.
            For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
            of end-users concern, so you can return something like :
            *
            "Internal Error : Please file a bug report .... "
            *
            from this method for such cases in the release version of your parser.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Parser.VelocityCharStream">
            <summary> An implementation of interface CharStream, where the stream is assumed to
            contain only ASCII characters (without unicode processing).
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Parser.VelocityCharStream.backup(System.Int32)">
            <deprecated>
            </deprecated>
            <seealso cref="!: #getEndLine
            
            "/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Runtime.Parser.VelocityCharStream.adjustBeginLineColumn(System.Int32,System.Int32)" -->
        <member name="T:NVelocity.Runtime.Resource.Loader.FileResourceLoader">
            <summary>
            A loader for templates stored on the file system.
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a> </author>
        </member>
        <member name="T:NVelocity.Runtime.Resource.Loader.ResourceLoader">
            <summary>
            This is abstract class the all text resource loaders should extend.
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
            <version> $Id$</version>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Loader.ResourceLoader.isCachingOn_Renamed_Field">
            
            <summary> Does this loader want templates produced with it
            cached in the Runtime.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Loader.ResourceLoader.modificationCheckInterval">
            <summary> This property will be passed on to the templates
            that are created with this loader.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Loader.ResourceLoader.className">
            <summary> Class name for this loader, for logging/debuggin
            purposes.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.ResourceLoader.commonInit(NVelocity.Runtime.RuntimeServices,Commons.Collections.ExtendedProperties)">
            <summary> This initialization is used by all resource
            loaders and must be called to set up common
            properties shared by all resource loaders
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.ResourceLoader.init(Commons.Collections.ExtendedProperties)">
            
            <summary> Initialize the template loader with a
            a resources class.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.ResourceLoader.getResourceStream(System.String)">
            
            <summary> Get the InputStream that the Runtime will parse
            to create a template.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.ResourceLoader.isSourceModified(NVelocity.Runtime.Resource.Resource)">
            <summary> Given a template, check to see if the source of InputStream
            has been modified.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.ResourceLoader.getLastModified(NVelocity.Runtime.Resource.Resource)">
            <summary> Get the last modified time of the InputStream source
            that was used to create the template. We need the template
            here because we have to extract the name of the template
            in order to locate the InputStream source.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.ResourceLoader.isCachingOn">
            <summary> The Runtime uses this to find out whether this
            template loader wants the Runtime to cache
            templates created with InputStreams provided
            by this loader.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Loader.FileResourceLoader.paths">
            <summary>
            The paths to search for templates.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Loader.FileResourceLoader.templatePaths">
            <summary>
            Used to map the path that a template was found on
            so that we can properly check the modification
            times of the files.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.FileResourceLoader.getResourceStream(System.String)">
            <summary>
            Get an InputStream so that the Runtime can build a
            template with it.
            </summary>
            <param name="name">name of template to get</param>
            <returns>InputStream containing the template
            @throws ResourceNotFoundException if template not found
            in the file template path.
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.FileResourceLoader.findTemplate(System.String,System.String)">
            <summary>
            Try to find a template given a normalized path.
            </summary>
            <param name="String">a normalized path</param>
            <returns>InputStream input stream that will be parsed</returns>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.FileResourceLoader.isSourceModified(NVelocity.Runtime.Resource.Resource)">
            <summary>
            How to keep track of all the modified times
            across the paths.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Resource.Loader.ResourceLoaderFactory">
            <summary>
            Factory to grab a template loader.
            </summary>
            <author><a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Loader.ResourceLoaderFactory.getLoader(NVelocity.Runtime.RuntimeServices,System.String)">
            <summary>
            Gets the loader specified in the configuration file.
            </summary>
            <returns>TemplateLoader</returns>
        </member>
        <member name="T:NVelocity.Runtime.Resource.Loader.ResourceLocator">
            <summary>
            Locates a resource (file) in the file system or as a resource in an assembly.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Resource.ContentResource">
            <summary> This class represent a general text resource that
            may have been retrieved from any number of possible
            sources.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="T:NVelocity.Runtime.Resource.Resource">
            <summary> This class represent a general text resource that
            may have been retrieved from any number of possible
            sources.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Resource.MILLIS_PER_SECOND">
            <summary> The number of milliseconds in a minute, used to calculate the
            check interval.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Resource.resourceLoader">
            <summary> The template loader that initially loaded the input
            stream for this template, and knows how to check the
            source of the input stream for modification.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Resource.modificationCheckInterval">
            <summary> How often the file modification time is checked (in milliseconds).
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Resource.lastModified">
            <summary> The file modification time (in milliseconds) for the cached template.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Resource.nextCheck">
            <summary> The next time the file modification time will be checked (in
            milliseconds).
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Resource.name">
            <summary>  Name of the resource
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Resource.encoding">
            <summary>  Character encoding of this resource
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.Resource.data">
            
            <summary>  Resource might require ancillary storage of some kind
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Resource.#ctor">
            
            <summary>  Default constructor
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Resource.Process">
            <summary> Perform any subsequent processing that might need
            to be done by a resource. In the case of a template
            the actual parsing of the input stream needs to be
            performed.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Resource.RequiresChecking">
            <summary> Is it time to check to see if the resource
            source has been updated?
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.Resource.Touch">
            <summary> 'Touch' this template and thereby resetting
            the nextCheck field.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ContentResource.#ctor">
            <summary>Default empty constructor
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ContentResource.Process">
            <summary>Pull in static content and store it
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Resource.ResourceCache">
            <summary> Interface that defines the shape of a pluggable resource cache
            for the included ResourceManager
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceCache.initialize(NVelocity.Runtime.RuntimeServices)">
            <summary>  initializes the ResourceCache.  Will be
            called before any utilization
            *
            </summary>
            <param name="rs">RuntimeServices to use for logging, etc
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceCache.get(System.Object)">
            <summary>  retrieves a Resource from the
            cache
            *
            </summary>
            <param name="resourceKey">key for Resource to be retrieved
            </param>
            <returns>Resource specified or null if not found
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceCache.put(System.Object,NVelocity.Runtime.Resource.Resource)">
            <summary>  stores a Resource in the cache
            *
            </summary>
            <param name="resourceKey">key to associate with the Resource
            </param>
            <param name="resource">Resource to be stored
            </param>
            <returns>existing Resource stored under this key, or null if none
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceCache.remove(System.Object)">
            <summary>  removes a Resource from the cache
            *
            </summary>
            <param name="resourceKey">resource to be removed
            </param>
            <param name="Resource">stored under key
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceCache.enumerateKeys">
            <summary>  returns an Iterator of Keys in the cache
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Resource.ResourceCacheImpl">
            <summary> Default implementation of the resource cache for the default
            ResourceManager.
            *
            </summary>
            <author> <a href="mailto:geirm@apache.org">Geir Magnusson Jr.</a>
            </author>
            <author> <a href="mailto:dlr@finemaltcoding.com">Daniel Rall</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceCacheImpl.cache">
            <summary>
            Cache storage, assumed to be thread-safe.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceCacheImpl.rsvc">
            <summary>
            Runtime services, generally initialized by the
            <code>initialize()</code> method.
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Resource.ResourceFactory">
            <summary> Class responsible for instantiating <code>Resource</code> objects,
            given name and type.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="T:NVelocity.Runtime.Resource.ResourceManager_Fields">
            <summary> Class to manage the text resource for the Velocity
            Runtime.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:paulo.gaspar@krankikom.de">Paulo Gaspar</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceManager.initialize(NVelocity.Runtime.RuntimeServices)">
            <summary> A template resources.
            </summary>
            <summary> A static content resource.
            </summary>
            <summary> Initialize the ResourceManager. It is assumed
            that assembleSourceInitializers() has been
            called before this is run.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceManager.getResource(System.String,System.Int32,System.String)">
            <summary> Gets the named resource.  Returned class type corresponds to specified type
            (i.e. <code>Template</code> to <code>RESOURCE_TEMPLATE</code>).
            *
            </summary>
            <param name="resourceName">The name of the resource to retrieve.
            </param>
            <param name="resourceType">The type of resource (<code>RESOURCE_TEMPLATE</code>,
            <code>RESOURCE_CONTENT</code>, etc.).
            </param>
            <param name="encoding"> The character encoding to use.
            </param>
            <returns>Resource with the template parsed and ready.
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception if a problem in parse
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceManager.getLoaderNameForResource(System.String)">
            <summary>  Determines is a template exists, and returns name of the loader that
            provides it.  This is a slightly less hokey way to support
            the Velocity.templateExists() utility method, which was broken
            when per-template encoding was introduced.  We can revisit this.
            *
            </summary>
            <param name="resourceName">Name of template or content resource
            </param>
            <returns>class name of loader than can provide it
            
            </returns>
        </member>
        <member name="T:NVelocity.Runtime.Resource.ResourceManagerImpl">
            <summary> Class to manage the text resource for the Velocity
            Runtime.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:paulo.gaspar@krankikom.de">Paulo Gaspar</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceManagerImpl.RESOURCE_TEMPLATE">
            <summary> A template resources.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceManagerImpl.RESOURCE_CONTENT">
            <summary> A static content resource.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceManagerImpl.RESOURCE_LOADER_IDENTIFIER">
            <summary> token used to identify the loader internally
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceManagerImpl.globalCache">
            <summary>  Object implementing ResourceCache to
            be our resource manager's Resource cache.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceManagerImpl.resourceLoaders">
            <summary> The List of templateLoaders that the Runtime will
            use to locate the InputStream source of a template.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NVelocity.Runtime.Resource.ResourceManagerImpl.sourceInitializerList" -->
        <member name="F:NVelocity.Runtime.Resource.ResourceManagerImpl.sourceInitializerMap">
            <summary> This is a map of public name of the template
            stream source to it's initializer. This is so
            that clients of velocity can set properties of
            a template source stream with its public name.
            So for example, a client could set the
            File.resource.path property and this would
            change the resource.path property for the
            file template stream source.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceManagerImpl.resourceLoaderInitializersActive">
            <summary> Each loader needs a configuration object for
            its initialization, this flags keeps track of whether
            or not the configuration objects have been created
            for the resource loaders.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Resource.ResourceManagerImpl.logWhenFound">
            <summary>
            switch to turn off log notice when a resource is found for
            the first time.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceManagerImpl.initialize(NVelocity.Runtime.RuntimeServices)">
            <summary> Initialize the ResourceManager. It is assumed
            that assembleSourceInitializers() has been
            called before this is run.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceManagerImpl.assembleResourceLoaderInitializers">
            <summary> This will produce a List of Hashtables, each
            hashtable contains the intialization info for
            a particular resource loader. This Hastable
            will be passed in when initializing the
            the template loader.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceManagerImpl.getResource(System.String,System.Int32,System.String)">
            <summary> Gets the named resource.  Returned class type corresponds to specified type
            (i.e. <code>Template</code> to <code>RESOURCE_TEMPLATE</code>).
            *
            </summary>
            <param name="resourceName">The name of the resource to retrieve.
            </param>
            <param name="resourceType">The type of resource (<code>RESOURCE_TEMPLATE</code>,
            <code>RESOURCE_CONTENT</code>, etc.).
            </param>
            <param name="encoding"> The character encoding to use.
            </param>
            <returns>Resource with the template parsed and ready.
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception if a problem in parse
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceManagerImpl.loadResource(System.String,System.Int32,System.String)">
            <summary>
            Loads a resource from the current set of resource loaders
            </summary>
            <param name="resourceName">The name of the resource to retrieve.</param>
            <param name="resourceType">The type of resource (<code>RESOURCE_TEMPLATE</code>,
            <code>RESOURCE_CONTENT</code>, etc.).
            </param>
            <param name="encoding"> The character encoding to use.</param>
            <returns>Resource with the template parsed and ready.
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception if a problem in parse
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceManagerImpl.refreshResource(NVelocity.Runtime.Resource.Resource,System.String)">
            <summary>  Takes an existing resource, and 'refreshes' it.  This
            generally means that the source of the resource is checked
            for changes according to some cache/check algorithm
            and if the resource changed, then the resource data is
            reloaded and re-parsed.
            *
            </summary>
            <param name="resource">resource to refresh
            *
            @throws ResourceNotFoundException if template not found
            from current source for this Resource
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception if a problem in parse
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceManagerImpl.getResource(System.String,System.Int32)">
            <summary> Gets the named resource.  Returned class type corresponds to specified type
            (i.e. <code>Template</code> to <code>RESOURCE_TEMPLATE</code>).
            *
            </summary>
            <param name="resourceName">The name of the resource to retrieve.
            </param>
            <param name="resourceType">The type of resource (<code>RESOURCE_TEMPLATE</code>,
            <code>RESOURCE_CONTENT</code>, etc.).
            </param>
            <returns>Resource with the template parsed and ready.
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception if a problem in parse
            *
            </returns>
            <deprecated>Use
            {@link #getResource(String resourceName, int resourceType,
            String encoding )}
            
            </deprecated>
        </member>
        <member name="M:NVelocity.Runtime.Resource.ResourceManagerImpl.getLoaderNameForResource(System.String)">
            <summary>  Determines is a template exists, and returns name of the loader that
            provides it.  This is a slightly less hokey way to support
            the Velocity.templateExists() utility method, which was broken
            when per-template encoding was introduced.  We can revisit this.
            *
            </summary>
            <param name="resourceName">Name of template or content resource
            </param>
            <returns>class name of loader than can provide it
            
            </returns>
        </member>
        <member name="T:NVelocity.Runtime.Visitor.BaseVisitor">
            <summary> This is the base class for all visitors.
            For each AST node, this class will provide
            a bare-bones method for traversal.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="F:NVelocity.Runtime.Visitor.BaseVisitor.context">
            <summary>Context used during traversal
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.Visitor.BaseVisitor.writer">
            <summary>Writer used as the output sink
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Visitor.NodeViewMode">
            <summary> This class is simply a visitor implementation
            that traverses the AST, produced by the Velocity
            parsing process, and creates a visual structure
            of the AST. This is primarily used for
            debugging, but it useful for documentation
            as well.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.indentString">
            <summary>Indent child nodes to help visually identify
            the structure of the AST.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.showNode(NVelocity.Runtime.Parser.Node.INode,System.Object)">
            <summary> Display the type of nodes and optionally the
            first token.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.SimpleNode,System.Object)">
            <summary>Display a SimpleNode
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTprocess,System.Object)">
            <summary>Display an ASTprocess node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTExpression,System.Object)">
            <summary>Display an ASTExpression node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTAssignment,System.Object)">
            <summary>Display an ASTAssignment node ( = )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTOrNode,System.Object)">
            <summary>Display an ASTOrNode ( || )
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTAndNode,System.Object)" -->
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTEQNode,System.Object)">
            <summary>Display an ASTEQNode ( == )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTNENode,System.Object)">
            <summary>Display an ASTNENode ( != )
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTLTNode,System.Object)" -->
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTGTNode,System.Object)">
            <summary>Display an ASTGTNode ( > )
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTLENode,System.Object)" -->
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTGENode,System.Object)">
            <summary>Display an ASTGENode ( >= )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTAddNode,System.Object)">
            <summary>Display an ASTAddNode ( + )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTSubtractNode,System.Object)">
            <summary>Display an ASTSubtractNode ( - )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTMulNode,System.Object)">
            <summary>Display an ASTMulNode ( * )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTDivNode,System.Object)">
            <summary>Display an ASTDivNode ( / )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTModNode,System.Object)">
            <summary>Display an ASTModNode ( % )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTNotNode,System.Object)">
            <summary>Display an ASTNotNode ( ! )
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTNumberLiteral,System.Object)">
            <summary>Display an ASTNumberLiteral node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTStringLiteral,System.Object)">
            <summary>Display an ASTStringLiteral node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTIdentifier,System.Object)">
            <summary>Display an ASTIdentifier node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTMethod,System.Object)">
            <summary>Display an ASTMethod node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTReference,System.Object)">
            <summary>Display an ASTReference node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTTrue,System.Object)">
            <summary>Display an ASTTrue node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTFalse,System.Object)">
            <summary>Display an ASTFalse node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTBlock,System.Object)">
            <summary>Display an ASTBlock node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTText,System.Object)">
            <summary>Display an ASTText node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTIfStatement,System.Object)">
            <summary>Display an ASTIfStatement node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTElseStatement,System.Object)">
            <summary>Display an ASTElseStatement node
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.NodeViewMode.visit(NVelocity.Runtime.Parser.Node.ASTElseIfStatement,System.Object)">
            <summary>Display an ASTElseIfStatement node
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.Visitor.VMReferenceMungeVisitor">
            <summary>
            This class is a visitor used by the VM proxy to change the
            literal representation of a reference in a VM.  The reason is
            to preserve the 'render literal if null' behavior w/o making
            the VMProxy stuff more complicated than it is already.
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
            <version> $Id$</version>
        </member>
        <member name="F:NVelocity.Runtime.Visitor.VMReferenceMungeVisitor.argmap">
            <summary>
            Map containing VM arg to instance-use reference
            Passed in with CTOR
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.VMReferenceMungeVisitor.#ctor(System.Collections.Hashtable)">
            <summary>
            CTOR - takes a map of args to reference
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.Visitor.VMReferenceMungeVisitor.visit(NVelocity.Runtime.Parser.Node.ASTReference,System.Object)">
            <summary>
            Visitor method - if the literal is right, will
            set the literal in the ASTReference node
            </summary>
            <param name="node">ASTReference to work on</param>
            <param name="data">Object to pass down from caller</param>
        </member>
        <member name="T:NVelocity.Runtime.RuntimeConstants_Fields">
            <summary>
            This class defines the keys that are used in the
            velocity.properties file so that they can be referenced as a constant
            within Java code.
            </summary>
            <author> <a href="mailto:jon@latchkey.com">Jon S. Stevens</a></author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a></author>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a></author>
        </member>
        <member name="T:NVelocity.Runtime.RuntimeInstance">
            <summary> This is the Runtime system for Velocity. It is the
            single access point for all functionality in Velocity.
            It adheres to the mediator pattern and is the only
            structure that developers need to be familiar with
            in order to get Velocity to perform.
            *
            The Runtime will also cooperate with external
            systems like Turbine. Runtime properties can
            set and then the Runtime is initialized.
            *
            Turbine for example knows where the templates
            are to be loaded from, and where the velocity
            log file should be placed.
            *
            So in the case of Velocity cooperating with Turbine
            the code might look something like the following:
            *
            <pre>
            Runtime.setProperty(Runtime.FILE_RESOURCE_LOADER_PATH, templatePath);
            Runtime.setProperty(Runtime.RUNTIME_LOG, pathToVelocityLog);
            Runtime.init();
            </pre>
            *
            <pre>
            -----------------------------------------------------------------------
            N O T E S  O N  R U N T I M E  I N I T I A L I Z A T I O N
            -----------------------------------------------------------------------
            Runtime.init()
            
            If Runtime.init() is called by itself the Runtime will
            initialize with a set of default values.
            -----------------------------------------------------------------------
            Runtime.init(String/Properties)
            *
            In this case the default velocity properties are layed down
            first to provide a solid base, then any properties provided
            in the given properties object will override the corresponding
            default property.
            -----------------------------------------------------------------------
            </pre>
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:jlb@houseofdistraction.com">Jeff Bowden</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="T:NVelocity.Runtime.RuntimeServices">
            <summary> Interface for internal runtime services that are needed by the
            various components w/in Velocity.  This was taken from the old
            Runtime singleton, and anything not necessary was removed.
            
            Currently implemented by RuntimeInstance.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.setProperty(System.String,System.Object)">
            <summary> Allows an external system to set a property in
            the Velocity Runtime.
            *
            </summary>
            <param name="String">property key
            </param>
            <param name="String">property value
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.addProperty(System.String,System.Object)">
            <summary> Allow an external system to set an ExtendedProperties
            object to use. This is useful where the external
            system also uses the ExtendedProperties class and
            the velocity configuration is a subset of
            parent application's configuration. This is
            the case with Turbine.
            *
            </summary>
            <param name="ExtendedProperties">configuration
            
            </param>
            <summary> Add a property to the configuration. If it already
            exists then the value stated here will be added
            to the configuration entry. For example, if
            *
            resource.loader = file
            *
            is already present in the configuration and you
            *
            addProperty("resource.loader", "classpath")
            *
            Then you will end up with a Vector like the
            following:
            *
            ["file", "classpath"]
            *
            </summary>
            <param name="String">key
            </param>
            <param name="String">value
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.clearProperty(System.String)">
            <summary> Clear the values pertaining to a particular
            property.
            *
            </summary>
            <param name="String">key of property to clear
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.getProperty(System.String)">
            <summary>  Allows an external caller to get a property.  The calling
            routine is required to know the type, as this routine
            will return an Object, as that is what properties can be.
            *
            </summary>
            <param name="key">property to return
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.init(System.String)">
            <summary> Initialize the Velocity Runtime with the name of
            ExtendedProperties object.
            *
            </summary>
            <param name="">Properties
            
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Runtime.RuntimeServices.parse(System.IO.TextReader,System.String)" -->
        <member name="M:NVelocity.Runtime.RuntimeServices.parse(System.IO.TextReader,System.String,System.Boolean)">
            <summary>  Parse the input and return the root of the AST node structure.
            *
            </summary>
            <param name="InputStream">inputstream retrieved by a resource loader
            </param>
            <param name="String">name of the template being parsed
            </param>
            <param name="dumpNamespace">flag to dump the Velocimacro namespace for this template
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.getTemplate(System.String)">
            <summary> Returns a <code>Template</code> from the resource manager.
            This method assumes that the character encoding of the
            template is set by the <code>input.encoding</code>
            property.  The default is "ISO-8859-1"
            *
            </summary>
            <param name="name">The file name of the desired template.
            </param>
            <returns>    The template.
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception if an error occurs in template initialization
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.getTemplate(System.String,System.String)">
            <summary> Returns a <code>Template</code> from the resource manager
            *
            </summary>
            <param name="name">The  name of the desired template.
            </param>
            <param name="encoding">Character encoding of the template
            </param>
            <returns>    The template.
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception if an error occurs in template initialization
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.getContent(System.String)">
            <summary> Returns a static content resource from the
            resource manager.  Uses the current value
            if INPUT_ENCODING as the character encoding.
            *
            </summary>
            <param name="name">Name of content resource to get
            </param>
            <returns>parsed ContentResource object ready for use
            @throws ResourceNotFoundException if template not found
            from any available source.
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.getContent(System.String,System.String)">
            <summary> Returns a static content resource from the
            resource manager.
            *
            </summary>
            <param name="name">Name of content resource to get
            </param>
            <param name="encoding">Character encoding to use
            </param>
            <returns>parsed ContentResource object ready for use
            @throws ResourceNotFoundException if template not found
            from any available source.
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.getLoaderNameForResource(System.String)">
            <summary>  Determines is a template exists, and returns name of the loader that
            provides it.  This is a slightly less hokey way to support
            the Velocity.templateExists() utility method, which was broken
            when per-template encoding was introduced.  We can revisit this.
            *
            </summary>
            <param name="resourceName">Name of template or content resource
            </param>
            <returns>class name of loader than can provide it
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.warn(System.Object)">
            <summary> Log a warning message.
            *
            </summary>
            <param name="Object">message to log
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.info(System.Object)">
            
            <summary> Log an info message.
            *
            </summary>
            <param name="Object">message to log
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.error(System.Object)">
            <summary> Log an error message.
            *
            </summary>
            <param name="Object">message to log
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.debug(System.Object)">
            <summary> Log a debug message.
            *
            </summary>
            <param name="Object">message to log
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.getString(System.String,System.String)">
            <summary> String property accessor method with default to hide the
            configuration implementation.
            
            </summary>
            <param name="String">key property key
            </param>
            <param name="String">defaultValue  default value to return if key not
            found in resource manager.
            </param>
            <returns>String  value of key or default
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.getVelocimacro(System.String,System.String)">
            <summary> Returns the appropriate VelocimacroProxy object if strVMname
            is a valid current Velocimacro.
            *
            </summary>
            <param name="String">vmName  Name of velocimacro requested
            </param>
            <returns>String VelocimacroProxy
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.addVelocimacro(System.String,System.String,System.String[],System.String)">
            <summary> Adds a new Velocimacro. Usually called by Macro only while parsing.
            *
            </summary>
            <param name="String">name  Name of velocimacro
            </param>
            <param name="String">macro  String form of macro body
            </param>
            <param name="String">argArray  Array of strings, containing the
            #macro() arguments.  the 0th is the name.
            </param>
            <returns>boolean  True if added, false if rejected for some
            reason (either parameters or permission settings)
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.isVelocimacro(System.String,System.String)">
            <summary>  Checks to see if a VM exists
            *
            </summary>
            <param name="name"> Name of velocimacro
            </param>
            <returns>boolean  True if VM by that name exists, false if not
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.dumpVMNamespace(System.String)">
            <summary>  tells the vmFactory to dump the specified namespace.  This is to support
            clearing the VM list when in inline-VM-local-scope mode
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.getString(System.String)">
            <summary> String property accessor method to hide the configuration implementation
            </summary>
            <param name="key"> property key
            </param>
            <returns>  value of key or null
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.getInt(System.String)">
            <summary> Int property accessor method to hide the configuration implementation.
            *
            </summary>
            <param name="String">key property key
            </param>
            <returns>int value
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.getInt(System.String,System.Int32)">
            <summary> Int property accessor method to hide the configuration implementation.
            *
            </summary>
            <param name="key"> property key
            </param>
            <param name="int">default value
            </param>
            <returns>int  value
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.getBoolean(System.String,System.Boolean)">
            <summary> Boolean property accessor method to hide the configuration implementation.
            
            </summary>
            <param name="String">key  property key
            </param>
            <param name="boolean">default default value if property not found
            </param>
            <returns>boolean  value of key or default value
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeServices.getApplicationAttribute(System.Object)">
            <summary> Return the velocity runtime configuration object.
            *
            </summary>
            <returns>ExtendedProperties configuration object which houses
            the velocity runtime properties.
            
            </returns>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeInstance.vmFactory">
            <summary>  VelocimacroFactory object to manage VMs
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeInstance.logSystem">
            
            <summary>  The Runtime logger.  We start with an instance of
            a 'primordial logger', which just collects log messages
            then, when the log system is initialized, we dump
            all messages out of the primordial one into the real one.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeInstance.parserPool">
            
            <summary> The Runtime parser pool
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeInstance.initialized">
            
            <summary> Indicate whether the Runtime has been fully initialized.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeInstance.overridingProperties">
            <summary> These are the properties that are laid down over top
            of the default properties when requested.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeInstance.runtimeDirectives">
            <summary> This is a hashtable of initialized directives.
            The directives that populate this hashtable are
            taken from the RUNTIME_DEFAULT_DIRECTIVES
            property file. This hashtable is passed
            to each parser that is created.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.RuntimeInstance.configuration">
            <summary> Object that houses the configuration options for
            the velocity runtime. The ExtendedProperties object allows
            the convenient retrieval of a subset of properties.
            For example all the properties for a resource loader
            can be retrieved from the main ExtendedProperties object
            using something like the following:
            *
            ExtendedProperties loaderConfiguration =
            configuration.subset(loaderID);
            *
            And a configuration is a lot more convenient to deal
            with then conventional properties objects, or Maps.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.setDefaultProperties">
            <summary> Initializes the Velocity Runtime with properties file.
            The properties file may be in the file system proper,
            or the properties file may be in the classpath.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.setProperty(System.String,System.Object)">
            <summary> Allows an external system to set a property in
            the Velocity Runtime.
            *
            </summary>
            <param name="String">property key
            </param>
            <param name="String">property value
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.addProperty(System.String,System.Object)">
            <summary> Add a property to the configuration. If it already
            exists then the value stated here will be added
            to the configuration entry. For example, if
            *
            resource.loader = file
            *
            is already present in the configuration and you
            *
            addProperty("resource.loader", "classpath")
            *
            Then you will end up with a Vector like the
            following:
            *
            ["file", "classpath"]
            *
            </summary>
            <param name="String">key
            </param>
            <param name="String">value
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.clearProperty(System.String)">
            <summary> Clear the values pertaining to a particular
            property.
            *
            </summary>
            <param name="String">key of property to clear
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.getProperty(System.String)">
            <summary>  Allows an external caller to get a property.  The calling
            routine is required to know the type, as this routine
            will return an Object, as that is what properties can be.
            *
            </summary>
            <param name="key">property to return
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.initializeProperties">
            <summary> Initialize Velocity properties, if the default
            properties have not been laid down first then
            do so. Then proceed to process any overriding
            properties. Laying down the default properties
            gives a much greater chance of having a
            working system.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.init(Commons.Collections.ExtendedProperties)">
            <summary> Initialize the Velocity Runtime with a Properties
            object.
            *
            </summary>
            <param name="">Properties
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.init(System.String)">
            <summary> Initialize the Velocity Runtime with the name of
            ExtendedProperties object.
            *
            </summary>
            <param name="">Properties
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.initializeLogger">
            <summary> Initialize the Velocity logging system.
            *
            @throws Exception
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.initializeDirectives">
            <summary> This methods initializes all the directives
            that are used by the Velocity Runtime. The
            directives to be initialized are listed in
            the RUNTIME_DEFAULT_DIRECTIVES properties
            file.
            
            @throws Exception
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.loadDirective(System.String,System.String)">
            <summary>  instantiates and loads the directive with some basic checks
            
            </summary>
            <param name="directiveClass">classname of directive to load
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.initializeParserPool">
            <summary> Initializes the Velocity parser pool.
            This still needs to be implemented.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.createNewParser">
            <summary> Returns a JavaCC generated Parser.
            </summary>
            <returns>Parser javacc generated parser
            
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Runtime.RuntimeInstance.parse(System.IO.TextReader,System.String)" -->
        <member name="M:NVelocity.Runtime.RuntimeInstance.parse(System.IO.TextReader,System.String,System.Boolean)">
            <summary>  Parse the input and return the root of the AST node structure.
            *
            </summary>
            <param name="InputStream">inputstream retrieved by a resource loader
            </param>
            <param name="String">name of the template being parsed
            </param>
            <param name="dumpNamespace">flag to dump the Velocimacro namespace for this template
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.getTemplate(System.String)">
            <summary> Returns a <code>Template</code> from the resource manager.
            This method assumes that the character encoding of the
            template is set by the <code>input.encoding</code>
            property.  The default is "ISO-8859-1"
            *
            </summary>
            <param name="name">The file name of the desired template.
            </param>
            <returns>    The template.
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception if an error occurs in template initialization
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.getTemplate(System.String,System.String)">
            <summary> Returns a <code>Template</code> from the resource manager
            *
            </summary>
            <param name="name">The  name of the desired template.
            </param>
            <param name="encoding">Character encoding of the template
            </param>
            <returns>    The template.
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception if an error occurs in template initialization
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.getContent(System.String)">
            <summary> Returns a static content resource from the
            resource manager.  Uses the current value
            if INPUT_ENCODING as the character encoding.
            *
            </summary>
            <param name="name">Name of content resource to get
            </param>
            <returns>parsed ContentResource object ready for use
            @throws ResourceNotFoundException if template not found
            from any available source.
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.getContent(System.String,System.String)">
            <summary> Returns a static content resource from the
            resource manager.
            *
            </summary>
            <param name="name">Name of content resource to get
            </param>
            <param name="encoding">Character encoding to use
            </param>
            <returns>parsed ContentResource object ready for use
            @throws ResourceNotFoundException if template not found
            from any available source.
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.getLoaderNameForResource(System.String)">
            <summary>  Determines is a template exists, and returns name of the loader that
            provides it.  This is a slightly less hokey way to support
            the Velocity.templateExists() utility method, which was broken
            when per-template encoding was introduced.  We can revisit this.
            *
            </summary>
            <param name="resourceName">Name of template or content resource
            </param>
            <returns>class name of loader than can provide it
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.showStackTrace">
            <summary> Added this to check and make sure that the configuration
            is initialized before trying to get properties from it.
            This occurs when there are errors during initialization
            and the default properties have yet to be layed down.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.log(System.Int32,System.Object)">
            <summary> Handle logging.
            *
            </summary>
            <param name="String">message to log
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.warn(System.Object)">
            <summary> Log a warning message.
            *
            </summary>
            <param name="Object">message to log
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.info(System.Object)">
            
            <summary> Log an info message.
            *
            </summary>
            <param name="Object">message to log
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.error(System.Object)">
            <summary> Log an error message.
            *
            </summary>
            <param name="Object">message to log
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.debug(System.Object)">
            <summary> Log a debug message.
            *
            </summary>
            <param name="Object">message to log
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.getString(System.String,System.String)">
            <summary> String property accessor method with default to hide the
            configuration implementation.
            
            </summary>
            <param name="String">key property key
            </param>
            <param name="String">defaultValue  default value to return if key not
            found in resource manager.
            </param>
            <returns>String  value of key or default
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.getVelocimacro(System.String,System.String)">
            <summary> Returns the appropriate VelocimacroProxy object if strVMname
            is a valid current Velocimacro.
            *
            </summary>
            <param name="String">vmName  Name of velocimacro requested
            </param>
            <returns>String VelocimacroProxy
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.addVelocimacro(System.String,System.String,System.String[],System.String)">
            <summary> Adds a new Velocimacro. Usually called by Macro only while parsing.
            *
            </summary>
            <param name="String">name  Name of velocimacro
            </param>
            <param name="String">macro  String form of macro body
            </param>
            <param name="String">argArray  Array of strings, containing the
            #macro() arguments.  the 0th is the name.
            </param>
            <returns>boolean  True if added, false if rejected for some
            reason (either parameters or permission settings)
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.isVelocimacro(System.String,System.String)">
            <summary>  Checks to see if a VM exists
            *
            </summary>
            <param name="name"> Name of velocimacro
            </param>
            <returns>boolean  True if VM by that name exists, false if not
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.dumpVMNamespace(System.String)">
            <summary>  tells the vmFactory to dump the specified namespace.  This is to support
            clearing the VM list when in inline-VM-local-scope mode
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.getString(System.String)">
            <summary> String property accessor method to hide the configuration implementation
            </summary>
            <param name="key"> property key
            </param>
            <returns>  value of key or null
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.getInt(System.String)">
            <summary> Int property accessor method to hide the configuration implementation.
            *
            </summary>
            <param name="String">key property key
            </param>
            <returns>int value
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.getInt(System.String,System.Int32)">
            <summary> Int property accessor method to hide the configuration implementation.
            *
            </summary>
            <param name="key"> property key
            </param>
            <param name="int">default value
            </param>
            <returns>int  value
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.getBoolean(System.String,System.Boolean)">
            <summary> Boolean property accessor method to hide the configuration implementation.
            
            </summary>
            <param name="String">key  property key
            </param>
            <param name="boolean">default default value if property not found
            </param>
            <returns>boolean  value of key or default value
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeInstance.getApplicationAttribute(System.Object)">
            <summary>  Return the Introspector for this instance
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.RuntimeSingleton">
            <summary> This is the Runtime system for Velocity. It is the
            single access point for all functionality in Velocity.
            It adheres to the mediator pattern and is the only
            structure that developers need to be familiar with
            in order to get Velocity to perform.
            *
            The Runtime will also cooperate with external
            systems like Turbine. Runtime properties can
            set and then the Runtime is initialized.
            *
            Turbine for example knows where the templates
            are to be loaded from, and where the velocity
            log file should be placed.
            *
            So in the case of Velocity cooperating with Turbine
            the code might look something like the following:
            *
            <pre>
            Runtime.setProperty(Runtime.FILE_RESOURCE_LOADER_PATH, templatePath);
            Runtime.setProperty(Runtime.RUNTIME_LOG, pathToVelocityLog);
            Runtime.init();
            </pre>
            *
            <pre>
            -----------------------------------------------------------------------
            N O T E S  O N  R U N T I M E  I N I T I A L I Z A T I O N
            -----------------------------------------------------------------------
            Runtime.init()
            
            If Runtime.init() is called by itself the Runtime will
            initialize with a set of default values.
            -----------------------------------------------------------------------
            Runtime.init(String/Properties)
            *
            In this case the default velocity properties are layed down
            first to provide a solid base, then any properties provided
            in the given properties object will override the corresponding
            default property.
            -----------------------------------------------------------------------
            </pre>
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:jlb@houseofdistraction.com">Jeff Bowden</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.setProperty(System.String,System.Object)">
            <summary> Allows an external system to set a property in
            the Velocity Runtime.
            *
            </summary>
            <param name="String">property key
            </param>
            <param name="String">property value
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.addProperty(System.String,System.Object)">
            <summary> Add a property to the configuration. If it already
            exists then the value stated here will be added
            to the configuration entry. For example, if
            *
            resource.loader = file
            *
            is already present in the configuration and you
            *
            addProperty("resource.loader", "classpath")
            *
            Then you will end up with a Vector like the
            following:
            *
            ["file", "classpath"]
            *
            </summary>
            <param name="String">key
            </param>
            <param name="String">value
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.clearProperty(System.String)">
            <summary> Clear the values pertaining to a particular
            property.
            *
            </summary>
            <param name="String">key of property to clear
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.getProperty(System.String)">
            <summary>  Allows an external caller to get a property.  The calling
            routine is required to know the type, as this routine
            will return an Object, as that is what properties can be.
            *
            </summary>
            <param name="key">property to return
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.init(Commons.Collections.ExtendedProperties)">
            <summary> Initialize the Velocity Runtime with a Properties
            object.
            *
            </summary>
            <param name="">Properties
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.init(System.String)">
            <summary> Initialize the Velocity Runtime with the name of
            ExtendedProperties object.
            *
            </summary>
            <param name="">Properties
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.createNewParser">
            <summary> Returns a JavaCC generated Parser.
            *
            </summary>
            <returns>Parser javacc generated parser
            
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NVelocity.Runtime.RuntimeSingleton.parse(System.IO.TextReader,System.String)" -->
        <member name="M:NVelocity.Runtime.RuntimeSingleton.parse(System.IO.TextReader,System.String,System.Boolean)">
            <summary>  Parse the input and return the root of the AST node structure.
            *
            </summary>
            <param name="InputStream">inputstream retrieved by a resource loader
            </param>
            <param name="String">name of the template being parsed
            </param>
            <param name="dumpNamespace">flag to dump the Velocimacro namespace for this template
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.getTemplate(System.String)">
            <summary> Returns a <code>Template</code> from the resource manager.
            This method assumes that the character encoding of the
            template is set by the <code>input.encoding</code>
            property.  The default is "ISO-8859-1"
            *
            </summary>
            <param name="name">The file name of the desired template.
            </param>
            <returns>    The template.
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception if an error occurs in template initialization
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.getTemplate(System.String,System.String)">
            <summary> Returns a <code>Template</code> from the resource manager
            *
            </summary>
            <param name="name">The  name of the desired template.
            </param>
            <param name="encoding">Character encoding of the template
            </param>
            <returns>    The template.
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception if an error occurs in template initialization
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.getContent(System.String)">
            <summary> Returns a static content resource from the
            resource manager.  Uses the current value
            if INPUT_ENCODING as the character encoding.
            *
            </summary>
            <param name="name">Name of content resource to get
            </param>
            <returns>parsed ContentResource object ready for use
            @throws ResourceNotFoundException if template not found
            from any available source.
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.getContent(System.String,System.String)">
            <summary> Returns a static content resource from the
            resource manager.
            *
            </summary>
            <param name="name">Name of content resource to get
            </param>
            <param name="encoding">Character encoding to use
            </param>
            <returns>parsed ContentResource object ready for use
            @throws ResourceNotFoundException if template not found
            from any available source.
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.getLoaderNameForResource(System.String)">
            <summary>  Determines is a template exists, and returns name of the loader that
            provides it.  This is a slightly less hokey way to support
            the Velocity.templateExists() utility method, which was broken
            when per-template encoding was introduced.  We can revisit this.
            *
            </summary>
            <param name="resourceName">Name of template or content resource
            </param>
            <returns>class name of loader than can provide it
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.warn(System.Object)">
            <summary> Log a warning message.
            *
            </summary>
            <param name="Object">message to log
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.info(System.Object)">
            
            <summary> Log an info message.
            *
            </summary>
            <param name="Object">message to log
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.error(System.Object)">
            <summary> Log an error message.
            *
            </summary>
            <param name="Object">message to log
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.debug(System.Object)">
            <summary> Log a debug message.
            *
            </summary>
            <param name="Object">message to log
            
            </param>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.getString(System.String,System.String)">
            <summary> String property accessor method with default to hide the
            configuration implementation.
            
            </summary>
            <param name="String">key property key
            </param>
            <param name="String">defaultValue  default value to return if key not
            found in resource manager.
            </param>
            <returns>String  value of key or default
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.getVelocimacro(System.String,System.String)">
            <summary> Returns the appropriate VelocimacroProxy object if strVMname
            is a valid current Velocimacro.
            *
            </summary>
            <param name="String">vmName  Name of velocimacro requested
            </param>
            <returns>String VelocimacroProxy
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.addVelocimacro(System.String,System.String,System.String[],System.String)">
            <summary> Adds a new Velocimacro. Usually called by Macro only while parsing.
            *
            </summary>
            <param name="String">name  Name of velocimacro
            </param>
            <param name="String">macro  String form of macro body
            </param>
            <param name="String">argArray  Array of strings, containing the
            #macro() arguments.  the 0th is the name.
            </param>
            <returns>boolean  True if added, false if rejected for some
            reason (either parameters or permission settings)
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.isVelocimacro(System.String,System.String)">
            <summary>  Checks to see if a VM exists
            *
            </summary>
            <param name="name"> Name of velocimacro
            </param>
            <returns>boolean  True if VM by that name exists, false if not
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.dumpVMNamespace(System.String)">
            <summary>  tells the vmFactory to dump the specified namespace.  This is to support
            clearing the VM list when in inline-VM-local-scope mode
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.getString(System.String)">
            <summary> String property accessor method to hide the configuration implementation
            </summary>
            <param name="key"> property key
            </param>
            <returns>  value of key or null
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.getInt(System.String)">
            <summary> Int property accessor method to hide the configuration implementation.
            *
            </summary>
            <param name="String">key property key
            </param>
            <returns>int value
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.getInt(System.String,System.Int32)">
            <summary> Int property accessor method to hide the configuration implementation.
            *
            </summary>
            <param name="key"> property key
            </param>
            <param name="int">default value
            </param>
            <returns>int  value
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.RuntimeSingleton.getBoolean(System.String,System.Boolean)">
            <summary> Boolean property accessor method to hide the configuration implementation.
            
            </summary>
            <param name="String">key  property key
            </param>
            <param name="boolean">default default value if property not found
            </param>
            <returns>boolean  value of key or default value
            
            </returns>
        </member>
        <member name="T:NVelocity.Runtime.VelocimacroFactory">
            <summary>  VelocimacroFactory.java
            *
            manages the set of VMs in a running Velocity engine.
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.rsvc">
            <summary>  runtime services for this instance
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.vmManager">
            <summary>  VMManager : deal with namespace management
            and actually keeps all the VM definitions
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.replaceAllowed">
            <summary>  determines if replacement of global VMs are allowed
            controlled by  VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.addNewAllowed">
            <summary>  controls if new VMs can be added.  Set by
            VM_PERM_ALLOW_INLINE  Note the assumption that only
            through inline defs can this happen.
            additions through autoloaded VMs is allowed
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.templateLocal">
            <summary>  sets if template-local namespace in used
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.blather">
            <summary>  controls log output
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.autoReloadLibrary">
            <summary>  determines if the libraries are auto-loaded
            when they change
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.macroLibVec">
            <summary>  vector of the library names
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroFactory.libModMap">
            <summary>  map of the library Template objects
            used for reload determination
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.#ctor(NVelocity.Runtime.RuntimeServices)">
            <summary>  CTOR : requires a runtime services from now
            on
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.initVelocimacro">
            <summary>  initialize the factory - setup all permissions
            load all global libraries.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.addVelocimacro(System.String,System.String,System.String[],System.String)">
            <summary>  adds a macro to the factory.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.canAddVelocimacro(System.String,System.String)">
            <summary>  determines if a given macro/namespace (name, source) combo is allowed
            to be added
            *
            </summary>
            <param name="name">Name of VM to add
            </param>
            <param name="sourceTemplate">Source template that contains the defintion of the VM
            </param>
            <returns>true if it is allowed to be added, false otherwise
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.logVMMessageInfo(System.String)">
            <summary>  localization of the logging logic
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.logVMMessageWarn(System.String)">
            <summary>  localization of the logging logic
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.isVelocimacro(System.String,System.String)">
            <summary>  Tells the world if a given directive string is a Velocimacro
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.getVelocimacro(System.String,System.String)">
            <summary>  actual factory : creates a Directive that will
            behave correctly wrt getting the framework to
            dig out the correct # of args
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroFactory.dumpVMNamespace(System.String)">
            <summary>  tells the vmManager to dump the specified namespace
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.VelocimacroFactory.Twonk">
            <summary> small continer class to hold the duple
            of a template and modification time.
            We keep the modification time so we can
            'override' it on a reload to prevent
            recursive reload due to inter-calling
            VMs in a library
            </summary>
        </member>
        <member name="T:NVelocity.Runtime.VelocimacroManager">
            <summary> Manages VMs in namespaces.  Currently, two namespace modes are
            supported:
            *
            <ul>
            <li>flat - all allowable VMs are in the global namespace</li>
            <li>local - inline VMs are added to it's own template namespace</li>
            </ul>
            *
            Thanks to <a href="mailto:JFernandez@viquity.com">Jose Alberto Fernandez</a>
            for some ideas incorporated here.
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <author> <a href="mailto:JFernandez@viquity.com">Jose Alberto Fernandez</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroManager.namespaceHash">
            <summary>Hash of namespace hashes.
            </summary>
        </member>
        <member name="F:NVelocity.Runtime.VelocimacroManager.libraryMap">
            <summary>map of names of library tempates/namespaces
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroManager.#ctor(NVelocity.Runtime.RuntimeServices)">
            <summary> Adds the global namespace to the hash.
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroManager.addVM(System.String,System.String,System.String[],System.String)">
            <summary> Adds a VM definition to the cache.
            </summary>
            <returns>Whether everything went okay.
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroManager.get(System.String,System.String)">
            <summary> gets a new living VelocimacroProxy object by the
            name / source template duple
            </summary>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroManager.dumpNamespace(System.String)">
            <summary> Removes the VMs and the namespace from the manager.
            Used when a template is reloaded to avoid
            accumulating drek
            *
            </summary>
            <param name="namespace">namespace to dump
            </param>
            <returns>boolean representing success
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroManager.getNamespace(System.String)">
            <summary>  returns the hash for the specified namespace.  Will not create a new one
            if it doesn't exist
            *
            </summary>
            <param name="namespace"> name of the namespace :)
            </param>
            <returns>namespace Hashtable of VMs or null if doesn't exist
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroManager.getNamespace(System.String,System.Boolean)">
            <summary>  returns the hash for the specified namespace, and if it doesn't exist
            will create a new one and add it to the namespaces
            *
            </summary>
            <param name="namespace"> name of the namespace :)
            </param>
            <param name="addIfNew"> flag to add a new namespace if it doesn't exist
            </param>
            <returns>namespace Hashtable of VMs or null if doesn't exist
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroManager.addNamespace(System.String)">
            <summary>   adds a namespace to the namespaces
            *
            </summary>
            <param name="namespace">name of namespace to add
            </param>
            <returns>Hash added to namespaces, ready for use
            
            </returns>
        </member>
        <member name="M:NVelocity.Runtime.VelocimacroManager.usingNamespaces(System.String)">
            <summary>  determines if currently using namespaces.
            *
            </summary>
            <param name="namespace">currently ignored
            </param>
            <returns>true if using namespaces, false if not
            
            </returns>
        </member>
        <member name="T:NVelocity.Runtime.VelocimacroManager.MacroEntry">
            <summary>  wrapper class for holding VM information
            </summary>
        </member>
        <member name="T:NVelocity.Tool.DataInfo">
            <summary> ToolInfo implementation to handle "primitive" data types.
            It currently supports String, Number, and Boolean data.
            *
            </summary>
            <author> <a href="mailto:nathan@esha.com">Nathan Bubna</a>
            *
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="T:NVelocity.Tool.IToolInfo">
            <summary> Interface to simplify and abstract tool handling.
            *
            Implementations of this class should hold both the context
            key for the tool and sufficient information to return
            an instance of the tool.
            *
            </summary>
            <author> <a href="mailto:nathan@esha.com">Nathan Bubna</a>
            *
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="M:NVelocity.Tool.IToolInfo.getInstance(System.Object)">
            <returns>the context key for the tool
            
            </returns>
            <returns>the fully qualified classname for the tool
            
            </returns>
            <summary> Returns an instance of the tool.
            *
            Instances returned may be new on each call, pooled, or
            the be same instance every time depending on the
            implementation.  The object passed to this method may
            be used to initialize or create the tool that is returned,
            or it may be null if no such data is required.
            *
            </summary>
            <param name="initData">an object that may be used to initialize the instance
            </param>
            <returns>an instance of the tool
            
            </returns>
        </member>
        <member name="M:NVelocity.Tool.DataInfo.#ctor(System.String,System.String,System.String)">
            <summary> Parses the value string into a recognized type. If
            the type specified is not supported, the data will
            be held and returned as a string.
            *
            </summary>
            <param name="key">the context key for the data
            </param>
            <param name="type">the data type
            </param>
            <param name="value">the data
            
            </param>
        </member>
        <member name="M:NVelocity.Tool.DataInfo.getInstance(System.Object)">
            <summary> Returns the data. Always returns the same
            object since the data is a constant. Initialization
            data is ignored.
            </summary>
        </member>
        <member name="T:NVelocity.Tool.ToolLoader">
            <summary>
            <p>A view tool that allows template designers to load
            an arbitrary object into the context. Any object
            with a public constructor without parameters can be used
            as a view tool.</p>
            <p>THIS CLASS IS HERE AS A PROOF OF CONCEPT ONLY. IT IS NOT
            INTENDED FOR USE IN PRODUCTION ENVIRONMENTS. USE AT YOUR OWN RISK.</p>
            </summary>
            <author><a href="mailto:sidler@teamup.com">Gabe Sidler</a></author>
            <author><a href="mailto:geirm@apache.org">Geir Magnusson Jr.</a></author>
        </member>
        <member name="M:NVelocity.Tool.ToolLoader.Load(System.String)">
            <summary>
            Creates and returns an object of the specified classname.
            The object must have a valid default constructor.
            </summary>
            <param name="clazz">the fully qualified class name of the object</param>
            <returns>an instance of the specified class or null if the class
            could not be instantiated.</returns>
        </member>
        <member name="T:NVelocity.Util.Introspection.AmbiguousException">
            <summary>  simple distinguishable exception, used when
            we run across ambiguous overloading
            </summary>
        </member>
        <member name="T:NVelocity.Util.Introspection.ClassMap">
            <summary> A cache of introspection information for a specific class instance.
            Keys {@link java.lang.Method} objects by a concatenation of the
            method name and the names of classes that make up the parameters.
            </summary>
        </member>
        <member name="F:NVelocity.Util.Introspection.ClassMap.clazz">
            
            <summary> Class passed into the constructor used to as
            the basis for the Method map.
            </summary>
        </member>
        <member name="F:NVelocity.Util.Introspection.ClassMap.methodCache">
            <summary> Cache of Methods, or CACHE_MISS, keyed by method
            name and actual arguments used to find it.
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.ClassMap.#ctor(System.Type)">
            <summary> Standard constructor
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.ClassMap.findMethod(System.String,System.Object[])">
            <summary> Find a Method using the methodKey
            provided.
            
            Look in the methodMap for an entry.  If found,
            it'll either be a CACHE_MISS, in which case we
            simply give up, or it'll be a Method, in which
            case, we return it.
            
            If nothing is found, then we must actually go
            and introspect the method from the MethodMap.
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.ClassMap.findProperty(System.String)">
            <summary> Find a Method using the methodKey
            provided.
            
            Look in the methodMap for an entry.  If found,
            it'll either be a CACHE_MISS, in which case we
            simply give up, or it'll be a Method, in which
            case, we return it.
            
            If nothing is found, then we must actually go
            and introspect the method from the MethodMap.
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.ClassMap.populateMethodCache">
            <summary> Populate the Map of direct hits. These
            are taken from all the public methods
            that our class provides.
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.ClassMap.makeMethodKey(System.Reflection.MethodInfo)">
            <summary> Make a methodKey for the given method using
            the concatenation of the name and the
            types of the method parameters.
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.ClassMap.getAccessibleMethods(System.Type)">
            <summary> Retrieves public methods for a class. In case the class is not
            public, retrieves methods with same signature as its public methods
            from public superclasses and interfaces (if they exist). Basically
            upcasts every method to the nearest acccessible method.
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.ClassMap.getAccessibleMethods(System.Type,NVelocity.Util.Introspection.ClassMap.MethodInfo[],System.Int32)">
            <summary>
            Recursively finds a match for each method, starting with the class, and then
            searching the superclass and interfaces.
            </summary>
            <param name="clazz">Class to check</param>
            <param name="methodInfos">array of methods we are searching to match</param>
            <param name="upcastCount">current number of methods we have matched</param>
            <returns>count of matched methods</returns>
        </member>
        <member name="M:NVelocity.Util.Introspection.ClassMap.getPublicMethod(System.Reflection.MethodInfo)">
            <summary>  For a given method, retrieves its publicly accessible counterpart.
            This method will look for a method with same name
            and signature declared in a public superclass or implemented interface of this
            method's declaring class. This counterpart method is publicly callable.
            </summary>
            <param name="method">a method whose publicly callable counterpart is requested.
            </param>
            <returns>the publicly callable counterpart method. Note that if the parameter
            method is itself declared by a public class, this method is an identity
            function.
            </returns>
        </member>
        <member name="M:NVelocity.Util.Introspection.ClassMap.getPublicMethod(System.Type,System.String,System.Type[])">
            <summary>  Looks up the method with specified name and signature in the first public
            superclass or implemented interface of the class.
            </summary>
            <param name="class">the class whose method is sought
            </param>
            <param name="name">the name of the method
            </param>
            <param name="paramTypes">the classes of method parameters
            </param>
        </member>
        <member name="T:NVelocity.Util.Introspection.ClassMap.MethodInfo">
            <summary>  Used for the iterative discovery process for public methods.
            </summary>
        </member>
        <member name="T:NVelocity.Util.Introspection.IntrospectionCacheData">
            <summary>  Holds information for node-local context data introspection
            information.
            *
            </summary>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="F:NVelocity.Util.Introspection.IntrospectionCacheData.thingy">
            
            <summary>  Object to pair with class - currently either a Method or
            AbstractExecutor. It can be used in any way the using node
            wishes.
            </summary>
        </member>
        <member name="T:NVelocity.Util.Introspection.Introspector">
            <summary> This basic function of this class is to return a Method
            object for a particular class given the name of a method
            and the parameters to the method in the form of an Object[]
            
            The first time the Introspector sees a
            class it creates a class method map for the
            class in question. Basically the class method map
            is a Hastable where Method objects are keyed by a
            concatenation of the method name and the names of
            classes that make up the parameters.
            
            For example, a method with the following signature:
            
            public void method(String a, StringBuffer b)
            
            would be mapped by the key:
            
            "method" + "java.lang.String" + "java.lang.StringBuffer"
            
            This mapping is performed for all the methods in a class
            and stored for
            </summary>
        </member>
        <member name="T:NVelocity.Util.Introspection.IntrospectorBase">
            <summary> This basic function of this class is to return a Method
            object for a particular class given the name of a method
            and the parameters to the method in the form of an Object[]
            
            The first time the Introspector sees a
            class it creates a class method map for the
            class in question. Basically the class method map
            is a Hastable where Method objects are keyed by a
            concatenation of the method name and the names of
            classes that make up the parameters.
            
            For example, a method with the following signature:
            
            public void method(String a, StringBuffer b)
            
            would be mapped by the key:
            
            "method" + "java.lang.String" + "java.lang.StringBuffer"
            
            This mapping is performed for all the methods in a class
            and stored for
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:bob@werken.com">Bob McWhirter</a>
            </author>
            <author> <a href="mailto:szegedia@freemail.hu">Attila Szegedi</a>
            </author>
            <author> <a href="mailto:paulo.gaspar@krankikom.de">Paulo Gaspar</a>
            </author>
            <version> $Id$
            </version>
        </member>
        <member name="F:NVelocity.Util.Introspection.IntrospectorBase.classMethodMaps">
            <summary> Holds the method maps for the classes we know about, keyed by
            Class object.
            </summary>
        </member>
        <member name="F:NVelocity.Util.Introspection.IntrospectorBase.cachedClassNames">
            <summary> Holds the qualified class names for the classes
            we hold in the classMethodMaps hash
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.IntrospectorBase.getMethod(System.Type,System.String,System.Object[])">
            <summary> Gets the method defined by <code>name</code> and
            <code>params</code> for the Class <code>c</code>.
            </summary>
            <param name="c">Class in which the method search is taking place
            </param>
            <param name="name">Name of the method being searched for
            </param>
            <param name="params">An array of Objects (not Classes) that describe the
            the parameters
            </param>
            <returns>The desired Method object.
            </returns>
        </member>
        <member name="M:NVelocity.Util.Introspection.IntrospectorBase.getProperty(System.Type,System.String)">
            <summary> Gets the method defined by <code>name</code> and
            <code>params</code> for the Class <code>c</code>.
            </summary>
            <param name="c">Class in which the method search is taking place
            </param>
            <param name="name">Name of the method being searched for
            </param>
            <param name="params">An array of Objects (not Classes) that describe the
            the parameters
            </param>
            <returns>The desired Method object.
            </returns>
        </member>
        <member name="M:NVelocity.Util.Introspection.IntrospectorBase.createClassMap(System.Type)">
            <summary> Creates a class map for specific class and registers it in the
            cache.  Also adds the qualified name to the name->class map
            for later Classloader change detection.
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.IntrospectorBase.clearCache">
            <summary> Clears the classmap and classname
            caches
            </summary>
        </member>
        <member name="F:NVelocity.Util.Introspection.Introspector.CACHEDUMP_MSG">
            <summary>  define a public string so that it can be looked for
            if interested
            </summary>
        </member>
        <member name="F:NVelocity.Util.Introspection.Introspector.rsvc">
            <summary>  our engine runtime services
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.Introspector.#ctor(NVelocity.Runtime.RuntimeServices)">
            <summary>  Recieves our RuntimeServices object
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.Introspector.getMethod(System.Type,System.String,System.Object[])">
            <summary> Gets the method defined by <code>name</code> and
            <code>params</code> for the Class <code>c</code>.
            </summary>
            <param name="c">Class in which the method search is taking place
            </param>
            <param name="name">Name of the method being searched for
            </param>
            <param name="params">An array of Objects (not Classes) that describe the
            the parameters
            </param>
            <returns>The desired Method object.
            </returns>
        </member>
        <member name="M:NVelocity.Util.Introspection.Introspector.getProperty(System.Type,System.String)">
            <summary> Gets the method defined by <code>name</code> and
            <code>params</code> for the Class <code>c</code>.
            </summary>
            <param name="c">Class in which the method search is taking place
            </param>
            <param name="name">Name of the method being searched for
            </param>
            <param name="params">An array of Objects (not Classes) that describe the
            the parameters
            </param>
            <returns>The desired Method object.
            </returns>
        </member>
        <member name="M:NVelocity.Util.Introspection.Introspector.clearCache">
            <summary> Clears the classmap and classname
            caches, and logs that we did so
            </summary>
        </member>
        <member name="F:NVelocity.Util.Introspection.MethodMap.methodByNameMap">
            <summary> Keep track of all methods with the same name.
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.MethodMap.add(System.Reflection.MethodInfo)">
            <summary> Add a method to a list of methods by name.
            For a particular class we are keeping track
            of all the methods with the same name.
            </summary>
        </member>
        <member name="M:NVelocity.Util.Introspection.MethodMap.get(System.String)">
            <summary> Return a list of methods with the same name.
            </summary>
            <param name="String">key
            </param>
            <returns>List list of methods
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.Introspection.MethodMap.find(System.String,System.Object[])">
            <summary>  <p>
            Find a method.  Attempts to find the
            most appropriate method using the
            sense of 'specificity'.
            </p>
            
            <p>
            This turns out to be a relatively rare case
            where this is needed - however, functionality
            like this is needed.  This may not be the
            optimum approach, but it works.
            </p>
            </summary>
            <param name="String">name of method
            </param>
            <param name="Object[]">params
            </param>
            <returns>Method
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.Introspection.MethodMap.calcDistance(System.Object[],System.Type[])">
            <summary>  Calculates the distance, expressed as a vector of inheritance
            steps, between the calling args and the method args.
            There still is an issue re interfaces...
            </summary>
        </member>
        <member name="T:NVelocity.Util.Introspection.Twonk">
            <summary>  little class to hold 'distance' information
            for calling params, as well as determine
            specificity
            </summary>
        </member>
        <member name="M:NVelocity.Util.Iterator.next">
            <summary> Move to next element in the array.
            </summary>
            <returns>The next object in the array.
            </returns>
        </member>
        <member name="M:NVelocity.Util.Iterator.hasNext">
            <summary> Check to see if there is another element in the array.
            </summary>
            <returns>Whether there is another element.
            </returns>
        </member>
        <member name="T:NVelocity.Util.SimplePool">
            <summary> Simple object pool. Based on ThreadPool and few other classes
            *
            The pool will ignore overflow and return null if empty.
            *
            </summary>
            <author> Gal Shachor
            </author>
            <author> Costin
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="F:NVelocity.Util.SimplePool.max">
            <summary>  max amount of objects to be managed
            set via CTOR
            </summary>
        </member>
        <member name="F:NVelocity.Util.SimplePool.current">
            <summary>  index of previous to next
            free slot
            </summary>
        </member>
        <member name="M:NVelocity.Util.SimplePool.put(System.Object)">
            <summary> Add the object to the pool, silent nothing if the pool is full
            </summary>
        </member>
        <member name="M:NVelocity.Util.SimplePool.get">
            <summary> Get an object from the pool, null if the pool is empty.
            </summary>
        </member>
        <member name="T:NVelocity.Util.StringUtils">
            <summary> This class provides some methods for dynamically
            invoking methods in objects, and some string
            manipulation methods used by torque. The string
            methods will soon be moved into the turbine
            string utilities class.
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:dlr@finemaltcoding.com">Daniel Rall</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="F:NVelocity.Util.StringUtils.EOL">
            <summary> Line separator for the OS we are operating on.
            </summary>
        </member>
        <member name="F:NVelocity.Util.StringUtils.EOL_LENGTH">
            <summary> Length of the line separator.
            </summary>
        </member>
        <member name="M:NVelocity.Util.StringUtils.concat(System.Collections.IList)">
            <summary> Concatenates a list of objects as a String.
            *
            </summary>
            <param name="list">The list of objects to concatenate.
            </param>
            <returns>    A text representation of the concatenated objects.
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.getPackageAsPath(System.String)">
            <summary> Return a package name as a relative path name
            *
            </summary>
            <param name="String">package name to convert to a directory.
            </param>
            <returns>String directory path.
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.removeUnderScores(System.String)">
            <summary> <p>
            Remove underscores from a string and replaces first
            letters with capitals.  Other letters are changed to lower case.
            </p>
            *
            <p>
            For example <code>foo_bar</code> becomes <code>FooBar</code>
            but <code>foo_barBar</code> becomes <code>FooBarbar</code>.
            </p>
            *
            </summary>
            <param name="data">string to remove underscores from.
            </param>
            <returns>String
            </returns>
            <deprecated>Use the org.apache.commons.util.StringUtils class
            instead.  Using its firstLetterCaps() method in conjunction
            with a StringTokenizer will achieve the same result.
            
            </deprecated>
        </member>
        <member name="M:NVelocity.Util.StringUtils.removeAndHump(System.String)">
            <summary> <p>
            'Camels Hump' replacement of underscores.
            </p>
            *
            <p>
            Remove underscores from a string but leave the capitalization of the
            other letters unchanged.
            </p>
            *
            <p>
            For example <code>foo_barBar</code> becomes <code>FooBarBar</code>.
            </p>
            *
            </summary>
            <param name="data">string to hump
            </param>
            <returns>String
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.removeAndHump(System.String,System.String)">
            <summary> <p>
            'Camels Hump' replacement.
            </p>
            *
            <p>
            Remove one string from another string but leave the capitalization of the
            other letters unchanged.
            </p>
            *
            <p>
            For example, removing "_" from <code>foo_barBar</code> becomes <code>FooBarBar</code>.
            </p>
            *
            </summary>
            <param name="data">string to hump
            </param>
            <param name="replaceThis">string to be replaced
            </param>
            <returns>String
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.firstLetterCaps(System.String)">
            <summary> <p>
            Makes the first letter caps and the rest lowercase.
            </p>
            *
            <p>
            For example <code>fooBar</code> becomes <code>Foobar</code>.
            </p>
            *
            </summary>
            <param name="data">capitalize this
            </param>
            <returns>String
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.capitalizeFirstLetter(System.String)">
            <summary> <p>
            Capitalize the first letter but leave the rest as they are.
            </p>
            *
            <p>
            For example <code>fooBar</code> becomes <code>FooBar</code>.
            </p>
            *
            </summary>
            <param name="data">capitalize this
            </param>
            <returns>String
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.split(System.String,System.String)">
            <summary> Create a string array from a string separated by delim
            *
            </summary>
            <param name="line">the line to split
            </param>
            <param name="delim">the delimter to split by
            </param>
            <returns>a string array of the split fields
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.chop(System.String,System.Int32)">
            <summary> Chop i characters off the end of a string.
            This method assumes that any EOL characters in String s
            and the platform EOL will be the same.
            A 2 character EOL will count as 1 character.
            *
            </summary>
            <param name="string">String to chop.
            </param>
            <param name="i">Number of characters to chop.
            </param>
            <returns>String with processed answer.
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.chop(System.String,System.Int32,System.String)">
            <summary> Chop i characters off the end of a string.
            A 2 character EOL will count as 1 character.
            *
            </summary>
            <param name="string">String to chop.
            </param>
            <param name="i">Number of characters to chop.
            </param>
            <param name="eol">A String representing the EOL (end of line).
            </param>
            <returns>String with processed answer.
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.stringSubstitution(System.String,System.Collections.Hashtable)">
            <summary> Perform a series of substitutions. The substitions
            are performed by replacing $variable in the target
            string with the value of provided by the key "variable"
            in the provided hashtable.
            *
            </summary>
            <param name="String">target string
            </param>
            <param name="Hashtable">name/value pairs used for substitution
            </param>
            <returns>String target string with replacements.
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.fileContentsToString(System.String)">
            <summary> Read the contents of a file and place them in
            a string object.
            *
            </summary>
            <param name="String">path to file.
            </param>
            <returns>String contents of the file.
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.collapseNewlines(System.String)">
            <summary> Remove/collapse multiple newline characters.
            *
            </summary>
            <param name="String">string to collapse newlines in.
            </param>
            <returns>String
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.collapseSpaces(System.String)">
            <summary> Remove/collapse multiple spaces.
            *
            </summary>
            <param name="String">string to remove multiple spaces from.
            </param>
            <returns>String
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.sub(System.String,System.String,System.String)">
            <summary> Replaces all instances of oldString with newString in line.
            Taken from the Jive forum package.
            *
            </summary>
            <param name="String">original string.
            </param>
            <param name="String">string in line to replace.
            </param>
            <param name="String">replace oldString with this.
            </param>
            <returns>String string with replacements.
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.stackTrace(System.Exception)">
            <summary> Returns the output of printStackTrace as a String.
            *
            </summary>
            <param name="e">A Throwable.
            </param>
            <returns>A String.
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.normalizePath(System.String)">
            <summary> Return a context-relative path, beginning with a "/", that represents
            the canonical version of the specified path after ".." and "." elements
            are resolved out.  If the specified path attempts to go outside the
            boundaries of the current context (i.e. too many ".." path elements
            are present), return <code>null</code> instead.
            *
            </summary>
            <param name="path">Path to be normalized
            </param>
            <returns>String normalized path
            
            </returns>
        </member>
        <member name="M:NVelocity.Util.StringUtils.select(System.Boolean,System.String,System.String)">
            <summary> If state is true then return the trueString, else
            return the falseString.
            *
            </summary>
            <param name="boolean">
            </param>
            <param name="String">trueString
            </param>
            <param name="String">falseString
            
            </param>
        </member>
        <member name="M:NVelocity.Util.StringUtils.allEmpty(System.Collections.IList)">
            <summary> Check to see if all the string objects passed
            in are empty.
            *
            </summary>
            <param name="list">A list of {@link java.lang.String} objects.
            </param>
            <returns>    Whether all strings are empty.
            
            </returns>
        </member>
        <member name="T:NVelocity.Template">
            <summary> This class is used for controlling all template
            operations. This class uses a parser created
            by JavaCC to create an AST that is subsequently
            traversed by a Visitor.
            *
            <pre>
            Template template = Velocity.getTemplate("test.wm");
            Context context = new VelocityContext();
            *
            context.put("foo", "bar");
            context.put("customer", new Customer());
            *
            template.merge(context, writer);
            </pre>
            *
            </summary>
            <author> <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
            </author>
            <author> <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
            </author>
            <version> $Id$
            
            </version>
        </member>
        <member name="F:NVelocity.Template.initialized">
            <summary>   To keep track of whether this template has been
            initialized. We use the document.init(context)
            to perform this.
            </summary>
        </member>
        <member name="M:NVelocity.Template.#ctor">
            <summary>Default constructor
            </summary>
        </member>
        <member name="M:NVelocity.Template.Process">
            <summary>  gets the named resource as a stream, parses and inits
            *
            </summary>
            <returns>true if successful
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws Exception some other problem, should only be from
            initialization of the template AST.
            
            </returns>
        </member>
        <member name="M:NVelocity.Template.InitDocument">
            <summary>  initializes the document.  init() is not longer
            dependant upon context, but we need to let the
            init() carry the template name down throught for VM
            namespace features
            </summary>
        </member>
        <member name="M:NVelocity.Template.Merge(NVelocity.Context.IContext,System.IO.TextWriter)">
            <summary> The AST node structure is merged with the
            context to produce the final output.
            *
            Throws IOException if failure is due to a file related
            issue, and Exception otherwise
            *
            </summary>
            <param name="context">Conext with data elements accessed by template
            </param>
            <param name="writer">output writer for rendered template
            @throws ResourceNotFoundException if template not found
            from any available source.
            @throws ParseErrorException if template cannot be parsed due
            to syntax (or other) error.
            @throws  Exception  anything else.
            
            </param>
        </member>
    </members>
</doc>
